/******************************************************************************
 * @file     ISD94XXXSeries.h
 * @version  V0.10
 * $Revision: 1 $
 * $Date: 16/06/14 10:24a $ 
 * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File for ISD94XXX Series MCU
 *
 * @note
 * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
*****************************************************************************/


#ifndef __ISD94XXXSERIES_H__    
#define __ISD94XXXSERIES_H__

#ifdef __cplusplus
 extern "C" {
#endif 
//#define PWM_MAX_CH  6
#define MAX_PWM0_CH 3
#define MAX_PWM1_CH 3

//#define MAX_GRP_CH      6
#define MAX_PWM_CH      12

#define PD_L(x)    PD->DOUT &= ~(BIT0<<(x))
#define PD_H(x)    PD->DOUT |= (BIT0<<(x))
#define PD_TOG(x)  PD->DOUT ^= (BIT0<<(x))

#define TP0_OUTPUT  _GPIO_SET_PIN_MODE(PD, 0, GPIO_PMD_OUTPUT)
#define TP0_L       (PD0 = 0)
#define TP0_H       (PD0 = 1)  
#define TP0_TOG     (PD0 ^= 1)   

#define TP1_OUTPUT  _GPIO_SET_PIN_MODE(PD, 4, GPIO_PMD_OUTPUT)
#define TP1_L       (PD4 = 0)
#define TP1_H       (PD4 = 1)  
#define TP1_TOG     (PD4 ^= 1)  

#define TP2_OUTPUT  _GPIO_SET_PIN_MODE(PA, 5, GPIO_PMD_OUTPUT)
#define TP2_L       (PA5 = 0)
#define TP2_H       (PA5 = 1)  
#define TP2_TOG     (PA5 ^= 1) 

#define TP3_OUTPUT  _GPIO_SET_PIN_MODE(PA, 6, GPIO_PMD_OUTPUT)
#define TP3_L       (PA6 = 0)
#define TP3_H       (PA6 = 1)  
#define TP3_TOG     (PA6 ^= 1) 

#define TP4_OUTPUT  _GPIO_SET_PIN_MODE(PA, 7, GPIO_PMD_OUTPUT)
#define TP4_L       (PA7 = 0)
#define TP4_H       (PA7 = 1)  
#define TP4_TOG     (PA7 ^= 1) 

//CWWeng 2014.3.18 add for BK00IN
#define TP5_OUTPUT  _GPIO_SET_PIN_MODE(PD, 8, GPIO_PMD_OUTPUT)
#define TP5_L       (PD8 = 0)
#define TP5_H       (PD8 = 1)  
#define TP5_TOG     (PD8 ^= 1) 

#define BK00IN_L       TP0_L//TP5_L //TP0_L
#define BK00IN_H       TP0_H//TP5_H //TP0_H
#define BK00IN_TOG     TP0_TOG//TP5_TOG //TP0_TOG


//M451 S4 CON30-38
#define TP_SYNCIN_OUTPUT  _GPIO_SET_PIN_MODE(PD, 1, GPIO_PMD_OUTPUT)
#define TP_SYNCIN_L       (PD1 = 0)
#define TP_SYNCIN_H       (PD1 = 1)  
#define TP_SYNCIN_TOG     (PD1 ^= 1) 
/** @addtogroup ISD94XXX_Definitions ISD94XXX Definitions
  This file defines all structures and symbols for ISD94XXX:
    - registers and bitfields
    - peripheral base address
    - peripheral ID
    - Peripheral definitions
  @{
*/


/******************************************************************************/
/*                Processor and Core Peripherals                              */
/******************************************************************************/
/** @addtogroup ISD94XXX_CMSIS Device CMSIS Definitions
  Configuration of the Cortex-M4 Processor and Core Peripherals
  @{
*/

/*
 * ==========================================================================
 * ---------- Interrupt Number Definition -----------------------------------
 * ==========================================================================
 */

typedef enum IRQn
{
/******  Cortex-M4 Processor Exceptions Numbers ***************************************************/
  NonMaskableInt_IRQn           = -14,      /*!<  2 Non Maskable Interrupt                        */
  MemoryManagement_IRQn         = -12,      /*!<  4 Memory Management Interrupt                   */
  BusFault_IRQn                 = -11,      /*!<  5 Bus Fault Interrupt                           */
  UsageFault_IRQn               = -10,      /*!<  6 Usage Fault Interrupt                         */
  SVCall_IRQn                   = -5,       /*!< 11 SV Call Interrupt                             */
  DebugMonitor_IRQn             = -4,       /*!< 12 Debug Monitor Interrupt                       */
  PendSV_IRQn                   = -2,       /*!< 14 Pend SV Interrupt                             */
  SysTick_IRQn                  = -1,       /*!< 15 System Tick Interrupt                         */

/******  ISD94XXX Specific Interrupt Numbers ********************************************************/

  BODOUT_IRQn  		= 0	,
  IRC_IRQn     		= 1	,
  PWRWU_IRQn   		= 2	,
  SRAM_IRQn		 		= 3	,
  CLKFAIL_IRQn 		= 4	,
  Reserved   	 		= 5	,
  RTC_IRQn     		= 6	,
  WDT_IRQn     		= 8	,
  WWDT_IRQn    		= 9	,
	EINT0_IRQn   		= 10,
	EINT1_IRQn   		= 11,
	EINT2_IRQn   		= 12,
	EINT3_IRQn   		= 13,
	EINT4_IRQn   		= 14,
	EINT5_IRQn   		= 15,
	GPA_IRQn     		= 16,
	GPB_IRQn     		= 17,
	GPC_IRQn     		= 18,
	GPD_IRQn     		= 19,
	SPI0_INT    		= 22,
	SPI1_INT    		= 23,
	PWM0_P0_IRQn 		= 25,
	PWM0_P1_IRQn 		= 26,
	PWM0_P2_IRQn 		= 27,
	TMR0_IRQn    		= 32,
	TMR1_IRQn    		= 33,
	TMR2_IRQn    		= 34,
	TMR3_IRQn    		= 35,
	UART0_IRQn   		= 36,
	I2C0_IRQn    		= 38,
	I2C1_IRQn    		= 39,
	PDMA_IRQn    		= 40,
	EADC0_IRQn   		= 42,
	EADC1_IRQn   		= 43,
	EADC2_IRQn   		= 46,
	EADC3_IRQn   		= 47,
	DMIC_IRQn				= 52,
	USBD_IRQn    		= 53,
  DPWM_IRQn       = 62,
	I2S0_IRQn    		= 68,

} IRQn_Type;


/*
 * ==========================================================================
 * ----------- Processor and Core Peripheral Section ------------------------
 * ==========================================================================
 */

/* Configuration of the Cortex-M# Processor and Core Peripherals */
#define __CM4_REV                 0x0201    /*!< Core Revision r2p1                               */
#define __NVIC_PRIO_BITS          4         /*!< Number of Bits used for Priority Levels          */
#define __Vendor_SysTickConfig    0         /*!< Set to 1 if different SysTick Config is used     */
#define __MPU_PRESENT             1         /*!< MPU present or not                               */
#define __FPU_PRESENT             1         /*!< FPU present or not                               */

/*@}*/ /* end of group ISD94XXX_CMSIS */


#include "core_cm4.h"                       /* Cortex-M4 processor and core peripherals           */
#include "system_ISD94XXXSeries.h"              /* ISD94XXX System include file                           */
#include <stdint.h>

/******************************************************************************/
/*                Device Specific Peripheral registers structures             */
/******************************************************************************/
/** @addtogroup ISD94XXX_Peripherals ISD94XXX Peripherals
  ISD94XXX Device Specific Peripheral registers structures
  @{
*/

#if defined ( __CC_ARM   )
#pragma anon_unions
#endif

/******************************************************************************/
/*                Device Specific Peripheral registers structures             */
/******************************************************************************/

/** @addtogroup REGISTER Control Register

  @{

*/


/*---------------------- ?????????????????????????????????????????? -------------------------*/
/**
    @addtogroup AHB ??????????????????????????????????????????(AHB)
    Memory Mapped Structure for AHB Controller
@{ */
 /*
typedef struct
{



} AHB_T;
*/

/**
    @addtogroup AHB_CONST AHB Bit Field Definition
    Constant Definitions for AHB Controller
@{ */

/**@}*/ /* AHB_CONST */
/**@}*/ /* end of AHB register group */



/******************************************************************************/
/*                Device Specific Peripheral registers structures             */
/******************************************************************************/

/** @addtogroup REGISTER Control Register

  @{

*/



/*---------------------- System Clock Controller -------------------------*/
/**
    @addtogroup CLK System Clock Controller(CLK)
    Memory Mapped Structure for CLK Controller
@{ */
 
typedef struct
{


/**
 * @var CLK_T::PWRCTL
 * Offset: 0x00  System Power-down Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |HXTEN     |HXT Enable Bit (Write Protect)
 * |        |          |The bit default value is set by flash controller user configuration register CONFIG0 [26]
 * |        |          |When the default clock source is from HXT, this bit is set to 1 automatically.
 * |        |          |0 = 4~24 MHz external high speed crystal (HXT) Disabled.
 * |        |          |1 = 4~24 MHz external high speed crystal (HXT) Enabled.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[1]     |LXTEN     |LXT Enable Bit (Write Protect)
 * |        |          |0 = 32.768 kHz external low speed crystal (LXT) Disabled.
 * |        |          |1 = 32.768 kHz external low speed crystal (LXT) Enabled.
 * |        |          |Note1: The reset value of this bit is 0.
 * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[2]     |HIRCEN    |HIRC Enable Bit (Write Protect)
 * |        |          |0 = 50 MHz internal high speed RC oscillator (HIRC) Disabled.
 * |        |          |1 = 50 MHz internal high speed RC oscillator (HIRC) Enabled.
 * |        |          |Note1: The reset value of this bit is 1.
 * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[3]     |LIRCEN    |LIRC Enable Bit (Write Protect)
 * |        |          |0 = 10 kHz internal low speed RC oscillator (LIRC) Disabled.
 * |        |          |1 = 10 kHz internal low speed RC oscillator (LIRC) Enabled.
 * |        |          |Note1: The reset value of this bit is 1.
 * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[4]     |PDWKDLY   |Enable the Wake-up Delay Counter (Write Protect)
 * |        |          |When the chip wakes up from Power-down mode, the clock control will delay certain clock cycles to wait system clock stable.
 * |        |          |The delayed clock cycle is 4096 clock cycles when chip works at 4~24 MHz external high speed crystal oscillator (HXT), and 512 clock cycles when chip works at 50 MHz internal high speed RC oscillator (HIRC[AlvinLiao1]).
 * |        |          |0 = Clock cycles delay Disabled.
 * |        |          |1 = Clock cycles delay Enabled.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |        |          |[AlvinLiao1]still keep in 256 clock when using 50MHz HIRC?
 * |[5]     |PDWKIEN   |Power-down Mode Wake-up Interrupt Enable Bit (Write Protect)
 * |        |          |0 = Power-down mode wake-up interrupt Disabled.
 * |        |          |1 = Power-down mode wake-up interrupt Enabled.
 * |        |          |Note1: The interrupt will occur when both PDWKIF and PDWKIEN are high.
 * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[6]     |PDWKIF    |Power-down Mode Wake-up Interrupt Status
 * |        |          |Set by ...Power-down wake-up eventu201D, it indicates that resume from Power-down modeu201D
 * |        |          |The flag is set if the EINT0~5, GPIO, USBD, UART0, WDT, BOD, RTC, TMR0~3 or I2C0~1 occurred.
 * |        |          |Note1: Write 1 to clear the bit to 0.
 * |        |          |Note2: This bit works only if PDWKIEN (CLK_PWRCTL[5]) set to 1.
 * |[7]     |PDEN      |System Power-down Enable (Write Protect)
 * |        |          |When this bit is set to 1, Power-down mode is enabled and chip Power-down behavior will depend on the PDWTCPU bit.
 * |        |          |(a) If the PDWTCPU is 0, then the chip enters Power-down mode immediately after the PDEN bit set
 * |        |          |(default)
 * |        |          |(b) if the PDWTCPU is 1, then the chip keeps active till the CPU sleep mode is also active and then the chip enters Power-down mode.
 * |        |          |When chip wakes up from Power-down mode, this bit is auto cleared
 * |        |          |Users need to set this bit again for next Power-down.
 * |        |          |In Power-down mode, HXT and the HIRC will be disabled in this mode, but LXT and LIRC are not controlled by Power-down mode.
 * |        |          |In Power-down mode, the PLL and system clock are disabled, and ignored the clock source selection
 * |        |          |The clocks of peripheral are not controlled by Power-down mode, if the peripheral clock source is from LXT or LIRC.
 * |        |          |0 = Chip operating normally or chip in idle mode because of WFI command.
 * |        |          |1 = Chip enters Power-down mode instant or wait CPU sleep command WFI.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[8]     |PDWTCPU   |this Bit Control the Power-down Entry Condition (Write Protect)
 * |        |          |0 = Chip enters Power-down mode when the PDEN bit is set to 1.
 * |        |          |1 = Chip enters Power-down mode when the both PDWTCPU and PDEN bits are set to 1 and CPU runs WFI instruction.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[9]     |DBPDEN    |Chip Entering Power-down Even ICE Connected
 * |        |          |0 = Chip does not enter Power-down during Debug mode.
 * |        |          |1 = Chip enters power-down in Debug mode. 
 * |[11:10] |HXTGAIN   |HXT Gain Control Bit (Write Protect)
 * |        |          |This is a protected register. Please refer to open lock sequence to program it.
 * |        |          |Gain control is used to enlarge the gain of crystal to make sure crystal work normally
 * |        |          |If gain control is enabled, crystal will consume more power than gain control off.
 * |        |          |00 = HXT frequency is lower than from 8 MHz.
 * |        |          |01 = HXT frequency is from 8 MHz to 12 MHz.
 * |        |          |10 = HXT frequency is from 12 MHz to 16 MHz.
 * |        |          |11 = HXT frequency is higher than 16 MHz.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[12]    |HXTSELTYP |HXT Crystal Type Select Bit (Write Protect)
 * |        |          |This is a protected register. Please refer to open lock sequence to program it.
 * |        |          |0 = Select INV type.
 * |        |          |1 = Select GM type.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[13]    |HXTTBEN   |HXT Crystal TURBO Mode (Write Protect)
 * |        |          |This is a protected register. Please refer to open lock sequence to program it.
 * |        |          |0 = HXT Crystal TURBO mode disabled.
 * |        |          |1 = HXT Crystal TURBO mode enabled.
 * |[17:16] |HIRCSTBS  |HIRC Stable Count Select (Write Protect ) (Not Release in TRM)
 * |        |          |00 = HIRC stable count = 128 clocks.
 * |        |          |01 = HIRC stable count = 64 clocks.
 * |        |          |10 = HIRC stable count = 32 clocks.
 * |        |          |11 = HIRC stable count = 16 clocks.
 * @var CLK_T::AHBCLK
 * Offset: 0x04  AHB Devices Clock Enable Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1]     |PDMACKEN  |PDMA Controller Clock Enable Bit
 * |        |          |0 = PDMA peripheral clock Disabled.
 * |        |          |1 = PDMA peripheral clock Enabled.
 * |[2]     |ISPCKEN   |Flash ISP Controller Clock Enable Bit
 * |        |          |0 = Flash ISP peripheral clock Disabled.
 * |        |          |1 = Flash ISP peripheral clock Enabled.
 * |[7]     |CRCCKEN   |CRC Generator Controller Clock Enable Bit
 * |        |          |0 = CRC peripheral clock Disabled.
 * |        |          |1 = CRC peripheral clock Enabled.
 * |[15]    |FMCIDLE   |Flash Memory Controller Clock Enable Bit in IDLE Mode
 * |        |          |0 = FMC clock Disabled when chip is under IDLE mode.
 * |        |          |1 = FMC clock Enabled when chip is under IDLE mode.
 * @var CLK_T::APBCLK0
 * Offset: 0x08  APB Devices Clock Enable Control Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |WDTCKEN   |Watchdog Timer Clock Enable Bit (Write Protect)
 * |        |          |0 = Watchdog timer clock Disabled.
 * |        |          |1 = Watchdog timer clock Enabled.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[1]     |RTCCKEN   |Real-time-clock APB Interface Clock Enable Bit
 * |        |          |This bit is used to control the RTC APB clock only
 * |        |          |The RTC peripheral clock source is selected from RTCSEL(CLK_CLKSEL3[8])
 * |        |          |It can be selected to 32.768 kHz external low speed crystal or 10 kHz internal low speed RC oscillator (LIRC).
 * |        |          |0 = RTC clock Disabled.
 * |        |          |1 = RTC clock Enabled.
 * |[2]     |TMR0CKEN  |Timer0 Clock Enable Bit
 * |        |          |0 = Timer0 clock Disabled.
 * |        |          |1 = Timer0 clock Enabled.
 * |[3]     |TMR1CKEN  |Timer1 Clock Enable Bit
 * |        |          |0 = Timer1 clock Disabled.
 * |        |          |1 = Timer1 clock Enabled.
 * |[4]     |TMR2CKEN  |Timer2 Clock Enable Bit
 * |        |          |0 = Timer2 clock Disabled.
 * |        |          |1 = Timer2 clock Enabled.
 * |[5]     |TMR3CKEN  |Timer3 Clock Enable Bit
 * |        |          |0 = Timer3 clock Disabled.
 * |        |          |1 = Timer3 clock Enabled.
 * |[6]     |CLKOCKEN  |CLKO Clock Enable Bit
 * |        |          |0 = CLKO clock Disabled.
 * |        |          |1 = CLKO clock Enabled.
 * |[8]     |I2C0CKEN  |I2C0 Clock Enable Bit
 * |        |          |0 = I2C0 clock Disabled.
 * |        |          |1 = I2C0 clock Enabled.
 * |[9]     |I2C1CKEN  |I2C1 Clock Enable Bit
 * |        |          |0 = I2C1 clock Disabled.
 * |        |          |1 = I2C1 clock Enabled.
 * |[12]    |SPI0CKEN  |SPI0 Clock Enable Bit
 * |        |          |0 = SPI0 clock Disabled.
 * |        |          |1 = SPI0 clock Enabled.
 * |[13]    |SPI1CKEN  |SPI1 Clock Enable Bit
 * |        |          |0 = SPI1 clock Disabled.
 * |        |          |1 = SPI1 clock Enabled.
 * |[14]    |SPI2CKEN  |SPI2 Clock Enable Bit
 * |        |          |0 = SPI2 clock Disabled.
 * |        |          |1 = SPI2 clock Enabled.
 * |[16]    |UART0CKEN |UART0 Clock Enable Bit
 * |        |          |0 = UART0 clock Disabled.
 * |        |          |1 = UART0 clock Enabled.
 * |[27]    |USBDCKEN  |USB Device Clock Enable Bit
 * |        |          |0 = USB Device clock Disabled.
 * |        |          |1 = USB Device clock Enabled.
 * |[28]    |EADCCKEN  |Enhanced Analog-digital-converter (EADC) Clock Enable Bit
 * |        |          |0 = EADC clock Disabled.
 * |        |          |1 = EADC clock Enabled.
 * |[29]    |I2S0CKEN  |I2S0 Clock Enable Bit
 * |        |          |0 = I2S0 Clock Disabled.
 * |        |          |1 = I2S0 Clock Enabled.
 * @var CLK_T::APBCLK1
 * Offset: 0x0C  APB Devices Clock Enable Control Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[16]    |PWM0CKEN  |PWM0 Clock Enable Bit
 * |        |          |0 = PWM0 clock Disabled.
 * |        |          |1 = PWM0 clock Enabled.
 * @var CLK_T::CLKSEL0
 * Offset: 0x10  Clock Source Select Control Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[2:0]   |HCLKSEL   |HCLK Clock Source Selection (Write Protect)
 * |        |          |Before clock switching, the related clock sources (both pre-select and new-select) must be turned on.
 * |        |          |The default value is reloaded from the value of CFOSC (CONFIG0[26]) in user configuration register of Flash controller by any reset
 * |        |          |Therefore the default value is either 000b or 111b.
 * |        |          |000 = Clock source from HXT.
 * |        |          |001 = Clock source from LXT.
 * |        |          |010 = Clock source from PLL.
 * |        |          |011 = Clock source from LIRC.
 * |        |          |111= Clock source from HIRC.
 * |        |          |Other = Reserved.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[5:3]   |STCLKSEL  |Cortex-M4 SysTick Clock Source Selection (Write Protect)
 * |        |          |If SYST_CTRL[2]=0, SysTick uses listed clock source below.
 * |        |          |000 = Clock source from HXT.
 * |        |          |001 = Clock source from LXT.
 * |        |          |010 = Clock source from HXT/2.
 * |        |          |011 = Clock source from HCLK/2.
 * |        |          |111 = Clock source from HIRC/2.
 * |        |          |Note1: if SysTick clock source is not from HCLK (i.e
 * |        |          |SYST_CTRL[2] = 0), SysTick clock source must less than or equal to HCLK/2.
 * |        |          |Note2: The reset value of this field is 111b.
 * |        |          |Note3: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[6]     |PCLK0SEL  |PCLK0 Clock Source Selection (Write Protect)
 * |        |          |0 = APB0 BUS clock source from HCLK.
 * |        |          |1 = APB0 BUS clock source from HCLK/2.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[7]     |PCLK1SEL  |PCLK1 Clock Source Selection (Write Protect)
 * |        |          |0 = APB1 BUS clock source from HCLK.
 * |        |          |1 = APB1 BUS clock source from HCLK/2.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * @var CLK_T::CLKSEL1
 * Offset: 0x14  Clock Source Select Control Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |WDTSEL    |Watchdog Timer Clock Source Selection (Write Protect)
 * |        |          |00 = Reserved.
 * |        |          |01 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT).
 * |        |          |10 = Clock source from HCLK/2048.
 * |        |          |11 = Clock source from 10 kHz internal low speed RC oscillator (LIRC).
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[10:8]  |TMR0SEL   |TIMER0 Clock Source Selection
 * |        |          |000 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT).
 * |        |          |001 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT).
 * |        |          |010 = Clock source from PCLK0.
 * |        |          |011 = Clock source from external clock T0 pin.
 * |        |          |101 = Clock source from 10 kHz internal low speed RC oscillator (LIRC).
 * |        |          |111 = Clock source from 50 MHz internal high speed RC oscillator (HIRC).
 * |        |          |Others = Reserved.
 * |[14:12] |TMR1SEL   |TIMER1 Clock Source Selection
 * |        |          |000 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT).
 * |        |          |001 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT).
 * |        |          |010 = Clock source from PCLK0.
 * |        |          |011 = Clock source from external clock T1 pin.
 * |        |          |101 = Clock source from 10 kHz internal low speed RC oscillator (LIRC).
 * |        |          |111 = Clock source from 50 MHz internal high speed RC oscillator (HIRC).
 * |        |          |Others = Reserved.
 * |[18:16] |TMR2SEL   |TIMER2 Clock Source Selection
 * |        |          |000 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT).
 * |        |          |001 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT).
 * |        |          |010 = Clock source from PCLK1.
 * |        |          |011 = Clock source from external clock T2 pin.
 * |        |          |101 = Clock source from 10 kHz internal low speed RC oscillator (LIRC).
 * |        |          |111 = Clock source from 50 MHz internal high speed RC oscillator (HIRC).
 * |        |          |Others = Reserved.
 * |[22:20] |TMR3SEL   |TIMER3 Clock Source Selection
 * |        |          |000 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT).
 * |        |          |001 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT).
 * |        |          |010 = Clock source from PCLK1.
 * |        |          |011 = Clock source from external clock T3 pin.
 * |        |          |101 = Clock source from 10 kHz internal low speed RC oscillator (LIRC).
 * |        |          |111 = Clock source from 50 MHz internal high speed RC oscillator (HIRC).
 * |        |          |Others = Reserved.
 * |[25:24] |UART0SEL  |UART0 Clock Source Selection
 * |        |          |00 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT).
 * |        |          |01 = Clock source from PLL.
 * |        |          |10 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT).
 * |        |          |11 = Clock source from 50 MHz internal high speed RC oscillator (HIRC).
 * |[29:28] |CLKOSEL   |Clock Divider Clock Source Selection
 * |        |          |00 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT).
 * |        |          |01 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT).
 * |        |          |10 = Clock source from HCLK.
 * |        |          |11 = Clock source from 50 MHz internal high speed RC oscillator (HIRC).
 * |[31:30] |WWDTSEL   |Window Watchdog Timer Clock Source Selection
 * |        |          |10 = Clock source from HCLK/2048.
 * |        |          |11 = Clock source from 10 kHz internal low speed RC oscillator (LIRC).
 * |        |          |Others = Reserved.
 * @var CLK_T::CLKSEL2
 * Offset: 0x18  Clock Source Select Control Register 2
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PWM0SEL   |PWM0 Clock Source Selection
 * |        |          |The peripheral clock source of PWM0 is defined by PWM0SEL.
 * |        |          |0 = Clock source from PLL.
 * |        |          |1 = Clock source from PCLK0.
 * |[3:2]   |SPI0SEL   |SPI0 Clock Source Selection
 * |        |          |00 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT).
 * |        |          |01 = Clock source from PLL.
 * |        |          |10 = Clock source from PCLK0.
 * |        |          |11 = Clock source from 50 MHz internal high speed RC oscillator (HIRC).
 * |[5:4]   |SPI1SEL   |SPI1 Clock Source Selection
 * |        |          |00 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT).
 * |        |          |01 = Clock source from PLL.
 * |        |          |10 = Clock source from PCLK1.
 * |        |          |11 = Clock source from 50 MHz internal high speed RC oscillator (HIRC).
 * |[7:6]   |SPI2SEL   |SPI2 Clock Source Selection
 * |        |          |00 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT).
 * |        |          |01 = Clock source from PLL.
 * |        |          |10 = Clock source from PCLK0.
 * |        |          |11 = Clock source from 50 MHz internal high speed RC oscillator (HIRC).
 * @var CLK_T::CLKSEL3
 * Offset: 0x1C  Clock Source Select Control Register 3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8]     |RTCSEL    |RTC Clock Source Selection
 * |        |          |0 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT).
 * |        |          |1 = Clock source from 10 kHz internal low speed RC oscillator (LIRC).
 * |[17:16] |I2S0SEL   |I2S0 Clock Source Selection
 * |        |          |00 = Clock source from HXT clock.
 * |        |          |01 = Clock source from PLL clock.
 * |        |          |10 = Clock source from PCLK.
 * |        |          |11 = Clock source from HIRC clock.
 * @var CLK_T::CLKDIV0
 * Offset: 0x20  Clock Divider Number Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |HCLKDIV   |HCLK Clock Divide Number From HCLK Clock Source
 * |        |          |HCLK clock frequency = (HCLK clock source frequency) / (HCLKDIV + 1).
 * |[7:4]   |USBDIV    |USB Clock Divide Number From PLL Clock
 * |        |          |USB clock frequency = (PLL frequency) / (USBDIV + 1).
 * |[11:8]  |UART0DIV  |UART0 Clock Divide Number From UART0 Clock Source
 * |        |          |UART0 clock frequency = (UART0 clock source frequency) / (UART0DIV + 1).
 * |[23:16] |EADCDIV   |EADC Clock Divide Number From EADC Clock Source
 * |        |          |EADC clock frequency = (EADC clock source frequency) / (EADCDIV + 1).
 * @var CLK_T::PCLKDIV
 * Offset: 0x34  APB Clock Divider Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[2:0]   |APB0DIV   |APB0 Clock DIvider
 * |        |          |APB0 clock can be divided from HCLK
 * |        |          |000: PCLK0 = HCLK.
 * |        |          |001: PCLK0 = 1/2 HCLK.
 * |        |          |010: PCLK0 = 1/4 HCLK.
 * |        |          |011: PCLK0 = 1/8 HCLK.
 * |        |          |100: PCLK0 = 1/16 HCLK.
 * |        |          |Others: PCLK0 = HCLK.
 * |[6:4]   |APB1DIV   |APB1 Clock DIvider
 * |        |          |APB1 clock can be divided from HCLK
 * |        |          |000: PCLK1 = HCLK.
 * |        |          |001: PCLK1 = 1/2 HCLK.
 * |        |          |010: PCLK1 = 1/4 HCLK.
 * |        |          |011: PCLK1 = 1/8 HCLK.
 * |        |          |100: PCLK1 = 1/16 HCLK.
 * |        |          |Others: PCLK1 = HCLK.
 * @var CLK_T::PLLCTL
 * Offset: 0x40  PLL Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:0]   |FBDIV     |PLL Feedback Divider Control (Write Protect)
 * |        |          |Refer to the formulas below the table.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[13:9]  |INDIV     |PLL Input Divider Control (Write Protect)
 * |        |          |Refer to the formulas below the table.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[15:14] |OUTDIV    |PLL Output Divider Control (Write Protect)
 * |        |          |Refer to the formulas below the table.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[16]    |PD        |Power-down Mode (Write Protect)
 * |        |          |If set the PDEN bit to 1 in CLK_PWRCTL register, the PLL will enter Power-down mode, too.
 * |        |          |0 = PLL is in normal mode.
 * |        |          |1 = PLL is in Power-down mode (default).
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[17]    |BP        |PLL Bypass Control (Write Protect)
 * |        |          |0 = PLL is in normal mode (default).
 * |        |          |1 = PLL clock output is same as PLL input clock FIN.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[18]    |OE        |PLL OE (FOUT Enable) Pin Control (Write Protect)
 * |        |          |0 = PLL FOUT Enabled.
 * |        |          |1 = PLL FOUT is fixed low.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[19]    |PLLSRC    |PLL Source Clock Selection (Write Protect)
 * |        |          |0 = PLL source clock from 4~24 MHz external high-speed crystal oscillator (HXT).
 * |        |          |1 = PLL source clock from 50 MHz internal high-speed oscillator (HIRC).
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[23]    |STBSEL    |PLL Stable Counter Selection (Write Protect)
 * |        |          |0 = PLL stable time is 6144 PLL source clock (suitable for source clock is equal to or less than 12 MHz).
 * |        |          |1 = PLL stable time is 12288 PLL source clock (suitable for source clock is larger than 12 MHz).
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * @var CLK_T::STATUS
 * Offset: 0x50  Clock Status Monitor Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |HXTSTB    |HXT Clock Source Stable Flag (Read Only)
 * |        |          |0 = 4~24 MHz external high speed crystal oscillator (HXT) clock is not stable or disabled.
 * |        |          |1 = 4~24 MHz external high speed crystal oscillator (HXT) clock is stable and enabled.
 * |[1]     |LXTSTB    |LXT Clock Source Stable Flag (Read Only)
 * |        |          |0 = 32.768 kHz external low speed crystal oscillator (LXT) clock is not stable or disabled.
 * |        |          |1 = 32.768 kHz external low speed crystal oscillator (LXT) clock is stabled and enabled.
 * |[2]     |PLLSTB    |Internal PLL Clock Source Stable Flag (Read Only)
 * |        |          |0 = Internal PLL clock is not stable or disabled.
 * |        |          |1 = Internal PLL clock is stable and enabled.
 * |[3]     |LIRCSTB   |LIRC Clock Source Stable Flag (Read Only)
 * |        |          |0 = 10 kHz internal low speed RC oscillator (LIRC) clock is not stable or disabled.
 * |        |          |1 = 10 kHz internal low speed RC oscillator (LIRC) clock is stable and enabled.
 * |[4]     |HIRCSTB   |HIRC Clock Source Stable Flag (Read Only)
 * |        |          |0 = 50 MHz internal high speed RC oscillator (HIRC) clock is not stable or disabled.
 * |        |          |1 = 50 MHz internal high speed RC oscillator (HIRC) clock is stabe and enabled.
 * |[7]     |CLKSFAIL  |Clock Switching Fail Flag (Read Only)
 * |        |          |This bit is updated when software switches system clock source (CLK_CLKSEL0[2:0])
 * |        |          |If switch target clock is stable, this bit will be set to 0
 * |        |          |If switch target clock is not stable, this bit will be set to 1.
 * |        |          |0 = Clock switching success.
 * |        |          |1 = Clock switching failure.
 * |        |          |Note1: Write 1 to clear the bit to 0.
 * @var CLK_T::CLKOCTL
 * Offset: 0x60  Clock Output Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |FREQSEL   |Clock Output Frequency Selection
 * |        |          |The formula of output frequency is
 * |        |          |Fout = Fin/2(N+1).
 * |        |          |Fin is the input clock frequency.
 * |        |          |Fout is the frequency of divider output clock.
 * |        |          |N is the 4-bit value of FREQSEL[3:0].
 * |[4]     |CLKOEN    |Clock Output Enable Bit
 * |        |          |0 = Clock Output function Disabled.
 * |        |          |1 = Clock Output function Enabled.
 * |[5]     |DIV1EN    |Clock Output Divide One Enable Bit
 * |        |          |0 = Clock Output will output clock with source frequency divided by FREQSEL.
 * |        |          |1 = Clock Output will output clock with source frequency.
 * |[6]     |CLK1HZEN  |Clock Output 1Hz Enable Bit
 * |        |          |0 = 1 Hz clock output for 32.768 kHz frequency compensation Disabled.
 * |        |          |1 = 1 Hz clock output for 32.768 kHz frequency compensation Enabled.
 * @var CLK_T::CLKDCTL
 * Offset: 0x70  Clock Fail Detector Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[4]     |HXTFDEN   |HXT Clock Fail Detector Enable Bit
 * |        |          |0 = 4~24 MHz external high speed crystal oscillator (HXT) clock fail detector Disabled.
 * |        |          |1 = 4~24 MHz external high speed crystal oscillator (HXT) clock fail detector Enabled.
 * |[5]     |HXTFIEN   |HXT Clock Fail Interrupt Enable Bit
 * |        |          |0 = 4~24 MHz external high speed crystal oscillator (HXT) clock fail interrupt Disabled.
 * |        |          |1 = 4~24 MHz external high speed crystal oscillator (HXT) clock fail interrupt Enabled.
 * |[12]    |LXTFDEN   |LXT Clock Fail Detector Enable Bit
 * |        |          |0 = 32.768 kHz external low speed crystal oscillator (LXT) clock fail detector Disabled.
 * |        |          |1 = 32.768 kHz external low speed crystal oscillator (LXT) clock fail detector Enabled.
 * |[13]    |LXTFIEN   |LXT Clock Fail Interrupt Enable Bit
 * |        |          |0 = 32.768 kHz external low speed crystal oscillator (LXT) clock fail interrupt Disabled.
 * |        |          |1 = 32.768 kHz external low speed crystal oscillator (LXT) clock fail interrupt Enabled.
 * |[16]    |HXTFQDEN  |HXT Clock Frequency Monitor Enable Bit
 * |        |          |0 = 4~24 MHz external high speed crystal oscillator (HXT) clock frequency monitor Disabled.
 * |        |          |1 = 4~24 MHz external high speed crystal oscillator (HXT) clock frequency monitor Enabled.
 * |[17]    |HXTFQIEN  |HXT Clock Frequency Monitor Interrupt Enable Bit
 * |        |          |0 = 4~24 MHz external high speed crystal oscillator (HXT) clock frequency monitor fail interrupt Disabled.
 * |        |          |1 = 4~24 MHz external high speed crystal oscillator (HXT) clock frequency monitor fail interrupt Enabled.
 * @var CLK_T::CLKDSTS
 * Offset: 0x74  Clock Fail Detector Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |HXTFIF    |HXT Clock Fail Interrupt Flag
 * |        |          |0 = 4~24 MHz external high speed crystal oscillator (HXT) clock is normal.
 * |        |          |1 = 4~24 MHz external high speed crystal oscillator (HXT) clock stops.
 * |        |          |Note: Write 1 to clear the bit to 0.
 * |[1]     |LXTFIF    |LXT Clock Fail Interrupt Flag
 * |        |          |0 = 32.768 kHz external low speed crystal oscillator (LXT) clock is normal.
 * |        |          |1 = 32.768 kHz external low speed crystal oscillator (LXT) stops.
 * |        |          |Note: Write 1 to clear the bit to 0. 
 * |[8]     |HXTFQIF   |HXT Clock Frequency Monitor Interrupt Flag
 * |        |          |0 = 4~24 MHz external high speed crystal oscillator (HXT) clock is normal.
 * |        |          |1 = 4~24 MHz external high speed crystal oscillator (HXT) clock frequency is abnormal.
 * |        |          |Note: Write 1 to clear the bit to 0.
 * @var CLK_T::CDUPB
 * Offset: 0x78  Clock Frequency Detector Upper Boundary Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[9:0]   |UPERBD    |HXT Clock Frequency Detector Upper Boundary
 * |        |          |The bits define the high value of frequency monitor window.
 * |        |          |When HXT frequency monitor value higher than this register, the HXT frequency detect fail interrupt flag will set to 1.
 * @var CLK_T::CDLOWB
 * Offset: 0x7C  Clock Frequency Detector Lower Boundary Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[9:0]   |LOWERBD   |HXT Clock Frequency Detector Lower Boundary
 * |        |          |The bits define the low value of frequency monitor window.
 * |        |          |When HXT frequency monitor value lower than this register, the HXT frequency detect fail interrupt flag will set to 1.
 * @var CLK_T::PMUCTL
 * Offset: 0x90  Power Manager Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[2:0]   |PDMSEL    |Power-down Mode Selection (Write Protect)
 * |        |          |This is a protected register. Please refer to open lock sequence to program it.
 * |        |          |These bits control chip power-down mode grade selection when CPU execute WFI/WFE instruction.
 * |        |          |000 = Power-down mode is selected. (PD)
 * |        |          |001 = Low leakage Power-down mode is selected (LLPD).
 * |        |          |010 = Reserved.
 * |        |          |011 = Reserved.
 * |        |          |100 = Standby Power-down mode 0 is selected (SPD0) (SRAM retention).
 * |        |          |101 = Standby Power-down mode 1 is selected (SPD1).
 * |        |          |110 = Deep Power-down mode is selected (DPD).
 * |        |          |111 = Reserved.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[7]     |HVLIRCEN  |High Voltage Internal Low Frequency Oscillator Enable (Write Protect)
 * |        |          |This is a protected register. Please refer to open lock sequence to program it.
 * |        |          |0 = High voltage internal low frequency oscillator Disabled.
 * |        |          |1 = High voltage internal low frequency oscillator Enabled.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[8]     |WKTMREN   |Wake-up Timer Enable (Write Protect)
 * |        |          |This is a protected register. Please refer to open lock sequence to program it.
 * |        |          |0 = Wake-up timer disable at DPD/SPD mode.
 * |        |          |1 = Wake-up timer enabled at DPD/SPD mode.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[11:9]  |WKTMRIS   |Wake-up Timer Time-out Interval Select (Write Protect)
 * |        |          |This is a protected register. Please refer to open lock sequence to program it.
 * |        |          |These bits control wake-up timer time-out interval when chip at DPD/SPD mode.
 * |        |          |000 = Time-out interval is 128 OSC10K clocks (12.8 ms).
 * |        |          |001 = Time-out interval is 256 OSC10K clocks (25.6 ms).
 * |        |          |010 = Time-out interval is 512 OSC10K clocks (51.2 ms).
 * |        |          |011 = Time-out interval is 1024 OSC10K clocks (102.4ms).
 * |        |          |100 = Time-out interval is 4096 OSC10K clocks (409.6ms).
 * |        |          |101 = Time-out interval is 8192 OSC10K clocks (819.2ms).
 * |        |          |110 = Time-out interval is 16384 OSC10K clocks (1638.4ms).
 * |        |          |111 = Time-out interval is 65536 OSC10K clocks (6553.6ms).
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[17:16] |WKPINEN   |Wake-up Pin Enable (Write Protect)
 * |        |          |This is a protected register. Please refer to open lock sequence to program it.
 * |        |          |00 = Wake-up pin disable at Deep Power-down mode.
 * |        |          |01 = Wake-up pin rising edge enabled at Deep Power-down mode.
 * |        |          |10 = Wake-up pin falling edge enabled at Deep Power-down mode.
 * |        |          |11 = Wake-up pin both edge enabled at Deep Power-down mode.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[19]    |LVDSPWK   |LVD Standby Power-down Mode Wake-up Enable (Write Protect)
 * |        |          |This is a protected register. Please refer to open lock sequence to program it.
 * |        |          |0 = LVD wake-up disable at Standby Power-down mode.
 * |        |          |1 = LVD wake-up enabled at Standby Power-down mode.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * @var CLK_T::PMUSTS
 * Offset: 0x94  Power Manager Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PORWK     |Power-on-reset Wake-up Flag (Read Only)
 * |        |          |This flag indicates that wakeup of device was requested with a power-on reset
 * |        |          |This flag is cleared when DPD mode is entered.
 * |[1]     |PINWK     |Pin Wake-up Flag (Read Only)
 * |        |          |This flag indicates that wake-up of chip from Deep Power-down mode was requested by a transition of the WAKEUP pin (PA.15)
 * |        |          |This flag is cleared when DPD mode is entered.
 * |[2]     |DPD_TMRWK |DPD Mode Wake-up Timer Wake-up Flag (Read Only)
 * |        |          |This flag indicates that wake-up of chip was requested by wakeup timer time-out
 * |        |          |This flag is cleared when DPD mode is entered.
 * |[4]     |LVDWK     |LVD Wake-up Flag (Read Only)
 * |        |          |This flag indicates that wakeup of device from Standby Power-down mode was requested with a LVD happened
 * |        |          |This flag is cleared when SPD mode is entered.
 * |[5]     |RTCWK     |RTC Wake-up Flag (Read Only)
 * |        |          |This flag indicates that wakeup of device from Deep Power-down or Standby Power-down mode was requested with a RTC alarm or tick time happened
 * |        |          |This flag is cleared when DPD or SPD mode is entered.
 * |        |          |Note: RTCu9A57u5B8Cu8981u95DCu6389uFF0Cu5426u5247u5176u4ED6Wake up sourceu4E0Du80FDu7528,u56E0u70BArtcu6703keepu539Fu672Crtcu7684u8A2Du5B9A.
 * |[6]     |SPD_TMRWK |SPD Mode Wake-up Timer Wake-up Flag (Read Only)
 * |        |          |This flag indicates that wake-up of chip was requested by wakeup timer time-out
 * |        |          |This flag is cleared when SPD mode is entered.
 * |[7]     |DPD_RSTWK |DPD Mode Reset Wake-up Flag (Read Only)
 * |        |          |This flag indicates that wakeup of device was requested with a reset
 * |        |          |This flag is cleared when DPD mode is entered.
 * |[8]     |GPAWK     |GPA Wake-up Flag (Read Only)
 * |        |          |This flag indicates that wake-up of chip from Standby Power-down mode was requested by a transition of selected one GPA group pins
 * |        |          |This flag is cleared when SPD mode is entered.
 * |[9]     |GPBWK     |GPB Wake-up Flag (Read Only)
 * |        |          |This flag indicates that wake-up of chip from Standby Power-down mode was requested by a transition of selected one GPB group pins
 * |        |          |This flag is cleared when SPD mode is entered.
 * |[10]    |GPCWK     |GPC Wake-up Flag (Read Only)
 * |        |          |This flag indicates that wake-up of chip from Standby Power-down mode was requested by a transition of selected one GPC group pins
 * |        |          |This flag is cleared when SPD mode is entered.
 * |[11]    |GPDWK     |GPD Wake-up Flag (Read Only)
 * |        |          |This flag indicates that wake-up of chip from Standby Power-down mode was requested by a transition of selected one GPD group pins
 * |        |          |This flag is cleared when SPD mode is entered.
 * |[18:16] |PDMSTS    |Power-down Mode Status (Read Only)
 * |        |          |These bits reflect current chip power-down mode grade
 * |        |          |000 = Power-down mode is selected. (PD)
 * |        |          |001 = Low leakage Power-down mode is selected (LLPD).
 * |        |          |010 = Reserved.
 * |        |          |011 = Reserved.
 * |        |          |100 = Standby Power-down mode 0 is selected (SPD0) (SRAM retention).
 * |        |          |101 = Standby Power-down mode 1 is selected (SPD1).
 * |        |          |110 = Deep Power-down mode is selected (DPD).
 * |        |          |111 = Reserved.
 * @var CLK_T::LDOCTL
 * Offset: 0x98  Chip LDO Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |LPEN      |Low Power Enable Bit
 * |        |          |0 = The LDO is working at standard voltage and CPU can run at up to 160 MHz.
 * |        |          |1 = The LDO is working at low voltage to save power and CPU can run up to 4[PT1] MHz.
 * |        |          |[PT1]The spec should be confirmed by STA analysis
 * |[1]     |FWKEN     |Fast Wake-up Enable Bit
 * |        |          |0 = LDO off when chip enter power-down mode.
 * |        |          |1 = LDO keep on when chip entrt power-down mode to reach fast power-wodn wake-up behavior.
 * |[8]     |OVEN      |LDO over Drive Enable Bit
 * |        |          |0 = LDO keep standard voltage operating.
 * |        |          |1 = LDO over drive voltage operating.
 * |        |          |Note: CPU can run up to 200MHz only when OVEN set to 1
 * |[16]    |MEGBIAS_TMD_EN|MEGBIAS Band-gap 0 Test Mode Enable
 * |        |          |If this bit is set, MEGBIAS Band-gap 0 Enable can be set by MEGBIAS_BG0_EN.
 * |[17]    |MEGBIAS_BG0_EN|MEGBIAS Band-gap 0 Enable Bit
 * |        |          |If MEGBIAS_TMD_EN = 1, and MEGBIAS_BG0_EN=1, MEGBIAS will output the 0.8V band-gap voltage from MEGBIAS VBGU0.
 * |[18]    |MEGBIAS_BIDET_EN|MEGBIAS BIDET Enable Bit
 * |        |          |This bit is used to enable MGBIAS Low power band-gap holding capacitor leakage current detection.
 * @var CLK_T::SWKDBCTL
 * Offset: 0x9C  Standby Power-down Wake-up De-bounce Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |SWKDBCLKSEL|Standby Power-down Wake-up De-bounce Sampling Cycle Selection
 * |        |          |0000 = Sample wake-up input once per 1 clocks.
 * |        |          |0001 = Sample wake-up input once per 2 clocks.
 * |        |          |0010 = Sample wake-up input once per 4 clocks.
 * |        |          |0011 = Sample wake-up input once per 8 clocks.
 * |        |          |0100 = Sample wake-up input once per 16 clocks.
 * |        |          |0101 = Sample wake-up input once per 32 clocks.
 * |        |          |0110 = Sample wake-up input once per 64 clocks.
 * |        |          |0111 = Sample wake-up input once per 128 clocks.
 * |        |          |1000 = Sample wake-up input once per 256 clocks.
 * |        |          |1001 = Sample wake-up input once per 2*256 clocks.
 * |        |          |1010 = Sample wake-up input once per 4*256 clocks.
 * |        |          |1011 = Sample wake-up input once per 8*256 clocks.
 * |        |          |1100 = Sample wake-up input once per 16*256 clocks.
 * |        |          |1101 = Sample wake-up input once per 32*256 clocks.
 * |        |          |1110 = Sample wake-up input once per 64*256 clocks.
 * |        |          |1111 = Sample wake-up input once per 128*256 clocks.
 * |        |          |Note: De-bounce counter clock source is the 10 kHz internal low speed RC oscillator (LIRC).
 * @var CLK_T::PASWKCTL
 * Offset: 0xA0  GPA Standby Power-down Wakeup Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |WKEN      |Standby Power-down Pin Wake-up Enable Bit
 * |        |          |0 = PA group pin wake-up function disabled.
 * |        |          |1 = PA group pin wake-up function enabled.
 * |[1]     |PRWKEN    |Pin Rising Edge Wake-up Enable Bit
 * |        |          |0 = PA group pin rising edge wake-up function disabled.
 * |        |          |1 = PA group pin rising edge wake-up function enabled.
 * |[2]     |PFWKEN    |Pin Falling Edge Wake-up Enable Bit
 * |        |          |0 = PA group pin falling edge wake-up function disabled.
 * |        |          |1 = PA group pin falling edge wake-up function enabled.
 * |[7:4]   |WKPSEL    |PA Standby Power-down Wake-up Pin Select
 * |        |          |0000 = PA.0 wake-up function enabled.
 * |        |          |0001 = PA.1 wake-up function enabled.
 * |        |          |0010 = PA.2 wake-up function enabled.
 * |        |          |0011 = PA.3 wake-up function enabled.
 * |        |          |0100 = PA.4 wake-up function enabled.
 * |        |          |0101 = PA.5 wake-up function enabled.
 * |        |          |0110 = PA.6 wake-up function enabled.
 * |        |          |0111 = PA.7 wake-up function enabled.
 * |        |          |1000 = PA.8 wake-up function enabled.
 * |        |          |1001 = PA.9 wake-up function enabled.
 * |        |          |1010 = PA.10 wake-up function enabled.
 * |        |          |1011 = PA.11 wake-up function enabled.
 * |        |          |1100 = PA.12 wake-up function enabled.
 * |        |          |1101 = PA.13 wake-up function enabled.
 * |        |          |1110 = PA.14 wake-up function enabled.
 * |        |          |1111 = PA.15 wake-up function enabled.
 * |[8]     |DBEN      |PA Input Signal De-bounce Enable Bit
 * |        |          |The DBEN bit is used to enable the de-bounce function for each corresponding IO
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the wakeup
 * |        |          |The de-bounce clock source is the 10 kHz internal low speed RC oscillator.
 * |        |          |0 = Standby power-down wake-up pin De-bounce function disable.
 * |        |          |1 = Standby power-down wake-up pin De-bounce function enable.
 * |        |          |The de-bounce function is valid only for edge triggered.
 * @var CLK_T::PBSWKCTL
 * Offset: 0xA4  GPB Standby Power-down Wakeup Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |WKEN      |Standby Power-down Pin Wake-up Enable Bit
 * |        |          |0 = PB group pin wake-up function disabled.
 * |        |          |1 = PB group pin wake-up function enabled.
 * |[1]     |PRWKEN    |Pin Rising Edge Wake-up Enable Bit
 * |        |          |0 = PB group pin rising edge wake-up function disabled.
 * |        |          |1 = PB group pin rising edge wake-up function enabled.
 * |[2]     |PFWKEN    |Pin Falling Edge Wake-up Enable Bit
 * |        |          |0 = PB group pin falling edge wake-up function disabled.
 * |        |          |1 = PB group pin falling edge wake-up function enabled.
 * |[7:4]   |WKPSEL    |PB Standby Power-down Wake-up Pin Select
 * |        |          |0000 = PB.0 wake-up function enabled.
 * |        |          |0001 = PB.1 wake-up function enabled.
 * |        |          |0010 = PB.2 wake-up function enabled.
 * |        |          |0011 = PB.3 wake-up function enabled.
 * |        |          |0100 = PB.4 wake-up function enabled.
 * |        |          |0101 = PB.5 wake-up function enabled.
 * |        |          |0110 = PB.6 wake-up function enabled.
 * |        |          |0111 = PB.7 wake-up function enabled.
 * |        |          |1000 = PB.8 wake-up function enabled.
 * |        |          |1001 = PB.9 wake-up function enabled.
 * |        |          |1010 = Reserved.
 * |        |          |1011 = Reserved.
 * |        |          |1100 = PB.12 wake-up function enabled.
 * |        |          |1101 = PB.13 wake-up function enabled.
 * |        |          |1110 = PB.14 wake-up function enabled.
 * |        |          |1111 = Reserved.
 * |[8]     |DBEN      |PB Input Signal De-bounce Enable Bit
 * |        |          |The DBEN bit is used to enable the de-bounce function for each corresponding IO
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the wakeup
 * |        |          |The de-bounce clock source is the 10 kHz internal low speed RC oscillator.
 * |        |          |0 = Standby power-down wake-up pin De-bounce function disable.
 * |        |          |1 = Standby power-down wake-up pin De-bounce function enable.
 * |        |          |The de-bounce function is valid only for edge triggered.
 * @var CLK_T::PCSWKCTL
 * Offset: 0xA8  GPC Standby Power-down Wakeup Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |WKEN      |Standby Power-down Pin Wake-up Enable Bit
 * |        |          |0 = PC group pin wake-up function disabled.
 * |        |          |1 = PC group pin wake-up function enabled.
 * |[1]     |PRWKEN    |Pin Rising Edge Wake-up Enable Bit
 * |        |          |0 = PC group pin rising edge wake-up function disabled.
 * |        |          |1 = PC group pin rising edge wake-up function enabled.
 * |[2]     |PFWKEN    |Pin Falling Edge Wake-up Enable Bit
 * |        |          |0 = PC group pin falling edge wake-up function disabled.
 * |        |          |1 = PC group pin falling edge wake-up function enabled.
 * |[7:4]   |WKPSEL    |PC Stabdby Power-down Wake-up Pin Select
 * |        |          |0000 = PC.0 wake-up function enabled.
 * |        |          |0001 = PC.1 wake-up function enabled.
 * |        |          |0010 = PC.2 wake-up function enabled.
 * |        |          |0011 = PC.3 wake-up function enabled.
 * |        |          |0100 = PC.4 wake-up function enabled.
 * |        |          |0101 = PC.5 wake-up function enabled.
 * |        |          |0110 = PC.6 wake-up function enabled.
 * |        |          |0111 = PC.7 wake-up function enabled.
 * |        |          |1000 = PC.8 wake-up function enabled.
 * |        |          |1001 = PC.9 wake-up function enabled.
 * |        |          |1010 = PC.10 wake-up function enabled.
 * |        |          |1011 = PC.11 wake-up function enabled.
 * |        |          |1100 = PC.12 wake-up function enabled.
 * |        |          |1101 = PC.13 wake-up function enabled.
 * |        |          |1110 = PC.14 wake-up function enabled.
 * |        |          |1111 = PC.15 wake-up function enabled.
 * |[8]     |DBEN      |PC Input Signal De-bounce Enable Bit
 * |        |          |The DBEN bit is used to enable the de-bounce function for each corresponding IO
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the wakeup
 * |        |          |The de-bounce clock source is the 10 kHz internal low speed RC oscillator.
 * |        |          |0 = Standby power-down wake-up pin De-bounce function disable.
 * |        |          |1 = Standby power-down wake-up pin De-bounce function enable.
 * |        |          |The de-bounce function is valid only for edge triggered.
 * @var CLK_T::PDSWKCTL
 * Offset: 0xAC  GPD Standby Power-down Wakeup Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |WKEN      |Standby Power-down Pin Wake-up Enable Bit
 * |        |          |0 = PD group pin wake-up function disabled.
 * |        |          |1 = PD group pin wake-up function enabled.
 * |[1]     |PRWKEN    |Pin Rising Edge Wake-up Enable Bit
 * |        |          |0 = PD group pin rising edge wake-up function disabled.
 * |        |          |1 = PD group pin rising edge wake-up function enabled.
 * |[2]     |PFWKEN    |Pin Falling Edge Wake-up Enable Bit
 * |        |          |0 = PD group pin falling edge wake-up function disabled.
 * |        |          |1 = PD group pin falling edge wake-up function enabled.
 * |[7:4]   |WKPSEL    |PD Stabdby Power-down Wake-up Pin Select
 * |        |          |0000 = PD.0 wake-up function enabled.
 * |        |          |0001 = PD.1 wake-up function enabled.
 * |        |          |0010 = PD.2 wake-up function enabled.
 * |        |          |0011 = PD.3 wake-up function enabled.
 * |        |          |0100 = PD.4 wake-up function enabled.
 * |        |          |0101 = PD.5 wake-up function enabled.
 * |        |          |0110 = PD.6 wake-up function enabled.
 * |        |          |0111 = PD.7 wake-up function enabled.
 * |        |          |1000 = PD.8 wake-up function enabled.
 * |        |          |1001 = PD.9 wake-up function enabled.
 * |        |          |1010 = PD.10 wake-up function enabled.
 * |        |          |1011 = PD.11 wake-up function enabled.
 * |        |          |1100 = PD.12 wake-up function enabled.
 * |        |          |1101 = PD.13 wake-up function enabled.
 * |        |          |1110 = PD.14 wake-up function enabled.
 * |        |          |1111 = PD.15 wake-up function enabled.
 * |[8]     |DBEN      |PD Input Signal De-bounce Enable Bit
 * |        |          |The DBEN bit is used to enable the de-bounce function for each corresponding IO
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the wakeup
 * |        |          |The de-bounce clock source is the 10 kHz internal low speed RC oscillator.
 * |        |          |0 = Standby power-down wake-up pin De-bounce function disable.
 * |        |          |1 = Standby power-down wake-up pin De-bounce function enable.
 * |        |          |The de-bounce function is valid only for edge triggered.
 * @var CLK_T::IOPDCTL
 * Offset: 0xB0  GPIO Standby Power-down Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |IOHR      |GPIO Hold Release
 * |        |          |When GPIO enter standby power-down mode, all I/O status are hold to keep normal operating status
 * |        |          |After chip was waked up from standby power-down mode, the I/O are still keep hold status until user set this bit to release I/O hold status.
 * |        |          |This bit is auto cleared by hardware.
 * @var CLK_T::HXTFSEL
 * Offset: 0xB4  HXT Filter Select Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |HXTFSEL   |HXT Filter Select (Write Protect)
 * |        |          |0 = HXT frequency is > 12MHz.
 * |        |          |1 = HXT frequency is <= 12MHz.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * @var CLK_T::TESTCLK
 * Offset: 0xF0  Test Clock Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[5:0]   |TCLKSEL   |Test Clock Source Selection
 * |        |          |TCLKSEL : Clock Source
 * |        |          |000_0000 : Reserved
 * |        |          |000_0001 : OSC22M
 * |        |          |000_0010 : XTL12M
 * |        |          |000_0011 : XTL32K
 * |        |          |000_0100 : OSC10K
 * |        |          |000_0101 : PLLFin
 * |        |          |000_0110 : PLLFout
 * |        |          |000_0111 : PLL2Fout
 * |        |          |000_1000 : CKO_OUT
 * |        |          |000_1001 : STCLK
 * |        |          |000_1010 : SWCLKTCK
 * |        |          |000_1011 : HCLK
 * |        |          |000_1100 : HCLK_AHBMTX
 * |        |          |000_1101 : HCLK_APB
 * |        |          |000_1110 : HCLK_CRC
 * |        |          |000_1111 : HCLK_EBI
 * |        |          |001_0000 : HCLK_EMC
 * |        |          |001_0001 : HCLK_ETMC
 * |        |          |001_0010 : HCLK_FMC
 * |        |          |001_0011 : HCLK_M4
 * |        |          |001_0100 : HCLK_PDMA
 * |        |          |001_0101 : HCLK_SDIO0
 * |        |          |001_0110 : HCLK_SDIO1
 * |        |          |001_0111 : HCLK_SPACC
 * |        |          |001_1000 : HCLK_SPIM 
 * |        |          |001_1001 : HCLK_SRAM
 * |        |          |001_1010 : HCLK_SRAM_PARITY
 * |        |          |001_1011 : HCLK_SWDC
 * |        |          |001_1100 : HCLK_UDC20
 * |        |          |001_1101 : HCLK_USBH
 * |        |          |001_1110 : HCLK_USBH20
 * |        |          |001_1111 : HCLKcpu
 * |        |          |010_0000 : PCLK0
 * |        |          |010_0001 : PCLK1
 * |        |          |010_0010 : PCLKacmp
 * |        |          |010_0011 : PCLKadc
 * |        |          |010_0100 : PCLKbpwm0
 * |        |          |010_0101 : PCLKbpwm1
 * |        |          |010_0110 : PCLKcan0
 * |        |          |010_0111 : PCLKcan1
 * |        |          |010_1000 : PCLKdac
 * |        |          |010_1001 : PCLKecap0
 * |        |          |010_1010 : PCLKecap1
 * |        |          |010_1011 : PCLKi2c0
 * |        |          |010_1100 : PCLKi2c1
 * |        |          |010_1101 : PCLKi2c2
 * |        |          |010_1110 : PCLKi2s
 * |        |          |010_1111 : PCLKopa
 * |        |          |011_0000 : PCLKotg
 * |        |          |011_0001 : PCLKotg20
 * |        |          |011_0010 : PCLKpwm0
 * |        |          |011_0011 : PCLKpwm1
 * |        |          |011_0100 : PCLKqei0
 * |        |          |011_0101 : PCLKqei1
 * |        |          |011_0110 : PCLKrtc
 * |        |          |011_0111 : PCLKsmc0 
 * |        |          |011_1000 : PCLKsmc1
 * |        |          |011_1001 : PCLKsmc2
 * |        |          |011_1010 : PCLKspi0
 * |        |          |011_1011 : PCLKspi1
 * |        |          |011_1100 : PCLKspi2
 * |        |          |011_1101 : PCLKspi3
 * |        |          |011_1110 : PCLKspi4
 * |        |          |011_1111 : PCLKtm0
 * |        |          |100_0000 : PCLKtm01
 * |        |          |100_0001 : PCLKtm1
 * |        |          |100_0010 : PCLKtm2
 * |        |          |100_0011 : PCLKtm23
 * |        |          |100_0100 : PCLKtm3
 * |        |          |100_0101 : PCLKur0
 * |        |          |100_0110 : PCLKur1
 * |        |          |100_0111 : PCLKur2
 * |        |          |100_1000 : PCLKur3
 * |        |          |100_1000 : PCLKur4
 * |        |          |100_1000 : PCLKur5
 * |        |          |100_1000 : PCLKusbd
 * |        |          |100_1100 : PCLKusci0
 * |        |          |100_1101 : PCLKusci1
 * |        |          |100_1110 : PCLKwdg
 * |        |          |100_1111 : ADC_CLK
 * |        |          |101_0000 : BPWM0_CLK
 * |        |          |101_0001 : BPWM1_CLK
 * |        |          |101_0010 : I2S_CLK
 * |        |          |101_0011 : ISP_CLK
 * |        |          |101_0100 : OPA_CLK_12M
 * |        |          |101_0101 : OTG_CLK12M
 * |        |          |101_0110 : OTG_CLK48
 * |        |          |101_0111 : PWM0_CLK
 * |        |          |101_1000 : PWM1_CLK
 * |        |          |101_1001 : SDIO0_CLK
 * |        |          |101_1010 : SDIO1_CLK
 * |        |          |101_1011 : SMC0_CLK
 * |        |          |101_1100 : SMC1_CLK
 * |        |          |101_1101 : SMC2_CLK
 * |        |          |101_1110 : SPI0_CLK
 * |        |          |101_1111 : SPI1_CLK
 * |        |          |110_0000 : SPI1_ECLK_SRCLK
 * |        |          |110_0001 : SPI2_CLK
 * |        |          |110_0010 : SPI2_ECLK_SRCLK
 * |        |          |110_0011 : SPI3_CLK
 * |        |          |110_0100 : SPI3_ECLK_SRCLK
 * |        |          |110_0101 : SPI4_CLK
 * |        |          |110_0110 : SPI4_ECLK_SRCLK
 * |        |          |110_0111 : TMR0_CLK
 * |        |          |110_1000 : TMR1_CLK 
 * |        |          |110_1001 : TMR2_CLK
 * |        |          |110_1010 : TMR3_CLK
 * |        |          |110_1011 : UR0_CLK
 * |        |          |110_1100 : UR1_CLK
 * |        |          |110_1101 : UR2_CLK
 * |        |          |110_1110 : UR3_CLK
 * |        |          |110_1111 : UR4_CLK
 * |        |          |111_0000 : UR5_CLK
 * |        |          |111_0001 : USBD_CLK48
 * |        |          |111_0010 : USBH20_CLK48
 * |        |          |111_0011 : USBH_CLK48
 * |        |          |111_0100 : WDG_CLK
 * |        |          |111_0101 : WWDG_CLK
 * |        |          |111_0110 : emc_MDClk
 * |        |          |111_0111 : emc_MDClk_Inv_o_p
 * |        |          |111_1000 : emc_REFCLK2
 * |        |          |111_1001 : emc_REFCLK_SEL
 * |        |          |111_1010 : emc_RXCLK
 * |        |          |111_1011 : emc_TXCLK
 * |        |          |111_1100 : VCAP_CLK
 * |        |          |111_1101 : HCLK_VCAP
 * |        |          |111_1110 : Sensor_CLK 
 * |[7]     |TESTEN    |Test Clock Output Enable Bit
 * |        |          |0 = Test clock function Disabled.
 * |        |          |1 = Test clock function Enabled.
 * |        |          |Test clock will output through PD.0 pin.
 * @var CLK_T::PLLTEST
 * Offset: 0xF4  PLL Test Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PLL480M_SEL|PLL 480M Select (Write Protect)
 * |        |          |0 = PLL clock comes from analog PLL output.
 * |        |          |1 = PLL clock comes from USB2.0 PHY 480MHz.
 */
    __IO uint32_t PWRCTL;                /*!< [0x0000] System Power-down Control Register                               */
    __IO uint32_t AHBCLK;                /*!< [0x0004] AHB Devices Clock Enable Control Register                        */
    __IO uint32_t APBCLK0;               /*!< [0x0008] APB Devices Clock Enable Control Register 0                      */
    __IO uint32_t APBCLK1;               /*!< [0x000c] APB Devices Clock Enable Control Register 1                      */
    __IO uint32_t CLKSEL0;               /*!< [0x0010] Clock Source Select Control Register 0                           */
    __IO uint32_t CLKSEL1;               /*!< [0x0014] Clock Source Select Control Register 1                           */
    __IO uint32_t CLKSEL2;               /*!< [0x0018] Clock Source Select Control Register 2                           */
    __IO uint32_t CLKSEL3;               /*!< [0x001c] Clock Source Select Control Register 3                           */
    __IO uint32_t CLKDIV0;               /*!< [0x0020] Clock Divider Number Register 0                                  */
    __I  uint32_t RESERVE0[4];
    __IO uint32_t PCLKDIV;               /*!< [0x0034] APB Clock Divider Register                                       */
    __I  uint32_t RESERVE1[2];
    __IO uint32_t PLLCTL;                /*!< [0x0040] PLL Control Register                                             */
    __I  uint32_t RESERVE2[3];
    __I  uint32_t STATUS;                /*!< [0x0050] Clock Status Monitor Register                                    */
    __I  uint32_t RESERVE3[3];
    __IO uint32_t CLKOCTL;               /*!< [0x0060] Clock Output Control Register                                    */
    __I  uint32_t RESERVE4[3];
    __IO uint32_t CLKDCTL;               /*!< [0x0070] Clock Fail Detector Control Register                             */
    __IO uint32_t CLKDSTS;               /*!< [0x0074] Clock Fail Detector Status Register                              */
    __IO uint32_t CDUPB;                 /*!< [0x0078] Clock Frequency Detector Upper Boundary Register                 */
    __IO uint32_t CDLOWB;                /*!< [0x007c] Clock Frequency Detector Lower Boundary Register                 */
    __I  uint32_t RESERVE5[4];
    __IO uint32_t PMUCTL;                /*!< [0x0090] Power Manager Control Register                                   */
    __IO uint32_t PMUSTS;                /*!< [0x0094] Power Manager Status Register                                    */
    __IO uint32_t LDOCTL;                /*!< [0x0098] Chip LDO Control Register                                        */
    __IO uint32_t SWKDBCTL;              /*!< [0x009c] Standby Power-down Wake-up De-bounce Control Register            */
    __IO uint32_t PASWKCTL;              /*!< [0x00a0] GPA Standby Power-down Wakeup Control Register                   */
    __IO uint32_t PBSWKCTL;              /*!< [0x00a4] GPB Standby Power-down Wakeup Control Register                   */
    __IO uint32_t PCSWKCTL;              /*!< [0x00a8] GPC Standby Power-down Wakeup Control Register                   */
    __IO uint32_t PDSWKCTL;              /*!< [0x00ac] GPD Standby Power-down Wakeup Control Register                   */
    __IO uint32_t IOPDCTL;               /*!< [0x00b0] GPIO Standby Power-down Control Register                         */
    __IO uint32_t HXTFSEL;               /*!< [0x00b4] HXT Filter Select Control Register                               */
    __I  uint32_t RESERVE6[14];
    __IO uint32_t TESTCLK;               /*!< [0x00f0] Test Clock Control Register                                      */
    __IO uint32_t PLLTEST;               /*!< [0x00f4] PLL Test Control Register                                        */

} CLK_T;

/**
    @addtogroup CLK_CONST CLK Bit Field Definition
    Constant Definitions for CLK Controller
@{ */

#define CLK_PWRCTL_HXTEN_Pos             (0)                                               /*!< CLK_T::PWRCTL: HXTEN Position          */
#define CLK_PWRCTL_HXTEN_Msk             (0x1ul << CLK_PWRCTL_HXTEN_Pos)                   /*!< CLK_T::PWRCTL: HXTEN Mask              */

#define CLK_PWRCTL_LXTEN_Pos             (1)                                               /*!< CLK_T::PWRCTL: LXTEN Position          */
#define CLK_PWRCTL_LXTEN_Msk             (0x1ul << CLK_PWRCTL_LXTEN_Pos)                   /*!< CLK_T::PWRCTL: LXTEN Mask              */

#define CLK_PWRCTL_HIRCEN_Pos            (2)                                               /*!< CLK_T::PWRCTL: HIRCEN Position         */
#define CLK_PWRCTL_HIRCEN_Msk            (0x1ul << CLK_PWRCTL_HIRCEN_Pos)                  /*!< CLK_T::PWRCTL: HIRCEN Mask             */

#define CLK_PWRCTL_LIRCEN_Pos            (3)                                               /*!< CLK_T::PWRCTL: LIRCEN Position         */
#define CLK_PWRCTL_LIRCEN_Msk            (0x1ul << CLK_PWRCTL_LIRCEN_Pos)                  /*!< CLK_T::PWRCTL: LIRCEN Mask             */

#define CLK_PWRCTL_PDWKDLY_Pos           (4)                                               /*!< CLK_T::PWRCTL: PDWKDLY Position        */
#define CLK_PWRCTL_PDWKDLY_Msk           (0x1ul << CLK_PWRCTL_PDWKDLY_Pos)                 /*!< CLK_T::PWRCTL: PDWKDLY Mask            */

#define CLK_PWRCTL_PDWKIEN_Pos           (5)                                               /*!< CLK_T::PWRCTL: PDWKIEN Position        */
#define CLK_PWRCTL_PDWKIEN_Msk           (0x1ul << CLK_PWRCTL_PDWKIEN_Pos)                 /*!< CLK_T::PWRCTL: PDWKIEN Mask            */

#define CLK_PWRCTL_PDWKIF_Pos            (6)                                               /*!< CLK_T::PWRCTL: PDWKIF Position         */
#define CLK_PWRCTL_PDWKIF_Msk            (0x1ul << CLK_PWRCTL_PDWKIF_Pos)                  /*!< CLK_T::PWRCTL: PDWKIF Mask             */

#define CLK_PWRCTL_PDEN_Pos              (7)                                               /*!< CLK_T::PWRCTL: PDEN Position           */
#define CLK_PWRCTL_PDEN_Msk              (0x1ul << CLK_PWRCTL_PDEN_Pos)                    /*!< CLK_T::PWRCTL: PDEN Mask               */

#define CLK_PWRCTL_PDWTCPU_Pos           (8)                                               /*!< CLK_T::PWRCTL: PDWTCPU Position        */
#define CLK_PWRCTL_PDWTCPU_Msk           (0x1ul << CLK_PWRCTL_PDWTCPU_Pos)                 /*!< CLK_T::PWRCTL: PDWTCPU Mask            */

#define CLK_PWRCTL_DBPDEN_Pos            (9)                                               /*!< CLK_T::PWRCTL: DBPDEN Position         */
#define CLK_PWRCTL_DBPDEN_Msk            (0x1ul << CLK_PWRCTL_DBPDEN_Pos)                  /*!< CLK_T::PWRCTL: DBPDEN Mask             */

#define CLK_PWRCTL_HXTGAIN_Pos           (10)                                              /*!< CLK_T::PWRCTL: HXTGAIN Position        */
#define CLK_PWRCTL_HXTGAIN_Msk           (0x3ul << CLK_PWRCTL_HXTGAIN_Pos)                 /*!< CLK_T::PWRCTL: HXTGAIN Mask            */

#define CLK_PWRCTL_HXTSELTYP_Pos         (12)                                              /*!< CLK_T::PWRCTL: HXTSELTYP Position      */
#define CLK_PWRCTL_HXTSELTYP_Msk         (0x1ul << CLK_PWRCTL_HXTSELTYP_Pos)               /*!< CLK_T::PWRCTL: HXTSELTYP Mask          */

#define CLK_PWRCTL_HXTTBEN_Pos           (13)                                              /*!< CLK_T::PWRCTL: HXTTBEN Position        */
#define CLK_PWRCTL_HXTTBEN_Msk           (0x1ul << CLK_PWRCTL_HXTTBEN_Pos)                 /*!< CLK_T::PWRCTL: HXTTBEN Mask            */

#define CLK_PWRCTL_HIRCSTBS_Pos          (16)                                              /*!< CLK_T::PWRCTL: HIRCSTBS Position       */
#define CLK_PWRCTL_HIRCSTBS_Msk          (0x3ul << CLK_PWRCTL_HIRCSTBS_Pos)                /*!< CLK_T::PWRCTL: HIRCSTBS Mask           */

#define CLK_AHBCLK_PDMACKEN_Pos          (1)                                               /*!< CLK_T::AHBCLK: PDMACKEN Position       */
#define CLK_AHBCLK_PDMACKEN_Msk          (0x1ul << CLK_AHBCLK_PDMACKEN_Pos)                /*!< CLK_T::AHBCLK: PDMACKEN Mask           */

#define CLK_AHBCLK_ISPCKEN_Pos           (2)                                               /*!< CLK_T::AHBCLK: ISPCKEN Position        */
#define CLK_AHBCLK_ISPCKEN_Msk           (0x1ul << CLK_AHBCLK_ISPCKEN_Pos)                 /*!< CLK_T::AHBCLK: ISPCKEN Mask            */

#define CLK_AHBCLK_CRCCKEN_Pos           (7)                                               /*!< CLK_T::AHBCLK: CRCCKEN Position        */
#define CLK_AHBCLK_CRCCKEN_Msk           (0x1ul << CLK_AHBCLK_CRCCKEN_Pos)                 /*!< CLK_T::AHBCLK: CRCCKEN Mask            */

#define CLK_AHBCLK_FMCIDLE_Pos           (15)                                              /*!< CLK_T::AHBCLK: FMCIDLE Position        */
#define CLK_AHBCLK_FMCIDLE_Msk           (0x1ul << CLK_AHBCLK_FMCIDLE_Pos)                 /*!< CLK_T::AHBCLK: FMCIDLE Mask            */

#define CLK_APBCLK0_WDTCKEN_Pos          (0)                                               /*!< CLK_T::APBCLK0: WDTCKEN Position       */
#define CLK_APBCLK0_WDTCKEN_Msk          (0x1ul << CLK_APBCLK0_WDTCKEN_Pos)                /*!< CLK_T::APBCLK0: WDTCKEN Mask           */

#define CLK_APBCLK0_RTCCKEN_Pos          (1)                                               /*!< CLK_T::APBCLK0: RTCCKEN Position       */
#define CLK_APBCLK0_RTCCKEN_Msk          (0x1ul << CLK_APBCLK0_RTCCKEN_Pos)                /*!< CLK_T::APBCLK0: RTCCKEN Mask           */

#define CLK_APBCLK0_TMR0CKEN_Pos         (2)                                               /*!< CLK_T::APBCLK0: TMR0CKEN Position      */
#define CLK_APBCLK0_TMR0CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR0CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR0CKEN Mask          */

#define CLK_APBCLK0_TMR1CKEN_Pos         (3)                                               /*!< CLK_T::APBCLK0: TMR1CKEN Position      */
#define CLK_APBCLK0_TMR1CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR1CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR1CKEN Mask          */

#define CLK_APBCLK0_TMR2CKEN_Pos         (4)                                               /*!< CLK_T::APBCLK0: TMR2CKEN Position      */
#define CLK_APBCLK0_TMR2CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR2CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR2CKEN Mask          */

#define CLK_APBCLK0_TMR3CKEN_Pos         (5)                                               /*!< CLK_T::APBCLK0: TMR3CKEN Position      */
#define CLK_APBCLK0_TMR3CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR3CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR3CKEN Mask          */

#define CLK_APBCLK0_CLKOCKEN_Pos         (6)                                               /*!< CLK_T::APBCLK0: CLKOCKEN Position      */
#define CLK_APBCLK0_CLKOCKEN_Msk         (0x1ul << CLK_APBCLK0_CLKOCKEN_Pos)               /*!< CLK_T::APBCLK0: CLKOCKEN Mask          */

#define CLK_APBCLK0_I2C0CKEN_Pos         (8)                                               /*!< CLK_T::APBCLK0: I2C0CKEN Position      */
#define CLK_APBCLK0_I2C0CKEN_Msk         (0x1ul << CLK_APBCLK0_I2C0CKEN_Pos)               /*!< CLK_T::APBCLK0: I2C0CKEN Mask          */

#define CLK_APBCLK0_I2C1CKEN_Pos         (9)                                               /*!< CLK_T::APBCLK0: I2C1CKEN Position      */
#define CLK_APBCLK0_I2C1CKEN_Msk         (0x1ul << CLK_APBCLK0_I2C1CKEN_Pos)               /*!< CLK_T::APBCLK0: I2C1CKEN Mask          */

#define CLK_APBCLK0_SPI0CKEN_Pos         (12)                                              /*!< CLK_T::APBCLK0: SPI0CKEN Position      */
#define CLK_APBCLK0_SPI0CKEN_Msk         (0x1ul << CLK_APBCLK0_SPI0CKEN_Pos)               /*!< CLK_T::APBCLK0: SPI0CKEN Mask          */

#define CLK_APBCLK0_SPI1CKEN_Pos         (13)                                              /*!< CLK_T::APBCLK0: SPI1CKEN Position      */
#define CLK_APBCLK0_SPI1CKEN_Msk         (0x1ul << CLK_APBCLK0_SPI1CKEN_Pos)               /*!< CLK_T::APBCLK0: SPI1CKEN Mask          */

#define CLK_APBCLK0_SPI2CKEN_Pos         (14)                                              /*!< CLK_T::APBCLK0: SPI2CKEN Position      */
#define CLK_APBCLK0_SPI2CKEN_Msk         (0x1ul << CLK_APBCLK0_SPI2CKEN_Pos)               /*!< CLK_T::APBCLK0: SPI2CKEN Mask          */

#define CLK_APBCLK0_UART0CKEN_Pos        (16)                                              /*!< CLK_T::APBCLK0: UART0CKEN Position     */
#define CLK_APBCLK0_UART0CKEN_Msk        (0x1ul << CLK_APBCLK0_UART0CKEN_Pos)              /*!< CLK_T::APBCLK0: UART0CKEN Mask         */

#define CLK_APBCLK0_USBDCKEN_Pos         (27)                                              /*!< CLK_T::APBCLK0: USBDCKEN Position      */
#define CLK_APBCLK0_USBDCKEN_Msk         (0x1ul << CLK_APBCLK0_USBDCKEN_Pos)               /*!< CLK_T::APBCLK0: USBDCKEN Mask          */

#define CLK_APBCLK0_EADCCKEN_Pos         (28)                                              /*!< CLK_T::APBCLK0: EADCCKEN Position      */
#define CLK_APBCLK0_EADCCKEN_Msk         (0x1ul << CLK_APBCLK0_EADCCKEN_Pos)               /*!< CLK_T::APBCLK0: EADCCKEN Mask          */

#define CLK_APBCLK0_I2S0CKEN_Pos         (29)                                              /*!< CLK_T::APBCLK0: I2S0CKEN Position      */
#define CLK_APBCLK0_I2S0CKEN_Msk         (0x1ul << CLK_APBCLK0_I2S0CKEN_Pos)               /*!< CLK_T::APBCLK0: I2S0CKEN Mask          */

#define CLK_APBCLK1_DPWMCKEN_Pos         (6)                                               /*!< CLK_T::APBCLK1: DPWMCKEN Position      */
#define CLK_APBCLK1_DPWMCKEN_Msk         (0x1ul << CLK_APBCLK1_DPWMCKEN_Pos)               /*!< CLK_T::APBCLK1: DPWMCKEN Mask          */

#define CLK_APBCLK1_PWM0CKEN_Pos         (16)                                              /*!< CLK_T::APBCLK1: PWM0CKEN Position      */
#define CLK_APBCLK1_PWM0CKEN_Msk         (0x1ul << CLK_APBCLK1_PWM0CKEN_Pos)               /*!< CLK_T::APBCLK1: PWM0CKEN Mask          */

#define CLK_CLKSEL0_HCLKSEL_Pos          (0)                                               /*!< CLK_T::CLKSEL0: HCLKSEL Position       */
#define CLK_CLKSEL0_HCLKSEL_Msk          (0x7ul << CLK_CLKSEL0_HCLKSEL_Pos)                /*!< CLK_T::CLKSEL0: HCLKSEL Mask           */

#define CLK_CLKSEL0_STCLKSEL_Pos         (3)                                               /*!< CLK_T::CLKSEL0: STCLKSEL Position      */
#define CLK_CLKSEL0_STCLKSEL_Msk         (0x7ul << CLK_CLKSEL0_STCLKSEL_Pos)               /*!< CLK_T::CLKSEL0: STCLKSEL Mask          */

#define CLK_CLKSEL0_PCLK0SEL_Pos         (6)                                               /*!< CLK_T::CLKSEL0: PCLK0SEL Position      */
#define CLK_CLKSEL0_PCLK0SEL_Msk         (0x1ul << CLK_CLKSEL0_PCLK0SEL_Pos)               /*!< CLK_T::CLKSEL0: PCLK0SEL Mask          */

#define CLK_CLKSEL0_PCLK1SEL_Pos         (7)                                               /*!< CLK_T::CLKSEL0: PCLK1SEL Position      */
#define CLK_CLKSEL0_PCLK1SEL_Msk         (0x1ul << CLK_CLKSEL0_PCLK1SEL_Pos)               /*!< CLK_T::CLKSEL0: PCLK1SEL Mask          */

#define CLK_CLKSEL1_WDTSEL_Pos           (0)                                               /*!< CLK_T::CLKSEL1: WDTSEL Position        */
#define CLK_CLKSEL1_WDTSEL_Msk           (0x3ul << CLK_CLKSEL1_WDTSEL_Pos)                 /*!< CLK_T::CLKSEL1: WDTSEL Mask            */

#define CLK_CLKSEL1_TMR0SEL_Pos          (8)                                               /*!< CLK_T::CLKSEL1: TMR0SEL Position       */
#define CLK_CLKSEL1_TMR0SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR0SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR0SEL Mask           */

#define CLK_CLKSEL1_TMR1SEL_Pos          (12)                                              /*!< CLK_T::CLKSEL1: TMR1SEL Position       */
#define CLK_CLKSEL1_TMR1SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR1SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR1SEL Mask           */

#define CLK_CLKSEL1_TMR2SEL_Pos          (16)                                              /*!< CLK_T::CLKSEL1: TMR2SEL Position       */
#define CLK_CLKSEL1_TMR2SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR2SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR2SEL Mask           */

#define CLK_CLKSEL1_TMR3SEL_Pos          (20)                                              /*!< CLK_T::CLKSEL1: TMR3SEL Position       */
#define CLK_CLKSEL1_TMR3SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR3SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR3SEL Mask           */

#define CLK_CLKSEL1_UART0SEL_Pos         (24)                                              /*!< CLK_T::CLKSEL1: UART0SEL Position      */
#define CLK_CLKSEL1_UART0SEL_Msk         (0x3ul << CLK_CLKSEL1_UART0SEL_Pos)               /*!< CLK_T::CLKSEL1: UART0SEL Mask          */

#define CLK_CLKSEL1_CLKOSEL_Pos          (28)                                              /*!< CLK_T::CLKSEL1: CLKOSEL Position       */
#define CLK_CLKSEL1_CLKOSEL_Msk          (0x3ul << CLK_CLKSEL1_CLKOSEL_Pos)                /*!< CLK_T::CLKSEL1: CLKOSEL Mask           */

#define CLK_CLKSEL1_WWDTSEL_Pos          (30)                                              /*!< CLK_T::CLKSEL1: WWDTSEL Position       */
#define CLK_CLKSEL1_WWDTSEL_Msk          (0x3ul << CLK_CLKSEL1_WWDTSEL_Pos)                /*!< CLK_T::CLKSEL1: WWDTSEL Mask           */

#define CLK_CLKSEL2_PWM0SEL_Pos          (0)                                               /*!< CLK_T::CLKSEL2: PWM0SEL Position       */
#define CLK_CLKSEL2_PWM0SEL_Msk          (0x1ul << CLK_CLKSEL2_PWM0SEL_Pos)                /*!< CLK_T::CLKSEL2: PWM0SEL Mask           */

#define CLK_CLKSEL2_SPI0SEL_Pos          (2)                                               /*!< CLK_T::CLKSEL2: SPI0SEL Position       */
#define CLK_CLKSEL2_SPI0SEL_Msk          (0x3ul << CLK_CLKSEL2_SPI0SEL_Pos)                /*!< CLK_T::CLKSEL2: SPI0SEL Mask           */

#define CLK_CLKSEL2_SPI1SEL_Pos          (4)                                               /*!< CLK_T::CLKSEL2: SPI1SEL Position       */
#define CLK_CLKSEL2_SPI1SEL_Msk          (0x3ul << CLK_CLKSEL2_SPI1SEL_Pos)                /*!< CLK_T::CLKSEL2: SPI1SEL Mask           */

#define CLK_CLKSEL2_SPI2SEL_Pos          (6)                                               /*!< CLK_T::CLKSEL2: SPI2SEL Position       */
#define CLK_CLKSEL2_SPI2SEL_Msk          (0x3ul << CLK_CLKSEL2_SPI2SEL_Pos)                /*!< CLK_T::CLKSEL2: SPI2SEL Mask           */

#define CLK_CLKSEL2_DPWMSEL_Pos          (12)                                              /*!< CLK_T::CLKSEL2: DPWMSEL Position       */
#define CLK_CLKSEL2_DPWMSEL_Msk          (0x3ul << CLK_CLKSEL2_DPWMSEL_Pos)                /*!< CLK_T::CLKSEL2: DPWMSEL Mask           */

#define CLK_CLKSEL3_RTCSEL_Pos           (8)                                               /*!< CLK_T::CLKSEL3: RTCSEL Position        */
#define CLK_CLKSEL3_RTCSEL_Msk           (0x1ul << CLK_CLKSEL3_RTCSEL_Pos)                 /*!< CLK_T::CLKSEL3: RTCSEL Mask            */

#define CLK_CLKSEL3_I2S0SEL_Pos          (16)                                              /*!< CLK_T::CLKSEL3: I2S0SEL Position       */
#define CLK_CLKSEL3_I2S0SEL_Msk          (0x3ul << CLK_CLKSEL3_I2S0SEL_Pos)                /*!< CLK_T::CLKSEL3: I2S0SEL Mask           */

#define CLK_CLKDIV0_HCLKDIV_Pos          (0)                                               /*!< CLK_T::CLKDIV0: HCLKDIV Position       */
#define CLK_CLKDIV0_HCLKDIV_Msk          (0xful << CLK_CLKDIV0_HCLKDIV_Pos)                /*!< CLK_T::CLKDIV0: HCLKDIV Mask           */

#define CLK_CLKDIV0_USBDIV_Pos           (4)                                               /*!< CLK_T::CLKDIV0: USBDIV Position        */
#define CLK_CLKDIV0_USBDIV_Msk           (0xful << CLK_CLKDIV0_USBDIV_Pos)                 /*!< CLK_T::CLKDIV0: USBDIV Mask            */

#define CLK_CLKDIV0_UART0DIV_Pos         (8)                                               /*!< CLK_T::CLKDIV0: UART0DIV Position      */
#define CLK_CLKDIV0_UART0DIV_Msk         (0xful << CLK_CLKDIV0_UART0DIV_Pos)               /*!< CLK_T::CLKDIV0: UART0DIV Mask          */

#define CLK_CLKDIV0_EADCDIV_Pos          (16)                                              /*!< CLK_T::CLKDIV0: EADCDIV Position       */
#define CLK_CLKDIV0_EADCDIV_Msk          (0xfful << CLK_CLKDIV0_EADCDIV_Pos)               /*!< CLK_T::CLKDIV0: EADCDIV Mask           */

#define CLK_PCLKDIV_APB0DIV_Pos          (0)                                               /*!< CLK_T::PCLKDIV: APB0DIV Position       */
#define CLK_PCLKDIV_APB0DIV_Msk          (0x7ul << CLK_PCLKDIV_APB0DIV_Pos)                /*!< CLK_T::PCLKDIV: APB0DIV Mask           */

#define CLK_PCLKDIV_APB1DIV_Pos          (4)                                               /*!< CLK_T::PCLKDIV: APB1DIV Position       */
#define CLK_PCLKDIV_APB1DIV_Msk          (0x7ul << CLK_PCLKDIV_APB1DIV_Pos)                /*!< CLK_T::PCLKDIV: APB1DIV Mask           */

#define CLK_PLLCTL_FBDIV_Pos             (0)                                               /*!< CLK_T::PLLCTL: FBDIV Position          */
#define CLK_PLLCTL_FBDIV_Msk             (0x1fful << CLK_PLLCTL_FBDIV_Pos)                 /*!< CLK_T::PLLCTL: FBDIV Mask              */

#define CLK_PLLCTL_INDIV_Pos             (9)                                               /*!< CLK_T::PLLCTL: INDIV Position          */
#define CLK_PLLCTL_INDIV_Msk             (0x1ful << CLK_PLLCTL_INDIV_Pos)                  /*!< CLK_T::PLLCTL: INDIV Mask              */

#define CLK_PLLCTL_OUTDIV_Pos            (14)                                              /*!< CLK_T::PLLCTL: OUTDIV Position         */
#define CLK_PLLCTL_OUTDIV_Msk            (0x3ul << CLK_PLLCTL_OUTDIV_Pos)                  /*!< CLK_T::PLLCTL: OUTDIV Mask             */

#define CLK_PLLCTL_PD_Pos                (16)                                              /*!< CLK_T::PLLCTL: PD Position             */
#define CLK_PLLCTL_PD_Msk                (0x1ul << CLK_PLLCTL_PD_Pos)                      /*!< CLK_T::PLLCTL: PD Mask                 */

#define CLK_PLLCTL_BP_Pos                (17)                                              /*!< CLK_T::PLLCTL: BP Position             */
#define CLK_PLLCTL_BP_Msk                (0x1ul << CLK_PLLCTL_BP_Pos)                      /*!< CLK_T::PLLCTL: BP Mask                 */

#define CLK_PLLCTL_OE_Pos                (18)                                              /*!< CLK_T::PLLCTL: OE Position             */
#define CLK_PLLCTL_OE_Msk                (0x1ul << CLK_PLLCTL_OE_Pos)                      /*!< CLK_T::PLLCTL: OE Mask                 */

#define CLK_PLLCTL_PLLSRC_Pos            (19)                                              /*!< CLK_T::PLLCTL: PLLSRC Position         */
#define CLK_PLLCTL_PLLSRC_Msk            (0x1ul << CLK_PLLCTL_PLLSRC_Pos)                  /*!< CLK_T::PLLCTL: PLLSRC Mask             */

#define CLK_PLLCTL_STBSEL_Pos            (23)                                              /*!< CLK_T::PLLCTL: STBSEL Position         */
#define CLK_PLLCTL_STBSEL_Msk            (0x1ul << CLK_PLLCTL_STBSEL_Pos)                  /*!< CLK_T::PLLCTL: STBSEL Mask             */

#define CLK_STATUS_HXTSTB_Pos            (0)                                               /*!< CLK_T::STATUS: HXTSTB Position         */
#define CLK_STATUS_HXTSTB_Msk            (0x1ul << CLK_STATUS_HXTSTB_Pos)                  /*!< CLK_T::STATUS: HXTSTB Mask             */

#define CLK_STATUS_LXTSTB_Pos            (1)                                               /*!< CLK_T::STATUS: LXTSTB Position         */
#define CLK_STATUS_LXTSTB_Msk            (0x1ul << CLK_STATUS_LXTSTB_Pos)                  /*!< CLK_T::STATUS: LXTSTB Mask             */

#define CLK_STATUS_PLLSTB_Pos            (2)                                               /*!< CLK_T::STATUS: PLLSTB Position         */
#define CLK_STATUS_PLLSTB_Msk            (0x1ul << CLK_STATUS_PLLSTB_Pos)                  /*!< CLK_T::STATUS: PLLSTB Mask             */

#define CLK_STATUS_LIRCSTB_Pos           (3)                                               /*!< CLK_T::STATUS: LIRCSTB Position        */
#define CLK_STATUS_LIRCSTB_Msk           (0x1ul << CLK_STATUS_LIRCSTB_Pos)                 /*!< CLK_T::STATUS: LIRCSTB Mask            */

#define CLK_STATUS_HIRCSTB_Pos           (4)                                               /*!< CLK_T::STATUS: HIRCSTB Position        */
#define CLK_STATUS_HIRCSTB_Msk           (0x1ul << CLK_STATUS_HIRCSTB_Pos)                 /*!< CLK_T::STATUS: HIRCSTB Mask            */

#define CLK_STATUS_CLKSFAIL_Pos          (7)                                               /*!< CLK_T::STATUS: CLKSFAIL Position       */
#define CLK_STATUS_CLKSFAIL_Msk          (0x1ul << CLK_STATUS_CLKSFAIL_Pos)                /*!< CLK_T::STATUS: CLKSFAIL Mask           */

#define CLK_CLKOCTL_FREQSEL_Pos          (0)                                               /*!< CLK_T::CLKOCTL: FREQSEL Position       */
#define CLK_CLKOCTL_FREQSEL_Msk          (0xful << CLK_CLKOCTL_FREQSEL_Pos)                /*!< CLK_T::CLKOCTL: FREQSEL Mask           */

#define CLK_CLKOCTL_CLKOEN_Pos           (4)                                               /*!< CLK_T::CLKOCTL: CLKOEN Position        */
#define CLK_CLKOCTL_CLKOEN_Msk           (0x1ul << CLK_CLKOCTL_CLKOEN_Pos)                 /*!< CLK_T::CLKOCTL: CLKOEN Mask            */

#define CLK_CLKOCTL_DIV1EN_Pos           (5)                                               /*!< CLK_T::CLKOCTL: DIV1EN Position        */
#define CLK_CLKOCTL_DIV1EN_Msk           (0x1ul << CLK_CLKOCTL_DIV1EN_Pos)                 /*!< CLK_T::CLKOCTL: DIV1EN Mask            */

#define CLK_CLKOCTL_CLK1HZEN_Pos         (6)                                               /*!< CLK_T::CLKOCTL: CLK1HZEN Position      */
#define CLK_CLKOCTL_CLK1HZEN_Msk         (0x1ul << CLK_CLKOCTL_CLK1HZEN_Pos)               /*!< CLK_T::CLKOCTL: CLK1HZEN Mask          */

#define CLK_CLKDCTL_HXTFDEN_Pos          (4)                                               /*!< CLK_T::CLKDCTL: HXTFDEN Position       */
#define CLK_CLKDCTL_HXTFDEN_Msk          (0x1ul << CLK_CLKDCTL_HXTFDEN_Pos)                /*!< CLK_T::CLKDCTL: HXTFDEN Mask           */

#define CLK_CLKDCTL_HXTFIEN_Pos          (5)                                               /*!< CLK_T::CLKDCTL: HXTFIEN Position       */
#define CLK_CLKDCTL_HXTFIEN_Msk          (0x1ul << CLK_CLKDCTL_HXTFIEN_Pos)                /*!< CLK_T::CLKDCTL: HXTFIEN Mask           */

#define CLK_CLKDCTL_LXTFDEN_Pos          (12)                                              /*!< CLK_T::CLKDCTL: LXTFDEN Position       */
#define CLK_CLKDCTL_LXTFDEN_Msk          (0x1ul << CLK_CLKDCTL_LXTFDEN_Pos)                /*!< CLK_T::CLKDCTL: LXTFDEN Mask           */

#define CLK_CLKDCTL_LXTFIEN_Pos          (13)                                              /*!< CLK_T::CLKDCTL: LXTFIEN Position       */
#define CLK_CLKDCTL_LXTFIEN_Msk          (0x1ul << CLK_CLKDCTL_LXTFIEN_Pos)                /*!< CLK_T::CLKDCTL: LXTFIEN Mask           */

#define CLK_CLKDCTL_HXTFQDEN_Pos         (16)                                              /*!< CLK_T::CLKDCTL: HXTFQDEN Position      */
#define CLK_CLKDCTL_HXTFQDEN_Msk         (0x1ul << CLK_CLKDCTL_HXTFQDEN_Pos)               /*!< CLK_T::CLKDCTL: HXTFQDEN Mask          */

#define CLK_CLKDCTL_HXTFQIEN_Pos         (17)                                              /*!< CLK_T::CLKDCTL: HXTFQIEN Position      */
#define CLK_CLKDCTL_HXTFQIEN_Msk         (0x1ul << CLK_CLKDCTL_HXTFQIEN_Pos)               /*!< CLK_T::CLKDCTL: HXTFQIEN Mask          */

#define CLK_CLKDSTS_HXTFIF_Pos           (0)                                               /*!< CLK_T::CLKDSTS: HXTFIF Position        */
#define CLK_CLKDSTS_HXTFIF_Msk           (0x1ul << CLK_CLKDSTS_HXTFIF_Pos)                 /*!< CLK_T::CLKDSTS: HXTFIF Mask            */

#define CLK_CLKDSTS_LXTFIF_Pos           (1)                                               /*!< CLK_T::CLKDSTS: LXTFIF Position        */
#define CLK_CLKDSTS_LXTFIF_Msk           (0x1ul << CLK_CLKDSTS_LXTFIF_Pos)                 /*!< CLK_T::CLKDSTS: LXTFIF Mask            */

#define CLK_CLKDSTS_HXTFQIF_Pos          (8)                                               /*!< CLK_T::CLKDSTS: HXTFQIF Position       */
#define CLK_CLKDSTS_HXTFQIF_Msk          (0x1ul << CLK_CLKDSTS_HXTFQIF_Pos)                /*!< CLK_T::CLKDSTS: HXTFQIF Mask           */

#define CLK_CDUPB_UPERBD_Pos             (0)                                               /*!< CLK_T::CDUPB: UPERBD Position          */
#define CLK_CDUPB_UPERBD_Msk             (0x3fful << CLK_CDUPB_UPERBD_Pos)                 /*!< CLK_T::CDUPB: UPERBD Mask              */

#define CLK_CDLOWB_LOWERBD_Pos           (0)                                               /*!< CLK_T::CDLOWB: LOWERBD Position        */
#define CLK_CDLOWB_LOWERBD_Msk           (0x3fful << CLK_CDLOWB_LOWERBD_Pos)               /*!< CLK_T::CDLOWB: LOWERBD Mask            */

#define CLK_PMUCTL_PDMSEL_Pos            (0)                                               /*!< CLK_T::PMUCTL: PDMSEL Position         */
#define CLK_PMUCTL_PDMSEL_Msk            (0x7ul << CLK_PMUCTL_PDMSEL_Pos)                  /*!< CLK_T::PMUCTL: PDMSEL Mask             */

#define CLK_PMUCTL_HVLIRCEN_Pos          (7)                                               /*!< CLK_T::PMUCTL: HVLIRCEN Position       */
#define CLK_PMUCTL_HVLIRCEN_Msk          (0x1ul << CLK_PMUCTL_HVLIRCEN_Pos)                /*!< CLK_T::PMUCTL: HVLIRCEN Mask           */

#define CLK_PMUCTL_WKTMREN_Pos           (8)                                               /*!< CLK_T::PMUCTL: WKTMREN Position        */
#define CLK_PMUCTL_WKTMREN_Msk           (0x1ul << CLK_PMUCTL_WKTMREN_Pos)                 /*!< CLK_T::PMUCTL: WKTMREN Mask            */

#define CLK_PMUCTL_WKTMRIS_Pos           (9)                                               /*!< CLK_T::PMUCTL: WKTMRIS Position        */
#define CLK_PMUCTL_WKTMRIS_Msk           (0x7ul << CLK_PMUCTL_WKTMRIS_Pos)                 /*!< CLK_T::PMUCTL: WKTMRIS Mask            */

#define CLK_PMUCTL_WKPINEN_Pos           (16)                                              /*!< CLK_T::PMUCTL: WKPINEN Position        */
#define CLK_PMUCTL_WKPINEN_Msk           (0x3ul << CLK_PMUCTL_WKPINEN_Pos)                 /*!< CLK_T::PMUCTL: WKPINEN Mask            */

#define CLK_PMUCTL_LVDSPWK_Pos           (19)                                              /*!< CLK_T::PMUCTL: LVDSPWK Position        */
#define CLK_PMUCTL_LVDSPWK_Msk           (0x1ul << CLK_PMUCTL_LVDSPWK_Pos)                 /*!< CLK_T::PMUCTL: LVDSPWK Mask            */

#define CLK_PMUSTS_PORWK_Pos             (0)                                               /*!< CLK_T::PMUSTS: PORWK Position          */
#define CLK_PMUSTS_PORWK_Msk             (0x1ul << CLK_PMUSTS_PORWK_Pos)                   /*!< CLK_T::PMUSTS: PORWK Mask              */

#define CLK_PMUSTS_PINWK_Pos             (1)                                               /*!< CLK_T::PMUSTS: PINWK Position          */
#define CLK_PMUSTS_PINWK_Msk             (0x1ul << CLK_PMUSTS_PINWK_Pos)                   /*!< CLK_T::PMUSTS: PINWK Mask              */

#define CLK_PMUSTS_DPD_TMRWK_Pos         (2)                                               /*!< CLK_T::PMUSTS: DPD_TMRWK Position      */
#define CLK_PMUSTS_DPD_TMRWK_Msk         (0x1ul << CLK_PMUSTS_DPD_TMRWK_Pos)               /*!< CLK_T::PMUSTS: DPD_TMRWK Mask          */

#define CLK_PMUSTS_LVDWK_Pos             (4)                                               /*!< CLK_T::PMUSTS: LVDWK Position          */
#define CLK_PMUSTS_LVDWK_Msk             (0x1ul << CLK_PMUSTS_LVDWK_Pos)                   /*!< CLK_T::PMUSTS: LVDWK Mask              */

#define CLK_PMUSTS_RTCWK_Pos             (5)                                               /*!< CLK_T::PMUSTS: RTCWK Position          */
#define CLK_PMUSTS_RTCWK_Msk             (0x1ul << CLK_PMUSTS_RTCWK_Pos)                   /*!< CLK_T::PMUSTS: RTCWK Mask              */

#define CLK_PMUSTS_SPD_TMRWK_Pos         (6)                                               /*!< CLK_T::PMUSTS: SPD_TMRWK Position      */
#define CLK_PMUSTS_SPD_TMRWK_Msk         (0x1ul << CLK_PMUSTS_SPD_TMRWK_Pos)               /*!< CLK_T::PMUSTS: SPD_TMRWK Mask          */

#define CLK_PMUSTS_DPD_RSTWK_Pos         (7)                                               /*!< CLK_T::PMUSTS: DPD_RSTWK Position      */
#define CLK_PMUSTS_DPD_RSTWK_Msk         (0x1ul << CLK_PMUSTS_DPD_RSTWK_Pos)               /*!< CLK_T::PMUSTS: DPD_RSTWK Mask          */

#define CLK_PMUSTS_GPAWK_Pos             (8)                                               /*!< CLK_T::PMUSTS: GPAWK Position          */
#define CLK_PMUSTS_GPAWK_Msk             (0x1ul << CLK_PMUSTS_GPAWK_Pos)                   /*!< CLK_T::PMUSTS: GPAWK Mask              */

#define CLK_PMUSTS_GPBWK_Pos             (9)                                               /*!< CLK_T::PMUSTS: GPBWK Position          */
#define CLK_PMUSTS_GPBWK_Msk             (0x1ul << CLK_PMUSTS_GPBWK_Pos)                   /*!< CLK_T::PMUSTS: GPBWK Mask              */

#define CLK_PMUSTS_GPCWK_Pos             (10)                                              /*!< CLK_T::PMUSTS: GPCWK Position          */
#define CLK_PMUSTS_GPCWK_Msk             (0x1ul << CLK_PMUSTS_GPCWK_Pos)                   /*!< CLK_T::PMUSTS: GPCWK Mask              */

#define CLK_PMUSTS_GPDWK_Pos             (11)                                              /*!< CLK_T::PMUSTS: GPDWK Position          */
#define CLK_PMUSTS_GPDWK_Msk             (0x1ul << CLK_PMUSTS_GPDWK_Pos)                   /*!< CLK_T::PMUSTS: GPDWK Mask              */

#define CLK_PMUSTS_PDMSTS_Pos            (16)                                              /*!< CLK_T::PMUSTS: PDMSTS Position         */
#define CLK_PMUSTS_PDMSTS_Msk            (0x7ul << CLK_PMUSTS_PDMSTS_Pos)                  /*!< CLK_T::PMUSTS: PDMSTS Mask             */

#define CLK_LDOCTL_LPEN_Pos              (0)                                               /*!< CLK_T::LDOCTL: LPEN Position           */
#define CLK_LDOCTL_LPEN_Msk              (0x1ul << CLK_LDOCTL_LPEN_Pos)                    /*!< CLK_T::LDOCTL: LPEN Mask               */

#define CLK_LDOCTL_FWKEN_Pos             (1)                                               /*!< CLK_T::LDOCTL: FWKEN Position          */
#define CLK_LDOCTL_FWKEN_Msk             (0x1ul << CLK_LDOCTL_FWKEN_Pos)                   /*!< CLK_T::LDOCTL: FWKEN Mask              */

#define CLK_LDOCTL_OVEN_Pos              (8)                                               /*!< CLK_T::LDOCTL: OVEN Position           */
#define CLK_LDOCTL_OVEN_Msk              (0x1ul << CLK_LDOCTL_OVEN_Pos)                    /*!< CLK_T::LDOCTL: OVEN Mask               */

#define CLK_LDOCTL_MEGBIAS_TMD_EN_Pos    (16)                                              /*!< CLK_T::LDOCTL: MEGBIAS_TMD_EN Position */
#define CLK_LDOCTL_MEGBIAS_TMD_EN_Msk    (0x1ul << CLK_LDOCTL_MEGBIAS_TMD_EN_Pos)          /*!< CLK_T::LDOCTL: MEGBIAS_TMD_EN Mask     */

#define CLK_LDOCTL_MEGBIAS_BG0_EN_Pos    (17)                                              /*!< CLK_T::LDOCTL: MEGBIAS_BG0_EN Position */
#define CLK_LDOCTL_MEGBIAS_BG0_EN_Msk    (0x1ul << CLK_LDOCTL_MEGBIAS_BG0_EN_Pos)          /*!< CLK_T::LDOCTL: MEGBIAS_BG0_EN Mask     */

#define CLK_LDOCTL_MEGBIAS_BIDET_EN_Pos  (18)                                              /*!< CLK_T::LDOCTL: MEGBIAS_BIDET_EN Position*/
#define CLK_LDOCTL_MEGBIAS_BIDET_EN_Msk  (0x1ul << CLK_LDOCTL_MEGBIAS_BIDET_EN_Pos)        /*!< CLK_T::LDOCTL: MEGBIAS_BIDET_EN Mask   */

#define CLK_SWKDBCTL_SWKDBCLKSEL_Pos     (0)                                               /*!< CLK_T::SWKDBCTL: SWKDBCLKSEL Position  */
#define CLK_SWKDBCTL_SWKDBCLKSEL_Msk     (0xful << CLK_SWKDBCTL_SWKDBCLKSEL_Pos)           /*!< CLK_T::SWKDBCTL: SWKDBCLKSEL Mask      */

#define CLK_PASWKCTL_WKEN_Pos            (0)                                               /*!< CLK_T::PASWKCTL: WKEN Position         */
#define CLK_PASWKCTL_WKEN_Msk            (0x1ul << CLK_PASWKCTL_WKEN_Pos)                  /*!< CLK_T::PASWKCTL: WKEN Mask             */

#define CLK_PASWKCTL_PRWKEN_Pos          (1)                                               /*!< CLK_T::PASWKCTL: PRWKEN Position       */
#define CLK_PASWKCTL_PRWKEN_Msk          (0x1ul << CLK_PASWKCTL_PRWKEN_Pos)                /*!< CLK_T::PASWKCTL: PRWKEN Mask           */

#define CLK_PASWKCTL_PFWKEN_Pos          (2)                                               /*!< CLK_T::PASWKCTL: PFWKEN Position       */
#define CLK_PASWKCTL_PFWKEN_Msk          (0x1ul << CLK_PASWKCTL_PFWKEN_Pos)                /*!< CLK_T::PASWKCTL: PFWKEN Mask           */

#define CLK_PASWKCTL_WKPSEL_Pos          (4)                                               /*!< CLK_T::PASWKCTL: WKPSEL Position       */
#define CLK_PASWKCTL_WKPSEL_Msk          (0xful << CLK_PASWKCTL_WKPSEL_Pos)                /*!< CLK_T::PASWKCTL: WKPSEL Mask           */

#define CLK_PASWKCTL_DBEN_Pos            (8)                                               /*!< CLK_T::PASWKCTL: DBEN Position         */
#define CLK_PASWKCTL_DBEN_Msk            (0x1ul << CLK_PASWKCTL_DBEN_Pos)                  /*!< CLK_T::PASWKCTL: DBEN Mask             */

#define CLK_PBSWKCTL_WKEN_Pos            (0)                                               /*!< CLK_T::PBSWKCTL: WKEN Position         */
#define CLK_PBSWKCTL_WKEN_Msk            (0x1ul << CLK_PBSWKCTL_WKEN_Pos)                  /*!< CLK_T::PBSWKCTL: WKEN Mask             */

#define CLK_PBSWKCTL_PRWKEN_Pos          (1)                                               /*!< CLK_T::PBSWKCTL: PRWKEN Position       */
#define CLK_PBSWKCTL_PRWKEN_Msk          (0x1ul << CLK_PBSWKCTL_PRWKEN_Pos)                /*!< CLK_T::PBSWKCTL: PRWKEN Mask           */

#define CLK_PBSWKCTL_PFWKEN_Pos          (2)                                               /*!< CLK_T::PBSWKCTL: PFWKEN Position       */
#define CLK_PBSWKCTL_PFWKEN_Msk          (0x1ul << CLK_PBSWKCTL_PFWKEN_Pos)                /*!< CLK_T::PBSWKCTL: PFWKEN Mask           */

#define CLK_PBSWKCTL_WKPSEL_Pos          (4)                                               /*!< CLK_T::PBSWKCTL: WKPSEL Position       */
#define CLK_PBSWKCTL_WKPSEL_Msk          (0xful << CLK_PBSWKCTL_WKPSEL_Pos)                /*!< CLK_T::PBSWKCTL: WKPSEL Mask           */

#define CLK_PBSWKCTL_DBEN_Pos            (8)                                               /*!< CLK_T::PBSWKCTL: DBEN Position         */
#define CLK_PBSWKCTL_DBEN_Msk            (0x1ul << CLK_PBSWKCTL_DBEN_Pos)                  /*!< CLK_T::PBSWKCTL: DBEN Mask             */

#define CLK_PCSWKCTL_WKEN_Pos            (0)                                               /*!< CLK_T::PCSWKCTL: WKEN Position         */
#define CLK_PCSWKCTL_WKEN_Msk            (0x1ul << CLK_PCSWKCTL_WKEN_Pos)                  /*!< CLK_T::PCSWKCTL: WKEN Mask             */

#define CLK_PCSWKCTL_PRWKEN_Pos          (1)                                               /*!< CLK_T::PCSWKCTL: PRWKEN Position       */
#define CLK_PCSWKCTL_PRWKEN_Msk          (0x1ul << CLK_PCSWKCTL_PRWKEN_Pos)                /*!< CLK_T::PCSWKCTL: PRWKEN Mask           */

#define CLK_PCSWKCTL_PFWKEN_Pos          (2)                                               /*!< CLK_T::PCSWKCTL: PFWKEN Position       */
#define CLK_PCSWKCTL_PFWKEN_Msk          (0x1ul << CLK_PCSWKCTL_PFWKEN_Pos)                /*!< CLK_T::PCSWKCTL: PFWKEN Mask           */

#define CLK_PCSWKCTL_WKPSEL_Pos          (4)                                               /*!< CLK_T::PCSWKCTL: WKPSEL Position       */
#define CLK_PCSWKCTL_WKPSEL_Msk          (0xful << CLK_PCSWKCTL_WKPSEL_Pos)                /*!< CLK_T::PCSWKCTL: WKPSEL Mask           */

#define CLK_PCSWKCTL_DBEN_Pos            (8)                                               /*!< CLK_T::PCSWKCTL: DBEN Position         */
#define CLK_PCSWKCTL_DBEN_Msk            (0x1ul << CLK_PCSWKCTL_DBEN_Pos)                  /*!< CLK_T::PCSWKCTL: DBEN Mask             */

#define CLK_PDSWKCTL_WKEN_Pos            (0)                                               /*!< CLK_T::PDSWKCTL: WKEN Position         */
#define CLK_PDSWKCTL_WKEN_Msk            (0x1ul << CLK_PDSWKCTL_WKEN_Pos)                  /*!< CLK_T::PDSWKCTL: WKEN Mask             */

#define CLK_PDSWKCTL_PRWKEN_Pos          (1)                                               /*!< CLK_T::PDSWKCTL: PRWKEN Position       */
#define CLK_PDSWKCTL_PRWKEN_Msk          (0x1ul << CLK_PDSWKCTL_PRWKEN_Pos)                /*!< CLK_T::PDSWKCTL: PRWKEN Mask           */

#define CLK_PDSWKCTL_PFWKEN_Pos          (2)                                               /*!< CLK_T::PDSWKCTL: PFWKEN Position       */
#define CLK_PDSWKCTL_PFWKEN_Msk          (0x1ul << CLK_PDSWKCTL_PFWKEN_Pos)                /*!< CLK_T::PDSWKCTL: PFWKEN Mask           */

#define CLK_PDSWKCTL_WKPSEL_Pos          (4)                                               /*!< CLK_T::PDSWKCTL: WKPSEL Position       */
#define CLK_PDSWKCTL_WKPSEL_Msk          (0xful << CLK_PDSWKCTL_WKPSEL_Pos)                /*!< CLK_T::PDSWKCTL: WKPSEL Mask           */

#define CLK_PDSWKCTL_DBEN_Pos            (8)                                               /*!< CLK_T::PDSWKCTL: DBEN Position         */
#define CLK_PDSWKCTL_DBEN_Msk            (0x1ul << CLK_PDSWKCTL_DBEN_Pos)                  /*!< CLK_T::PDSWKCTL: DBEN Mask             */

#define CLK_IOPDCTL_IOHR_Pos             (0)                                               /*!< CLK_T::IOPDCTL: IOHR Position          */
#define CLK_IOPDCTL_IOHR_Msk             (0x1ul << CLK_IOPDCTL_IOHR_Pos)                   /*!< CLK_T::IOPDCTL: IOHR Mask              */

#define CLK_HXTFSEL_HXTFSEL_Pos          (0)                                               /*!< CLK_T::HXTFSEL: HXTFSEL Position       */
#define CLK_HXTFSEL_HXTFSEL_Msk          (0x1ul << CLK_HXTFSEL_HXTFSEL_Pos)                /*!< CLK_T::HXTFSEL: HXTFSEL Mask           */

#define CLK_TESTCLK_TCLKSEL_Pos          (0)                                               /*!< CLK_T::TESTCLK: TCLKSEL Position       */
#define CLK_TESTCLK_TCLKSEL_Msk          (0x3ful << CLK_TESTCLK_TCLKSEL_Pos)               /*!< CLK_T::TESTCLK: TCLKSEL Mask           */

#define CLK_TESTCLK_TESTEN_Pos           (7)                                               /*!< CLK_T::TESTCLK: TESTEN Position        */
#define CLK_TESTCLK_TESTEN_Msk           (0x1ul << CLK_TESTCLK_TESTEN_Pos)                 /*!< CLK_T::TESTCLK: TESTEN Mask            */

#define CLK_PLLTEST_PLL480M_SEL_Pos      (0)                                               /*!< CLK_T::PLLTEST: PLL480M_SEL Position   */
#define CLK_PLLTEST_PLL480M_SEL_Msk      (0x1ul << CLK_PLLTEST_PLL480M_SEL_Pos)            /*!< CLK_T::PLLTEST: PLL480M_SEL Mask       */

/**@}*/ /* CLK_CONST */
/**@}*/ /* end of CLK register group */


/*---------------------- Cyclic Redundancy Check Controller -------------------------*/
/**
    @addtogroup CRC Cyclic Redundancy Check Controller(CRC)
    Memory Mapped Structure for CRC Controller
@{ */
 
typedef struct
{


/**
 * @var CRC_T::CTL
 * Offset: 0x00  CRC Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CRCEN     |CRC Channel Enable Bit
 * |        |          |0 = No effect.
 * |        |          |1 = CRC operation Enabled.
 * |[1]     |CRCRST    |CRC Engine Reset
 * |        |          |0 = No effect.
 * |        |          |1 = Reset the internal CRC state machine and internal buffer
 * |        |          |The others contents of CRC_CTL register will not be cleared.
 * |        |          |Note1: This bit will be cleared automatically
 * |        |          |Note2: Setting this bit will reload the initial seed vavalue from lue (CRC_SEED register as checksum initial vale).
 * |[24]    |DATREV    |Write Data Bit Order Reverse
 * |        |          |This bit is used to enable the bit order reverse function for write data value in CRC_DAT register.
 * |        |          |0 = Bit order reversed for CRC write data in Disabled.
 * |        |          |1 = Bit order reversed for CRC write data in Enabled (per byte).
 * |        |          |Note: If the write data is 0xAABBCCDD, the bit order reverse for CRC write data is 0x55DD33BB.
 * |[25]    |CHKSREV   |Checksum Bit Order Reverse
 * |        |          |This bit is used to enable the bit order reverse function for write data value in CRC_CHECKSUM register.
 * |        |          |0 = Bit order reverse for CRC checksum Disabled.
 * |        |          |1 = Bit order reverse for CRC checksum Enabled.
 * |        |          |Note: If the checksum result is 0xDD7B0F2E, the bit order reverse for CRC checksum is 0x74F0DEBB.
 * |[26]    |DATFMT    |Write Data 1's Complement
 * |        |          |This bit is used to enable the 1's complement function for write data value in CRC_DAT register.
 * |        |          |0 = 1's complement for CRC writes data in Disabled.
 * |        |          |1 = 1's complement for CRC writes data in Enabled.
 * |[27]    |CHKSFMT   |Checksum 1's Complement
 * |        |          |This bit is used to enable the 1's complement function for checksum result in CRC_CHECKSUM register.
 * |        |          |0 = 1's complement for CRC checksum Disabled.
 * |        |          |1 = 1's complement for CRC checksum Enabled.
 * |[29:28] |DATLEN    |CPU Write Data Length
 * |        |          |This field indicates the write data length.
 * |        |          |00 = Data length is 8-bit mode.
 * |        |          |01 = Data length is 16-bit mode.
 * |        |          |1x = Data length is 32-bit mode.
 * |        |          |Note:When the write data length is 8-bit mode, the valid data in CRC_DAT register is only DATA[7:0] bits; if the write data length is 16-bit mode, the valid data in CRC_DAT register is only DATA[15:0]
 * |[31:30] |CRCMODE   |CRC Polynomial Mode
 * |        |          |This field indicates the CRC operation polynomial mode.
 * |        |          |00 = CRC-CCITT Polynomial mode.
 * |        |          |01 = CRC-8 Polynomial mode.
 * |        |          |10 = CRC-16 Polynomial mode.
 * |        |          |11 = CRC-32 Polynomial mode.
 * @var CRC_T::DAT
 * Offset: 0x04  CRC Write Data Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |DATA      |CRC Write Data Bits
 * |        |          |User can write data directly by CPU mode or use PDMA function to write data to this field to perform CRC operation.
 * |        |          |Note:When the write data length is 8-bit mode, the valid data in CRC_DAT register is only DATA[7:0] bits; if the write data length is 16-bit mode, the valid data in CRC_DAT register is only DATA[15:0].
 * @var CRC_T::SEED
 * Offset: 0x08  CRC Seed Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |SEED      |CRC Seed Value
 * |        |          |This field indicates the CRC seed value.
 * @var CRC_T::CHECKSUM
 * Offset: 0x0C  CRC Checksum Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |CHECKSUM  |CRC Checksum Results
 * |        |          |This field indicates the CRC checksum result.
 * @var CRC_T::VERSION
 * Offset: 0xFFC  CRC RTL Design Version Number
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |MINOR     |CRC RTL Design MINOR Version Number
 * |        |          |Minor version number is dependent on ECO version control
 * |        |          |0x0000: (current Minor Version Number)
 * |[23:16] |SUB       |CRC RTL Design SUB Version Number
 * |        |          |Sub version number is relative tokey feature
 * |        |          |0x01: (current Sub Version Number)
 * |[31:24] |MAJOR     |CRC RTL Design MAJOR Version Number
 * |        |          |Major version number is correlated to Product Line
 * |        |          |0x01: (current Major Version Number)
 */
    __IO uint32_t CTL;                   /*!< [0x0000] CRC Control Register                                             */
    __IO uint32_t DAT;                   /*!< [0x0004] CRC Write Data Register                                          */
    __IO uint32_t SEED;                  /*!< [0x0008] CRC Seed Register                                                */
    __I  uint32_t CHECKSUM;              /*!< [0x000c] CRC Checksum Register                                            */
    __I  uint32_t RESERVE0[1019];
    __I  uint32_t VERSION;               /*!< [0x0ffc] CRC RTL Design Version Number                                    */

} CRC_T;

/**
    @addtogroup CRC_CONST CRC Bit Field Definition
    Constant Definitions for CRC Controller
@{ */

#define CRC_CTL_CRCEN_Pos                (0)                                               /*!< CRC_T::CTL: CRCEN Position             */
#define CRC_CTL_CRCEN_Msk                (0x1ul << CRC_CTL_CRCEN_Pos)                      /*!< CRC_T::CTL: CRCEN Mask                 */

#define CRC_CTL_CRCRST_Pos               (1)                                               /*!< CRC_T::CTL: CRCRST Position            */
#define CRC_CTL_CRCRST_Msk               (0x1ul << CRC_CTL_CRCRST_Pos)                     /*!< CRC_T::CTL: CRCRST Mask                */

#define CRC_CTL_DATREV_Pos               (24)                                              /*!< CRC_T::CTL: DATREV Position            */
#define CRC_CTL_DATREV_Msk               (0x1ul << CRC_CTL_DATREV_Pos)                     /*!< CRC_T::CTL: DATREV Mask                */

#define CRC_CTL_CHKSREV_Pos              (25)                                              /*!< CRC_T::CTL: CHKSREV Position           */
#define CRC_CTL_CHKSREV_Msk              (0x1ul << CRC_CTL_CHKSREV_Pos)                    /*!< CRC_T::CTL: CHKSREV Mask               */

#define CRC_CTL_DATFMT_Pos               (26)                                              /*!< CRC_T::CTL: DATFMT Position            */
#define CRC_CTL_DATFMT_Msk               (0x1ul << CRC_CTL_DATFMT_Pos)                     /*!< CRC_T::CTL: DATFMT Mask                */

#define CRC_CTL_CHKSFMT_Pos              (27)                                              /*!< CRC_T::CTL: CHKSFMT Position           */
#define CRC_CTL_CHKSFMT_Msk              (0x1ul << CRC_CTL_CHKSFMT_Pos)                    /*!< CRC_T::CTL: CHKSFMT Mask               */

#define CRC_CTL_DATLEN_Pos               (28)                                              /*!< CRC_T::CTL: DATLEN Position            */
#define CRC_CTL_DATLEN_Msk               (0x3ul << CRC_CTL_DATLEN_Pos)                     /*!< CRC_T::CTL: DATLEN Mask                */

#define CRC_CTL_CRCMODE_Pos              (30)                                              /*!< CRC_T::CTL: CRCMODE Position           */
#define CRC_CTL_CRCMODE_Msk              (0x3ul << CRC_CTL_CRCMODE_Pos)                    /*!< CRC_T::CTL: CRCMODE Mask               */

#define CRC_DAT_DATA_Pos                 (0)                                               /*!< CRC_T::DAT: DATA Position              */
#define CRC_DAT_DATA_Msk                 (0xfffffffful << CRC_DAT_DATA_Pos)                /*!< CRC_T::DAT: DATA Mask                  */

#define CRC_SEED_SEED_Pos                (0)                                               /*!< CRC_T::SEED: SEED Position             */
#define CRC_SEED_SEED_Msk                (0xfffffffful << CRC_SEED_SEED_Pos)               /*!< CRC_T::SEED: SEED Mask                 */

#define CRC_CHECKSUM_CHECKSUM_Pos        (0)                                               /*!< CRC_T::CHECKSUM: CHECKSUM Position     */
#define CRC_CHECKSUM_CHECKSUM_Msk        (0xfffffffful << CRC_CHECKSUM_CHECKSUM_Pos)       /*!< CRC_T::CHECKSUM: CHECKSUM Mask         */

#define CRC_VERSION_MINOR_Pos            (0)                                               /*!< CRC_T::VERSION: MINOR Position         */
#define CRC_VERSION_MINOR_Msk            (0xfffful << CRC_VERSION_MINOR_Pos)               /*!< CRC_T::VERSION: MINOR Mask             */

#define CRC_VERSION_SUB_Pos              (16)                                              /*!< CRC_T::VERSION: SUB Position           */
#define CRC_VERSION_SUB_Msk              (0xfful << CRC_VERSION_SUB_Pos)                   /*!< CRC_T::VERSION: SUB Mask               */

#define CRC_VERSION_MAJOR_Pos            (24)                                              /*!< CRC_T::VERSION: MAJOR Position         */
#define CRC_VERSION_MAJOR_Msk            (0xfful << CRC_VERSION_MAJOR_Pos)                 /*!< CRC_T::VERSION: MAJOR Mask             */

/**@}*/ /* CRC_CONST */
/**@}*/ /* end of CRC register group */


/*---------------------- Enhanced Analog to Digital Converter -------------------------*/
/**
    @addtogroup EADC Enhanced Analog to Digital Converter(EADC)
    Memory Mapped Structure for EADC Controller
@{ */
 
typedef struct
{


/**
 * @var EADC_T::DAT0
 * Offset: 0x00  ADC Data Register 0 for Sample Module 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RESULT    |ADC Conversion Result
 * |        |          |This field contains 12 bits conversion result.
 * |        |          |When DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT[11:0] and zero will be filled in RESULT[15:12].
 * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT[11:0] and signed bits to will be filled in RESULT[15:12].
 * |[16]    |OV        |Overrun Flag
 * |        |          |If converted data in RESULT[11:0] has not been read before new conversion result is loaded to this register, OV is set to 1.
 * |        |          |0 = Data in RESULT[11:0] is recent conversion result.
 * |        |          |1 = Data in RESULT[11:0] is overwrite.
 * |        |          |Note: It is cleared by hardware after EADC_DAT register is read.
 * |[17]    |VALID     |Valid Flag
 * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DAT register is read.
 * |        |          |0 = Data in RESULT[11:0] bits is not valid.
 * |        |          |1 = Data in RESULT[11:0] bits is valid.
 * @var EADC_T::DAT1
 * Offset: 0x04  ADC Data Register 1 for Sample Module 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RESULT    |ADC Conversion Result
 * |        |          |This field contains 12 bits conversion result.
 * |        |          |When DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT[11:0] and zero will be filled in RESULT[15:12].
 * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT[11:0] and signed bits to will be filled in RESULT[15:12].
 * |[16]    |OV        |Overrun Flag
 * |        |          |If converted data in RESULT[11:0] has not been read before new conversion result is loaded to this register, OV is set to 1.
 * |        |          |0 = Data in RESULT[11:0] is recent conversion result.
 * |        |          |1 = Data in RESULT[11:0] is overwrite.
 * |        |          |Note: It is cleared by hardware after EADC_DAT register is read.
 * |[17]    |VALID     |Valid Flag
 * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DAT register is read.
 * |        |          |0 = Data in RESULT[11:0] bits is not valid.
 * |        |          |1 = Data in RESULT[11:0] bits is valid.
 * @var EADC_T::DAT2
 * Offset: 0x08  ADC Data Register 2 for Sample Module 2
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RESULT    |ADC Conversion Result
 * |        |          |This field contains 12 bits conversion result.
 * |        |          |When DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT[11:0] and zero will be filled in RESULT[15:12].
 * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT[11:0] and signed bits to will be filled in RESULT[15:12].
 * |[16]    |OV        |Overrun Flag
 * |        |          |If converted data in RESULT[11:0] has not been read before new conversion result is loaded to this register, OV is set to 1.
 * |        |          |0 = Data in RESULT[11:0] is recent conversion result.
 * |        |          |1 = Data in RESULT[11:0] is overwrite.
 * |        |          |Note: It is cleared by hardware after EADC_DAT register is read.
 * |[17]    |VALID     |Valid Flag
 * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DAT register is read.
 * |        |          |0 = Data in RESULT[11:0] bits is not valid.
 * |        |          |1 = Data in RESULT[11:0] bits is valid.
 * @var EADC_T::DAT3
 * Offset: 0x0C  ADC Data Register 3 for Sample Module 3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RESULT    |ADC Conversion Result
 * |        |          |This field contains 12 bits conversion result.
 * |        |          |When DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT[11:0] and zero will be filled in RESULT[15:12].
 * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT[11:0] and signed bits to will be filled in RESULT[15:12].
 * |[16]    |OV        |Overrun Flag
 * |        |          |If converted data in RESULT[11:0] has not been read before new conversion result is loaded to this register, OV is set to 1.
 * |        |          |0 = Data in RESULT[11:0] is recent conversion result.
 * |        |          |1 = Data in RESULT[11:0] is overwrite.
 * |        |          |Note: It is cleared by hardware after EADC_DAT register is read.
 * |[17]    |VALID     |Valid Flag
 * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DAT register is read.
 * |        |          |0 = Data in RESULT[11:0] bits is not valid.
 * |        |          |1 = Data in RESULT[11:0] bits is valid.
 * @var EADC_T::DAT4
 * Offset: 0x10  ADC Data Register 4 for Sample Module 4
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RESULT    |ADC Conversion Result
 * |        |          |This field contains 12 bits conversion result.
 * |        |          |When DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT[11:0] and zero will be filled in RESULT[15:12].
 * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT[11:0] and signed bits to will be filled in RESULT[15:12].
 * |[16]    |OV        |Overrun Flag
 * |        |          |If converted data in RESULT[11:0] has not been read before new conversion result is loaded to this register, OV is set to 1.
 * |        |          |0 = Data in RESULT[11:0] is recent conversion result.
 * |        |          |1 = Data in RESULT[11:0] is overwrite.
 * |        |          |Note: It is cleared by hardware after EADC_DAT register is read.
 * |[17]    |VALID     |Valid Flag
 * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DAT register is read.
 * |        |          |0 = Data in RESULT[11:0] bits is not valid.
 * |        |          |1 = Data in RESULT[11:0] bits is valid.
 * @var EADC_T::DAT5
 * Offset: 0x14  ADC Data Register 5 for Sample Module 5
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RESULT    |ADC Conversion Result
 * |        |          |This field contains 12 bits conversion result.
 * |        |          |When DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT[11:0] and zero will be filled in RESULT[15:12].
 * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT[11:0] and signed bits to will be filled in RESULT[15:12].
 * |[16]    |OV        |Overrun Flag
 * |        |          |If converted data in RESULT[11:0] has not been read before new conversion result is loaded to this register, OV is set to 1.
 * |        |          |0 = Data in RESULT[11:0] is recent conversion result.
 * |        |          |1 = Data in RESULT[11:0] is overwrite.
 * |        |          |Note: It is cleared by hardware after EADC_DAT register is read.
 * |[17]    |VALID     |Valid Flag
 * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DAT register is read.
 * |        |          |0 = Data in RESULT[11:0] bits is not valid.
 * |        |          |1 = Data in RESULT[11:0] bits is valid.
 * @var EADC_T::DAT6
 * Offset: 0x18  ADC Data Register 6 for Sample Module 6
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RESULT    |ADC Conversion Result
 * |        |          |This field contains 12 bits conversion result.
 * |        |          |When DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT[11:0] and zero will be filled in RESULT[15:12].
 * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT[11:0] and signed bits to will be filled in RESULT[15:12].
 * |[16]    |OV        |Overrun Flag
 * |        |          |If converted data in RESULT[11:0] has not been read before new conversion result is loaded to this register, OV is set to 1.
 * |        |          |0 = Data in RESULT[11:0] is recent conversion result.
 * |        |          |1 = Data in RESULT[11:0] is overwrite.
 * |        |          |Note: It is cleared by hardware after EADC_DAT register is read.
 * |[17]    |VALID     |Valid Flag
 * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DAT register is read.
 * |        |          |0 = Data in RESULT[11:0] bits is not valid.
 * |        |          |1 = Data in RESULT[11:0] bits is valid.
 * @var EADC_T::DAT7
 * Offset: 0x1C  ADC Data Register 7 for Sample Module 7
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RESULT    |ADC Conversion Result
 * |        |          |This field contains 12 bits conversion result.
 * |        |          |When DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT[11:0] and zero will be filled in RESULT[15:12].
 * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT[11:0] and signed bits to will be filled in RESULT[15:12].
 * |[16]    |OV        |Overrun Flag
 * |        |          |If converted data in RESULT[11:0] has not been read before new conversion result is loaded to this register, OV is set to 1.
 * |        |          |0 = Data in RESULT[11:0] is recent conversion result.
 * |        |          |1 = Data in RESULT[11:0] is overwrite.
 * |        |          |Note: It is cleared by hardware after EADC_DAT register is read.
 * |[17]    |VALID     |Valid Flag
 * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DAT register is read.
 * |        |          |0 = Data in RESULT[11:0] bits is not valid.
 * |        |          |1 = Data in RESULT[11:0] bits is valid.
 * @var EADC_T::DAT8
 * Offset: 0x20  ADC Data Register 8 for Sample Module 8
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RESULT    |ADC Conversion Result
 * |        |          |This field contains 12 bits conversion result.
 * |        |          |When DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT[11:0] and zero will be filled in RESULT[15:12].
 * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT[11:0] and signed bits to will be filled in RESULT[15:12].
 * |[16]    |OV        |Overrun Flag
 * |        |          |If converted data in RESULT[11:0] has not been read before new conversion result is loaded to this register, OV is set to 1.
 * |        |          |0 = Data in RESULT[11:0] is recent conversion result.
 * |        |          |1 = Data in RESULT[11:0] is overwrite.
 * |        |          |Note: It is cleared by hardware after EADC_DAT register is read.
 * |[17]    |VALID     |Valid Flag
 * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DAT register is read.
 * |        |          |0 = Data in RESULT[11:0] bits is not valid.
 * |        |          |1 = Data in RESULT[11:0] bits is valid.
 * @var EADC_T::DAT9
 * Offset: 0x24  ADC Data Register 9 for Sample Module 9
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RESULT    |ADC Conversion Result
 * |        |          |This field contains 12 bits conversion result.
 * |        |          |When DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT[11:0] and zero will be filled in RESULT[15:12].
 * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT[11:0] and signed bits to will be filled in RESULT[15:12].
 * |[16]    |OV        |Overrun Flag
 * |        |          |If converted data in RESULT[11:0] has not been read before new conversion result is loaded to this register, OV is set to 1.
 * |        |          |0 = Data in RESULT[11:0] is recent conversion result.
 * |        |          |1 = Data in RESULT[11:0] is overwrite.
 * |        |          |Note: It is cleared by hardware after EADC_DAT register is read.
 * |[17]    |VALID     |Valid Flag
 * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DAT register is read.
 * |        |          |0 = Data in RESULT[11:0] bits is not valid.
 * |        |          |1 = Data in RESULT[11:0] bits is valid.
 * @var EADC_T::DAT10
 * Offset: 0x28  ADC Data Register 10 for Sample Module 10
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RESULT    |ADC Conversion Result
 * |        |          |This field contains 12 bits conversion result.
 * |        |          |When DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT[11:0] and zero will be filled in RESULT[15:12].
 * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT[11:0] and signed bits to will be filled in RESULT[15:12].
 * |[16]    |OV        |Overrun Flag
 * |        |          |If converted data in RESULT[11:0] has not been read before new conversion result is loaded to this register, OV is set to 1.
 * |        |          |0 = Data in RESULT[11:0] is recent conversion result.
 * |        |          |1 = Data in RESULT[11:0] is overwrite.
 * |        |          |Note: It is cleared by hardware after EADC_DAT register is read.
 * |[17]    |VALID     |Valid Flag
 * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DAT register is read.
 * |        |          |0 = Data in RESULT[11:0] bits is not valid.
 * |        |          |1 = Data in RESULT[11:0] bits is valid.
 * @var EADC_T::DAT11
 * Offset: 0x2C  ADC Data Register 11 for Sample Module 11
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RESULT    |ADC Conversion Result
 * |        |          |This field contains 12 bits conversion result.
 * |        |          |When DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT[11:0] and zero will be filled in RESULT[15:12].
 * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT[11:0] and signed bits to will be filled in RESULT[15:12].
 * |[16]    |OV        |Overrun Flag
 * |        |          |If converted data in RESULT[11:0] has not been read before new conversion result is loaded to this register, OV is set to 1.
 * |        |          |0 = Data in RESULT[11:0] is recent conversion result.
 * |        |          |1 = Data in RESULT[11:0] is overwrite.
 * |        |          |Note: It is cleared by hardware after EADC_DAT register is read.
 * |[17]    |VALID     |Valid Flag
 * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DAT register is read.
 * |        |          |0 = Data in RESULT[11:0] bits is not valid.
 * |        |          |1 = Data in RESULT[11:0] bits is valid.
 * @var EADC_T::DAT12
 * Offset: 0x30  ADC Data Register 12 for Sample Module 12
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RESULT    |ADC Conversion Result
 * |        |          |This field contains 12 bits conversion result.
 * |        |          |When DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT[11:0] and zero will be filled in RESULT[15:12].
 * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT[11:0] and signed bits to will be filled in RESULT[15:12].
 * |[16]    |OV        |Overrun Flag
 * |        |          |If converted data in RESULT[11:0] has not been read before new conversion result is loaded to this register, OV is set to 1.
 * |        |          |0 = Data in RESULT[11:0] is recent conversion result.
 * |        |          |1 = Data in RESULT[11:0] is overwrite.
 * |        |          |Note: It is cleared by hardware after EADC_DAT register is read.
 * |[17]    |VALID     |Valid Flag
 * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DAT register is read.
 * |        |          |0 = Data in RESULT[11:0] bits is not valid.
 * |        |          |1 = Data in RESULT[11:0] bits is valid.
 * @var EADC_T::DAT16
 * Offset: 0x40  ADC Data Register 16 for Sample Module 16
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RESULT    |ADC Conversion Result
 * |        |          |This field contains 12 bits conversion result.
 * |        |          |When DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT[11:0] and zero will be filled in RESULT[15:12].
 * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT[11:0] and signed bits to will be filled in RESULT[15:12].
 * |[16]    |OV        |Overrun Flag
 * |        |          |If converted data in RESULT[11:0] has not been read before new conversion result is loaded to this register, OV is set to 1.
 * |        |          |0 = Data in RESULT[11:0] is recent conversion result.
 * |        |          |1 = Data in RESULT[11:0] is overwrite.
 * |        |          |Note: It is cleared by hardware after EADC_DAT register is read.
 * |[17]    |VALID     |Valid Flag
 * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DAT register is read.
 * |        |          |0 = Data in RESULT[11:0] bits is not valid.
 * |        |          |1 = Data in RESULT[11:0] bits is valid.
 * @var EADC_T::DAT17
 * Offset: 0x44  ADC Data Register 17 for Sample Module 17
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RESULT    |ADC Conversion Result
 * |        |          |This field contains 12 bits conversion result.
 * |        |          |When DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT[11:0] and zero will be filled in RESULT[15:12].
 * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT[11:0] and signed bits to will be filled in RESULT[15:12].
 * |[16]    |OV        |Overrun Flag
 * |        |          |If converted data in RESULT[11:0] has not been read before new conversion result is loaded to this register, OV is set to 1.
 * |        |          |0 = Data in RESULT[11:0] is recent conversion result.
 * |        |          |1 = Data in RESULT[11:0] is overwrite.
 * |        |          |Note: It is cleared by hardware after EADC_DAT register is read.
 * |[17]    |VALID     |Valid Flag
 * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DAT register is read.
 * |        |          |0 = Data in RESULT[11:0] bits is not valid.
 * |        |          |1 = Data in RESULT[11:0] bits is valid.
 * @var EADC_T::CURDAT
 * Offset: 0x4C  ADC PDMA Current Transfer Data Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[17:0]  |CURDAT    |ADC PDMA Current Transfer Data Register
 * |        |          |This register is a shadow register of EADC_DATn (n=0~12, 16, 17) for PDMA support.
 * |        |          |This is a read only register.
 * @var EADC_T::CTL
 * Offset: 0x50  ADC Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ADCEN     |ADC Converter Enable Bit
 * |        |          |0 = Disabled EADC.
 * |        |          |1 = Enabled EADC.
 * |        |          |Note: Before starting ADC conversion function, this bit should be set to 1
 * |        |          |Clear it to 0 to disable ADC converter analog circuit power consumption.
 * |[1]     |ADCRST    |ADC ADC Converter Control Circuits Reset
 * |        |          |0 = No effect.
 * |        |          |1 = Cause ADC control circuits reset to initial state, but not change the ADC registers value.
 * |        |          |Note: ADCRST bit remains 1 during ADC reset, when ADC reset end, the ADCRST bit is automatically cleared to 0.
 * |[2]     |ADCIEN0   |Specific Sample Module ADC ADINT0 Interrupt Enable Bit
 * |        |          |The ADC converter generates a conversion end ADIF0 (EADC_STATUS2[0]) upon the end of specific sample module ADC conversion
 * |        |          |If ADCIEN0 bit is set then conversion end interrupt request ADINT0 is generated.
 * |        |          |0 = Specific sample module ADC ADINT0 interrupt function Disabled.
 * |        |          |1 = Specific sample module ADC ADINT0 interrupt function Enabled.
 * |[3]     |ADCIEN1   |Specific Sample Module ADC ADINT1 Interrupt Enable Bit
 * |        |          |The ADC converter generates a conversion end ADIF1 (EADC_STATUS2[1]) upon the end of specific sample module ADC conversion
 * |        |          |If ADCIEN1 bit is set then conversion end interrupt request ADINT1 is generated.
 * |        |          |0 = Specific sample module ADC ADINT1 interrupt function Disabled.
 * |        |          |1 = Specific sample module ADC ADINT1 interrupt function Enabled.
 * |[4]     |ADCIEN2   |Specific Sample Module ADC ADINT2 Interrupt Enable Bit
 * |        |          |The ADC converter generates a conversion end ADIF2 (EADC_STATUS2[2]) upon the end of specific sample module ADC conversion
 * |        |          |If ADCIEN2 bit is set then conversion end interrupt request ADINT2 is generated.
 * |        |          |0 = Specific sample module ADC ADINT2 interrupt function Disabled.
 * |        |          |1 = Specific sample module ADC ADINT2 interrupt function Enabled.
 * |[5]     |ADCIEN3   |Specific Sample Module ADC ADINT3 Interrupt Enable Bit
 * |        |          |The ADC converter generates a conversion end ADIF3 (EADC_STATUS2[3]) upon the end of specific sample module ADC conversion
 * |        |          |If ADCIEN3 bit is set then conversion end interrupt request ADINT3 is generated.
 * |        |          |0 = Specific sample module ADC ADINT3 interrupt function Disabled.
 * |        |          |1 = Specific sample module ADC ADINT3 interrupt function Enabled.
 * |[7:6]   |RESSEL    |Resolution Selection
 * |        |          |00 = 6-bit. ADC result will put at RESULT (EADC_DATx[5:0]).
 * |        |          |01 = 8-bit. ADC result will put at RESULT (EADC_DATx[7:0]).
 * |        |          |10 = 10-bit. ADC result will put at RESULT (EADC_DATx[9:0]).
 * |        |          |11 = 12-bit. ADC result will put at RESULT (EADC_DATx[11:0]).
 * |[8]     |DIFFEN    |Differential Analog Input Mode Enable Bit
 * |        |          |0 = Single-end analog input mode.
 * |        |          |1 = Differential analog input mode.
 * |[9]     |DMOF      |ADC Differential Input Mode Output Format
 * |        |          |0 = ADC conversion result will be filled in RESULT (EADC_DATn[15:0] , n= 0 ~12, 16, 17) with unsigned format.
 * |        |          |1 = ADC conversion result will be filled in RESULT (EADC_DATn[15:0] , n= 0 ~12, 16, 17) with 2'complement format.
 * |[11]    |PDMAEN    |PDMA Transfer Enable Bit
 * |        |          |When ADC conversion is completed, the converted data is loaded into EADC_DATn (n: 0 ~ 12, 16, 17) register, user can enable this bit to generate a PDMA data transfer request.
 * |        |          |0 = PDMA data transfer Disabled.
 * |        |          |1 = PDMA data transfer Enabled.
 * |        |          |Note: When set this bit field to 1, user must set ADCIENn (EADC_CTL[5:2], n=0~3) = 0 to disable interrupt.
 * |[18:16] |SMPTSEL   |ADC Internal Sampling Time Selection
 * |        |          |ADC internal sampling cycle = SMPTSEL + 1.
 * |        |          |000 = 1 ADC clock sampling time.
 * |        |          |001 = 2 ADC clock sampling time.
 * |        |          |010 = 3 ADC clock sampling time.
 * |        |          |011 = 4 ADC clock sampling time.
 * |        |          |100 = 5 ADC clock sampling time.
 * |        |          |101 = 6 ADC clock sampling time.
 * |        |          |110 = 7 ADC clock sampling time.
 * |        |          |111 = 8 ADC clock sampling time.
 * @var EADC_T::SWTRG
 * Offset: 0x54  ADC Sample Module Software Start Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[18:0]  |SWTRG     |ADC Sample Module 0~12, 16, 17 Software Force to Start ADC Conversion
 * |        |          |0 = No effect.
 * |        |          |1 = Cause an ADC conversion when the priority is given to sample module.
 * |        |          |Note: After write this register to start ADC conversion, the EADC_PENDSTS register will show which sample module will conversion
 * |        |          |If user want to disable the conversion of the sample module, user can write EADC_PENDSTS register to clear it.
 * @var EADC_T::PENDSTS
 * Offset: 0x58  ADC Start of Conversion Pending Flag Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[18:0]  |STPF      |ADC Sample Module 0~12, 16, 17 Start of Conversion Pending Flag
 * |        |          |Read:
 * |        |          |0 = There is no pending conversion for sample module.
 * |        |          |1 = Sample module ADC start of conversion is pending.
 * |        |          |Write:
 * |        |          |1 = clear pending flag & cancel the conversion for sample module.
 * |        |          |Note: This bit remains 1 during pending state, when the respective ADC conversion is end, the STPFn (n=0~12, 16, 17) bit is automatically cleared to 0
 * @var EADC_T::OVSTS
 * Offset: 0x5C  ADC Sample Module Start of Conversion Overrun Flag Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[18:0]  |SPOVF     |ADC SAMPLE0~12, 16, 17 Overrun Flag
 * |        |          |0 = No sample module event overrun.
 * |        |          |1 = Indicates a new sample module event is generated while an old one event is pending.
 * |        |          |Note: This bit is cleared by writing 1 to it.
 * @var EADC_T::SELFTCTL
 * Offset: 0x7C  ADC Self Test Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |SELFTEN   |ADC Self Test Enable (Write Protect)
 * |        |          |0 = ADC self-test mode Disabled.
 * |        |          |1 = ADC self-test mode Enabled.
 * |        |          |When ADC self-test mode enable, the ADC channel can controlled by correlate GPIO register
 * |        |          |User can use GPIO to force each ADC channel as GND or VDD to check each channel path is OK.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * @var EADC_T::SCTL0
 * Offset: 0x80  ADC Sample Module 0 Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |CHSEL     |ADC Sample Module Channel Selection
 * |        |          |00H = EADC0_CH0.
 * |        |          |01H = EADC0_CH1.
 * |        |          |02H = EADC0_CH2.
 * |        |          |03H = EADC0_CH3.
 * |        |          |04H = EADC0_CH4.
 * |        |          |05H = EADC0_CH5.
 * |        |          |06H = EADC0_CH6.
 * |        |          |07H = EADC0_CH7.
 * |        |          |08H = EADC0_CH8.
 * |        |          |09H = EADC0_CH9.
 * |        |          |0AH = EADC0_CH10.
 * |        |          |0BH = EADC0_CH11.
 * |        |          |0CH = EADC0_CH12.
 * |        |          |other = Reserved.
 * |[4]     |EXTREN    |ADC External Trigger Rising Edge Enable Bit
 * |        |          |0 = Rising edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Rising edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[5]     |EXTFEN    |ADC External Trigger Falling Edge Enable Bit
 * |        |          |0 = Falling edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Falling edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[7:6]   |TRGDLYDIV |ADC Sample Module Start of Conversion Trigger Delay Clock Divider Selection
 * |        |          |Trigger delay clock frequency:
 * |        |          |00 = ADC_CLK/1.
 * |        |          |01 = ADC_CLK/2.
 * |        |          |10 = ADC_CLK/4.
 * |        |          |11 = ADC_CLK/16.
 * |[15:8]  |TRGDLYCNT |ADC Sample Module Start of Conversion Trigger Delay Time
 * |        |          |Trigger delay time = TRGDLYCNT x ADC_CLK x n (n=1,2,4,16 from TRGDLYDIV setting).
 * |[20:16] |TRGSEL    |ADC Sample Module Start of Conversion Trigger Source Selection
 * |        |          |0H = Disable trigger.
 * |        |          |1H = External trigger from EADC0_ST pin input.
 * |        |          |2H = ADC ADINT0 interrupt EOC (End of conversion) pulse trigger.
 * |        |          |3H = ADC ADINT1 interrupt EOC (End of conversion) pulse trigger.
 * |        |          |4H = Timer0 overflow pulse trigger.
 * |        |          |5H = Timer1 overflow pulse trigger.
 * |        |          |6H = Timer2 overflow pulse trigger.
 * |        |          |7H = Timer3 overflow pulse trigger.
 * |        |          |8H = PWM0TG0.
 * |        |          |9H = PWM0TG1.
 * |        |          |AH = PWM0TG2.
 * |        |          |BH = PWM0TG3.
 * |        |          |CH = PWM0TG4.
 * |        |          |DH = PWM0TG5.
 * |        |          |other = Reserved.
 * |[22]    |INTPOS    |Interrupt Flag Position Select
 * |        |          |0 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC end of conversion.
 * |        |          |1 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC start of conversion.
 * |[23]    |DBMEN     |Double Buffer Mode Enable Bit
 * |        |          |0 = Sample has one sample result register. (default).
 * |        |          |1 = Sample has two sample result registers.
 * |[31:24] |EXTSMPT   |ADC Sampling Time Extend
 * |        |          |When ADC converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, user can extend ADC sampling time after trigger source is coming to get enough sampling time.
 * |        |          |The range of start delay time is from 0~255 ADC clock.
 * @var EADC_T::SCTL1
 * Offset: 0x84  ADC Sample Module 1 Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |CHSEL     |ADC Sample Module Channel Selection
 * |        |          |00H = EADC0_CH0.
 * |        |          |01H = EADC0_CH1.
 * |        |          |02H = EADC0_CH2.
 * |        |          |03H = EADC0_CH3.
 * |        |          |04H = EADC0_CH4.
 * |        |          |05H = EADC0_CH5.
 * |        |          |06H = EADC0_CH6.
 * |        |          |07H = EADC0_CH7.
 * |        |          |08H = EADC0_CH8.
 * |        |          |09H = EADC0_CH9.
 * |        |          |0AH = EADC0_CH10.
 * |        |          |0BH = EADC0_CH11.
 * |        |          |0CH = EADC0_CH12.
 * |        |          |other = Reserved.
 * |[4]     |EXTREN    |ADC External Trigger Rising Edge Enable Bit
 * |        |          |0 = Rising edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Rising edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[5]     |EXTFEN    |ADC External Trigger Falling Edge Enable Bit
 * |        |          |0 = Falling edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Falling edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[7:6]   |TRGDLYDIV |ADC Sample Module Start of Conversion Trigger Delay Clock Divider Selection
 * |        |          |Trigger delay clock frequency:
 * |        |          |00 = ADC_CLK/1.
 * |        |          |01 = ADC_CLK/2.
 * |        |          |10 = ADC_CLK/4.
 * |        |          |11 = ADC_CLK/16.
 * |[15:8]  |TRGDLYCNT |ADC Sample Module Start of Conversion Trigger Delay Time
 * |        |          |Trigger delay time = TRGDLYCNT x ADC_CLK x n (n=1,2,4,16 from TRGDLYDIV setting).
 * |[20:16] |TRGSEL    |ADC Sample Module Start of Conversion Trigger Source Selection
 * |        |          |0H = Disable trigger.
 * |        |          |1H = External trigger from EADC0_ST pin input.
 * |        |          |2H = ADC ADINT0 interrupt EOC (End of conversion) pulse trigger.
 * |        |          |3H = ADC ADINT1 interrupt EOC (End of conversion) pulse trigger.
 * |        |          |4H = Timer0 overflow pulse trigger.
 * |        |          |5H = Timer1 overflow pulse trigger.
 * |        |          |6H = Timer2 overflow pulse trigger.
 * |        |          |7H = Timer3 overflow pulse trigger.
 * |        |          |8H = PWM0TG0.
 * |        |          |9H = PWM0TG1.
 * |        |          |AH = PWM0TG2.
 * |        |          |BH = PWM0TG3.
 * |        |          |CH = PWM0TG4.
 * |        |          |DH = PWM0TG5.
 * |        |          |other = Reserved.
 * |[22]    |INTPOS    |Interrupt Flag Position Select
 * |        |          |0 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC end of conversion.
 * |        |          |1 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC start of conversion.
 * |[23]    |DBMEN     |Double Buffer Mode Enable Bit
 * |        |          |0 = Sample has one sample result register. (default).
 * |        |          |1 = Sample has two sample result registers.
 * |[31:24] |EXTSMPT   |ADC Sampling Time Extend
 * |        |          |When ADC converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, user can extend ADC sampling time after trigger source is coming to get enough sampling time.
 * |        |          |The range of start delay time is from 0~255 ADC clock.
 * @var EADC_T::SCTL2
 * Offset: 0x88  ADC Sample Module 2 Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |CHSEL     |ADC Sample Module Channel Selection
 * |        |          |00H = EADC0_CH0.
 * |        |          |01H = EADC0_CH1.
 * |        |          |02H = EADC0_CH2.
 * |        |          |03H = EADC0_CH3.
 * |        |          |04H = EADC0_CH4.
 * |        |          |05H = EADC0_CH5.
 * |        |          |06H = EADC0_CH6.
 * |        |          |07H = EADC0_CH7.
 * |        |          |08H = EADC0_CH8.
 * |        |          |09H = EADC0_CH9.
 * |        |          |0AH = EADC0_CH10.
 * |        |          |0BH = EADC0_CH11.
 * |        |          |0CH = EADC0_CH12.
 * |        |          |other = Reserved.
 * |[4]     |EXTREN    |ADC External Trigger Rising Edge Enable Bit
 * |        |          |0 = Rising edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Rising edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[5]     |EXTFEN    |ADC External Trigger Falling Edge Enable Bit
 * |        |          |0 = Falling edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Falling edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[7:6]   |TRGDLYDIV |ADC Sample Module Start of Conversion Trigger Delay Clock Divider Selection
 * |        |          |Trigger delay clock frequency:
 * |        |          |00 = ADC_CLK/1.
 * |        |          |01 = ADC_CLK/2.
 * |        |          |10 = ADC_CLK/4.
 * |        |          |11 = ADC_CLK/16.
 * |[15:8]  |TRGDLYCNT |ADC Sample Module Start of Conversion Trigger Delay Time
 * |        |          |Trigger delay time = TRGDLYCNT x ADC_CLK x n (n=1,2,4,16 from TRGDLYDIV setting).
 * |[20:16] |TRGSEL    |ADC Sample Module Start of Conversion Trigger Source Selection
 * |        |          |0H = Disable trigger.
 * |        |          |1H = External trigger from EADC0_ST pin input.
 * |        |          |2H = ADC ADINT0 interrupt EOC (End of conversion) pulse trigger.
 * |        |          |3H = ADC ADINT1 interrupt EOC (End of conversion) pulse trigger.
 * |        |          |4H = Timer0 overflow pulse trigger.
 * |        |          |5H = Timer1 overflow pulse trigger.
 * |        |          |6H = Timer2 overflow pulse trigger.
 * |        |          |7H = Timer3 overflow pulse trigger.
 * |        |          |8H = PWM0TG0.
 * |        |          |9H = PWM0TG1.
 * |        |          |AH = PWM0TG2.
 * |        |          |BH = PWM0TG3.
 * |        |          |CH = PWM0TG4.
 * |        |          |DH = PWM0TG5.
 * |        |          |other = Reserved.
 * |[22]    |INTPOS    |Interrupt Flag Position Select
 * |        |          |0 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC end of conversion.
 * |        |          |1 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC start of conversion.
 * |[23]    |DBMEN     |Double Buffer Mode Enable Bit
 * |        |          |0 = Sample has one sample result register. (default).
 * |        |          |1 = Sample has two sample result registers.
 * |[31:24] |EXTSMPT   |ADC Sampling Time Extend
 * |        |          |When ADC converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, user can extend ADC sampling time after trigger source is coming to get enough sampling time.
 * |        |          |The range of start delay time is from 0~255 ADC clock.
 * @var EADC_T::SCTL3
 * Offset: 0x8C  ADC Sample Module 3 Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |CHSEL     |ADC Sample Module Channel Selection
 * |        |          |00H = EADC0_CH0.
 * |        |          |01H = EADC0_CH1.
 * |        |          |02H = EADC0_CH2.
 * |        |          |03H = EADC0_CH3.
 * |        |          |04H = EADC0_CH4.
 * |        |          |05H = EADC0_CH5.
 * |        |          |06H = EADC0_CH6.
 * |        |          |07H = EADC0_CH7.
 * |        |          |08H = EADC0_CH8.
 * |        |          |09H = EADC0_CH9.
 * |        |          |0AH = EADC0_CH10.
 * |        |          |0BH = EADC0_CH11.
 * |        |          |0CH = EADC0_CH12.
 * |        |          |other = Reserved.
 * |[4]     |EXTREN    |ADC External Trigger Rising Edge Enable Bit
 * |        |          |0 = Rising edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Rising edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[5]     |EXTFEN    |ADC External Trigger Falling Edge Enable Bit
 * |        |          |0 = Falling edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Falling edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[7:6]   |TRGDLYDIV |ADC Sample Module Start of Conversion Trigger Delay Clock Divider Selection
 * |        |          |Trigger delay clock frequency:
 * |        |          |00 = ADC_CLK/1.
 * |        |          |01 = ADC_CLK/2.
 * |        |          |10 = ADC_CLK/4.
 * |        |          |11 = ADC_CLK/16.
 * |[15:8]  |TRGDLYCNT |ADC Sample Module Start of Conversion Trigger Delay Time
 * |        |          |Trigger delay time = TRGDLYCNT x ADC_CLK x n (n=1,2,4,16 from TRGDLYDIV setting).
 * |[20:16] |TRGSEL    |ADC Sample Module Start of Conversion Trigger Source Selection
 * |        |          |0H = Disable trigger.
 * |        |          |1H = External trigger from EADC0_ST pin input.
 * |        |          |2H = ADC ADINT0 interrupt EOC (End of conversion) pulse trigger.
 * |        |          |3H = ADC ADINT1 interrupt EOC (End of conversion) pulse trigger.
 * |        |          |4H = Timer0 overflow pulse trigger.
 * |        |          |5H = Timer1 overflow pulse trigger.
 * |        |          |6H = Timer2 overflow pulse trigger.
 * |        |          |7H = Timer3 overflow pulse trigger.
 * |        |          |8H = PWM0TG0.
 * |        |          |9H = PWM0TG1.
 * |        |          |AH = PWM0TG2.
 * |        |          |BH = PWM0TG3.
 * |        |          |CH = PWM0TG4.
 * |        |          |DH = PWM0TG5.
 * |        |          |other = Reserved.
 * |[22]    |INTPOS    |Interrupt Flag Position Select
 * |        |          |0 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC end of conversion.
 * |        |          |1 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC start of conversion.
 * |[23]    |DBMEN     |Double Buffer Mode Enable Bit
 * |        |          |0 = Sample has one sample result register. (default).
 * |        |          |1 = Sample has two sample result registers.
 * |[31:24] |EXTSMPT   |ADC Sampling Time Extend
 * |        |          |When ADC converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, user can extend ADC sampling time after trigger source is coming to get enough sampling time.
 * |        |          |The range of start delay time is from 0~255 ADC clock.
 * @var EADC_T::SCTL4
 * Offset: 0x90  ADC Sample Module 4 Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |CHSEL     |ADC Sample Module Channel Selection
 * |        |          |00H = EADC0_CH0.
 * |        |          |01H = EADC0_CH1.
 * |        |          |02H = EADC0_CH2.
 * |        |          |03H = EADC0_CH3.
 * |        |          |04H = EADC0_CH4.
 * |        |          |05H = EADC0_CH5.
 * |        |          |06H = EADC0_CH6.
 * |        |          |07H = EADC0_CH7.
 * |        |          |08H = EADC0_CH8.
 * |        |          |09H = EADC0_CH9.
 * |        |          |0AH = EADC0_CH10.
 * |        |          |0BH = EADC0_CH11.
 * |        |          |0CH = EADC0_CH12.
 * |        |          |other = Reserved.
 * |[4]     |EXTREN    |ADC External Trigger Rising Edge Enable Bit
 * |        |          |0 = Rising edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Rising edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[5]     |EXTFEN    |ADC External Trigger Falling Edge Enable Bit
 * |        |          |0 = Falling edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Falling edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[7:6]   |TRGDLYDIV |ADC Sample Module Start of Conversion Trigger Delay Clock Divider Selection
 * |        |          |Trigger delay clock frequency:
 * |        |          |00 = ADC_CLK/1.
 * |        |          |01 = ADC_CLK/2.
 * |        |          |10 = ADC_CLK/4.
 * |        |          |11 = ADC_CLK/16.
 * |[15:8]  |TRGDLYCNT |ADC Sample Module Start of Conversion Trigger Delay Time
 * |        |          |Trigger delay time = TRGDLYCNT x ADC_CLK x n (n=1,2,4,16 from TRGDLYDIV setting).
 * |[20:16] |TRGSEL    |ADC Sample Module Start of Conversion Trigger Source Selection
 * |        |          |0H = Disable trigger.
 * |        |          |1H = External trigger from EADC0_ST pin input.
 * |        |          |2H = ADC ADINT0 interrupt EOC pulse trigger.
 * |        |          |3H = ADC ADINT1 interrupt EOC pulse trigger.
 * |        |          |4H = Timer0 overflow pulse trigger.
 * |        |          |5H = Timer1 overflow pulse trigger.
 * |        |          |6H = Timer2 overflow pulse trigger.
 * |        |          |7H = Timer3 overflow pulse trigger.
 * |        |          |8H = PWM0TG0.
 * |        |          |9H = PWM0TG1.
 * |        |          |AH = PWM0TG2.
 * |        |          |BH = PWM0TG3.
 * |        |          |CH = PWM0TG4.
 * |        |          |DH = PWM0TG5.
 * |        |          |other = Reserved.
 * |[22]    |INTPOS    |Interrupt Flag Position Select
 * |        |          |0 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC end of conversion.
 * |        |          |1 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC start of conversion.
 * |[31:24] |EXTSMPT   |ADC Sampling Time Extend
 * |        |          |When ADC converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, SW can extend ADC sampling time after trigger source is coming to get enough sampling time.
 * |        |          |The range of start delay time is from 0~255 ADC clock.
 * @var EADC_T::SCTL5
 * Offset: 0x94  ADC Sample Module 5 Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |CHSEL     |ADC Sample Module Channel Selection
 * |        |          |00H = EADC0_CH0.
 * |        |          |01H = EADC0_CH1.
 * |        |          |02H = EADC0_CH2.
 * |        |          |03H = EADC0_CH3.
 * |        |          |04H = EADC0_CH4.
 * |        |          |05H = EADC0_CH5.
 * |        |          |06H = EADC0_CH6.
 * |        |          |07H = EADC0_CH7.
 * |        |          |08H = EADC0_CH8.
 * |        |          |09H = EADC0_CH9.
 * |        |          |0AH = EADC0_CH10.
 * |        |          |0BH = EADC0_CH11.
 * |        |          |0CH = EADC0_CH12.
 * |        |          |other = Reserved.
 * |[4]     |EXTREN    |ADC External Trigger Rising Edge Enable Bit
 * |        |          |0 = Rising edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Rising edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[5]     |EXTFEN    |ADC External Trigger Falling Edge Enable Bit
 * |        |          |0 = Falling edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Falling edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[7:6]   |TRGDLYDIV |ADC Sample Module Start of Conversion Trigger Delay Clock Divider Selection
 * |        |          |Trigger delay clock frequency:
 * |        |          |00 = ADC_CLK/1.
 * |        |          |01 = ADC_CLK/2.
 * |        |          |10 = ADC_CLK/4.
 * |        |          |11 = ADC_CLK/16.
 * |[15:8]  |TRGDLYCNT |ADC Sample Module Start of Conversion Trigger Delay Time
 * |        |          |Trigger delay time = TRGDLYCNT x ADC_CLK x n (n=1,2,4,16 from TRGDLYDIV setting).
 * |[20:16] |TRGSEL    |ADC Sample Module Start of Conversion Trigger Source Selection
 * |        |          |0H = Disable trigger.
 * |        |          |1H = External trigger from EADC0_ST pin input.
 * |        |          |2H = ADC ADINT0 interrupt EOC pulse trigger.
 * |        |          |3H = ADC ADINT1 interrupt EOC pulse trigger.
 * |        |          |4H = Timer0 overflow pulse trigger.
 * |        |          |5H = Timer1 overflow pulse trigger.
 * |        |          |6H = Timer2 overflow pulse trigger.
 * |        |          |7H = Timer3 overflow pulse trigger.
 * |        |          |8H = PWM0TG0.
 * |        |          |9H = PWM0TG1.
 * |        |          |AH = PWM0TG2.
 * |        |          |BH = PWM0TG3.
 * |        |          |CH = PWM0TG4.
 * |        |          |DH = PWM0TG5.
 * |        |          |other = Reserved.
 * |[22]    |INTPOS    |Interrupt Flag Position Select
 * |        |          |0 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC end of conversion.
 * |        |          |1 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC start of conversion.
 * |[31:24] |EXTSMPT   |ADC Sampling Time Extend
 * |        |          |When ADC converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, SW can extend ADC sampling time after trigger source is coming to get enough sampling time.
 * |        |          |The range of start delay time is from 0~255 ADC clock.
 * @var EADC_T::SCTL6
 * Offset: 0x98  ADC Sample Module 6 Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |CHSEL     |ADC Sample Module Channel Selection
 * |        |          |00H = EADC0_CH0.
 * |        |          |01H = EADC0_CH1.
 * |        |          |02H = EADC0_CH2.
 * |        |          |03H = EADC0_CH3.
 * |        |          |04H = EADC0_CH4.
 * |        |          |05H = EADC0_CH5.
 * |        |          |06H = EADC0_CH6.
 * |        |          |07H = EADC0_CH7.
 * |        |          |08H = EADC0_CH8.
 * |        |          |09H = EADC0_CH9.
 * |        |          |0AH = EADC0_CH10.
 * |        |          |0BH = EADC0_CH11.
 * |        |          |0CH = EADC0_CH12.
 * |        |          |other = Reserved.
 * |[4]     |EXTREN    |ADC External Trigger Rising Edge Enable Bit
 * |        |          |0 = Rising edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Rising edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[5]     |EXTFEN    |ADC External Trigger Falling Edge Enable Bit
 * |        |          |0 = Falling edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Falling edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[7:6]   |TRGDLYDIV |ADC Sample Module Start of Conversion Trigger Delay Clock Divider Selection
 * |        |          |Trigger delay clock frequency:
 * |        |          |00 = ADC_CLK/1.
 * |        |          |01 = ADC_CLK/2.
 * |        |          |10 = ADC_CLK/4.
 * |        |          |11 = ADC_CLK/16.
 * |[15:8]  |TRGDLYCNT |ADC Sample Module Start of Conversion Trigger Delay Time
 * |        |          |Trigger delay time = TRGDLYCNT x ADC_CLK x n (n=1,2,4,16 from TRGDLYDIV setting).
 * |[20:16] |TRGSEL    |ADC Sample Module Start of Conversion Trigger Source Selection
 * |        |          |0H = Disable trigger.
 * |        |          |1H = External trigger from EADC0_ST pin input.
 * |        |          |2H = ADC ADINT0 interrupt EOC pulse trigger.
 * |        |          |3H = ADC ADINT1 interrupt EOC pulse trigger.
 * |        |          |4H = Timer0 overflow pulse trigger.
 * |        |          |5H = Timer1 overflow pulse trigger.
 * |        |          |6H = Timer2 overflow pulse trigger.
 * |        |          |7H = Timer3 overflow pulse trigger.
 * |        |          |8H = PWM0TG0.
 * |        |          |9H = PWM0TG1.
 * |        |          |AH = PWM0TG2.
 * |        |          |BH = PWM0TG3.
 * |        |          |CH = PWM0TG4.
 * |        |          |DH = PWM0TG5.
 * |        |          |other = Reserved.
 * |[22]    |INTPOS    |Interrupt Flag Position Select
 * |        |          |0 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC end of conversion.
 * |        |          |1 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC start of conversion.
 * |[31:24] |EXTSMPT   |ADC Sampling Time Extend
 * |        |          |When ADC converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, SW can extend ADC sampling time after trigger source is coming to get enough sampling time.
 * |        |          |The range of start delay time is from 0~255 ADC clock.
 * @var EADC_T::SCTL7
 * Offset: 0x9C  ADC Sample Module 7 Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |CHSEL     |ADC Sample Module Channel Selection
 * |        |          |00H = EADC0_CH0.
 * |        |          |01H = EADC0_CH1.
 * |        |          |02H = EADC0_CH2.
 * |        |          |03H = EADC0_CH3.
 * |        |          |04H = EADC0_CH4.
 * |        |          |05H = EADC0_CH5.
 * |        |          |06H = EADC0_CH6.
 * |        |          |07H = EADC0_CH7.
 * |        |          |08H = EADC0_CH8.
 * |        |          |09H = EADC0_CH9.
 * |        |          |0AH = EADC0_CH10.
 * |        |          |0BH = EADC0_CH11.
 * |        |          |0CH = EADC0_CH12.
 * |        |          |other = Reserved.
 * |[4]     |EXTREN    |ADC External Trigger Rising Edge Enable Bit
 * |        |          |0 = Rising edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Rising edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[5]     |EXTFEN    |ADC External Trigger Falling Edge Enable Bit
 * |        |          |0 = Falling edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Falling edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[7:6]   |TRGDLYDIV |ADC Sample Module Start of Conversion Trigger Delay Clock Divider Selection
 * |        |          |Trigger delay clock frequency:
 * |        |          |00 = ADC_CLK/1.
 * |        |          |01 = ADC_CLK/2.
 * |        |          |10 = ADC_CLK/4.
 * |        |          |11 = ADC_CLK/16.
 * |[15:8]  |TRGDLYCNT |ADC Sample Module Start of Conversion Trigger Delay Time
 * |        |          |Trigger delay time = TRGDLYCNT x ADC_CLK x n (n=1,2,4,16 from TRGDLYDIV setting).
 * |[20:16] |TRGSEL    |ADC Sample Module Start of Conversion Trigger Source Selection
 * |        |          |0H = Disable trigger.
 * |        |          |1H = External trigger from EADC0_ST pin input.
 * |        |          |2H = ADC ADINT0 interrupt EOC pulse trigger.
 * |        |          |3H = ADC ADINT1 interrupt EOC pulse trigger.
 * |        |          |4H = Timer0 overflow pulse trigger.
 * |        |          |5H = Timer1 overflow pulse trigger.
 * |        |          |6H = Timer2 overflow pulse trigger.
 * |        |          |7H = Timer3 overflow pulse trigger.
 * |        |          |8H = PWM0TG0.
 * |        |          |9H = PWM0TG1.
 * |        |          |AH = PWM0TG2.
 * |        |          |BH = PWM0TG3.
 * |        |          |CH = PWM0TG4.
 * |        |          |DH = PWM0TG5.
 * |        |          |other = Reserved.
 * |[22]    |INTPOS    |Interrupt Flag Position Select
 * |        |          |0 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC end of conversion.
 * |        |          |1 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC start of conversion.
 * |[31:24] |EXTSMPT   |ADC Sampling Time Extend
 * |        |          |When ADC converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, SW can extend ADC sampling time after trigger source is coming to get enough sampling time.
 * |        |          |The range of start delay time is from 0~255 ADC clock.
 * @var EADC_T::SCTL8
 * Offset: 0xA0  ADC Sample Module 8 Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |CHSEL     |ADC Sample Module Channel Selection
 * |        |          |00H = EADC0_CH0.
 * |        |          |01H = EADC0_CH1.
 * |        |          |02H = EADC0_CH2.
 * |        |          |03H = EADC0_CH3.
 * |        |          |04H = EADC0_CH4.
 * |        |          |05H = EADC0_CH5.
 * |        |          |06H = EADC0_CH6.
 * |        |          |07H = EADC0_CH7.
 * |        |          |08H = EADC0_CH8.
 * |        |          |09H = EADC0_CH9.
 * |        |          |0AH = EADC0_CH10.
 * |        |          |0BH = EADC0_CH11.
 * |        |          |0CH = EADC0_CH12.
 * |        |          |other = Reserved.
 * |[4]     |EXTREN    |ADC External Trigger Rising Edge Enable Bit
 * |        |          |0 = Rising edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Rising edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[5]     |EXTFEN    |ADC External Trigger Falling Edge Enable Bit
 * |        |          |0 = Falling edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Falling edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[7:6]   |TRGDLYDIV |ADC Sample Module Start of Conversion Trigger Delay Clock Divider Selection
 * |        |          |Trigger delay clock frequency:
 * |        |          |00 = ADC_CLK/1.
 * |        |          |01 = ADC_CLK/2.
 * |        |          |10 = ADC_CLK/4.
 * |        |          |11 = ADC_CLK/16.
 * |[15:8]  |TRGDLYCNT |ADC Sample Module Start of Conversion Trigger Delay Time
 * |        |          |Trigger delay time = TRGDLYCNT x ADC_CLK x n (n=1,2,4,16 from TRGDLYDIV setting).
 * |[20:16] |TRGSEL    |ADC Sample Module Start of Conversion Trigger Source Selection
 * |        |          |0H = Disable trigger.
 * |        |          |1H = External trigger from EADC0_ST pin input.
 * |        |          |2H = ADC ADINT0 interrupt EOC pulse trigger.
 * |        |          |3H = ADC ADINT1 interrupt EOC pulse trigger.
 * |        |          |4H = Timer0 overflow pulse trigger.
 * |        |          |5H = Timer1 overflow pulse trigger.
 * |        |          |6H = Timer2 overflow pulse trigger.
 * |        |          |7H = Timer3 overflow pulse trigger.
 * |        |          |8H = PWM0TG0.
 * |        |          |9H = PWM0TG1.
 * |        |          |AH = PWM0TG2.
 * |        |          |BH = PWM0TG3.
 * |        |          |CH = PWM0TG4.
 * |        |          |DH = PWM0TG5.
 * |        |          |other = Reserved.
 * |[22]    |INTPOS    |Interrupt Flag Position Select
 * |        |          |0 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC end of conversion.
 * |        |          |1 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC start of conversion.
 * |[31:24] |EXTSMPT   |ADC Sampling Time Extend
 * |        |          |When ADC converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, SW can extend ADC sampling time after trigger source is coming to get enough sampling time.
 * |        |          |The range of start delay time is from 0~255 ADC clock.
 * @var EADC_T::SCTL9
 * Offset: 0xA4  ADC Sample Module 9 Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |CHSEL     |ADC Sample Module Channel Selection
 * |        |          |00H = EADC0_CH0.
 * |        |          |01H = EADC0_CH1.
 * |        |          |02H = EADC0_CH2.
 * |        |          |03H = EADC0_CH3.
 * |        |          |04H = EADC0_CH4.
 * |        |          |05H = EADC0_CH5.
 * |        |          |06H = EADC0_CH6.
 * |        |          |07H = EADC0_CH7.
 * |        |          |08H = EADC0_CH8.
 * |        |          |09H = EADC0_CH9.
 * |        |          |0AH = EADC0_CH10.
 * |        |          |0BH = EADC0_CH11.
 * |        |          |0CH = EADC0_CH12.
 * |        |          |other = Reserved.
 * |[4]     |EXTREN    |ADC External Trigger Rising Edge Enable Bit
 * |        |          |0 = Rising edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Rising edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[5]     |EXTFEN    |ADC External Trigger Falling Edge Enable Bit
 * |        |          |0 = Falling edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Falling edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[7:6]   |TRGDLYDIV |ADC Sample Module Start of Conversion Trigger Delay Clock Divider Selection
 * |        |          |Trigger delay clock frequency:
 * |        |          |00 = ADC_CLK/1.
 * |        |          |01 = ADC_CLK/2.
 * |        |          |10 = ADC_CLK/4.
 * |        |          |11 = ADC_CLK/16.
 * |[15:8]  |TRGDLYCNT |ADC Sample Module Start of Conversion Trigger Delay Time
 * |        |          |Trigger delay time = TRGDLYCNT x ADC_CLK x n (n=1,2,4,16 from TRGDLYDIV setting).
 * |[20:16] |TRGSEL    |ADC Sample Module Start of Conversion Trigger Source Selection
 * |        |          |0H = Disable trigger.
 * |        |          |1H = External trigger from EADC0_ST pin input.
 * |        |          |2H = ADC ADINT0 interrupt EOC pulse trigger.
 * |        |          |3H = ADC ADINT1 interrupt EOC pulse trigger.
 * |        |          |4H = Timer0 overflow pulse trigger.
 * |        |          |5H = Timer1 overflow pulse trigger.
 * |        |          |6H = Timer2 overflow pulse trigger.
 * |        |          |7H = Timer3 overflow pulse trigger.
 * |        |          |8H = PWM0TG0.
 * |        |          |9H = PWM0TG1.
 * |        |          |AH = PWM0TG2.
 * |        |          |BH = PWM0TG3.
 * |        |          |CH = PWM0TG4.
 * |        |          |DH = PWM0TG5.
 * |        |          |other = Reserved.
 * |[22]    |INTPOS    |Interrupt Flag Position Select
 * |        |          |0 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC end of conversion.
 * |        |          |1 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC start of conversion.
 * |[31:24] |EXTSMPT   |ADC Sampling Time Extend
 * |        |          |When ADC converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, SW can extend ADC sampling time after trigger source is coming to get enough sampling time.
 * |        |          |The range of start delay time is from 0~255 ADC clock.
 * @var EADC_T::SCTL10
 * Offset: 0xA8  ADC Sample Module 10 Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |CHSEL     |ADC Sample Module Channel Selection
 * |        |          |00H = EADC0_CH0.
 * |        |          |01H = EADC0_CH1.
 * |        |          |02H = EADC0_CH2.
 * |        |          |03H = EADC0_CH3.
 * |        |          |04H = EADC0_CH4.
 * |        |          |05H = EADC0_CH5.
 * |        |          |06H = EADC0_CH6.
 * |        |          |07H = EADC0_CH7.
 * |        |          |08H = EADC0_CH8.
 * |        |          |09H = EADC0_CH9.
 * |        |          |0AH = EADC0_CH10.
 * |        |          |0BH = EADC0_CH11.
 * |        |          |0CH = EADC0_CH12.
 * |        |          |other = Reserved.
 * |[4]     |EXTREN    |ADC External Trigger Rising Edge Enable Bit
 * |        |          |0 = Rising edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Rising edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[5]     |EXTFEN    |ADC External Trigger Falling Edge Enable Bit
 * |        |          |0 = Falling edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Falling edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[7:6]   |TRGDLYDIV |ADC Sample Module Start of Conversion Trigger Delay Clock Divider Selection
 * |        |          |Trigger delay clock frequency:
 * |        |          |00 = ADC_CLK/1.
 * |        |          |01 = ADC_CLK/2.
 * |        |          |10 = ADC_CLK/4.
 * |        |          |11 = ADC_CLK/16.
 * |[15:8]  |TRGDLYCNT |ADC Sample Module Start of Conversion Trigger Delay Time
 * |        |          |Trigger delay time = TRGDLYCNT x ADC_CLK x n (n=1,2,4,16 from TRGDLYDIV setting).
 * |[20:16] |TRGSEL    |ADC Sample Module Start of Conversion Trigger Source Selection
 * |        |          |0H = Disable trigger.
 * |        |          |1H = External trigger from EADC0_ST pin input.
 * |        |          |2H = ADC ADINT0 interrupt EOC pulse trigger.
 * |        |          |3H = ADC ADINT1 interrupt EOC pulse trigger.
 * |        |          |4H = Timer0 overflow pulse trigger.
 * |        |          |5H = Timer1 overflow pulse trigger.
 * |        |          |6H = Timer2 overflow pulse trigger.
 * |        |          |7H = Timer3 overflow pulse trigger.
 * |        |          |8H = PWM0TG0.
 * |        |          |9H = PWM0TG1.
 * |        |          |AH = PWM0TG2.
 * |        |          |BH = PWM0TG3.
 * |        |          |CH = PWM0TG4.
 * |        |          |DH = PWM0TG5.
 * |        |          |other = Reserved.
 * |[22]    |INTPOS    |Interrupt Flag Position Select
 * |        |          |0 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC end of conversion.
 * |        |          |1 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC start of conversion.
 * |[31:24] |EXTSMPT   |ADC Sampling Time Extend
 * |        |          |When ADC converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, SW can extend ADC sampling time after trigger source is coming to get enough sampling time.
 * |        |          |The range of start delay time is from 0~255 ADC clock.
 * @var EADC_T::SCTL11
 * Offset: 0xAC  ADC Sample Module 11 Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |CHSEL     |ADC Sample Module Channel Selection
 * |        |          |00H = EADC0_CH0.
 * |        |          |01H = EADC0_CH1.
 * |        |          |02H = EADC0_CH2.
 * |        |          |03H = EADC0_CH3.
 * |        |          |04H = EADC0_CH4.
 * |        |          |05H = EADC0_CH5.
 * |        |          |06H = EADC0_CH6.
 * |        |          |07H = EADC0_CH7.
 * |        |          |08H = EADC0_CH8.
 * |        |          |09H = EADC0_CH9.
 * |        |          |0AH = EADC0_CH10.
 * |        |          |0BH = EADC0_CH11.
 * |        |          |0CH = EADC0_CH12.
 * |        |          |other = Reserved.
 * |[4]     |EXTREN    |ADC External Trigger Rising Edge Enable Bit
 * |        |          |0 = Rising edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Rising edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[5]     |EXTFEN    |ADC External Trigger Falling Edge Enable Bit
 * |        |          |0 = Falling edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Falling edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[7:6]   |TRGDLYDIV |ADC Sample Module Start of Conversion Trigger Delay Clock Divider Selection
 * |        |          |Trigger delay clock frequency:
 * |        |          |00 = ADC_CLK/1.
 * |        |          |01 = ADC_CLK/2.
 * |        |          |10 = ADC_CLK/4.
 * |        |          |11 = ADC_CLK/16.
 * |[15:8]  |TRGDLYCNT |ADC Sample Module Start of Conversion Trigger Delay Time
 * |        |          |Trigger delay time = TRGDLYCNT x ADC_CLK x n (n=1,2,4,16 from TRGDLYDIV setting).
 * |[20:16] |TRGSEL    |ADC Sample Module Start of Conversion Trigger Source Selection
 * |        |          |0H = Disable trigger.
 * |        |          |1H = External trigger from EADC0_ST pin input.
 * |        |          |2H = ADC ADINT0 interrupt EOC pulse trigger.
 * |        |          |3H = ADC ADINT1 interrupt EOC pulse trigger.
 * |        |          |4H = Timer0 overflow pulse trigger.
 * |        |          |5H = Timer1 overflow pulse trigger.
 * |        |          |6H = Timer2 overflow pulse trigger.
 * |        |          |7H = Timer3 overflow pulse trigger.
 * |        |          |8H = PWM0TG0.
 * |        |          |9H = PWM0TG1.
 * |        |          |AH = PWM0TG2.
 * |        |          |BH = PWM0TG3.
 * |        |          |CH = PWM0TG4.
 * |        |          |DH = PWM0TG5.
 * |        |          |other = Reserved.
 * |[22]    |INTPOS    |Interrupt Flag Position Select
 * |        |          |0 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC end of conversion.
 * |        |          |1 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC start of conversion.
 * |[31:24] |EXTSMPT   |ADC Sampling Time Extend
 * |        |          |When ADC converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, SW can extend ADC sampling time after trigger source is coming to get enough sampling time.
 * |        |          |The range of start delay time is from 0~255 ADC clock.
 * @var EADC_T::SCTL12
 * Offset: 0xB0  ADC Sample Module 12 Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |CHSEL     |ADC Sample Module Channel Selection
 * |        |          |00H = EADC0_CH0.
 * |        |          |01H = EADC0_CH1.
 * |        |          |02H = EADC0_CH2.
 * |        |          |03H = EADC0_CH3.
 * |        |          |04H = EADC0_CH4.
 * |        |          |05H = EADC0_CH5.
 * |        |          |06H = EADC0_CH6.
 * |        |          |07H = EADC0_CH7.
 * |        |          |08H = EADC0_CH8.
 * |        |          |09H = EADC0_CH9.
 * |        |          |0AH = EADC0_CH10.
 * |        |          |0BH = EADC0_CH11.
 * |        |          |0CH = EADC0_CH12.
 * |        |          |other = Reserved.
 * |[4]     |EXTREN    |ADC External Trigger Rising Edge Enable Bit
 * |        |          |0 = Rising edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Rising edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[5]     |EXTFEN    |ADC External Trigger Falling Edge Enable Bit
 * |        |          |0 = Falling edge Disabled when ADC selects EADC0_ST as trigger source.
 * |        |          |1 = Falling edge Enabled when ADC selects EADC0_ST as trigger source.
 * |[7:6]   |TRGDLYDIV |ADC Sample Module Start of Conversion Trigger Delay Clock Divider Selection
 * |        |          |Trigger delay clock frequency:
 * |        |          |00 = ADC_CLK/1.
 * |        |          |01 = ADC_CLK/2.
 * |        |          |10 = ADC_CLK/4.
 * |        |          |11 = ADC_CLK/16.
 * |[15:8]  |TRGDLYCNT |ADC Sample Module Start of Conversion Trigger Delay Time
 * |        |          |Trigger delay time = TRGDLYCNT x ADC_CLK x n (n=1,2,4,16 from TRGDLYDIV setting).
 * |[20:16] |TRGSEL    |ADC Sample Module Start of Conversion Trigger Source Selection
 * |        |          |0H = Disable trigger.
 * |        |          |1H = External trigger from EADC0_ST pin input.
 * |        |          |2H = ADC ADINT0 interrupt EOC pulse trigger.
 * |        |          |3H = ADC ADINT1 interrupt EOC pulse trigger.
 * |        |          |4H = Timer0 overflow pulse trigger.
 * |        |          |5H = Timer1 overflow pulse trigger.
 * |        |          |6H = Timer2 overflow pulse trigger.
 * |        |          |7H = Timer3 overflow pulse trigger.
 * |        |          |8H = PWM0TG0.
 * |        |          |9H = PWM0TG1.
 * |        |          |AH = PWM0TG2.
 * |        |          |BH = PWM0TG3.
 * |        |          |CH = PWM0TG4.
 * |        |          |DH = PWM0TG5.
 * |        |          |other = Reserved.
 * |[22]    |INTPOS    |Interrupt Flag Position Select
 * |        |          |0 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC end of conversion.
 * |        |          |1 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC start of conversion.
 * |[31:24] |EXTSMPT   |ADC Sampling Time Extend
 * |        |          |When ADC converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, SW can extend ADC sampling time after trigger source is coming to get enough sampling time.
 * |        |          |The range of start delay time is from 0~255 ADC clock.
 * @var EADC_T::SCTL16
 * Offset: 0xC0  ADC Sample Module 16 Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:24] |EXTSMPT   |ADC Sampling Time Extend
 * |        |          |When ADC converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, SW can extend ADC sampling time after trigger source is coming to get enough sampling time.
 * |        |          |The range of start delay time is from 0~255 ADC clock.
 * @var EADC_T::SCTL17
 * Offset: 0xC4  ADC Sample Module 17 Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:24] |EXTSMPT   |ADC Sampling Time Extend
 * |        |          |When ADC converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, SW can extend ADC sampling time after trigger source is coming to get enough sampling time.
 * |        |          |The range of start delay time is from 0~255 ADC clock.
 * @var EADC_T::INTSRC0
 * Offset: 0xD0  ADC interrupt 0 Source Enable Control Register.
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |SPLIE0    |Sample Module 0 Interrupt Enable Bit
 * |        |          |0 = Sample Module 0 interrupt Disabled.
 * |        |          |1 = Sample Module 0 interrupt Enabled.
 * |[1]     |SPLIE1    |Sample Module 1 Interrupt Enable Bit
 * |        |          |0 = Sample Module 1 interrupt Disabled.
 * |        |          |1 = Sample Module 1 interrupt Enabled.
 * |[2]     |SPLIE2    |Sample Module 2 Interrupt Enable Bit
 * |        |          |0 = Sample Module 2 interrupt Disabled.
 * |        |          |1 = Sample Module 2 interrupt Enabled.
 * |[3]     |SPLIE3    |Sample Module 3 Interrupt Enable Bit
 * |        |          |0 = Sample Module 3 interrupt Disabled.
 * |        |          |1 = Sample Module 3 interrupt Enabled.
 * |[4]     |SPLIE4    |Sample Module 4 Interrupt Enable Bit
 * |        |          |0 = Sample Module 4 interrupt Disabled.
 * |        |          |1 = Sample Module 4 interrupt Enabled.
 * |[5]     |SPLIE5    |Sample Module 5 Interrupt Enable Bit
 * |        |          |0 = Sample Module 5 interrupt Disabled.
 * |        |          |1 = Sample Module 5 interrupt Enabled.
 * |[6]     |SPLIE6    |Sample Module 6 Interrupt Enable Bit
 * |        |          |0 = Sample Module 6 interrupt Disabled.
 * |        |          |1 = Sample Module 6 interrupt Enabled.
 * |[7]     |SPLIE7    |Sample Module 7 Interrupt Enable Bit
 * |        |          |0 = Sample Module 7 interrupt Disabled.
 * |        |          |1 = Sample Module 7 interrupt Enabled.
 * |[8]     |SPLIE8    |Sample Module 8 Interrupt Enable Bit
 * |        |          |0 = Sample Module 8 interrupt Disabled.
 * |        |          |1 = Sample Module 8 interrupt Enabled.
 * |[9]     |SPLIE9    |Sample Module 9 Interrupt Enable Bit
 * |        |          |0 = Sample Module 9 interrupt Disabled.
 * |        |          |1 = Sample Module 9 interrupt Enabled.
 * |[10]    |SPLIE10   |Sample Module 10 Interrupt Enable Bit
 * |        |          |0 = Sample Module 10 interrupt Disabled.
 * |        |          |1 = Sample Module 10 interrupt Enabled.
 * |[11]    |SPLIE11   |Sample Module 11 Interrupt Enable Bit
 * |        |          |0 = Sample Module 11 interrupt Disabled.
 * |        |          |1 = Sample Module 11 interrupt Enabled.
 * |[12]    |SPLIE12   |Sample Module 12 Interrupt Enable Bit
 * |        |          |0 = Sample Module 12 interrupt Disabled.
 * |        |          |1 = Sample Module 12 interrupt Enabled.
 * |[16]    |SPLIE16   |Sample Module 16 Interrupt Enable Bit
 * |        |          |0 = Sample Module 16 interrupt Disabled.
 * |        |          |1 = Sample Module 16 interrupt Enabled.
 * |[17]    |SPLIE17   |Sample Module 17 Interrupt Enable Bit
 * |        |          |0 = Sample Module 17 interrupt Disabled.
 * |        |          |1 = Sample Module 17 interrupt Enabled.
 * @var EADC_T::INTSRC1
 * Offset: 0xD4  ADC interrupt 1 Source Enable Control Register.
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |SPLIE0    |Sample Module 0 Interrupt Enable Bit
 * |        |          |0 = Sample Module 0 interrupt Disabled.
 * |        |          |1 = Sample Module 0 interrupt Enabled.
 * |[1]     |SPLIE1    |Sample Module 1 Interrupt Enable Bit
 * |        |          |0 = Sample Module 1 interrupt Disabled.
 * |        |          |1 = Sample Module 1 interrupt Enabled.
 * |[2]     |SPLIE2    |Sample Module 2 Interrupt Enable Bit
 * |        |          |0 = Sample Module 2 interrupt Disabled.
 * |        |          |1 = Sample Module 2 interrupt Enabled.
 * |[3]     |SPLIE3    |Sample Module 3 Interrupt Enable Bit
 * |        |          |0 = Sample Module 3 interrupt Disabled.
 * |        |          |1 = Sample Module 3 interrupt Enabled.
 * |[4]     |SPLIE4    |Sample Module 4 Interrupt Enable Bit
 * |        |          |0 = Sample Module 4 interrupt Disabled.
 * |        |          |1 = Sample Module 4 interrupt Enabled.
 * |[5]     |SPLIE5    |Sample Module 5 Interrupt Enable Bit
 * |        |          |0 = Sample Module 5 interrupt Disabled.
 * |        |          |1 = Sample Module 5 interrupt Enabled.
 * |[6]     |SPLIE6    |Sample Module 6 Interrupt Enable Bit
 * |        |          |0 = Sample Module 6 interrupt Disabled.
 * |        |          |1 = Sample Module 6 interrupt Enabled.
 * |[7]     |SPLIE7    |Sample Module 7 Interrupt Enable Bit
 * |        |          |0 = Sample Module 7 interrupt Disabled.
 * |        |          |1 = Sample Module 7 interrupt Enabled.
 * |[8]     |SPLIE8    |Sample Module 8 Interrupt Enable Bit
 * |        |          |0 = Sample Module 8 interrupt Disabled.
 * |        |          |1 = Sample Module 8 interrupt Enabled.
 * |[9]     |SPLIE9    |Sample Module 9 Interrupt Enable Bit
 * |        |          |0 = Sample Module 9 interrupt Disabled.
 * |        |          |1 = Sample Module 9 interrupt Enabled.
 * |[10]    |SPLIE10   |Sample Module 10 Interrupt Enable Bit
 * |        |          |0 = Sample Module 10 interrupt Disabled.
 * |        |          |1 = Sample Module 10 interrupt Enabled.
 * |[11]    |SPLIE11   |Sample Module 11 Interrupt Enable Bit
 * |        |          |0 = Sample Module 11 interrupt Disabled.
 * |        |          |1 = Sample Module 11 interrupt Enabled.
 * |[12]    |SPLIE12   |Sample Module 12 Interrupt Enable Bit
 * |        |          |0 = Sample Module 12 interrupt Disabled.
 * |        |          |1 = Sample Module 12 interrupt Enabled.
 * |[16]    |SPLIE16   |Sample Module 16 Interrupt Enable Bit
 * |        |          |0 = Sample Module 16 interrupt Disabled.
 * |        |          |1 = Sample Module 16 interrupt Enabled.
 * |[17]    |SPLIE17   |Sample Module 17 Interrupt Enable Bit
 * |        |          |0 = Sample Module 17 interrupt Disabled.
 * |        |          |1 = Sample Module 17 interrupt Enabled.
 * @var EADC_T::INTSRC2
 * Offset: 0xD8  ADC interrupt 2 Source Enable Control Register.
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |SPLIE0    |Sample Module 0 Interrupt Enable Bit
 * |        |          |0 = Sample Module 0 interrupt Disabled.
 * |        |          |1 = Sample Module 0 interrupt Enabled.
 * |[1]     |SPLIE1    |Sample Module 1 Interrupt Enable Bit
 * |        |          |0 = Sample Module 1 interrupt Disabled.
 * |        |          |1 = Sample Module 1 interrupt Enabled.
 * |[2]     |SPLIE2    |Sample Module 2 Interrupt Enable Bit
 * |        |          |0 = Sample Module 2 interrupt Disabled.
 * |        |          |1 = Sample Module 2 interrupt Enabled.
 * |[3]     |SPLIE3    |Sample Module 3 Interrupt Enable Bit
 * |        |          |0 = Sample Module 3 interrupt Disabled.
 * |        |          |1 = Sample Module 3 interrupt Enabled.
 * |[4]     |SPLIE4    |Sample Module 4 Interrupt Enable Bit
 * |        |          |0 = Sample Module 4 interrupt Disabled.
 * |        |          |1 = Sample Module 4 interrupt Enabled.
 * |[5]     |SPLIE5    |Sample Module 5 Interrupt Enable Bit
 * |        |          |0 = Sample Module 5 interrupt Disabled.
 * |        |          |1 = Sample Module 5 interrupt Enabled.
 * |[6]     |SPLIE6    |Sample Module 6 Interrupt Enable Bit
 * |        |          |0 = Sample Module 6 interrupt Disabled.
 * |        |          |1 = Sample Module 6 interrupt Enabled.
 * |[7]     |SPLIE7    |Sample Module 7 Interrupt Enable Bit
 * |        |          |0 = Sample Module 7 interrupt Disabled.
 * |        |          |1 = Sample Module 7 interrupt Enabled.
 * |[8]     |SPLIE8    |Sample Module 8 Interrupt Enable Bit
 * |        |          |0 = Sample Module 8 interrupt Disabled.
 * |        |          |1 = Sample Module 8 interrupt Enabled.
 * |[9]     |SPLIE9    |Sample Module 9 Interrupt Enable Bit
 * |        |          |0 = Sample Module 9 interrupt Disabled.
 * |        |          |1 = Sample Module 9 interrupt Enabled.
 * |[10]    |SPLIE10   |Sample Module 10 Interrupt Enable Bit
 * |        |          |0 = Sample Module 10 interrupt Disabled.
 * |        |          |1 = Sample Module 10 interrupt Enabled.
 * |[11]    |SPLIE11   |Sample Module 11 Interrupt Enable Bit
 * |        |          |0 = Sample Module 11 interrupt Disabled.
 * |        |          |1 = Sample Module 11 interrupt Enabled.
 * |[12]    |SPLIE12   |Sample Module 12 Interrupt Enable Bit
 * |        |          |0 = Sample Module 12 interrupt Disabled.
 * |        |          |1 = Sample Module 12 interrupt Enabled.
 * |[16]    |SPLIE16   |Sample Module 16 Interrupt Enable Bit
 * |        |          |0 = Sample Module 16 interrupt Disabled.
 * |        |          |1 = Sample Module 16 interrupt Enabled.
 * |[17]    |SPLIE17   |Sample Module 17 Interrupt Enable Bit
 * |        |          |0 = Sample Module 17 interrupt Disabled.
 * |        |          |1 = Sample Module 17 interrupt Enabled.
 * @var EADC_T::INTSRC3
 * Offset: 0xDC  ADC interrupt 3 Source Enable Control Register.
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |SPLIE0    |Sample Module 0 Interrupt Enable Bit
 * |        |          |0 = Sample Module 0 interrupt Disabled.
 * |        |          |1 = Sample Module 0 interrupt Enabled.
 * |[1]     |SPLIE1    |Sample Module 1 Interrupt Enable Bit
 * |        |          |0 = Sample Module 1 interrupt Disabled.
 * |        |          |1 = Sample Module 1 interrupt Enabled.
 * |[2]     |SPLIE2    |Sample Module 2 Interrupt Enable Bit
 * |        |          |0 = Sample Module 2 interrupt Disabled.
 * |        |          |1 = Sample Module 2 interrupt Enabled.
 * |[3]     |SPLIE3    |Sample Module 3 Interrupt Enable Bit
 * |        |          |0 = Sample Module 3 interrupt Disabled.
 * |        |          |1 = Sample Module 3 interrupt Enabled.
 * |[4]     |SPLIE4    |Sample Module 4 Interrupt Enable Bit
 * |        |          |0 = Sample Module 4 interrupt Disabled.
 * |        |          |1 = Sample Module 4 interrupt Enabled.
 * |[5]     |SPLIE5    |Sample Module 5 Interrupt Enable Bit
 * |        |          |0 = Sample Module 5 interrupt Disabled.
 * |        |          |1 = Sample Module 5 interrupt Enabled.
 * |[6]     |SPLIE6    |Sample Module 6 Interrupt Enable Bit
 * |        |          |0 = Sample Module 6 interrupt Disabled.
 * |        |          |1 = Sample Module 6 interrupt Enabled.
 * |[7]     |SPLIE7    |Sample Module 7 Interrupt Enable Bit
 * |        |          |0 = Sample Module 7 interrupt Disabled.
 * |        |          |1 = Sample Module 7 interrupt Enabled.
 * |[8]     |SPLIE8    |Sample Module 8 Interrupt Enable Bit
 * |        |          |0 = Sample Module 8 interrupt Disabled.
 * |        |          |1 = Sample Module 8 interrupt Enabled.
 * |[9]     |SPLIE9    |Sample Module 9 Interrupt Enable Bit
 * |        |          |0 = Sample Module 9 interrupt Disabled.
 * |        |          |1 = Sample Module 9 interrupt Enabled.
 * |[10]    |SPLIE10   |Sample Module 10 Interrupt Enable Bit
 * |        |          |0 = Sample Module 10 interrupt Disabled.
 * |        |          |1 = Sample Module 10 interrupt Enabled.
 * |[11]    |SPLIE11   |Sample Module 11 Interrupt Enable Bit
 * |        |          |0 = Sample Module 11 interrupt Disabled.
 * |        |          |1 = Sample Module 11 interrupt Enabled.
 * |[12]    |SPLIE12   |Sample Module 12 Interrupt Enable Bit
 * |        |          |0 = Sample Module 12 interrupt Disabled.
 * |        |          |1 = Sample Module 12 interrupt Enabled.
 * |[16]    |SPLIE16   |Sample Module 16 Interrupt Enable Bit
 * |        |          |0 = Sample Module 16 interrupt Disabled.
 * |        |          |1 = Sample Module 16 interrupt Enabled.
 * |[17]    |SPLIE17   |Sample Module 17 Interrupt Enable Bit
 * |        |          |0 = Sample Module 17 interrupt Disabled.
 * |        |          |1 = Sample Module 17 interrupt Enabled.
 * @var EADC_T::CMP0
 * Offset: 0xE0  ADC Result Compare Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ADCMPEN   |ADC Result Compare Enable Bit
 * |        |          |0 = Compare Disabled.
 * |        |          |1 = Compare Enabled.
 * |        |          |Set this bit to 1 to enable compare CMPDAT (EADC_CMPn[27:16], n=0~3) with specified sample module conversion result when converted data is loaded into EADC_DAT register.
 * |[1]     |ADCMPIE   |ADC Result Compare Interrupt Enable Bit
 * |        |          |0 = Compare function interrupt Disabled.
 * |        |          |1 = Compare function interrupt Enabled.
 * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND (EADC_CMPn[2], n=0~3) and CMPMCNT (EADC_CMPn[11:8], n=0~3), ADCMPFn (EADC_STATUS2[7:4], n=0~3) will be asserted, in the meanwhile, if ADCMPIE is set to 1, a compare interrupt request is generated.
 * |[2]     |CMPCOND   |Compare Condition
 * |        |          |0= Set the compare condition as that when a 12-bit ADC conversion result is less than the 12-bit CMPDAT (EADC_CMPn [27:16]), the internal match counter will increase one.
 * |        |          |1= Set the compare condition as that when a 12-bit ADC conversion result is greater or equal to the 12-bit CMPDAT (EADC_CMPn [27:16]), the internal match counter will increase one.
 * |        |          |Note: When the internal counter reaches the value to (CMPMCNT (EADC_CMPn[11:8], n=0~3) +1), the CMPF bit will be set.
 * |[7:3]   |CMPSPL    |Compare Sample Module Selection
 * |        |          |00000 = Sample Module 0 conversion result EADC_DAT0 is selected to be compared.
 * |        |          |00001 = Sample Module 1 conversion result EADC_DAT1 is selected to be compared.
 * |        |          |00010 = Sample Module 2 conversion result EADC_DAT2 is selected to be compared.
 * |        |          |00011 = Sample Module 3 conversion result EADC_DAT3 is selected to be compared.
 * |        |          |00100 = Sample Module 4 conversion result EADC_DAT4 is selected to be compared.
 * |        |          |00101 = Sample Module 5 conversion result EADC_DAT5 is selected to be compared.
 * |        |          |00110 = Sample Module 6 conversion result EADC_DAT6 is selected to be compared.
 * |        |          |00111 = Sample Module 7 conversion result EADC_DAT7 is selected to be compared.
 * |        |          |01000 = Sample Module 8 conversion result EADC_DAT8 is selected to be compared.
 * |        |          |01001 = Sample Module 9 conversion result EADC_DAT9 is selected to be compared.
 * |        |          |01010 = Sample Module 10 conversion result EADC_DAT10 is selected to be compared.
 * |        |          |01011 = Sample Module 11 conversion result EADC_DAT11 is selected to be compared.
 * |        |          |01100 = Sample Module 12 conversion result EADC_DAT12 is selected to be compared.
 * |        |          |10000 = Sample Module 16 conversion result EADC_DAT16 is selected to be compared.
 * |        |          |10001 = Sample Module 17 conversion result EADC_DAT17 is selected to be compared.
 * |        |          |other = Reserved.
 * |[11:8]  |CMPMCNT   |Compare Match Count
 * |        |          |When the specified ADC sample module analog conversion result matches the compare condition defined by CMPCOND (EADC_CMPn[2], n=0~3), the internal match counter will increase 1
 * |        |          |If the compare result does not meet the compare condition, the internal compare match counter will reset to 0
 * |        |          |When the internal counter reaches the value to (CMPMCNT +1), the ADCMPFn (EADC_STATUS2[7:4], n=0~3) will be set.
 * |[15]    |CMPWEN    |Compare Window Mode Enable Bit
 * |        |          |0 = ADCMPF0 (EADC_STATUS2[4]) will be set when EADC_CMP0 compared condition matched
 * |        |          |ADCMPF2 (EADC_STATUS2[6]) will be set when EADC_CMP2 compared condition matched
 * |        |          |1 = ADCMPF0 (EADC_STATUS2[4]) will be set when both EADC_CMP0 and EADC_CMP1 compared condition matched
 * |        |          |ADCMPF2 (EADC_STATUS2[6]) will be set when both EADC_CMP2 and EADC_CMP3 compared condition matched.
 * |        |          |Note: This bit is only present in EADC_CMP0 and EADC_CMP2 register.
 * |[27:16] |CMPDAT    |Comparison Data
 * |        |          |The 12 bits data is used to compare with conversion result of specified sample module
 * |        |          |User can use it to monitor the external analog input pin voltage transition without imposing a load on software.
 * @var EADC_T::CMP1
 * Offset: 0xE4  ADC Result Compare Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ADCMPEN   |ADC Result Compare Enable Bit
 * |        |          |0 = Compare Disabled.
 * |        |          |1 = Compare Enabled.
 * |        |          |Set this bit to 1 to enable compare CMPDAT (EADC_CMPn[27:16], n=0~3) with specified sample module conversion result when converted data is loaded into EADC_DAT register.
 * |[1]     |ADCMPIE   |ADC Result Compare Interrupt Enable Bit
 * |        |          |0 = Compare function interrupt Disabled.
 * |        |          |1 = Compare function interrupt Enabled.
 * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND (EADC_CMPn[2], n=0~3) and CMPMCNT (EADC_CMPn[11:8], n=0~3), ADCMPFn (EADC_STATUS2[7:4], n=0~3) will be asserted, in the meanwhile, if ADCMPIE is set to 1, a compare interrupt request is generated.
 * |[2]     |CMPCOND   |Compare Condition
 * |        |          |0= Set the compare condition as that when a 12-bit ADC conversion result is less than the 12-bit CMPDAT (EADC_CMPn [27:16]), the internal match counter will increase one.
 * |        |          |1= Set the compare condition as that when a 12-bit ADC conversion result is greater or equal to the 12-bit CMPDAT (EADC_CMPn [27:16]), the internal match counter will increase one.
 * |        |          |Note: When the internal counter reaches the value to (CMPMCNT (EADC_CMPn[11:8], n=0~3) +1), the CMPF bit will be set.
 * |[7:3]   |CMPSPL    |Compare Sample Module Selection
 * |        |          |00000 = Sample Module 0 conversion result EADC_DAT0 is selected to be compared.
 * |        |          |00001 = Sample Module 1 conversion result EADC_DAT1 is selected to be compared.
 * |        |          |00010 = Sample Module 2 conversion result EADC_DAT2 is selected to be compared.
 * |        |          |00011 = Sample Module 3 conversion result EADC_DAT3 is selected to be compared.
 * |        |          |00100 = Sample Module 4 conversion result EADC_DAT4 is selected to be compared.
 * |        |          |00101 = Sample Module 5 conversion result EADC_DAT5 is selected to be compared.
 * |        |          |00110 = Sample Module 6 conversion result EADC_DAT6 is selected to be compared.
 * |        |          |00111 = Sample Module 7 conversion result EADC_DAT7 is selected to be compared.
 * |        |          |01000 = Sample Module 8 conversion result EADC_DAT8 is selected to be compared.
 * |        |          |01001 = Sample Module 9 conversion result EADC_DAT9 is selected to be compared.
 * |        |          |01010 = Sample Module 10 conversion result EADC_DAT10 is selected to be compared.
 * |        |          |01011 = Sample Module 11 conversion result EADC_DAT11 is selected to be compared.
 * |        |          |01100 = Sample Module 12 conversion result EADC_DAT12 is selected to be compared.
 * |        |          |10000 = Sample Module 16 conversion result EADC_DAT16 is selected to be compared.
 * |        |          |10001 = Sample Module 17 conversion result EADC_DAT17 is selected to be compared.
 * |        |          |other = Reserved.
 * |[11:8]  |CMPMCNT   |Compare Match Count
 * |        |          |When the specified ADC sample module analog conversion result matches the compare condition defined by CMPCOND (EADC_CMPn[2], n=0~3), the internal match counter will increase 1
 * |        |          |If the compare result does not meet the compare condition, the internal compare match counter will reset to 0
 * |        |          |When the internal counter reaches the value to (CMPMCNT +1), the ADCMPFn (EADC_STATUS2[7:4], n=0~3) will be set.
 * |[15]    |CMPWEN    |Compare Window Mode Enable Bit
 * |        |          |0 = ADCMPF0 (EADC_STATUS2[4]) will be set when EADC_CMP0 compared condition matched
 * |        |          |ADCMPF2 (EADC_STATUS2[6]) will be set when EADC_CMP2 compared condition matched
 * |        |          |1 = ADCMPF0 (EADC_STATUS2[4]) will be set when both EADC_CMP0 and EADC_CMP1 compared condition matched
 * |        |          |ADCMPF2 (EADC_STATUS2[6]) will be set when both EADC_CMP2 and EADC_CMP3 compared condition matched.
 * |        |          |Note: This bit is only present in EADC_CMP0 and EADC_CMP2 register.
 * |[27:16] |CMPDAT    |Comparison Data
 * |        |          |The 12 bits data is used to compare with conversion result of specified sample module
 * |        |          |User can use it to monitor the external analog input pin voltage transition without imposing a load on software.
 * @var EADC_T::CMP2
 * Offset: 0xE8  ADC Result Compare Register 2
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ADCMPEN   |ADC Result Compare Enable Bit
 * |        |          |0 = Compare Disabled.
 * |        |          |1 = Compare Enabled.
 * |        |          |Set this bit to 1 to enable compare CMPDAT (EADC_CMPn[27:16], n=0~3) with specified sample module conversion result when converted data is loaded into EADC_DAT register.
 * |[1]     |ADCMPIE   |ADC Result Compare Interrupt Enable Bit
 * |        |          |0 = Compare function interrupt Disabled.
 * |        |          |1 = Compare function interrupt Enabled.
 * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND (EADC_CMPn[2], n=0~3) and CMPMCNT (EADC_CMPn[11:8], n=0~3), ADCMPFn (EADC_STATUS2[7:4], n=0~3) will be asserted, in the meanwhile, if ADCMPIE is set to 1, a compare interrupt request is generated.
 * |[2]     |CMPCOND   |Compare Condition
 * |        |          |0= Set the compare condition as that when a 12-bit ADC conversion result is less than the 12-bit CMPDAT (EADC_CMPn [27:16]), the internal match counter will increase one.
 * |        |          |1= Set the compare condition as that when a 12-bit ADC conversion result is greater or equal to the 12-bit CMPDAT (EADC_CMPn [27:16]), the internal match counter will increase one.
 * |        |          |Note: When the internal counter reaches the value to (CMPMCNT (EADC_CMPn[11:8], n=0~3) +1), the CMPF bit will be set.
 * |[7:3]   |CMPSPL    |Compare Sample Module Selection
 * |        |          |00000 = Sample Module 0 conversion result EADC_DAT0 is selected to be compared.
 * |        |          |00001 = Sample Module 1 conversion result EADC_DAT1 is selected to be compared.
 * |        |          |00010 = Sample Module 2 conversion result EADC_DAT2 is selected to be compared.
 * |        |          |00011 = Sample Module 3 conversion result EADC_DAT3 is selected to be compared.
 * |        |          |00100 = Sample Module 4 conversion result EADC_DAT4 is selected to be compared.
 * |        |          |00101 = Sample Module 5 conversion result EADC_DAT5 is selected to be compared.
 * |        |          |00110 = Sample Module 6 conversion result EADC_DAT6 is selected to be compared.
 * |        |          |00111 = Sample Module 7 conversion result EADC_DAT7 is selected to be compared.
 * |        |          |01000 = Sample Module 8 conversion result EADC_DAT8 is selected to be compared.
 * |        |          |01001 = Sample Module 9 conversion result EADC_DAT9 is selected to be compared.
 * |        |          |01010 = Sample Module 10 conversion result EADC_DAT10 is selected to be compared.
 * |        |          |01011 = Sample Module 11 conversion result EADC_DAT11 is selected to be compared.
 * |        |          |01100 = Sample Module 12 conversion result EADC_DAT12 is selected to be compared.
 * |        |          |10000 = Sample Module 16 conversion result EADC_DAT16 is selected to be compared.
 * |        |          |10001 = Sample Module 17 conversion result EADC_DAT17 is selected to be compared.
 * |        |          |other = Reserved.
 * |[11:8]  |CMPMCNT   |Compare Match Count
 * |        |          |When the specified ADC sample module analog conversion result matches the compare condition defined by CMPCOND (EADC_CMPn[2], n=0~3), the internal match counter will increase 1
 * |        |          |If the compare result does not meet the compare condition, the internal compare match counter will reset to 0
 * |        |          |When the internal counter reaches the value to (CMPMCNT +1), the ADCMPFn (EADC_STATUS2[7:4], n=0~3) will be set.
 * |[15]    |CMPWEN    |Compare Window Mode Enable Bit
 * |        |          |0 = ADCMPF0 (EADC_STATUS2[4]) will be set when EADC_CMP0 compared condition matched
 * |        |          |ADCMPF2 (EADC_STATUS2[6]) will be set when EADC_CMP2 compared condition matched
 * |        |          |1 = ADCMPF0 (EADC_STATUS2[4]) will be set when both EADC_CMP0 and EADC_CMP1 compared condition matched
 * |        |          |ADCMPF2 (EADC_STATUS2[6]) will be set when both EADC_CMP2 and EADC_CMP3 compared condition matched.
 * |        |          |Note: This bit is only present in EADC_CMP0 and EADC_CMP2 register.
 * |[27:16] |CMPDAT    |Comparison Data
 * |        |          |The 12 bits data is used to compare with conversion result of specified sample module
 * |        |          |User can use it to monitor the external analog input pin voltage transition without imposing a load on software.
 * @var EADC_T::CMP3
 * Offset: 0xEC  ADC Result Compare Register 3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ADCMPEN   |ADC Result Compare Enable Bit
 * |        |          |0 = Compare Disabled.
 * |        |          |1 = Compare Enabled.
 * |        |          |Set this bit to 1 to enable compare CMPDAT (EADC_CMPn[27:16], n=0~3) with specified sample module conversion result when converted data is loaded into EADC_DAT register.
 * |[1]     |ADCMPIE   |ADC Result Compare Interrupt Enable Bit
 * |        |          |0 = Compare function interrupt Disabled.
 * |        |          |1 = Compare function interrupt Enabled.
 * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND (EADC_CMPn[2], n=0~3) and CMPMCNT (EADC_CMPn[11:8], n=0~3), ADCMPFn (EADC_STATUS2[7:4], n=0~3) will be asserted, in the meanwhile, if ADCMPIE is set to 1, a compare interrupt request is generated.
 * |[2]     |CMPCOND   |Compare Condition
 * |        |          |0= Set the compare condition as that when a 12-bit ADC conversion result is less than the 12-bit CMPDAT (EADC_CMPn [27:16]), the internal match counter will increase one.
 * |        |          |1= Set the compare condition as that when a 12-bit ADC conversion result is greater or equal to the 12-bit CMPDAT (EADC_CMPn [27:16]), the internal match counter will increase one.
 * |        |          |Note: When the internal counter reaches the value to (CMPMCNT (EADC_CMPn[11:8], n=0~3) +1), the CMPF bit will be set.
 * |[7:3]   |CMPSPL    |Compare Sample Module Selection
 * |        |          |00000 = Sample Module 0 conversion result EADC_DAT0 is selected to be compared.
 * |        |          |00001 = Sample Module 1 conversion result EADC_DAT1 is selected to be compared.
 * |        |          |00010 = Sample Module 2 conversion result EADC_DAT2 is selected to be compared.
 * |        |          |00011 = Sample Module 3 conversion result EADC_DAT3 is selected to be compared.
 * |        |          |00100 = Sample Module 4 conversion result EADC_DAT4 is selected to be compared.
 * |        |          |00101 = Sample Module 5 conversion result EADC_DAT5 is selected to be compared.
 * |        |          |00110 = Sample Module 6 conversion result EADC_DAT6 is selected to be compared.
 * |        |          |00111 = Sample Module 7 conversion result EADC_DAT7 is selected to be compared.
 * |        |          |01000 = Sample Module 8 conversion result EADC_DAT8 is selected to be compared.
 * |        |          |01001 = Sample Module 9 conversion result EADC_DAT9 is selected to be compared.
 * |        |          |01010 = Sample Module 10 conversion result EADC_DAT10 is selected to be compared.
 * |        |          |01011 = Sample Module 11 conversion result EADC_DAT11 is selected to be compared.
 * |        |          |01100 = Sample Module 12 conversion result EADC_DAT12 is selected to be compared.
 * |        |          |10000 = Sample Module 16 conversion result EADC_DAT16 is selected to be compared.
 * |        |          |10001 = Sample Module 17 conversion result EADC_DAT17 is selected to be compared.
 * |        |          |other = Reserved.
 * |[11:8]  |CMPMCNT   |Compare Match Count
 * |        |          |When the specified ADC sample module analog conversion result matches the compare condition defined by CMPCOND (EADC_CMPn[2], n=0~3), the internal match counter will increase 1
 * |        |          |If the compare result does not meet the compare condition, the internal compare match counter will reset to 0
 * |        |          |When the internal counter reaches the value to (CMPMCNT +1), the ADCMPFn (EADC_STATUS2[7:4], n=0~3) will be set.
 * |[15]    |CMPWEN    |Compare Window Mode Enable Bit
 * |        |          |0 = ADCMPF0 (EADC_STATUS2[4]) will be set when EADC_CMP0 compared condition matched
 * |        |          |ADCMPF2 (EADC_STATUS2[6]) will be set when EADC_CMP2 compared condition matched
 * |        |          |1 = ADCMPF0 (EADC_STATUS2[4]) will be set when both EADC_CMP0 and EADC_CMP1 compared condition matched
 * |        |          |ADCMPF2 (EADC_STATUS2[6]) will be set when both EADC_CMP2 and EADC_CMP3 compared condition matched.
 * |        |          |Note: This bit is only present in EADC_CMP0 and EADC_CMP2 register.
 * |[27:16] |CMPDAT    |Comparison Data
 * |        |          |The 12 bits data is used to compare with conversion result of specified sample module
 * |        |          |User can use it to monitor the external analog input pin voltage transition without imposing a load on software.
 * @var EADC_T::STATUS0
 * Offset: 0xF0  ADC Status Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[12:0]  |VALID     |EADC_DAT0~12 Data Valid Flag
 * |        |          |It is a mirror of VALID bit in sample module ADC result data register EADC_DATn. (n=0~12).
 * |[28:16] |OV        |EADC_DAT0~12 Overrun Flag
 * |        |          |It is a mirror to OV bit in sample module ADC result data register EADC_DATn. (n=0~12).
 * @var EADC_T::STATUS1
 * Offset: 0xF4  ADC Status Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |VALID     |EADC_DAT16~17 Data Valid Flag
 * |        |          |It is a mirror of VALID bit in sample module ADC result data register EADC_DATn. (n=16, 17).
 * |[17:16] |OV        |EADC_DAT16~17 Overrun Flag
 * |        |          |It is a mirror to OV bit in sample module ADC result data register EADC_DATn. (n=16, 17).
 * @var EADC_T::STATUS2
 * Offset: 0xF8  ADC Status Register 2
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ADIF0     |ADC ADINT0 Interrupt Flag
 * |        |          |0 = No ADINT0 interrupt pulse received.
 * |        |          |1 = ADINT0 interrupt pulse has been received.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2:This bit indicates whether an ADC conversion of specific sample module has been completed
 * |[1]     |ADIF1     |ADC ADINT1 Interrupt Flag
 * |        |          |0 = No ADINT1 interrupt pulse received.
 * |        |          |1 = ADINT1 interrupt pulse has been received.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2:This bit indicates whether an ADC conversion of specific sample module has been completed
 * |[2]     |ADIF2     |ADC ADINT2 Interrupt Flag
 * |        |          |0 = No ADINT2 interrupt pulse received.
 * |        |          |1 = ADINT2 interrupt pulse has been received.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2:This bit indicates whether an ADC conversion of specific sample module has been completed
 * |[3]     |ADIF3     |ADC ADINT3 Interrupt Flag
 * |        |          |0 = No ADINT3 interrupt pulse received.
 * |        |          |1 = ADINT3 interrupt pulse has been received.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2:This bit indicates whether an ADC conversion of specific sample module has been completed
 * |[4]     |ADCMPF0   |ADC Compare 0 Flag
 * |        |          |When the specific sample module ADC conversion result meets setting condition in EADC_CMP0 then this bit is set to 1.
 * |        |          |0 = Conversion result in EADC_DAT does not meet EADC_CMP0 register setting.
 * |        |          |1 = Conversion result in EADC_DAT meets EADC_CMP0 register setting.
 * |        |          |Note: This bit is cleared by writing 1 to it.
 * |[5]     |ADCMPF1   |ADC Compare 1 Flag
 * |        |          |When the specific sample module ADC conversion result meets setting condition in EADC_CMP1 then this bit is set to 1.
 * |        |          |0 = Conversion result in EADC_DAT does not meet EADC_CMP1 register setting.
 * |        |          |1 = Conversion result in EADC_DAT meets EADC_CMP1 register setting.
 * |        |          |Note: This bit is cleared by writing 1 to it.
 * |[6]     |ADCMPF2   |ADC Compare 2 Flag
 * |        |          |When the specific sample module ADC conversion result meets setting condition in EADC_CMP2 then this bit is set to 1.
 * |        |          |0 = Conversion result in EADC_DAT does not meet EADC_CMP2 register setting.
 * |        |          |1 = Conversion result in EADC_DAT meets EADC_CMP2 register setting.
 * |        |          |Note: This bit is cleared by writing 1 to it.
 * |[7]     |ADCMPF3   |ADC Compare 3 Flag
 * |        |          |When the specific sample module ADC conversion result meets setting condition in EADC_CMP3 then this bit is set to 1.
 * |        |          |0 = Conversion result in EADC_DAT does not meet EADC_CMP3 register setting.
 * |        |          |1 = Conversion result in EADC_DAT meets EADC_CMP3 register setting.
 * |        |          |Note: This bit is cleared by writing 1 to it.
 * |[8]     |ADOVIF0   |ADC ADINT0 Interrupt Flag Overrun
 * |        |          |0 = ADINT0 interrupt flag is not overwritten to 1.
 * |        |          |1 = ADINT0 interrupt flag is overwritten to 1.
 * |        |          |Note: This bit is cleared by writing 1 to it.
 * |[9]     |ADOVIF1   |ADC ADINT1 Interrupt Flag Overrun
 * |        |          |0 = ADINT1 interrupt flag is not overwritten to 1.
 * |        |          |1 = ADINT1 interrupt flag is overwritten to 1.
 * |        |          |Note: This bit is cleared by writing 1 to it.
 * |[10]    |ADOVIF2   |ADC ADINT2 Interrupt Flag Overrun
 * |        |          |0 = ADINT2 interrupt flag is not overwritten to 1.
 * |        |          |1 = ADINT2 interrupt flag is s overwritten to 1.
 * |        |          |Note: This bit is cleared by writing 1 to it.
 * |[11]    |ADOVIF3   |ADC ADINT3 Interrupt Flag Overrun
 * |        |          |0 = ADINT3 interrupt flag is not overwritten to 1.
 * |        |          |1 = ADINT3 interrupt flag is overwritten to 1.
 * |        |          |Note: This bit is cleared by writing 1 to it.
 * |[12]    |ADCMPO0   |ADC Compare 0 Output Status
 * |        |          |The 12 bits compare0 data CMPDAT0 (EADC_CMP0[27:16]) is used to compare with conversion result of specified sample module
 * |        |          |User can use it to monitor the external analog input pin voltage status.
 * |        |          |0 = Conversion result in EADC_DAT less than CMPDAT0 setting.
 * |        |          |1 = Conversion result in EADC_DAT great than or equal CMPDAT0 setting.
 * |[13]    |ADCMPO1   |ADC Compare 1 Output Status
 * |        |          |The 12 bits compare1 data CMPDAT1 (EADC_CMP1[27:16]) is used to compare with conversion result of specified sample module
 * |        |          |User can use it to monitor the external analog input pin voltage status.
 * |        |          |0 = Conversion result in EADC_DAT less than CMPDAT1 setting.
 * |        |          |1 = Conversion result in EADC_DAT great than or equal CMPDAT1 setting.
 * |[14]    |ADCMPO2   |ADC Compare 2 Output Status
 * |        |          |The 12 bits compare2 data CMPDAT2 (EADC_CMP2[27:16]) is used to compare with conversion result of specified sample module
 * |        |          |User can use it to monitor the external analog input pin voltage status.
 * |        |          |0 = Conversion result in EADC_DAT less than CMPDAT2 setting.
 * |        |          |1 = Conversion result in EADC_DAT great than or equal CMPDAT2 setting.
 * |[15]    |ADCMPO3   |ADC Compare 3 Output Status
 * |        |          |The 12 bits compare3 data CMPDAT3 (EADC_CMP3[27:16]) is used to compare with conversion result of specified sample module
 * |        |          |User can use it to monitor the external analog input pin voltage status.
 * |        |          |0 = Conversion result in EADC_DAT less than CMPDAT3 setting.
 * |        |          |1 = Conversion result in EADC_DAT great than or equal CMPDAT3 setting.
 * |[20:16] |CHANNEL   |Current Conversion Channel
 * |        |          |This filed reflects ADC current conversion channel when BUSY=1.
 * |        |          |It is read only.
 * |        |          |00H = EADC0_CH0.
 * |        |          |01H = EADC0_CH1.
 * |        |          |02H = EADC0_CH2.
 * |        |          |03H = EADC0_CH3.
 * |        |          |04H = EADC0_CH4.
 * |        |          |05H = EADC0_CH5.
 * |        |          |06H = EADC0_CH6.
 * |        |          |07H = EADC0_CH7.
 * |        |          |08H = EADC0_CH8.
 * |        |          |09H = EADC0_CH9.
 * |        |          |0AH = EADC0_CH10.
 * |        |          |0BH = EADC0_CH11.
 * |        |          |0CH = EADC0_CH12.
 * |        |          |10H = VBG.
 * |        |          |11H = VTEMP.
 * |[23]    |BUSY      |Busy/Idle
 * |        |          |0 = EADC is in idle state.
 * |        |          |1 = EADC is busy at conversion.
 * |        |          |Note: This bit is read only.
 * |[24]    |ADOVIF    |All ADC Interrupt Flag Overrun Bits Check
 * |        |          |n=0~3.
 * |        |          |0 = None of ADINT interrupt flag ADOVIFn (EADC_STATUS2[11:8]) is overwritten to 1.
 * |        |          |1 = Any one of ADINT interrupt flag ADOVIFn (EADC_STATUS2[11:8]) is overwritten to 1.
 * |        |          |Note: This bit will keep 1 when any ADOVIFn Flag is equal to 1.
 * |[25]    |STOVF     |for All ADC Sample Module Start of Conversion Overrun Flags Check
 * |        |          |n=0~12, 16, 17.
 * |        |          |0 = None of sample module event overrun flag SPOVFn (EADC_OVSTS[n]) is set to 1.
 * |        |          |1 = Any one of sample module event overrun flag SPOVFn (EADC_OVSTS[n]) is set to 1.
 * |        |          |Note: This bit will keep 1 when any SPOVFn Flag is equal to 1. 
 * |[26]    |AVALID    |for All Sample Module ADC Result Data Register EADC_DAT Data Valid Flag Check
 * |        |          |n=0~12, 16, 17.
 * |        |          |0 = None of sample module data register valid flag VALIDn (EADC_DATn[17]) is set to 1.
 * |        |          |1 = Any one of sample module data register valid flag VALIDn (EADC_DATn[17]) is set to 1.
 * |        |          |Note: This bit will keep 1 when any VALIDn Flag is equal to 1.
 * |[27]    |AOV       |for All Sample Module ADC Result Data Register Overrun Flags Check
 * |        |          |n=0~12, 16, 17.
 * |        |          |0 = None of sample module data register overrun flag OVn (EADC_DATn[16]) is set to 1.
 * |        |          |1 = Any one of sample module data register overrun flag OVn (EADC_DATn[16]) is set to 1.
 * |        |          |Note: This bit will keep 1 when any OVn Flag is equal to 1.
 * @var EADC_T::STATUS3
 * Offset: 0xFC  ADC Status Register 3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[4:0]   |CURSPL    |ADC Current Sample Module
 * |        |          |This register show the current ADC is controlled by which sample module control logic modules.
 * |        |          |If the ADC is Idle, this bit filed will set to 0x1F.
 * |        |          |This is a read only register.
 * @var EADC_T::DDAT0
 * Offset: 0x100  ADC Double Data Register 0 for Sample Module 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RESULT    |ADC Conversion Results
 * |        |          |This field contains 12 bits conversion results.
 * |        |          |When the DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT [11:0] and zero will be filled in RESULT [15:12].
 * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT [11:0] and signed bits to will be filled in RESULT [15:12].
 * |[16]    |OV        |Overrun Flag
 * |        |          |0 = Data in RESULT (EADC_DATn[15:0], n=0~3) is recent conversion result.
 * |        |          |1 = Data in RESULT (EADC_DATn[15:0], n=0~3) is overwrite.
 * |        |          |If converted data in RESULT[15:0] has not been read before new conversion result is loaded to this register, OV is set to 1
 * |        |          |It is cleared by hardware after EADC_DDAT register is read.
 * |[17]    |VALID     |Valid Flag
 * |        |          |0 = Double data in RESULT (EADC_DDATn[15:0]) is not valid.
 * |        |          |1 = Double data in RESULT (EADC_DDATn[15:0]) is valid.
 * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DDATn register is read
 * |        |          |(n=0~3).
 * @var EADC_T::DDAT1
 * Offset: 0x104  ADC Double Data Register 1 for Sample Module 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RESULT    |ADC Conversion Results
 * |        |          |This field contains 12 bits conversion results.
 * |        |          |When the DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT [11:0] and zero will be filled in RESULT [15:12].
 * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT [11:0] and signed bits to will be filled in RESULT [15:12].
 * |[16]    |OV        |Overrun Flag
 * |        |          |0 = Data in RESULT (EADC_DATn[15:0], n=0~3) is recent conversion result.
 * |        |          |1 = Data in RESULT (EADC_DATn[15:0], n=0~3) is overwrite.
 * |        |          |If converted data in RESULT[15:0] has not been read before new conversion result is loaded to this register, OV is set to 1
 * |        |          |It is cleared by hardware after EADC_DDAT register is read.
 * |[17]    |VALID     |Valid Flag
 * |        |          |0 = Double data in RESULT (EADC_DDATn[15:0]) is not valid.
 * |        |          |1 = Double data in RESULT (EADC_DDATn[15:0]) is valid.
 * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DDATn register is read
 * |        |          |(n=0~3).
 * @var EADC_T::DDAT2
 * Offset: 0x108  ADC Double Data Register 2 for Sample Module 2
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RESULT    |ADC Conversion Results
 * |        |          |This field contains 12 bits conversion results.
 * |        |          |When the DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT [11:0] and zero will be filled in RESULT [15:12].
 * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT [11:0] and signed bits to will be filled in RESULT [15:12].
 * |[16]    |OV        |Overrun Flag
 * |        |          |0 = Data in RESULT (EADC_DATn[15:0], n=0~3) is recent conversion result.
 * |        |          |1 = Data in RESULT (EADC_DATn[15:0], n=0~3) is overwrite.
 * |        |          |If converted data in RESULT[15:0] has not been read before new conversion result is loaded to this register, OV is set to 1
 * |        |          |It is cleared by hardware after EADC_DDAT register is read.
 * |[17]    |VALID     |Valid Flag
 * |        |          |0 = Double data in RESULT (EADC_DDATn[15:0]) is not valid.
 * |        |          |1 = Double data in RESULT (EADC_DDATn[15:0]) is valid.
 * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DDATn register is read
 * |        |          |(n=0~3).
 * @var EADC_T::DDAT3
 * Offset: 0x10C  ADC Double Data Register 3 for Sample Module 3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RESULT    |ADC Conversion Results
 * |        |          |This field contains 12 bits conversion results.
 * |        |          |When the DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT [11:0] and zero will be filled in RESULT [15:12].
 * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT [11:0] and signed bits to will be filled in RESULT [15:12].
 * |[16]    |OV        |Overrun Flag
 * |        |          |0 = Data in RESULT (EADC_DATn[15:0], n=0~3) is recent conversion result.
 * |        |          |1 = Data in RESULT (EADC_DATn[15:0], n=0~3) is overwrite.
 * |        |          |If converted data in RESULT[15:0] has not been read before new conversion result is loaded to this register, OV is set to 1
 * |        |          |It is cleared by hardware after EADC_DDAT register is read.
 * |[17]    |VALID     |Valid Flag
 * |        |          |0 = Double data in RESULT (EADC_DDATn[15:0]) is not valid.
 * |        |          |1 = Double data in RESULT (EADC_DDATn[15:0]) is valid.
 * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DDATn register is read
 * |        |          |(n=0~3).
 * @var EADC_T::PWRM
 * Offset: 0x110  ADC Power Management Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PWUPRDY   |ADC Power-up Sequence Completed and Ready for Conversion
 * |        |          |0 = ADC is not ready for conversion may be in power down state or in the progress of power up.
 * |        |          |1 = ADC is ready for conversion. 
 * |[1]     |PWDCALEN  |Power Up Calibration Function Enable Control
 * |        |          |0 = Disable the function of calibration at power up.
 * |        |          |1 = Enable the function of calibration at power up.
 * |        |          |Note: This bit work together with CALSEL (ADCCALCTL[3]), see the following
 * |        |          |{PWDCALEN,CALFBSEL} Description:
 * |        |          |PWDCALEN is 0 and CALFBSEL is 0: No need to calibrate.
 * |        |          |PWDCALEN is 0 and CALFBSEL is 1: No need to calibrate.
 * |        |          |PWDCALEN is 1 and CALFBSEL is 0: Load calibration word when power up.
 * |        |          |PWDCALEN is 1 and CALFBSEL is 1: Calibrate when power up.
 * |[3:2]   |PWDMOD    |ADC Power-down Mode
 * |        |          |Set this bit fields to select ADC power down mode when system power-down.
 * |        |          |00 = ADC Deep power down mode.
 * |        |          |01 = ADC Power down.
 * |        |          |10 = ADC Standby mode.
 * |        |          |11 = ADC Deep power down mode.
 * |        |          |Note: Different PWDMOD has different power down/up sequence, in order to avoid ADC powering up with wrong sequence; user must keep PWMOD consistent each time in power down and power up
 * |[4]     |PWAWARE   |Power Aware Function Enable Bit
 * |        |          |0 = ADC clock always Enabled.
 * |        |          |1 = When ADCEN (EADC_CTL[0]) is set to 0, ADC clock will automatically be gated to save power. 
 * |[19:8]  |LDOSTB    |ADC Internal LDO Start-up Time
 * |        |          |Set this bit fields to control LDO start-up time
 * |        |          |The minimum required LDO start-up time is 20us
 * |        |          |LDO start-up time = (1/ADC_CLK) x LDOSTB.
 * @var EADC_T::CALCTL
 * Offset: 0x114  ADC Calibration Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CALEN     |Calibration Function Enable Control
 * |        |          |0 = Disable the calibration function block.
 * |        |          |1 = Enabled the calibration function block.
 * |[1]     |CALSTART  |Calibration Functional Block Start
 * |        |          |0 = Stops calibration functional block.
 * |        |          |1 = Starts calibration functional block.
 * |        |          |Note: This bit is set by SW and clear by HW; don't write 1 to this bit while CALEN = 0.
 * |[2]     |CALDONE   |Calibrate Functional Block Complete
 * |        |          |0 = Not yet.
 * |        |          |1 = Selected functional block complete.
 * |[3]     |CALSEL    |Select Calibration Functional Block
 * |        |          |0 = Load calibration functional block.
 * |        |          |1 = Calibration functional block.
 * @var EADC_T::CALDWRD
 * Offset: 0x118  ADC Calibration Load Word Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[6:0]   |CALWORD   |Calibration Word Bits
 * |        |          |Write to this register with the previous calibration word before load calibration action.
 * |        |          |Read this register after calibration done.
 * |        |          |Note: The calibration block contains two parts ...CALIBRATION... and ...LOAD CALIBRATIONu201D; if the calibration block configure as ...CALIBRATION...; then this register represent the result of calibration when calibration is completed; if configure as ...LOAD CALIBRATIONu201D ; configure this register before loading calibration action, after loading calibration complete, the loaded calibration word will apply to the ADC; while in loading calibration function the loaded value will not be equal to the original CALWORD until calibration is done.
 * @var EADC_T::TEST
 * Offset: 0x200  ADC Test Mode Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var EADC_T::VERSION
 * Offset: 0xFFC  ADC RTL Design Version Number
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 */
    __I  uint32_t DAT0;                  /*!< [0x0000] ADC Data Register 0 for Sample Module 0                          */
    __I  uint32_t DAT1;                  /*!< [0x0004] ADC Data Register 1 for Sample Module 1                          */
    __I  uint32_t DAT2;                  /*!< [0x0008] ADC Data Register 2 for Sample Module 2                          */
    __I  uint32_t DAT3;                  /*!< [0x000c] ADC Data Register 3 for Sample Module 3                          */
    __I  uint32_t DAT4;                  /*!< [0x0010] ADC Data Register 4 for Sample Module 4                          */
    __I  uint32_t DAT5;                  /*!< [0x0014] ADC Data Register 5 for Sample Module 5                          */
    __I  uint32_t DAT6;                  /*!< [0x0018] ADC Data Register 6 for Sample Module 6                          */
    __I  uint32_t DAT7;                  /*!< [0x001c] ADC Data Register 7 for Sample Module 7                          */
    __I  uint32_t DAT8;                  /*!< [0x0020] ADC Data Register 8 for Sample Module 8                          */
    __I  uint32_t DAT9;                  /*!< [0x0024] ADC Data Register 9 for Sample Module 9                          */
    __I  uint32_t DAT10;                 /*!< [0x0028] ADC Data Register 10 for Sample Module 10                        */
    __I  uint32_t DAT11;                 /*!< [0x002c] ADC Data Register 11 for Sample Module 11                        */
    __I  uint32_t DAT12;                 /*!< [0x0030] ADC Data Register 12 for Sample Module 12                        */
    __I  uint32_t RESERVE0[3];
    __I  uint32_t DAT16;                 /*!< [0x0040] ADC Data Register 16 for Sample Module 16                        */
    __I  uint32_t DAT17;                 /*!< [0x0044] ADC Data Register 17 for Sample Module 17                        */
    __I  uint32_t RESERVE1[1];
    __I  uint32_t CURDAT;                /*!< [0x004c] ADC PDMA Current Transfer Data Register                          */
    __IO uint32_t CTL;                   /*!< [0x0050] ADC Control Register                                             */
    __O  uint32_t SWTRG;                 /*!< [0x0054] ADC Sample Module Software Start Register                        */
    __IO uint32_t PENDSTS;               /*!< [0x0058] ADC Start of Conversion Pending Flag Register                    */
    __IO uint32_t OVSTS;                 /*!< [0x005c] ADC Sample Module Start of Conversion Overrun Flag Register      */
    __I  uint32_t RESERVE2[7];
    __IO uint32_t SELFTCTL;              /*!< [0x007c] ADC Self Test Control Register                                   */
    __IO uint32_t SCTL0;                 /*!< [0x0080] ADC Sample Module 0 Control Register                             */
    __IO uint32_t SCTL1;                 /*!< [0x0084] ADC Sample Module 1 Control Register                             */
    __IO uint32_t SCTL2;                 /*!< [0x0088] ADC Sample Module 2 Control Register                             */
    __IO uint32_t SCTL3;                 /*!< [0x008c] ADC Sample Module 3 Control Register                             */
    __IO uint32_t SCTL4;                 /*!< [0x0090] ADC Sample Module 4 Control Register                             */
    __IO uint32_t SCTL5;                 /*!< [0x0094] ADC Sample Module 5 Control Register                             */
    __IO uint32_t SCTL6;                 /*!< [0x0098] ADC Sample Module 6 Control Register                             */
    __IO uint32_t SCTL7;                 /*!< [0x009c] ADC Sample Module 7 Control Register                             */
    __IO uint32_t SCTL8;                 /*!< [0x00a0] ADC Sample Module 8 Control Register                             */
    __IO uint32_t SCTL9;                 /*!< [0x00a4] ADC Sample Module 9 Control Register                             */
    __IO uint32_t SCTL10;                /*!< [0x00a8] ADC Sample Module 10 Control Register                            */
    __IO uint32_t SCTL11;                /*!< [0x00ac] ADC Sample Module 11 Control Register                            */
    __IO uint32_t SCTL12;                /*!< [0x00b0] ADC Sample Module 12 Control Register                            */
    __I  uint32_t RESERVE3[3];
    __IO uint32_t SCTL16;                /*!< [0x00c0] ADC Sample Module 16 Control Register                            */
    __IO uint32_t SCTL17;                /*!< [0x00c4] ADC Sample Module 17 Control Register                            */
    __I  uint32_t RESERVE4[2];
    __IO uint32_t INTSRC0;               /*!< [0x00d0] ADC interrupt 0 Source Enable Control Register.                  */
    __IO uint32_t INTSRC1;               /*!< [0x00d4] ADC interrupt 1 Source Enable Control Register.                  */
    __IO uint32_t INTSRC2;               /*!< [0x00d8] ADC interrupt 2 Source Enable Control Register.                  */
    __IO uint32_t INTSRC3;               /*!< [0x00dc] ADC interrupt 3 Source Enable Control Register.                  */
    __IO uint32_t CMP0;                  /*!< [0x00e0] ADC Result Compare Register 0                                    */
    __IO uint32_t CMP1;                  /*!< [0x00e4] ADC Result Compare Register 1                                    */
    __IO uint32_t CMP2;                  /*!< [0x00e8] ADC Result Compare Register 2                                    */
    __IO uint32_t CMP3;                  /*!< [0x00ec] ADC Result Compare Register 3                                    */
    __I  uint32_t STATUS0;               /*!< [0x00f0] ADC Status Register 0                                            */
    __I  uint32_t STATUS1;               /*!< [0x00f4] ADC Status Register 1                                            */
    __IO uint32_t STATUS2;               /*!< [0x00f8] ADC Status Register 2                                            */
    __I  uint32_t STATUS3;               /*!< [0x00fc] ADC Status Register 3                                            */
    __I  uint32_t DDAT0;                 /*!< [0x0100] ADC Double Data Register 0 for Sample Module 0                   */
    __I  uint32_t DDAT1;                 /*!< [0x0104] ADC Double Data Register 1 for Sample Module 1                   */
    __I  uint32_t DDAT2;                 /*!< [0x0108] ADC Double Data Register 2 for Sample Module 2                   */
    __I  uint32_t DDAT3;                 /*!< [0x010c] ADC Double Data Register 3 for Sample Module 3                   */
    __IO uint32_t PWRM;                  /*!< [0x0110] ADC Power Management Register                                    */
    __IO uint32_t CALCTL;                /*!< [0x0114] ADC Calibration Control Register                                 */
    __IO uint32_t CALDWRD;               /*!< [0x0118] ADC Calibration Load Word Register                               */
    __I  uint32_t RESERVE5[57];
    __IO uint32_t TEST;                  /*!< [0x0200] ADC Test Mode Control Register                                   */
    __I  uint32_t RESERVE6[894];
    __IO uint32_t VERSION;               /*!< [0x0ffc] ADC RTL Design Version Number                                    */

} EADC_T;

/**
    @addtogroup EADC_CONST EADC Bit Field Definition
    Constant Definitions for EADC Controller
@{ */

#define EADC_DAT0_RESULT_Pos             (0)                                               /*!< EADC_T::DAT0: RESULT Position          */
#define EADC_DAT0_RESULT_Msk             (0xfffful << EADC_DAT0_RESULT_Pos)                /*!< EADC_T::DAT0: RESULT Mask              */

#define EADC_DAT0_OV_Pos                 (16)                                              /*!< EADC_T::DAT0: OV Position              */
#define EADC_DAT0_OV_Msk                 (0x1ul << EADC_DAT0_OV_Pos)                       /*!< EADC_T::DAT0: OV Mask                  */

#define EADC_DAT0_VALID_Pos              (17)                                              /*!< EADC_T::DAT0: VALID Position           */
#define EADC_DAT0_VALID_Msk              (0x1ul << EADC_DAT0_VALID_Pos)                    /*!< EADC_T::DAT0: VALID Mask               */

#define EADC_DAT1_RESULT_Pos             (0)                                               /*!< EADC_T::DAT1: RESULT Position          */
#define EADC_DAT1_RESULT_Msk             (0xfffful << EADC_DAT1_RESULT_Pos)                /*!< EADC_T::DAT1: RESULT Mask              */

#define EADC_DAT1_OV_Pos                 (16)                                              /*!< EADC_T::DAT1: OV Position              */
#define EADC_DAT1_OV_Msk                 (0x1ul << EADC_DAT1_OV_Pos)                       /*!< EADC_T::DAT1: OV Mask                  */

#define EADC_DAT1_VALID_Pos              (17)                                              /*!< EADC_T::DAT1: VALID Position           */
#define EADC_DAT1_VALID_Msk              (0x1ul << EADC_DAT1_VALID_Pos)                    /*!< EADC_T::DAT1: VALID Mask               */

#define EADC_DAT2_RESULT_Pos             (0)                                               /*!< EADC_T::DAT2: RESULT Position          */
#define EADC_DAT2_RESULT_Msk             (0xfffful << EADC_DAT2_RESULT_Pos)                /*!< EADC_T::DAT2: RESULT Mask              */

#define EADC_DAT2_OV_Pos                 (16)                                              /*!< EADC_T::DAT2: OV Position              */
#define EADC_DAT2_OV_Msk                 (0x1ul << EADC_DAT2_OV_Pos)                       /*!< EADC_T::DAT2: OV Mask                  */

#define EADC_DAT2_VALID_Pos              (17)                                              /*!< EADC_T::DAT2: VALID Position           */
#define EADC_DAT2_VALID_Msk              (0x1ul << EADC_DAT2_VALID_Pos)                    /*!< EADC_T::DAT2: VALID Mask               */

#define EADC_DAT3_RESULT_Pos             (0)                                               /*!< EADC_T::DAT3: RESULT Position          */
#define EADC_DAT3_RESULT_Msk             (0xfffful << EADC_DAT3_RESULT_Pos)                /*!< EADC_T::DAT3: RESULT Mask              */

#define EADC_DAT3_OV_Pos                 (16)                                              /*!< EADC_T::DAT3: OV Position              */
#define EADC_DAT3_OV_Msk                 (0x1ul << EADC_DAT3_OV_Pos)                       /*!< EADC_T::DAT3: OV Mask                  */

#define EADC_DAT3_VALID_Pos              (17)                                              /*!< EADC_T::DAT3: VALID Position           */
#define EADC_DAT3_VALID_Msk              (0x1ul << EADC_DAT3_VALID_Pos)                    /*!< EADC_T::DAT3: VALID Mask               */

#define EADC_DAT4_RESULT_Pos             (0)                                               /*!< EADC_T::DAT4: RESULT Position          */
#define EADC_DAT4_RESULT_Msk             (0xfffful << EADC_DAT4_RESULT_Pos)                /*!< EADC_T::DAT4: RESULT Mask              */

#define EADC_DAT4_OV_Pos                 (16)                                              /*!< EADC_T::DAT4: OV Position              */
#define EADC_DAT4_OV_Msk                 (0x1ul << EADC_DAT4_OV_Pos)                       /*!< EADC_T::DAT4: OV Mask                  */

#define EADC_DAT4_VALID_Pos              (17)                                              /*!< EADC_T::DAT4: VALID Position           */
#define EADC_DAT4_VALID_Msk              (0x1ul << EADC_DAT4_VALID_Pos)                    /*!< EADC_T::DAT4: VALID Mask               */

#define EADC_DAT5_RESULT_Pos             (0)                                               /*!< EADC_T::DAT5: RESULT Position          */
#define EADC_DAT5_RESULT_Msk             (0xfffful << EADC_DAT5_RESULT_Pos)                /*!< EADC_T::DAT5: RESULT Mask              */

#define EADC_DAT5_OV_Pos                 (16)                                              /*!< EADC_T::DAT5: OV Position              */
#define EADC_DAT5_OV_Msk                 (0x1ul << EADC_DAT5_OV_Pos)                       /*!< EADC_T::DAT5: OV Mask                  */

#define EADC_DAT5_VALID_Pos              (17)                                              /*!< EADC_T::DAT5: VALID Position           */
#define EADC_DAT5_VALID_Msk              (0x1ul << EADC_DAT5_VALID_Pos)                    /*!< EADC_T::DAT5: VALID Mask               */

#define EADC_DAT6_RESULT_Pos             (0)                                               /*!< EADC_T::DAT6: RESULT Position          */
#define EADC_DAT6_RESULT_Msk             (0xfffful << EADC_DAT6_RESULT_Pos)                /*!< EADC_T::DAT6: RESULT Mask              */

#define EADC_DAT6_OV_Pos                 (16)                                              /*!< EADC_T::DAT6: OV Position              */
#define EADC_DAT6_OV_Msk                 (0x1ul << EADC_DAT6_OV_Pos)                       /*!< EADC_T::DAT6: OV Mask                  */

#define EADC_DAT6_VALID_Pos              (17)                                              /*!< EADC_T::DAT6: VALID Position           */
#define EADC_DAT6_VALID_Msk              (0x1ul << EADC_DAT6_VALID_Pos)                    /*!< EADC_T::DAT6: VALID Mask               */

#define EADC_DAT7_RESULT_Pos             (0)                                               /*!< EADC_T::DAT7: RESULT Position          */
#define EADC_DAT7_RESULT_Msk             (0xfffful << EADC_DAT7_RESULT_Pos)                /*!< EADC_T::DAT7: RESULT Mask              */

#define EADC_DAT7_OV_Pos                 (16)                                              /*!< EADC_T::DAT7: OV Position              */
#define EADC_DAT7_OV_Msk                 (0x1ul << EADC_DAT7_OV_Pos)                       /*!< EADC_T::DAT7: OV Mask                  */

#define EADC_DAT7_VALID_Pos              (17)                                              /*!< EADC_T::DAT7: VALID Position           */
#define EADC_DAT7_VALID_Msk              (0x1ul << EADC_DAT7_VALID_Pos)                    /*!< EADC_T::DAT7: VALID Mask               */

#define EADC_DAT8_RESULT_Pos             (0)                                               /*!< EADC_T::DAT8: RESULT Position          */
#define EADC_DAT8_RESULT_Msk             (0xfffful << EADC_DAT8_RESULT_Pos)                /*!< EADC_T::DAT8: RESULT Mask              */

#define EADC_DAT8_OV_Pos                 (16)                                              /*!< EADC_T::DAT8: OV Position              */
#define EADC_DAT8_OV_Msk                 (0x1ul << EADC_DAT8_OV_Pos)                       /*!< EADC_T::DAT8: OV Mask                  */

#define EADC_DAT8_VALID_Pos              (17)                                              /*!< EADC_T::DAT8: VALID Position           */
#define EADC_DAT8_VALID_Msk              (0x1ul << EADC_DAT8_VALID_Pos)                    /*!< EADC_T::DAT8: VALID Mask               */

#define EADC_DAT9_RESULT_Pos             (0)                                               /*!< EADC_T::DAT9: RESULT Position          */
#define EADC_DAT9_RESULT_Msk             (0xfffful << EADC_DAT9_RESULT_Pos)                /*!< EADC_T::DAT9: RESULT Mask              */

#define EADC_DAT9_OV_Pos                 (16)                                              /*!< EADC_T::DAT9: OV Position              */
#define EADC_DAT9_OV_Msk                 (0x1ul << EADC_DAT9_OV_Pos)                       /*!< EADC_T::DAT9: OV Mask                  */

#define EADC_DAT9_VALID_Pos              (17)                                              /*!< EADC_T::DAT9: VALID Position           */
#define EADC_DAT9_VALID_Msk              (0x1ul << EADC_DAT9_VALID_Pos)                    /*!< EADC_T::DAT9: VALID Mask               */

#define EADC_DAT10_RESULT_Pos            (0)                                               /*!< EADC_T::DAT10: RESULT Position         */
#define EADC_DAT10_RESULT_Msk            (0xfffful << EADC_DAT10_RESULT_Pos)               /*!< EADC_T::DAT10: RESULT Mask             */

#define EADC_DAT10_OV_Pos                (16)                                              /*!< EADC_T::DAT10: OV Position             */
#define EADC_DAT10_OV_Msk                (0x1ul << EADC_DAT10_OV_Pos)                      /*!< EADC_T::DAT10: OV Mask                 */

#define EADC_DAT10_VALID_Pos             (17)                                              /*!< EADC_T::DAT10: VALID Position          */
#define EADC_DAT10_VALID_Msk             (0x1ul << EADC_DAT10_VALID_Pos)                   /*!< EADC_T::DAT10: VALID Mask              */

#define EADC_DAT11_RESULT_Pos            (0)                                               /*!< EADC_T::DAT11: RESULT Position         */
#define EADC_DAT11_RESULT_Msk            (0xfffful << EADC_DAT11_RESULT_Pos)               /*!< EADC_T::DAT11: RESULT Mask             */

#define EADC_DAT11_OV_Pos                (16)                                              /*!< EADC_T::DAT11: OV Position             */
#define EADC_DAT11_OV_Msk                (0x1ul << EADC_DAT11_OV_Pos)                      /*!< EADC_T::DAT11: OV Mask                 */

#define EADC_DAT11_VALID_Pos             (17)                                              /*!< EADC_T::DAT11: VALID Position          */
#define EADC_DAT11_VALID_Msk             (0x1ul << EADC_DAT11_VALID_Pos)                   /*!< EADC_T::DAT11: VALID Mask              */

#define EADC_DAT12_RESULT_Pos            (0)                                               /*!< EADC_T::DAT12: RESULT Position         */
#define EADC_DAT12_RESULT_Msk            (0xfffful << EADC_DAT12_RESULT_Pos)               /*!< EADC_T::DAT12: RESULT Mask             */

#define EADC_DAT12_OV_Pos                (16)                                              /*!< EADC_T::DAT12: OV Position             */
#define EADC_DAT12_OV_Msk                (0x1ul << EADC_DAT12_OV_Pos)                      /*!< EADC_T::DAT12: OV Mask                 */

#define EADC_DAT12_VALID_Pos             (17)                                              /*!< EADC_T::DAT12: VALID Position          */
#define EADC_DAT12_VALID_Msk             (0x1ul << EADC_DAT12_VALID_Pos)                   /*!< EADC_T::DAT12: VALID Mask              */

#define EADC_DAT16_RESULT_Pos            (0)                                               /*!< EADC_T::DAT16: RESULT Position         */
#define EADC_DAT16_RESULT_Msk            (0xfffful << EADC_DAT16_RESULT_Pos)               /*!< EADC_T::DAT16: RESULT Mask             */

#define EADC_DAT16_OV_Pos                (16)                                              /*!< EADC_T::DAT16: OV Position             */
#define EADC_DAT16_OV_Msk                (0x1ul << EADC_DAT16_OV_Pos)                      /*!< EADC_T::DAT16: OV Mask                 */

#define EADC_DAT16_VALID_Pos             (17)                                              /*!< EADC_T::DAT16: VALID Position          */
#define EADC_DAT16_VALID_Msk             (0x1ul << EADC_DAT16_VALID_Pos)                   /*!< EADC_T::DAT16: VALID Mask              */

#define EADC_DAT17_RESULT_Pos            (0)                                               /*!< EADC_T::DAT17: RESULT Position         */
#define EADC_DAT17_RESULT_Msk            (0xfffful << EADC_DAT17_RESULT_Pos)               /*!< EADC_T::DAT17: RESULT Mask             */

#define EADC_DAT17_OV_Pos                (16)                                              /*!< EADC_T::DAT17: OV Position             */
#define EADC_DAT17_OV_Msk                (0x1ul << EADC_DAT17_OV_Pos)                      /*!< EADC_T::DAT17: OV Mask                 */

#define EADC_DAT17_VALID_Pos             (17)                                              /*!< EADC_T::DAT17: VALID Position          */
#define EADC_DAT17_VALID_Msk             (0x1ul << EADC_DAT17_VALID_Pos)                   /*!< EADC_T::DAT17: VALID Mask              */

#define EADC_CURDAT_CURDAT_Pos           (0)                                               /*!< EADC_T::CURDAT: CURDAT Position        */
#define EADC_CURDAT_CURDAT_Msk           (0x3fffful << EADC_CURDAT_CURDAT_Pos)             /*!< EADC_T::CURDAT: CURDAT Mask            */

#define EADC_CTL_ADCEN_Pos               (0)                                               /*!< EADC_T::CTL: ADCEN Position            */
#define EADC_CTL_ADCEN_Msk               (0x1ul << EADC_CTL_ADCEN_Pos)                     /*!< EADC_T::CTL: ADCEN Mask                */

#define EADC_CTL_ADCRST_Pos              (1)                                               /*!< EADC_T::CTL: ADCRST Position           */
#define EADC_CTL_ADCRST_Msk              (0x1ul << EADC_CTL_ADCRST_Pos)                    /*!< EADC_T::CTL: ADCRST Mask               */

#define EADC_CTL_ADCIEN0_Pos             (2)                                               /*!< EADC_T::CTL: ADCIEN0 Position          */
#define EADC_CTL_ADCIEN0_Msk             (0x1ul << EADC_CTL_ADCIEN0_Pos)                   /*!< EADC_T::CTL: ADCIEN0 Mask              */

#define EADC_CTL_ADCIEN1_Pos             (3)                                               /*!< EADC_T::CTL: ADCIEN1 Position          */
#define EADC_CTL_ADCIEN1_Msk             (0x1ul << EADC_CTL_ADCIEN1_Pos)                   /*!< EADC_T::CTL: ADCIEN1 Mask              */

#define EADC_CTL_ADCIEN2_Pos             (4)                                               /*!< EADC_T::CTL: ADCIEN2 Position          */
#define EADC_CTL_ADCIEN2_Msk             (0x1ul << EADC_CTL_ADCIEN2_Pos)                   /*!< EADC_T::CTL: ADCIEN2 Mask              */

#define EADC_CTL_ADCIEN3_Pos             (5)                                               /*!< EADC_T::CTL: ADCIEN3 Position          */
#define EADC_CTL_ADCIEN3_Msk             (0x1ul << EADC_CTL_ADCIEN3_Pos)                   /*!< EADC_T::CTL: ADCIEN3 Mask              */

#define EADC_CTL_RESSEL_Pos              (6)                                               /*!< EADC_T::CTL: RESSEL Position           */
#define EADC_CTL_RESSEL_Msk              (0x3ul << EADC_CTL_RESSEL_Pos)                    /*!< EADC_T::CTL: RESSEL Mask               */

#define EADC_CTL_DIFFEN_Pos              (8)                                               /*!< EADC_T::CTL: DIFFEN Position           */
#define EADC_CTL_DIFFEN_Msk              (0x1ul << EADC_CTL_DIFFEN_Pos)                    /*!< EADC_T::CTL: DIFFEN Mask               */

#define EADC_CTL_DMOF_Pos                (9)                                               /*!< EADC_T::CTL: DMOF Position             */
#define EADC_CTL_DMOF_Msk                (0x1ul << EADC_CTL_DMOF_Pos)                      /*!< EADC_T::CTL: DMOF Mask                 */

#define EADC_CTL_PDMAEN_Pos              (11)                                              /*!< EADC_T::CTL: PDMAEN Position           */
#define EADC_CTL_PDMAEN_Msk              (0x1ul << EADC_CTL_PDMAEN_Pos)                    /*!< EADC_T::CTL: PDMAEN Mask               */

#define EADC_CTL_SMPTSEL_Pos             (16)                                              /*!< EADC_T::CTL: SMPTSEL Position          */
#define EADC_CTL_SMPTSEL_Msk             (0x7ul << EADC_CTL_SMPTSEL_Pos)                   /*!< EADC_T::CTL: SMPTSEL Mask              */

#define EADC_SWTRG_SWTRG_Pos             (0)                                               /*!< EADC_T::SWTRG: SWTRG Position          */
#define EADC_SWTRG_SWTRG_Msk             (0x7fffful << EADC_SWTRG_SWTRG_Pos)               /*!< EADC_T::SWTRG: SWTRG Mask              */

#define EADC_PENDSTS_STPF_Pos            (0)                                               /*!< EADC_T::PENDSTS: STPF Position         */
#define EADC_PENDSTS_STPF_Msk            (0x7fffful << EADC_PENDSTS_STPF_Pos)              /*!< EADC_T::PENDSTS: STPF Mask             */

#define EADC_OVSTS_SPOVF_Pos             (0)                                               /*!< EADC_T::OVSTS: SPOVF Position          */
#define EADC_OVSTS_SPOVF_Msk             (0x7fffful << EADC_OVSTS_SPOVF_Pos)               /*!< EADC_T::OVSTS: SPOVF Mask              */

#define EADC_SELFTCTL_SELFTEN_Pos        (0)                                               /*!< EADC_T::SELFTCTL: SELFTEN Position     */
#define EADC_SELFTCTL_SELFTEN_Msk        (0x1ul << EADC_SELFTCTL_SELFTEN_Pos)              /*!< EADC_T::SELFTCTL: SELFTEN Mask         */

#define EADC_SCTL0_CHSEL_Pos             (0)                                               /*!< EADC_T::SCTL0: CHSEL Position          */
#define EADC_SCTL0_CHSEL_Msk             (0xful << EADC_SCTL0_CHSEL_Pos)                   /*!< EADC_T::SCTL0: CHSEL Mask              */

#define EADC_SCTL0_EXTREN_Pos            (4)                                               /*!< EADC_T::SCTL0: EXTREN Position         */
#define EADC_SCTL0_EXTREN_Msk            (0x1ul << EADC_SCTL0_EXTREN_Pos)                  /*!< EADC_T::SCTL0: EXTREN Mask             */

#define EADC_SCTL0_EXTFEN_Pos            (5)                                               /*!< EADC_T::SCTL0: EXTFEN Position         */
#define EADC_SCTL0_EXTFEN_Msk            (0x1ul << EADC_SCTL0_EXTFEN_Pos)                  /*!< EADC_T::SCTL0: EXTFEN Mask             */

#define EADC_SCTL0_TRGDLYDIV_Pos         (6)                                               /*!< EADC_T::SCTL0: TRGDLYDIV Position      */
#define EADC_SCTL0_TRGDLYDIV_Msk         (0x3ul << EADC_SCTL0_TRGDLYDIV_Pos)               /*!< EADC_T::SCTL0: TRGDLYDIV Mask          */

#define EADC_SCTL0_TRGDLYCNT_Pos         (8)                                               /*!< EADC_T::SCTL0: TRGDLYCNT Position      */
#define EADC_SCTL0_TRGDLYCNT_Msk         (0xfful << EADC_SCTL0_TRGDLYCNT_Pos)              /*!< EADC_T::SCTL0: TRGDLYCNT Mask          */

#define EADC_SCTL0_TRGSEL_Pos            (16)                                              /*!< EADC_T::SCTL0: TRGSEL Position         */
#define EADC_SCTL0_TRGSEL_Msk            (0x1ful << EADC_SCTL0_TRGSEL_Pos)                 /*!< EADC_T::SCTL0: TRGSEL Mask             */

#define EADC_SCTL0_INTPOS_Pos            (22)                                              /*!< EADC_T::SCTL0: INTPOS Position         */
#define EADC_SCTL0_INTPOS_Msk            (0x1ul << EADC_SCTL0_INTPOS_Pos)                  /*!< EADC_T::SCTL0: INTPOS Mask             */

#define EADC_SCTL0_DBMEN_Pos             (23)                                              /*!< EADC_T::SCTL0: DBMEN Position          */
#define EADC_SCTL0_DBMEN_Msk             (0x1ul << EADC_SCTL0_DBMEN_Pos)                   /*!< EADC_T::SCTL0: DBMEN Mask              */

#define EADC_SCTL0_EXTSMPT_Pos           (24)                                              /*!< EADC_T::SCTL0: EXTSMPT Position        */
#define EADC_SCTL0_EXTSMPT_Msk           (0xfful << EADC_SCTL0_EXTSMPT_Pos)                /*!< EADC_T::SCTL0: EXTSMPT Mask            */

#define EADC_SCTL1_CHSEL_Pos             (0)                                               /*!< EADC_T::SCTL1: CHSEL Position          */
#define EADC_SCTL1_CHSEL_Msk             (0xful << EADC_SCTL1_CHSEL_Pos)                   /*!< EADC_T::SCTL1: CHSEL Mask              */

#define EADC_SCTL1_EXTREN_Pos            (4)                                               /*!< EADC_T::SCTL1: EXTREN Position         */
#define EADC_SCTL1_EXTREN_Msk            (0x1ul << EADC_SCTL1_EXTREN_Pos)                  /*!< EADC_T::SCTL1: EXTREN Mask             */

#define EADC_SCTL1_EXTFEN_Pos            (5)                                               /*!< EADC_T::SCTL1: EXTFEN Position         */
#define EADC_SCTL1_EXTFEN_Msk            (0x1ul << EADC_SCTL1_EXTFEN_Pos)                  /*!< EADC_T::SCTL1: EXTFEN Mask             */

#define EADC_SCTL1_TRGDLYDIV_Pos         (6)                                               /*!< EADC_T::SCTL1: TRGDLYDIV Position      */
#define EADC_SCTL1_TRGDLYDIV_Msk         (0x3ul << EADC_SCTL1_TRGDLYDIV_Pos)               /*!< EADC_T::SCTL1: TRGDLYDIV Mask          */

#define EADC_SCTL1_TRGDLYCNT_Pos         (8)                                               /*!< EADC_T::SCTL1: TRGDLYCNT Position      */
#define EADC_SCTL1_TRGDLYCNT_Msk         (0xfful << EADC_SCTL1_TRGDLYCNT_Pos)              /*!< EADC_T::SCTL1: TRGDLYCNT Mask          */

#define EADC_SCTL1_TRGSEL_Pos            (16)                                              /*!< EADC_T::SCTL1: TRGSEL Position         */
#define EADC_SCTL1_TRGSEL_Msk            (0x1ful << EADC_SCTL1_TRGSEL_Pos)                 /*!< EADC_T::SCTL1: TRGSEL Mask             */

#define EADC_SCTL1_INTPOS_Pos            (22)                                              /*!< EADC_T::SCTL1: INTPOS Position         */
#define EADC_SCTL1_INTPOS_Msk            (0x1ul << EADC_SCTL1_INTPOS_Pos)                  /*!< EADC_T::SCTL1: INTPOS Mask             */

#define EADC_SCTL1_DBMEN_Pos             (23)                                              /*!< EADC_T::SCTL1: DBMEN Position          */
#define EADC_SCTL1_DBMEN_Msk             (0x1ul << EADC_SCTL1_DBMEN_Pos)                   /*!< EADC_T::SCTL1: DBMEN Mask              */

#define EADC_SCTL1_EXTSMPT_Pos           (24)                                              /*!< EADC_T::SCTL1: EXTSMPT Position        */
#define EADC_SCTL1_EXTSMPT_Msk           (0xfful << EADC_SCTL1_EXTSMPT_Pos)                /*!< EADC_T::SCTL1: EXTSMPT Mask            */

#define EADC_SCTL2_CHSEL_Pos             (0)                                               /*!< EADC_T::SCTL2: CHSEL Position          */
#define EADC_SCTL2_CHSEL_Msk             (0xful << EADC_SCTL2_CHSEL_Pos)                   /*!< EADC_T::SCTL2: CHSEL Mask              */

#define EADC_SCTL2_EXTREN_Pos            (4)                                               /*!< EADC_T::SCTL2: EXTREN Position         */
#define EADC_SCTL2_EXTREN_Msk            (0x1ul << EADC_SCTL2_EXTREN_Pos)                  /*!< EADC_T::SCTL2: EXTREN Mask             */

#define EADC_SCTL2_EXTFEN_Pos            (5)                                               /*!< EADC_T::SCTL2: EXTFEN Position         */
#define EADC_SCTL2_EXTFEN_Msk            (0x1ul << EADC_SCTL2_EXTFEN_Pos)                  /*!< EADC_T::SCTL2: EXTFEN Mask             */

#define EADC_SCTL2_TRGDLYDIV_Pos         (6)                                               /*!< EADC_T::SCTL2: TRGDLYDIV Position      */
#define EADC_SCTL2_TRGDLYDIV_Msk         (0x3ul << EADC_SCTL2_TRGDLYDIV_Pos)               /*!< EADC_T::SCTL2: TRGDLYDIV Mask          */

#define EADC_SCTL2_TRGDLYCNT_Pos         (8)                                               /*!< EADC_T::SCTL2: TRGDLYCNT Position      */
#define EADC_SCTL2_TRGDLYCNT_Msk         (0xfful << EADC_SCTL2_TRGDLYCNT_Pos)              /*!< EADC_T::SCTL2: TRGDLYCNT Mask          */

#define EADC_SCTL2_TRGSEL_Pos            (16)                                              /*!< EADC_T::SCTL2: TRGSEL Position         */
#define EADC_SCTL2_TRGSEL_Msk            (0x1ful << EADC_SCTL2_TRGSEL_Pos)                 /*!< EADC_T::SCTL2: TRGSEL Mask             */

#define EADC_SCTL2_INTPOS_Pos            (22)                                              /*!< EADC_T::SCTL2: INTPOS Position         */
#define EADC_SCTL2_INTPOS_Msk            (0x1ul << EADC_SCTL2_INTPOS_Pos)                  /*!< EADC_T::SCTL2: INTPOS Mask             */

#define EADC_SCTL2_DBMEN_Pos             (23)                                              /*!< EADC_T::SCTL2: DBMEN Position          */
#define EADC_SCTL2_DBMEN_Msk             (0x1ul << EADC_SCTL2_DBMEN_Pos)                   /*!< EADC_T::SCTL2: DBMEN Mask              */

#define EADC_SCTL2_EXTSMPT_Pos           (24)                                              /*!< EADC_T::SCTL2: EXTSMPT Position        */
#define EADC_SCTL2_EXTSMPT_Msk           (0xfful << EADC_SCTL2_EXTSMPT_Pos)                /*!< EADC_T::SCTL2: EXTSMPT Mask            */

#define EADC_SCTL3_CHSEL_Pos             (0)                                               /*!< EADC_T::SCTL3: CHSEL Position          */
#define EADC_SCTL3_CHSEL_Msk             (0xful << EADC_SCTL3_CHSEL_Pos)                   /*!< EADC_T::SCTL3: CHSEL Mask              */

#define EADC_SCTL3_EXTREN_Pos            (4)                                               /*!< EADC_T::SCTL3: EXTREN Position         */
#define EADC_SCTL3_EXTREN_Msk            (0x1ul << EADC_SCTL3_EXTREN_Pos)                  /*!< EADC_T::SCTL3: EXTREN Mask             */

#define EADC_SCTL3_EXTFEN_Pos            (5)                                               /*!< EADC_T::SCTL3: EXTFEN Position         */
#define EADC_SCTL3_EXTFEN_Msk            (0x1ul << EADC_SCTL3_EXTFEN_Pos)                  /*!< EADC_T::SCTL3: EXTFEN Mask             */

#define EADC_SCTL3_TRGDLYDIV_Pos         (6)                                               /*!< EADC_T::SCTL3: TRGDLYDIV Position      */
#define EADC_SCTL3_TRGDLYDIV_Msk         (0x3ul << EADC_SCTL3_TRGDLYDIV_Pos)               /*!< EADC_T::SCTL3: TRGDLYDIV Mask          */

#define EADC_SCTL3_TRGDLYCNT_Pos         (8)                                               /*!< EADC_T::SCTL3: TRGDLYCNT Position      */
#define EADC_SCTL3_TRGDLYCNT_Msk         (0xfful << EADC_SCTL3_TRGDLYCNT_Pos)              /*!< EADC_T::SCTL3: TRGDLYCNT Mask          */

#define EADC_SCTL3_TRGSEL_Pos            (16)                                              /*!< EADC_T::SCTL3: TRGSEL Position         */
#define EADC_SCTL3_TRGSEL_Msk            (0x1ful << EADC_SCTL3_TRGSEL_Pos)                 /*!< EADC_T::SCTL3: TRGSEL Mask             */

#define EADC_SCTL3_INTPOS_Pos            (22)                                              /*!< EADC_T::SCTL3: INTPOS Position         */
#define EADC_SCTL3_INTPOS_Msk            (0x1ul << EADC_SCTL3_INTPOS_Pos)                  /*!< EADC_T::SCTL3: INTPOS Mask             */

#define EADC_SCTL3_DBMEN_Pos             (23)                                              /*!< EADC_T::SCTL3: DBMEN Position          */
#define EADC_SCTL3_DBMEN_Msk             (0x1ul << EADC_SCTL3_DBMEN_Pos)                   /*!< EADC_T::SCTL3: DBMEN Mask              */

#define EADC_SCTL3_EXTSMPT_Pos           (24)                                              /*!< EADC_T::SCTL3: EXTSMPT Position        */
#define EADC_SCTL3_EXTSMPT_Msk           (0xfful << EADC_SCTL3_EXTSMPT_Pos)                /*!< EADC_T::SCTL3: EXTSMPT Mask            */

#define EADC_SCTL4_CHSEL_Pos             (0)                                               /*!< EADC_T::SCTL4: CHSEL Position          */
#define EADC_SCTL4_CHSEL_Msk             (0xful << EADC_SCTL4_CHSEL_Pos)                   /*!< EADC_T::SCTL4: CHSEL Mask              */

#define EADC_SCTL4_EXTREN_Pos            (4)                                               /*!< EADC_T::SCTL4: EXTREN Position         */
#define EADC_SCTL4_EXTREN_Msk            (0x1ul << EADC_SCTL4_EXTREN_Pos)                  /*!< EADC_T::SCTL4: EXTREN Mask             */

#define EADC_SCTL4_EXTFEN_Pos            (5)                                               /*!< EADC_T::SCTL4: EXTFEN Position         */
#define EADC_SCTL4_EXTFEN_Msk            (0x1ul << EADC_SCTL4_EXTFEN_Pos)                  /*!< EADC_T::SCTL4: EXTFEN Mask             */

#define EADC_SCTL4_TRGDLYDIV_Pos         (6)                                               /*!< EADC_T::SCTL4: TRGDLYDIV Position      */
#define EADC_SCTL4_TRGDLYDIV_Msk         (0x3ul << EADC_SCTL4_TRGDLYDIV_Pos)               /*!< EADC_T::SCTL4: TRGDLYDIV Mask          */

#define EADC_SCTL4_TRGDLYCNT_Pos         (8)                                               /*!< EADC_T::SCTL4: TRGDLYCNT Position      */
#define EADC_SCTL4_TRGDLYCNT_Msk         (0xfful << EADC_SCTL4_TRGDLYCNT_Pos)              /*!< EADC_T::SCTL4: TRGDLYCNT Mask          */

#define EADC_SCTL4_TRGSEL_Pos            (16)                                              /*!< EADC_T::SCTL4: TRGSEL Position         */
#define EADC_SCTL4_TRGSEL_Msk            (0x1ful << EADC_SCTL4_TRGSEL_Pos)                 /*!< EADC_T::SCTL4: TRGSEL Mask             */

#define EADC_SCTL4_INTPOS_Pos            (22)                                              /*!< EADC_T::SCTL4: INTPOS Position         */
#define EADC_SCTL4_INTPOS_Msk            (0x1ul << EADC_SCTL4_INTPOS_Pos)                  /*!< EADC_T::SCTL4: INTPOS Mask             */

#define EADC_SCTL4_EXTSMPT_Pos           (24)                                              /*!< EADC_T::SCTL4: EXTSMPT Position        */
#define EADC_SCTL4_EXTSMPT_Msk           (0xfful << EADC_SCTL4_EXTSMPT_Pos)                /*!< EADC_T::SCTL4: EXTSMPT Mask            */

#define EADC_SCTL5_CHSEL_Pos             (0)                                               /*!< EADC_T::SCTL5: CHSEL Position          */
#define EADC_SCTL5_CHSEL_Msk             (0xful << EADC_SCTL5_CHSEL_Pos)                   /*!< EADC_T::SCTL5: CHSEL Mask              */

#define EADC_SCTL5_EXTREN_Pos            (4)                                               /*!< EADC_T::SCTL5: EXTREN Position         */
#define EADC_SCTL5_EXTREN_Msk            (0x1ul << EADC_SCTL5_EXTREN_Pos)                  /*!< EADC_T::SCTL5: EXTREN Mask             */

#define EADC_SCTL5_EXTFEN_Pos            (5)                                               /*!< EADC_T::SCTL5: EXTFEN Position         */
#define EADC_SCTL5_EXTFEN_Msk            (0x1ul << EADC_SCTL5_EXTFEN_Pos)                  /*!< EADC_T::SCTL5: EXTFEN Mask             */

#define EADC_SCTL5_TRGDLYDIV_Pos         (6)                                               /*!< EADC_T::SCTL5: TRGDLYDIV Position      */
#define EADC_SCTL5_TRGDLYDIV_Msk         (0x3ul << EADC_SCTL5_TRGDLYDIV_Pos)               /*!< EADC_T::SCTL5: TRGDLYDIV Mask          */

#define EADC_SCTL5_TRGDLYCNT_Pos         (8)                                               /*!< EADC_T::SCTL5: TRGDLYCNT Position      */
#define EADC_SCTL5_TRGDLYCNT_Msk         (0xfful << EADC_SCTL5_TRGDLYCNT_Pos)              /*!< EADC_T::SCTL5: TRGDLYCNT Mask          */

#define EADC_SCTL5_TRGSEL_Pos            (16)                                              /*!< EADC_T::SCTL5: TRGSEL Position         */
#define EADC_SCTL5_TRGSEL_Msk            (0x1ful << EADC_SCTL5_TRGSEL_Pos)                 /*!< EADC_T::SCTL5: TRGSEL Mask             */

#define EADC_SCTL5_INTPOS_Pos            (22)                                              /*!< EADC_T::SCTL5: INTPOS Position         */
#define EADC_SCTL5_INTPOS_Msk            (0x1ul << EADC_SCTL5_INTPOS_Pos)                  /*!< EADC_T::SCTL5: INTPOS Mask             */

#define EADC_SCTL5_EXTSMPT_Pos           (24)                                              /*!< EADC_T::SCTL5: EXTSMPT Position        */
#define EADC_SCTL5_EXTSMPT_Msk           (0xfful << EADC_SCTL5_EXTSMPT_Pos)                /*!< EADC_T::SCTL5: EXTSMPT Mask            */

#define EADC_SCTL6_CHSEL_Pos             (0)                                               /*!< EADC_T::SCTL6: CHSEL Position          */
#define EADC_SCTL6_CHSEL_Msk             (0xful << EADC_SCTL6_CHSEL_Pos)                   /*!< EADC_T::SCTL6: CHSEL Mask              */

#define EADC_SCTL6_EXTREN_Pos            (4)                                               /*!< EADC_T::SCTL6: EXTREN Position         */
#define EADC_SCTL6_EXTREN_Msk            (0x1ul << EADC_SCTL6_EXTREN_Pos)                  /*!< EADC_T::SCTL6: EXTREN Mask             */

#define EADC_SCTL6_EXTFEN_Pos            (5)                                               /*!< EADC_T::SCTL6: EXTFEN Position         */
#define EADC_SCTL6_EXTFEN_Msk            (0x1ul << EADC_SCTL6_EXTFEN_Pos)                  /*!< EADC_T::SCTL6: EXTFEN Mask             */

#define EADC_SCTL6_TRGDLYDIV_Pos         (6)                                               /*!< EADC_T::SCTL6: TRGDLYDIV Position      */
#define EADC_SCTL6_TRGDLYDIV_Msk         (0x3ul << EADC_SCTL6_TRGDLYDIV_Pos)               /*!< EADC_T::SCTL6: TRGDLYDIV Mask          */

#define EADC_SCTL6_TRGDLYCNT_Pos         (8)                                               /*!< EADC_T::SCTL6: TRGDLYCNT Position      */
#define EADC_SCTL6_TRGDLYCNT_Msk         (0xfful << EADC_SCTL6_TRGDLYCNT_Pos)              /*!< EADC_T::SCTL6: TRGDLYCNT Mask          */

#define EADC_SCTL6_TRGSEL_Pos            (16)                                              /*!< EADC_T::SCTL6: TRGSEL Position         */
#define EADC_SCTL6_TRGSEL_Msk            (0x1ful << EADC_SCTL6_TRGSEL_Pos)                 /*!< EADC_T::SCTL6: TRGSEL Mask             */

#define EADC_SCTL6_INTPOS_Pos            (22)                                              /*!< EADC_T::SCTL6: INTPOS Position         */
#define EADC_SCTL6_INTPOS_Msk            (0x1ul << EADC_SCTL6_INTPOS_Pos)                  /*!< EADC_T::SCTL6: INTPOS Mask             */

#define EADC_SCTL6_EXTSMPT_Pos           (24)                                              /*!< EADC_T::SCTL6: EXTSMPT Position        */
#define EADC_SCTL6_EXTSMPT_Msk           (0xfful << EADC_SCTL6_EXTSMPT_Pos)                /*!< EADC_T::SCTL6: EXTSMPT Mask            */

#define EADC_SCTL7_CHSEL_Pos             (0)                                               /*!< EADC_T::SCTL7: CHSEL Position          */
#define EADC_SCTL7_CHSEL_Msk             (0xful << EADC_SCTL7_CHSEL_Pos)                   /*!< EADC_T::SCTL7: CHSEL Mask              */

#define EADC_SCTL7_EXTREN_Pos            (4)                                               /*!< EADC_T::SCTL7: EXTREN Position         */
#define EADC_SCTL7_EXTREN_Msk            (0x1ul << EADC_SCTL7_EXTREN_Pos)                  /*!< EADC_T::SCTL7: EXTREN Mask             */

#define EADC_SCTL7_EXTFEN_Pos            (5)                                               /*!< EADC_T::SCTL7: EXTFEN Position         */
#define EADC_SCTL7_EXTFEN_Msk            (0x1ul << EADC_SCTL7_EXTFEN_Pos)                  /*!< EADC_T::SCTL7: EXTFEN Mask             */

#define EADC_SCTL7_TRGDLYDIV_Pos         (6)                                               /*!< EADC_T::SCTL7: TRGDLYDIV Position      */
#define EADC_SCTL7_TRGDLYDIV_Msk         (0x3ul << EADC_SCTL7_TRGDLYDIV_Pos)               /*!< EADC_T::SCTL7: TRGDLYDIV Mask          */

#define EADC_SCTL7_TRGDLYCNT_Pos         (8)                                               /*!< EADC_T::SCTL7: TRGDLYCNT Position      */
#define EADC_SCTL7_TRGDLYCNT_Msk         (0xfful << EADC_SCTL7_TRGDLYCNT_Pos)              /*!< EADC_T::SCTL7: TRGDLYCNT Mask          */

#define EADC_SCTL7_TRGSEL_Pos            (16)                                              /*!< EADC_T::SCTL7: TRGSEL Position         */
#define EADC_SCTL7_TRGSEL_Msk            (0x1ful << EADC_SCTL7_TRGSEL_Pos)                 /*!< EADC_T::SCTL7: TRGSEL Mask             */

#define EADC_SCTL7_INTPOS_Pos            (22)                                              /*!< EADC_T::SCTL7: INTPOS Position         */
#define EADC_SCTL7_INTPOS_Msk            (0x1ul << EADC_SCTL7_INTPOS_Pos)                  /*!< EADC_T::SCTL7: INTPOS Mask             */

#define EADC_SCTL7_EXTSMPT_Pos           (24)                                              /*!< EADC_T::SCTL7: EXTSMPT Position        */
#define EADC_SCTL7_EXTSMPT_Msk           (0xfful << EADC_SCTL7_EXTSMPT_Pos)                /*!< EADC_T::SCTL7: EXTSMPT Mask            */

#define EADC_SCTL8_CHSEL_Pos             (0)                                               /*!< EADC_T::SCTL8: CHSEL Position          */
#define EADC_SCTL8_CHSEL_Msk             (0xful << EADC_SCTL8_CHSEL_Pos)                   /*!< EADC_T::SCTL8: CHSEL Mask              */

#define EADC_SCTL8_EXTREN_Pos            (4)                                               /*!< EADC_T::SCTL8: EXTREN Position         */
#define EADC_SCTL8_EXTREN_Msk            (0x1ul << EADC_SCTL8_EXTREN_Pos)                  /*!< EADC_T::SCTL8: EXTREN Mask             */

#define EADC_SCTL8_EXTFEN_Pos            (5)                                               /*!< EADC_T::SCTL8: EXTFEN Position         */
#define EADC_SCTL8_EXTFEN_Msk            (0x1ul << EADC_SCTL8_EXTFEN_Pos)                  /*!< EADC_T::SCTL8: EXTFEN Mask             */

#define EADC_SCTL8_TRGDLYDIV_Pos         (6)                                               /*!< EADC_T::SCTL8: TRGDLYDIV Position      */
#define EADC_SCTL8_TRGDLYDIV_Msk         (0x3ul << EADC_SCTL8_TRGDLYDIV_Pos)               /*!< EADC_T::SCTL8: TRGDLYDIV Mask          */

#define EADC_SCTL8_TRGDLYCNT_Pos         (8)                                               /*!< EADC_T::SCTL8: TRGDLYCNT Position      */
#define EADC_SCTL8_TRGDLYCNT_Msk         (0xfful << EADC_SCTL8_TRGDLYCNT_Pos)              /*!< EADC_T::SCTL8: TRGDLYCNT Mask          */

#define EADC_SCTL8_TRGSEL_Pos            (16)                                              /*!< EADC_T::SCTL8: TRGSEL Position         */
#define EADC_SCTL8_TRGSEL_Msk            (0x1ful << EADC_SCTL8_TRGSEL_Pos)                 /*!< EADC_T::SCTL8: TRGSEL Mask             */

#define EADC_SCTL8_INTPOS_Pos            (22)                                              /*!< EADC_T::SCTL8: INTPOS Position         */
#define EADC_SCTL8_INTPOS_Msk            (0x1ul << EADC_SCTL8_INTPOS_Pos)                  /*!< EADC_T::SCTL8: INTPOS Mask             */

#define EADC_SCTL8_EXTSMPT_Pos           (24)                                              /*!< EADC_T::SCTL8: EXTSMPT Position        */
#define EADC_SCTL8_EXTSMPT_Msk           (0xfful << EADC_SCTL8_EXTSMPT_Pos)                /*!< EADC_T::SCTL8: EXTSMPT Mask            */

#define EADC_SCTL9_CHSEL_Pos             (0)                                               /*!< EADC_T::SCTL9: CHSEL Position          */
#define EADC_SCTL9_CHSEL_Msk             (0xful << EADC_SCTL9_CHSEL_Pos)                   /*!< EADC_T::SCTL9: CHSEL Mask              */

#define EADC_SCTL9_EXTREN_Pos            (4)                                               /*!< EADC_T::SCTL9: EXTREN Position         */
#define EADC_SCTL9_EXTREN_Msk            (0x1ul << EADC_SCTL9_EXTREN_Pos)                  /*!< EADC_T::SCTL9: EXTREN Mask             */

#define EADC_SCTL9_EXTFEN_Pos            (5)                                               /*!< EADC_T::SCTL9: EXTFEN Position         */
#define EADC_SCTL9_EXTFEN_Msk            (0x1ul << EADC_SCTL9_EXTFEN_Pos)                  /*!< EADC_T::SCTL9: EXTFEN Mask             */

#define EADC_SCTL9_TRGDLYDIV_Pos         (6)                                               /*!< EADC_T::SCTL9: TRGDLYDIV Position      */
#define EADC_SCTL9_TRGDLYDIV_Msk         (0x3ul << EADC_SCTL9_TRGDLYDIV_Pos)               /*!< EADC_T::SCTL9: TRGDLYDIV Mask          */

#define EADC_SCTL9_TRGDLYCNT_Pos         (8)                                               /*!< EADC_T::SCTL9: TRGDLYCNT Position      */
#define EADC_SCTL9_TRGDLYCNT_Msk         (0xfful << EADC_SCTL9_TRGDLYCNT_Pos)              /*!< EADC_T::SCTL9: TRGDLYCNT Mask          */

#define EADC_SCTL9_TRGSEL_Pos            (16)                                              /*!< EADC_T::SCTL9: TRGSEL Position         */
#define EADC_SCTL9_TRGSEL_Msk            (0x1ful << EADC_SCTL9_TRGSEL_Pos)                 /*!< EADC_T::SCTL9: TRGSEL Mask             */

#define EADC_SCTL9_INTPOS_Pos            (22)                                              /*!< EADC_T::SCTL9: INTPOS Position         */
#define EADC_SCTL9_INTPOS_Msk            (0x1ul << EADC_SCTL9_INTPOS_Pos)                  /*!< EADC_T::SCTL9: INTPOS Mask             */

#define EADC_SCTL9_EXTSMPT_Pos           (24)                                              /*!< EADC_T::SCTL9: EXTSMPT Position        */
#define EADC_SCTL9_EXTSMPT_Msk           (0xfful << EADC_SCTL9_EXTSMPT_Pos)                /*!< EADC_T::SCTL9: EXTSMPT Mask            */

#define EADC_SCTL10_CHSEL_Pos            (0)                                               /*!< EADC_T::SCTL10: CHSEL Position         */
#define EADC_SCTL10_CHSEL_Msk            (0xful << EADC_SCTL10_CHSEL_Pos)                  /*!< EADC_T::SCTL10: CHSEL Mask             */

#define EADC_SCTL10_EXTREN_Pos           (4)                                               /*!< EADC_T::SCTL10: EXTREN Position        */
#define EADC_SCTL10_EXTREN_Msk           (0x1ul << EADC_SCTL10_EXTREN_Pos)                 /*!< EADC_T::SCTL10: EXTREN Mask            */

#define EADC_SCTL10_EXTFEN_Pos           (5)                                               /*!< EADC_T::SCTL10: EXTFEN Position        */
#define EADC_SCTL10_EXTFEN_Msk           (0x1ul << EADC_SCTL10_EXTFEN_Pos)                 /*!< EADC_T::SCTL10: EXTFEN Mask            */

#define EADC_SCTL10_TRGDLYDIV_Pos        (6)                                               /*!< EADC_T::SCTL10: TRGDLYDIV Position     */
#define EADC_SCTL10_TRGDLYDIV_Msk        (0x3ul << EADC_SCTL10_TRGDLYDIV_Pos)              /*!< EADC_T::SCTL10: TRGDLYDIV Mask         */

#define EADC_SCTL10_TRGDLYCNT_Pos        (8)                                               /*!< EADC_T::SCTL10: TRGDLYCNT Position     */
#define EADC_SCTL10_TRGDLYCNT_Msk        (0xfful << EADC_SCTL10_TRGDLYCNT_Pos)             /*!< EADC_T::SCTL10: TRGDLYCNT Mask         */

#define EADC_SCTL10_TRGSEL_Pos           (16)                                              /*!< EADC_T::SCTL10: TRGSEL Position        */
#define EADC_SCTL10_TRGSEL_Msk           (0x1ful << EADC_SCTL10_TRGSEL_Pos)                /*!< EADC_T::SCTL10: TRGSEL Mask            */

#define EADC_SCTL10_INTPOS_Pos           (22)                                              /*!< EADC_T::SCTL10: INTPOS Position        */
#define EADC_SCTL10_INTPOS_Msk           (0x1ul << EADC_SCTL10_INTPOS_Pos)                 /*!< EADC_T::SCTL10: INTPOS Mask            */

#define EADC_SCTL10_EXTSMPT_Pos          (24)                                              /*!< EADC_T::SCTL10: EXTSMPT Position       */
#define EADC_SCTL10_EXTSMPT_Msk          (0xfful << EADC_SCTL10_EXTSMPT_Pos)               /*!< EADC_T::SCTL10: EXTSMPT Mask           */

#define EADC_SCTL11_CHSEL_Pos            (0)                                               /*!< EADC_T::SCTL11: CHSEL Position         */
#define EADC_SCTL11_CHSEL_Msk            (0xful << EADC_SCTL11_CHSEL_Pos)                  /*!< EADC_T::SCTL11: CHSEL Mask             */

#define EADC_SCTL11_EXTREN_Pos           (4)                                               /*!< EADC_T::SCTL11: EXTREN Position        */
#define EADC_SCTL11_EXTREN_Msk           (0x1ul << EADC_SCTL11_EXTREN_Pos)                 /*!< EADC_T::SCTL11: EXTREN Mask            */

#define EADC_SCTL11_EXTFEN_Pos           (5)                                               /*!< EADC_T::SCTL11: EXTFEN Position        */
#define EADC_SCTL11_EXTFEN_Msk           (0x1ul << EADC_SCTL11_EXTFEN_Pos)                 /*!< EADC_T::SCTL11: EXTFEN Mask            */

#define EADC_SCTL11_TRGDLYDIV_Pos        (6)                                               /*!< EADC_T::SCTL11: TRGDLYDIV Position     */
#define EADC_SCTL11_TRGDLYDIV_Msk        (0x3ul << EADC_SCTL11_TRGDLYDIV_Pos)              /*!< EADC_T::SCTL11: TRGDLYDIV Mask         */

#define EADC_SCTL11_TRGDLYCNT_Pos        (8)                                               /*!< EADC_T::SCTL11: TRGDLYCNT Position     */
#define EADC_SCTL11_TRGDLYCNT_Msk        (0xfful << EADC_SCTL11_TRGDLYCNT_Pos)             /*!< EADC_T::SCTL11: TRGDLYCNT Mask         */

#define EADC_SCTL11_TRGSEL_Pos           (16)                                              /*!< EADC_T::SCTL11: TRGSEL Position        */
#define EADC_SCTL11_TRGSEL_Msk           (0x1ful << EADC_SCTL11_TRGSEL_Pos)                /*!< EADC_T::SCTL11: TRGSEL Mask            */

#define EADC_SCTL11_INTPOS_Pos           (22)                                              /*!< EADC_T::SCTL11: INTPOS Position        */
#define EADC_SCTL11_INTPOS_Msk           (0x1ul << EADC_SCTL11_INTPOS_Pos)                 /*!< EADC_T::SCTL11: INTPOS Mask            */

#define EADC_SCTL11_EXTSMPT_Pos          (24)                                              /*!< EADC_T::SCTL11: EXTSMPT Position       */
#define EADC_SCTL11_EXTSMPT_Msk          (0xfful << EADC_SCTL11_EXTSMPT_Pos)               /*!< EADC_T::SCTL11: EXTSMPT Mask           */

#define EADC_SCTL12_CHSEL_Pos            (0)                                               /*!< EADC_T::SCTL12: CHSEL Position         */
#define EADC_SCTL12_CHSEL_Msk            (0xful << EADC_SCTL12_CHSEL_Pos)                  /*!< EADC_T::SCTL12: CHSEL Mask             */

#define EADC_SCTL12_EXTREN_Pos           (4)                                               /*!< EADC_T::SCTL12: EXTREN Position        */
#define EADC_SCTL12_EXTREN_Msk           (0x1ul << EADC_SCTL12_EXTREN_Pos)                 /*!< EADC_T::SCTL12: EXTREN Mask            */

#define EADC_SCTL12_EXTFEN_Pos           (5)                                               /*!< EADC_T::SCTL12: EXTFEN Position        */
#define EADC_SCTL12_EXTFEN_Msk           (0x1ul << EADC_SCTL12_EXTFEN_Pos)                 /*!< EADC_T::SCTL12: EXTFEN Mask            */

#define EADC_SCTL12_TRGDLYDIV_Pos        (6)                                               /*!< EADC_T::SCTL12: TRGDLYDIV Position     */
#define EADC_SCTL12_TRGDLYDIV_Msk        (0x3ul << EADC_SCTL12_TRGDLYDIV_Pos)              /*!< EADC_T::SCTL12: TRGDLYDIV Mask         */

#define EADC_SCTL12_TRGDLYCNT_Pos        (8)                                               /*!< EADC_T::SCTL12: TRGDLYCNT Position     */
#define EADC_SCTL12_TRGDLYCNT_Msk        (0xfful << EADC_SCTL12_TRGDLYCNT_Pos)             /*!< EADC_T::SCTL12: TRGDLYCNT Mask         */

#define EADC_SCTL12_TRGSEL_Pos           (16)                                              /*!< EADC_T::SCTL12: TRGSEL Position        */
#define EADC_SCTL12_TRGSEL_Msk           (0x1ful << EADC_SCTL12_TRGSEL_Pos)                /*!< EADC_T::SCTL12: TRGSEL Mask            */

#define EADC_SCTL12_INTPOS_Pos           (22)                                              /*!< EADC_T::SCTL12: INTPOS Position        */
#define EADC_SCTL12_INTPOS_Msk           (0x1ul << EADC_SCTL12_INTPOS_Pos)                 /*!< EADC_T::SCTL12: INTPOS Mask            */

#define EADC_SCTL12_EXTSMPT_Pos          (24)                                              /*!< EADC_T::SCTL12: EXTSMPT Position       */
#define EADC_SCTL12_EXTSMPT_Msk          (0xfful << EADC_SCTL12_EXTSMPT_Pos)               /*!< EADC_T::SCTL12: EXTSMPT Mask           */

#define EADC_SCTL16_EXTSMPT_Pos          (24)                                              /*!< EADC_T::SCTL16: EXTSMPT Position       */
#define EADC_SCTL16_EXTSMPT_Msk          (0xfful << EADC_SCTL16_EXTSMPT_Pos)               /*!< EADC_T::SCTL16: EXTSMPT Mask           */

#define EADC_SCTL17_EXTSMPT_Pos          (24)                                              /*!< EADC_T::SCTL17: EXTSMPT Position       */
#define EADC_SCTL17_EXTSMPT_Msk          (0xfful << EADC_SCTL17_EXTSMPT_Pos)               /*!< EADC_T::SCTL17: EXTSMPT Mask           */

#define EADC_INTSRC0_SPLIE0_Pos          (0)                                               /*!< EADC_T::INTSRC0: SPLIE0 Position       */
#define EADC_INTSRC0_SPLIE0_Msk          (0x1ul << EADC_INTSRC0_SPLIE0_Pos)                /*!< EADC_T::INTSRC0: SPLIE0 Mask           */

#define EADC_INTSRC0_SPLIE1_Pos          (1)                                               /*!< EADC_T::INTSRC0: SPLIE1 Position       */
#define EADC_INTSRC0_SPLIE1_Msk          (0x1ul << EADC_INTSRC0_SPLIE1_Pos)                /*!< EADC_T::INTSRC0: SPLIE1 Mask           */

#define EADC_INTSRC0_SPLIE2_Pos          (2)                                               /*!< EADC_T::INTSRC0: SPLIE2 Position       */
#define EADC_INTSRC0_SPLIE2_Msk          (0x1ul << EADC_INTSRC0_SPLIE2_Pos)                /*!< EADC_T::INTSRC0: SPLIE2 Mask           */

#define EADC_INTSRC0_SPLIE3_Pos          (3)                                               /*!< EADC_T::INTSRC0: SPLIE3 Position       */
#define EADC_INTSRC0_SPLIE3_Msk          (0x1ul << EADC_INTSRC0_SPLIE3_Pos)                /*!< EADC_T::INTSRC0: SPLIE3 Mask           */

#define EADC_INTSRC0_SPLIE4_Pos          (4)                                               /*!< EADC_T::INTSRC0: SPLIE4 Position       */
#define EADC_INTSRC0_SPLIE4_Msk          (0x1ul << EADC_INTSRC0_SPLIE4_Pos)                /*!< EADC_T::INTSRC0: SPLIE4 Mask           */

#define EADC_INTSRC0_SPLIE5_Pos          (5)                                               /*!< EADC_T::INTSRC0: SPLIE5 Position       */
#define EADC_INTSRC0_SPLIE5_Msk          (0x1ul << EADC_INTSRC0_SPLIE5_Pos)                /*!< EADC_T::INTSRC0: SPLIE5 Mask           */

#define EADC_INTSRC0_SPLIE6_Pos          (6)                                               /*!< EADC_T::INTSRC0: SPLIE6 Position       */
#define EADC_INTSRC0_SPLIE6_Msk          (0x1ul << EADC_INTSRC0_SPLIE6_Pos)                /*!< EADC_T::INTSRC0: SPLIE6 Mask           */

#define EADC_INTSRC0_SPLIE7_Pos          (7)                                               /*!< EADC_T::INTSRC0: SPLIE7 Position       */
#define EADC_INTSRC0_SPLIE7_Msk          (0x1ul << EADC_INTSRC0_SPLIE7_Pos)                /*!< EADC_T::INTSRC0: SPLIE7 Mask           */

#define EADC_INTSRC0_SPLIE8_Pos          (8)                                               /*!< EADC_T::INTSRC0: SPLIE8 Position       */
#define EADC_INTSRC0_SPLIE8_Msk          (0x1ul << EADC_INTSRC0_SPLIE8_Pos)                /*!< EADC_T::INTSRC0: SPLIE8 Mask           */

#define EADC_INTSRC0_SPLIE9_Pos          (9)                                               /*!< EADC_T::INTSRC0: SPLIE9 Position       */
#define EADC_INTSRC0_SPLIE9_Msk          (0x1ul << EADC_INTSRC0_SPLIE9_Pos)                /*!< EADC_T::INTSRC0: SPLIE9 Mask           */

#define EADC_INTSRC0_SPLIE10_Pos         (10)                                              /*!< EADC_T::INTSRC0: SPLIE10 Position      */
#define EADC_INTSRC0_SPLIE10_Msk         (0x1ul << EADC_INTSRC0_SPLIE10_Pos)               /*!< EADC_T::INTSRC0: SPLIE10 Mask          */

#define EADC_INTSRC0_SPLIE11_Pos         (11)                                              /*!< EADC_T::INTSRC0: SPLIE11 Position      */
#define EADC_INTSRC0_SPLIE11_Msk         (0x1ul << EADC_INTSRC0_SPLIE11_Pos)               /*!< EADC_T::INTSRC0: SPLIE11 Mask          */

#define EADC_INTSRC0_SPLIE12_Pos         (12)                                              /*!< EADC_T::INTSRC0: SPLIE12 Position      */
#define EADC_INTSRC0_SPLIE12_Msk         (0x1ul << EADC_INTSRC0_SPLIE12_Pos)               /*!< EADC_T::INTSRC0: SPLIE12 Mask          */

#define EADC_INTSRC0_SPLIE16_Pos         (16)                                              /*!< EADC_T::INTSRC0: SPLIE16 Position      */
#define EADC_INTSRC0_SPLIE16_Msk         (0x1ul << EADC_INTSRC0_SPLIE16_Pos)               /*!< EADC_T::INTSRC0: SPLIE16 Mask          */

#define EADC_INTSRC0_SPLIE17_Pos         (17)                                              /*!< EADC_T::INTSRC0: SPLIE17 Position      */
#define EADC_INTSRC0_SPLIE17_Msk         (0x1ul << EADC_INTSRC0_SPLIE17_Pos)               /*!< EADC_T::INTSRC0: SPLIE17 Mask          */

#define EADC_INTSRC1_SPLIE0_Pos          (0)                                               /*!< EADC_T::INTSRC1: SPLIE0 Position       */
#define EADC_INTSRC1_SPLIE0_Msk          (0x1ul << EADC_INTSRC1_SPLIE0_Pos)                /*!< EADC_T::INTSRC1: SPLIE0 Mask           */

#define EADC_INTSRC1_SPLIE1_Pos          (1)                                               /*!< EADC_T::INTSRC1: SPLIE1 Position       */
#define EADC_INTSRC1_SPLIE1_Msk          (0x1ul << EADC_INTSRC1_SPLIE1_Pos)                /*!< EADC_T::INTSRC1: SPLIE1 Mask           */

#define EADC_INTSRC1_SPLIE2_Pos          (2)                                               /*!< EADC_T::INTSRC1: SPLIE2 Position       */
#define EADC_INTSRC1_SPLIE2_Msk          (0x1ul << EADC_INTSRC1_SPLIE2_Pos)                /*!< EADC_T::INTSRC1: SPLIE2 Mask           */

#define EADC_INTSRC1_SPLIE3_Pos          (3)                                               /*!< EADC_T::INTSRC1: SPLIE3 Position       */
#define EADC_INTSRC1_SPLIE3_Msk          (0x1ul << EADC_INTSRC1_SPLIE3_Pos)                /*!< EADC_T::INTSRC1: SPLIE3 Mask           */

#define EADC_INTSRC1_SPLIE4_Pos          (4)                                               /*!< EADC_T::INTSRC1: SPLIE4 Position       */
#define EADC_INTSRC1_SPLIE4_Msk          (0x1ul << EADC_INTSRC1_SPLIE4_Pos)                /*!< EADC_T::INTSRC1: SPLIE4 Mask           */

#define EADC_INTSRC1_SPLIE5_Pos          (5)                                               /*!< EADC_T::INTSRC1: SPLIE5 Position       */
#define EADC_INTSRC1_SPLIE5_Msk          (0x1ul << EADC_INTSRC1_SPLIE5_Pos)                /*!< EADC_T::INTSRC1: SPLIE5 Mask           */

#define EADC_INTSRC1_SPLIE6_Pos          (6)                                               /*!< EADC_T::INTSRC1: SPLIE6 Position       */
#define EADC_INTSRC1_SPLIE6_Msk          (0x1ul << EADC_INTSRC1_SPLIE6_Pos)                /*!< EADC_T::INTSRC1: SPLIE6 Mask           */

#define EADC_INTSRC1_SPLIE7_Pos          (7)                                               /*!< EADC_T::INTSRC1: SPLIE7 Position       */
#define EADC_INTSRC1_SPLIE7_Msk          (0x1ul << EADC_INTSRC1_SPLIE7_Pos)                /*!< EADC_T::INTSRC1: SPLIE7 Mask           */

#define EADC_INTSRC1_SPLIE8_Pos          (8)                                               /*!< EADC_T::INTSRC1: SPLIE8 Position       */
#define EADC_INTSRC1_SPLIE8_Msk          (0x1ul << EADC_INTSRC1_SPLIE8_Pos)                /*!< EADC_T::INTSRC1: SPLIE8 Mask           */

#define EADC_INTSRC1_SPLIE9_Pos          (9)                                               /*!< EADC_T::INTSRC1: SPLIE9 Position       */
#define EADC_INTSRC1_SPLIE9_Msk          (0x1ul << EADC_INTSRC1_SPLIE9_Pos)                /*!< EADC_T::INTSRC1: SPLIE9 Mask           */

#define EADC_INTSRC1_SPLIE10_Pos         (10)                                              /*!< EADC_T::INTSRC1: SPLIE10 Position      */
#define EADC_INTSRC1_SPLIE10_Msk         (0x1ul << EADC_INTSRC1_SPLIE10_Pos)               /*!< EADC_T::INTSRC1: SPLIE10 Mask          */

#define EADC_INTSRC1_SPLIE11_Pos         (11)                                              /*!< EADC_T::INTSRC1: SPLIE11 Position      */
#define EADC_INTSRC1_SPLIE11_Msk         (0x1ul << EADC_INTSRC1_SPLIE11_Pos)               /*!< EADC_T::INTSRC1: SPLIE11 Mask          */

#define EADC_INTSRC1_SPLIE12_Pos         (12)                                              /*!< EADC_T::INTSRC1: SPLIE12 Position      */
#define EADC_INTSRC1_SPLIE12_Msk         (0x1ul << EADC_INTSRC1_SPLIE12_Pos)               /*!< EADC_T::INTSRC1: SPLIE12 Mask          */

#define EADC_INTSRC1_SPLIE16_Pos         (16)                                              /*!< EADC_T::INTSRC1: SPLIE16 Position      */
#define EADC_INTSRC1_SPLIE16_Msk         (0x1ul << EADC_INTSRC1_SPLIE16_Pos)               /*!< EADC_T::INTSRC1: SPLIE16 Mask          */

#define EADC_INTSRC1_SPLIE17_Pos         (17)                                              /*!< EADC_T::INTSRC1: SPLIE17 Position      */
#define EADC_INTSRC1_SPLIE17_Msk         (0x1ul << EADC_INTSRC1_SPLIE17_Pos)               /*!< EADC_T::INTSRC1: SPLIE17 Mask          */

#define EADC_INTSRC2_SPLIE0_Pos          (0)                                               /*!< EADC_T::INTSRC2: SPLIE0 Position       */
#define EADC_INTSRC2_SPLIE0_Msk          (0x1ul << EADC_INTSRC2_SPLIE0_Pos)                /*!< EADC_T::INTSRC2: SPLIE0 Mask           */

#define EADC_INTSRC2_SPLIE1_Pos          (1)                                               /*!< EADC_T::INTSRC2: SPLIE1 Position       */
#define EADC_INTSRC2_SPLIE1_Msk          (0x1ul << EADC_INTSRC2_SPLIE1_Pos)                /*!< EADC_T::INTSRC2: SPLIE1 Mask           */

#define EADC_INTSRC2_SPLIE2_Pos          (2)                                               /*!< EADC_T::INTSRC2: SPLIE2 Position       */
#define EADC_INTSRC2_SPLIE2_Msk          (0x1ul << EADC_INTSRC2_SPLIE2_Pos)                /*!< EADC_T::INTSRC2: SPLIE2 Mask           */

#define EADC_INTSRC2_SPLIE3_Pos          (3)                                               /*!< EADC_T::INTSRC2: SPLIE3 Position       */
#define EADC_INTSRC2_SPLIE3_Msk          (0x1ul << EADC_INTSRC2_SPLIE3_Pos)                /*!< EADC_T::INTSRC2: SPLIE3 Mask           */

#define EADC_INTSRC2_SPLIE4_Pos          (4)                                               /*!< EADC_T::INTSRC2: SPLIE4 Position       */
#define EADC_INTSRC2_SPLIE4_Msk          (0x1ul << EADC_INTSRC2_SPLIE4_Pos)                /*!< EADC_T::INTSRC2: SPLIE4 Mask           */

#define EADC_INTSRC2_SPLIE5_Pos          (5)                                               /*!< EADC_T::INTSRC2: SPLIE5 Position       */
#define EADC_INTSRC2_SPLIE5_Msk          (0x1ul << EADC_INTSRC2_SPLIE5_Pos)                /*!< EADC_T::INTSRC2: SPLIE5 Mask           */

#define EADC_INTSRC2_SPLIE6_Pos          (6)                                               /*!< EADC_T::INTSRC2: SPLIE6 Position       */
#define EADC_INTSRC2_SPLIE6_Msk          (0x1ul << EADC_INTSRC2_SPLIE6_Pos)                /*!< EADC_T::INTSRC2: SPLIE6 Mask           */

#define EADC_INTSRC2_SPLIE7_Pos          (7)                                               /*!< EADC_T::INTSRC2: SPLIE7 Position       */
#define EADC_INTSRC2_SPLIE7_Msk          (0x1ul << EADC_INTSRC2_SPLIE7_Pos)                /*!< EADC_T::INTSRC2: SPLIE7 Mask           */

#define EADC_INTSRC2_SPLIE8_Pos          (8)                                               /*!< EADC_T::INTSRC2: SPLIE8 Position       */
#define EADC_INTSRC2_SPLIE8_Msk          (0x1ul << EADC_INTSRC2_SPLIE8_Pos)                /*!< EADC_T::INTSRC2: SPLIE8 Mask           */

#define EADC_INTSRC2_SPLIE9_Pos          (9)                                               /*!< EADC_T::INTSRC2: SPLIE9 Position       */
#define EADC_INTSRC2_SPLIE9_Msk          (0x1ul << EADC_INTSRC2_SPLIE9_Pos)                /*!< EADC_T::INTSRC2: SPLIE9 Mask           */

#define EADC_INTSRC2_SPLIE10_Pos         (10)                                              /*!< EADC_T::INTSRC2: SPLIE10 Position      */
#define EADC_INTSRC2_SPLIE10_Msk         (0x1ul << EADC_INTSRC2_SPLIE10_Pos)               /*!< EADC_T::INTSRC2: SPLIE10 Mask          */

#define EADC_INTSRC2_SPLIE11_Pos         (11)                                              /*!< EADC_T::INTSRC2: SPLIE11 Position      */
#define EADC_INTSRC2_SPLIE11_Msk         (0x1ul << EADC_INTSRC2_SPLIE11_Pos)               /*!< EADC_T::INTSRC2: SPLIE11 Mask          */

#define EADC_INTSRC2_SPLIE12_Pos         (12)                                              /*!< EADC_T::INTSRC2: SPLIE12 Position      */
#define EADC_INTSRC2_SPLIE12_Msk         (0x1ul << EADC_INTSRC2_SPLIE12_Pos)               /*!< EADC_T::INTSRC2: SPLIE12 Mask          */

#define EADC_INTSRC2_SPLIE16_Pos         (16)                                              /*!< EADC_T::INTSRC2: SPLIE16 Position      */
#define EADC_INTSRC2_SPLIE16_Msk         (0x1ul << EADC_INTSRC2_SPLIE16_Pos)               /*!< EADC_T::INTSRC2: SPLIE16 Mask          */

#define EADC_INTSRC2_SPLIE17_Pos         (17)                                              /*!< EADC_T::INTSRC2: SPLIE17 Position      */
#define EADC_INTSRC2_SPLIE17_Msk         (0x1ul << EADC_INTSRC2_SPLIE17_Pos)               /*!< EADC_T::INTSRC2: SPLIE17 Mask          */

#define EADC_INTSRC3_SPLIE0_Pos          (0)                                               /*!< EADC_T::INTSRC3: SPLIE0 Position       */
#define EADC_INTSRC3_SPLIE0_Msk          (0x1ul << EADC_INTSRC3_SPLIE0_Pos)                /*!< EADC_T::INTSRC3: SPLIE0 Mask           */

#define EADC_INTSRC3_SPLIE1_Pos          (1)                                               /*!< EADC_T::INTSRC3: SPLIE1 Position       */
#define EADC_INTSRC3_SPLIE1_Msk          (0x1ul << EADC_INTSRC3_SPLIE1_Pos)                /*!< EADC_T::INTSRC3: SPLIE1 Mask           */

#define EADC_INTSRC3_SPLIE2_Pos          (2)                                               /*!< EADC_T::INTSRC3: SPLIE2 Position       */
#define EADC_INTSRC3_SPLIE2_Msk          (0x1ul << EADC_INTSRC3_SPLIE2_Pos)                /*!< EADC_T::INTSRC3: SPLIE2 Mask           */

#define EADC_INTSRC3_SPLIE3_Pos          (3)                                               /*!< EADC_T::INTSRC3: SPLIE3 Position       */
#define EADC_INTSRC3_SPLIE3_Msk          (0x1ul << EADC_INTSRC3_SPLIE3_Pos)                /*!< EADC_T::INTSRC3: SPLIE3 Mask           */

#define EADC_INTSRC3_SPLIE4_Pos          (4)                                               /*!< EADC_T::INTSRC3: SPLIE4 Position       */
#define EADC_INTSRC3_SPLIE4_Msk          (0x1ul << EADC_INTSRC3_SPLIE4_Pos)                /*!< EADC_T::INTSRC3: SPLIE4 Mask           */

#define EADC_INTSRC3_SPLIE5_Pos          (5)                                               /*!< EADC_T::INTSRC3: SPLIE5 Position       */
#define EADC_INTSRC3_SPLIE5_Msk          (0x1ul << EADC_INTSRC3_SPLIE5_Pos)                /*!< EADC_T::INTSRC3: SPLIE5 Mask           */

#define EADC_INTSRC3_SPLIE6_Pos          (6)                                               /*!< EADC_T::INTSRC3: SPLIE6 Position       */
#define EADC_INTSRC3_SPLIE6_Msk          (0x1ul << EADC_INTSRC3_SPLIE6_Pos)                /*!< EADC_T::INTSRC3: SPLIE6 Mask           */

#define EADC_INTSRC3_SPLIE7_Pos          (7)                                               /*!< EADC_T::INTSRC3: SPLIE7 Position       */
#define EADC_INTSRC3_SPLIE7_Msk          (0x1ul << EADC_INTSRC3_SPLIE7_Pos)                /*!< EADC_T::INTSRC3: SPLIE7 Mask           */

#define EADC_INTSRC3_SPLIE8_Pos          (8)                                               /*!< EADC_T::INTSRC3: SPLIE8 Position       */
#define EADC_INTSRC3_SPLIE8_Msk          (0x1ul << EADC_INTSRC3_SPLIE8_Pos)                /*!< EADC_T::INTSRC3: SPLIE8 Mask           */

#define EADC_INTSRC3_SPLIE9_Pos          (9)                                               /*!< EADC_T::INTSRC3: SPLIE9 Position       */
#define EADC_INTSRC3_SPLIE9_Msk          (0x1ul << EADC_INTSRC3_SPLIE9_Pos)                /*!< EADC_T::INTSRC3: SPLIE9 Mask           */

#define EADC_INTSRC3_SPLIE10_Pos         (10)                                              /*!< EADC_T::INTSRC3: SPLIE10 Position      */
#define EADC_INTSRC3_SPLIE10_Msk         (0x1ul << EADC_INTSRC3_SPLIE10_Pos)               /*!< EADC_T::INTSRC3: SPLIE10 Mask          */

#define EADC_INTSRC3_SPLIE11_Pos         (11)                                              /*!< EADC_T::INTSRC3: SPLIE11 Position      */
#define EADC_INTSRC3_SPLIE11_Msk         (0x1ul << EADC_INTSRC3_SPLIE11_Pos)               /*!< EADC_T::INTSRC3: SPLIE11 Mask          */

#define EADC_INTSRC3_SPLIE12_Pos         (12)                                              /*!< EADC_T::INTSRC3: SPLIE12 Position      */
#define EADC_INTSRC3_SPLIE12_Msk         (0x1ul << EADC_INTSRC3_SPLIE12_Pos)               /*!< EADC_T::INTSRC3: SPLIE12 Mask          */

#define EADC_INTSRC3_SPLIE16_Pos         (16)                                              /*!< EADC_T::INTSRC3: SPLIE16 Position      */
#define EADC_INTSRC3_SPLIE16_Msk         (0x1ul << EADC_INTSRC3_SPLIE16_Pos)               /*!< EADC_T::INTSRC3: SPLIE16 Mask          */

#define EADC_INTSRC3_SPLIE17_Pos         (17)                                              /*!< EADC_T::INTSRC3: SPLIE17 Position      */
#define EADC_INTSRC3_SPLIE17_Msk         (0x1ul << EADC_INTSRC3_SPLIE17_Pos)               /*!< EADC_T::INTSRC3: SPLIE17 Mask          */

#define EADC_CMP0_ADCMPEN_Pos            (0)                                               /*!< EADC_T::CMP0: ADCMPEN Position         */
#define EADC_CMP0_ADCMPEN_Msk            (0x1ul << EADC_CMP0_ADCMPEN_Pos)                  /*!< EADC_T::CMP0: ADCMPEN Mask             */

#define EADC_CMP0_ADCMPIE_Pos            (1)                                               /*!< EADC_T::CMP0: ADCMPIE Position         */
#define EADC_CMP0_ADCMPIE_Msk            (0x1ul << EADC_CMP0_ADCMPIE_Pos)                  /*!< EADC_T::CMP0: ADCMPIE Mask             */

#define EADC_CMP0_CMPCOND_Pos            (2)                                               /*!< EADC_T::CMP0: CMPCOND Position         */
#define EADC_CMP0_CMPCOND_Msk            (0x1ul << EADC_CMP0_CMPCOND_Pos)                  /*!< EADC_T::CMP0: CMPCOND Mask             */

#define EADC_CMP0_CMPSPL_Pos             (3)                                               /*!< EADC_T::CMP0: CMPSPL Position          */
#define EADC_CMP0_CMPSPL_Msk             (0x1ful << EADC_CMP0_CMPSPL_Pos)                  /*!< EADC_T::CMP0: CMPSPL Mask              */

#define EADC_CMP0_CMPMCNT_Pos            (8)                                               /*!< EADC_T::CMP0: CMPMCNT Position         */
#define EADC_CMP0_CMPMCNT_Msk            (0xful << EADC_CMP0_CMPMCNT_Pos)                  /*!< EADC_T::CMP0: CMPMCNT Mask             */

#define EADC_CMP0_CMPWEN_Pos             (15)                                              /*!< EADC_T::CMP0: CMPWEN Position          */
#define EADC_CMP0_CMPWEN_Msk             (0x1ul << EADC_CMP0_CMPWEN_Pos)                   /*!< EADC_T::CMP0: CMPWEN Mask              */

#define EADC_CMP0_CMPDAT_Pos             (16)                                              /*!< EADC_T::CMP0: CMPDAT Position          */
#define EADC_CMP0_CMPDAT_Msk             (0xffful << EADC_CMP0_CMPDAT_Pos)                 /*!< EADC_T::CMP0: CMPDAT Mask              */

#define EADC_CMP1_ADCMPEN_Pos            (0)                                               /*!< EADC_T::CMP1: ADCMPEN Position         */
#define EADC_CMP1_ADCMPEN_Msk            (0x1ul << EADC_CMP1_ADCMPEN_Pos)                  /*!< EADC_T::CMP1: ADCMPEN Mask             */

#define EADC_CMP1_ADCMPIE_Pos            (1)                                               /*!< EADC_T::CMP1: ADCMPIE Position         */
#define EADC_CMP1_ADCMPIE_Msk            (0x1ul << EADC_CMP1_ADCMPIE_Pos)                  /*!< EADC_T::CMP1: ADCMPIE Mask             */

#define EADC_CMP1_CMPCOND_Pos            (2)                                               /*!< EADC_T::CMP1: CMPCOND Position         */
#define EADC_CMP1_CMPCOND_Msk            (0x1ul << EADC_CMP1_CMPCOND_Pos)                  /*!< EADC_T::CMP1: CMPCOND Mask             */

#define EADC_CMP1_CMPSPL_Pos             (3)                                               /*!< EADC_T::CMP1: CMPSPL Position          */
#define EADC_CMP1_CMPSPL_Msk             (0x1ful << EADC_CMP1_CMPSPL_Pos)                  /*!< EADC_T::CMP1: CMPSPL Mask              */

#define EADC_CMP1_CMPMCNT_Pos            (8)                                               /*!< EADC_T::CMP1: CMPMCNT Position         */
#define EADC_CMP1_CMPMCNT_Msk            (0xful << EADC_CMP1_CMPMCNT_Pos)                  /*!< EADC_T::CMP1: CMPMCNT Mask             */

#define EADC_CMP1_CMPWEN_Pos             (15)                                              /*!< EADC_T::CMP1: CMPWEN Position          */
#define EADC_CMP1_CMPWEN_Msk             (0x1ul << EADC_CMP1_CMPWEN_Pos)                   /*!< EADC_T::CMP1: CMPWEN Mask              */

#define EADC_CMP1_CMPDAT_Pos             (16)                                              /*!< EADC_T::CMP1: CMPDAT Position          */
#define EADC_CMP1_CMPDAT_Msk             (0xffful << EADC_CMP1_CMPDAT_Pos)                 /*!< EADC_T::CMP1: CMPDAT Mask              */

#define EADC_CMP2_ADCMPEN_Pos            (0)                                               /*!< EADC_T::CMP2: ADCMPEN Position         */
#define EADC_CMP2_ADCMPEN_Msk            (0x1ul << EADC_CMP2_ADCMPEN_Pos)                  /*!< EADC_T::CMP2: ADCMPEN Mask             */

#define EADC_CMP2_ADCMPIE_Pos            (1)                                               /*!< EADC_T::CMP2: ADCMPIE Position         */
#define EADC_CMP2_ADCMPIE_Msk            (0x1ul << EADC_CMP2_ADCMPIE_Pos)                  /*!< EADC_T::CMP2: ADCMPIE Mask             */

#define EADC_CMP2_CMPCOND_Pos            (2)                                               /*!< EADC_T::CMP2: CMPCOND Position         */
#define EADC_CMP2_CMPCOND_Msk            (0x1ul << EADC_CMP2_CMPCOND_Pos)                  /*!< EADC_T::CMP2: CMPCOND Mask             */

#define EADC_CMP2_CMPSPL_Pos             (3)                                               /*!< EADC_T::CMP2: CMPSPL Position          */
#define EADC_CMP2_CMPSPL_Msk             (0x1ful << EADC_CMP2_CMPSPL_Pos)                  /*!< EADC_T::CMP2: CMPSPL Mask              */

#define EADC_CMP2_CMPMCNT_Pos            (8)                                               /*!< EADC_T::CMP2: CMPMCNT Position         */
#define EADC_CMP2_CMPMCNT_Msk            (0xful << EADC_CMP2_CMPMCNT_Pos)                  /*!< EADC_T::CMP2: CMPMCNT Mask             */

#define EADC_CMP2_CMPWEN_Pos             (15)                                              /*!< EADC_T::CMP2: CMPWEN Position          */
#define EADC_CMP2_CMPWEN_Msk             (0x1ul << EADC_CMP2_CMPWEN_Pos)                   /*!< EADC_T::CMP2: CMPWEN Mask              */

#define EADC_CMP2_CMPDAT_Pos             (16)                                              /*!< EADC_T::CMP2: CMPDAT Position          */
#define EADC_CMP2_CMPDAT_Msk             (0xffful << EADC_CMP2_CMPDAT_Pos)                 /*!< EADC_T::CMP2: CMPDAT Mask              */

#define EADC_CMP3_ADCMPEN_Pos            (0)                                               /*!< EADC_T::CMP3: ADCMPEN Position         */
#define EADC_CMP3_ADCMPEN_Msk            (0x1ul << EADC_CMP3_ADCMPEN_Pos)                  /*!< EADC_T::CMP3: ADCMPEN Mask             */

#define EADC_CMP3_ADCMPIE_Pos            (1)                                               /*!< EADC_T::CMP3: ADCMPIE Position         */
#define EADC_CMP3_ADCMPIE_Msk            (0x1ul << EADC_CMP3_ADCMPIE_Pos)                  /*!< EADC_T::CMP3: ADCMPIE Mask             */

#define EADC_CMP3_CMPCOND_Pos            (2)                                               /*!< EADC_T::CMP3: CMPCOND Position         */
#define EADC_CMP3_CMPCOND_Msk            (0x1ul << EADC_CMP3_CMPCOND_Pos)                  /*!< EADC_T::CMP3: CMPCOND Mask             */

#define EADC_CMP3_CMPSPL_Pos             (3)                                               /*!< EADC_T::CMP3: CMPSPL Position          */
#define EADC_CMP3_CMPSPL_Msk             (0x1ful << EADC_CMP3_CMPSPL_Pos)                  /*!< EADC_T::CMP3: CMPSPL Mask              */

#define EADC_CMP3_CMPMCNT_Pos            (8)                                               /*!< EADC_T::CMP3: CMPMCNT Position         */
#define EADC_CMP3_CMPMCNT_Msk            (0xful << EADC_CMP3_CMPMCNT_Pos)                  /*!< EADC_T::CMP3: CMPMCNT Mask             */

#define EADC_CMP3_CMPWEN_Pos             (15)                                              /*!< EADC_T::CMP3: CMPWEN Position          */
#define EADC_CMP3_CMPWEN_Msk             (0x1ul << EADC_CMP3_CMPWEN_Pos)                   /*!< EADC_T::CMP3: CMPWEN Mask              */

#define EADC_CMP3_CMPDAT_Pos             (16)                                              /*!< EADC_T::CMP3: CMPDAT Position          */
#define EADC_CMP3_CMPDAT_Msk             (0xffful << EADC_CMP3_CMPDAT_Pos)                 /*!< EADC_T::CMP3: CMPDAT Mask              */

#define EADC_STATUS0_VALID_Pos           (0)                                               /*!< EADC_T::STATUS0: VALID Position        */
#define EADC_STATUS0_VALID_Msk           (0x1ffful << EADC_STATUS0_VALID_Pos)              /*!< EADC_T::STATUS0: VALID Mask            */

#define EADC_STATUS0_OV_Pos              (16)                                              /*!< EADC_T::STATUS0: OV Position           */
#define EADC_STATUS0_OV_Msk              (0x1ffful << EADC_STATUS0_OV_Pos)                 /*!< EADC_T::STATUS0: OV Mask               */

#define EADC_STATUS1_VALID_Pos           (0)                                               /*!< EADC_T::STATUS1: VALID Position        */
#define EADC_STATUS1_VALID_Msk           (0x3ul << EADC_STATUS1_VALID_Pos)                 /*!< EADC_T::STATUS1: VALID Mask            */

#define EADC_STATUS1_OV_Pos              (16)                                              /*!< EADC_T::STATUS1: OV Position           */
#define EADC_STATUS1_OV_Msk              (0x3ul << EADC_STATUS1_OV_Pos)                    /*!< EADC_T::STATUS1: OV Mask               */

#define EADC_STATUS2_ADIF0_Pos           (0)                                               /*!< EADC_T::STATUS2: ADIF0 Position        */
#define EADC_STATUS2_ADIF0_Msk           (0x1ul << EADC_STATUS2_ADIF0_Pos)                 /*!< EADC_T::STATUS2: ADIF0 Mask            */

#define EADC_STATUS2_ADIF1_Pos           (1)                                               /*!< EADC_T::STATUS2: ADIF1 Position        */
#define EADC_STATUS2_ADIF1_Msk           (0x1ul << EADC_STATUS2_ADIF1_Pos)                 /*!< EADC_T::STATUS2: ADIF1 Mask            */

#define EADC_STATUS2_ADIF2_Pos           (2)                                               /*!< EADC_T::STATUS2: ADIF2 Position        */
#define EADC_STATUS2_ADIF2_Msk           (0x1ul << EADC_STATUS2_ADIF2_Pos)                 /*!< EADC_T::STATUS2: ADIF2 Mask            */

#define EADC_STATUS2_ADIF3_Pos           (3)                                               /*!< EADC_T::STATUS2: ADIF3 Position        */
#define EADC_STATUS2_ADIF3_Msk           (0x1ul << EADC_STATUS2_ADIF3_Pos)                 /*!< EADC_T::STATUS2: ADIF3 Mask            */

#define EADC_STATUS2_ADCMPF0_Pos         (4)                                               /*!< EADC_T::STATUS2: ADCMPF0 Position      */
#define EADC_STATUS2_ADCMPF0_Msk         (0x1ul << EADC_STATUS2_ADCMPF0_Pos)               /*!< EADC_T::STATUS2: ADCMPF0 Mask          */

#define EADC_STATUS2_ADCMPF1_Pos         (5)                                               /*!< EADC_T::STATUS2: ADCMPF1 Position      */
#define EADC_STATUS2_ADCMPF1_Msk         (0x1ul << EADC_STATUS2_ADCMPF1_Pos)               /*!< EADC_T::STATUS2: ADCMPF1 Mask          */

#define EADC_STATUS2_ADCMPF2_Pos         (6)                                               /*!< EADC_T::STATUS2: ADCMPF2 Position      */
#define EADC_STATUS2_ADCMPF2_Msk         (0x1ul << EADC_STATUS2_ADCMPF2_Pos)               /*!< EADC_T::STATUS2: ADCMPF2 Mask          */

#define EADC_STATUS2_ADCMPF3_Pos         (7)                                               /*!< EADC_T::STATUS2: ADCMPF3 Position      */
#define EADC_STATUS2_ADCMPF3_Msk         (0x1ul << EADC_STATUS2_ADCMPF3_Pos)               /*!< EADC_T::STATUS2: ADCMPF3 Mask          */

#define EADC_STATUS2_ADOVIF0_Pos         (8)                                               /*!< EADC_T::STATUS2: ADOVIF0 Position      */
#define EADC_STATUS2_ADOVIF0_Msk         (0x1ul << EADC_STATUS2_ADOVIF0_Pos)               /*!< EADC_T::STATUS2: ADOVIF0 Mask          */

#define EADC_STATUS2_ADOVIF1_Pos         (9)                                               /*!< EADC_T::STATUS2: ADOVIF1 Position      */
#define EADC_STATUS2_ADOVIF1_Msk         (0x1ul << EADC_STATUS2_ADOVIF1_Pos)               /*!< EADC_T::STATUS2: ADOVIF1 Mask          */

#define EADC_STATUS2_ADOVIF2_Pos         (10)                                              /*!< EADC_T::STATUS2: ADOVIF2 Position      */
#define EADC_STATUS2_ADOVIF2_Msk         (0x1ul << EADC_STATUS2_ADOVIF2_Pos)               /*!< EADC_T::STATUS2: ADOVIF2 Mask          */

#define EADC_STATUS2_ADOVIF3_Pos         (11)                                              /*!< EADC_T::STATUS2: ADOVIF3 Position      */
#define EADC_STATUS2_ADOVIF3_Msk         (0x1ul << EADC_STATUS2_ADOVIF3_Pos)               /*!< EADC_T::STATUS2: ADOVIF3 Mask          */

#define EADC_STATUS2_ADCMPO0_Pos         (12)                                              /*!< EADC_T::STATUS2: ADCMPO0 Position      */
#define EADC_STATUS2_ADCMPO0_Msk         (0x1ul << EADC_STATUS2_ADCMPO0_Pos)               /*!< EADC_T::STATUS2: ADCMPO0 Mask          */

#define EADC_STATUS2_ADCMPO1_Pos         (13)                                              /*!< EADC_T::STATUS2: ADCMPO1 Position      */
#define EADC_STATUS2_ADCMPO1_Msk         (0x1ul << EADC_STATUS2_ADCMPO1_Pos)               /*!< EADC_T::STATUS2: ADCMPO1 Mask          */

#define EADC_STATUS2_ADCMPO2_Pos         (14)                                              /*!< EADC_T::STATUS2: ADCMPO2 Position      */
#define EADC_STATUS2_ADCMPO2_Msk         (0x1ul << EADC_STATUS2_ADCMPO2_Pos)               /*!< EADC_T::STATUS2: ADCMPO2 Mask          */

#define EADC_STATUS2_ADCMPO3_Pos         (15)                                              /*!< EADC_T::STATUS2: ADCMPO3 Position      */
#define EADC_STATUS2_ADCMPO3_Msk         (0x1ul << EADC_STATUS2_ADCMPO3_Pos)               /*!< EADC_T::STATUS2: ADCMPO3 Mask          */

#define EADC_STATUS2_CHANNEL_Pos         (16)                                              /*!< EADC_T::STATUS2: CHANNEL Position      */
#define EADC_STATUS2_CHANNEL_Msk         (0x1ful << EADC_STATUS2_CHANNEL_Pos)              /*!< EADC_T::STATUS2: CHANNEL Mask          */

#define EADC_STATUS2_BUSY_Pos            (23)                                              /*!< EADC_T::STATUS2: BUSY Position         */
#define EADC_STATUS2_BUSY_Msk            (0x1ul << EADC_STATUS2_BUSY_Pos)                  /*!< EADC_T::STATUS2: BUSY Mask             */

#define EADC_STATUS2_ADOVIF_Pos          (24)                                              /*!< EADC_T::STATUS2: ADOVIF Position       */
#define EADC_STATUS2_ADOVIF_Msk          (0x1ul << EADC_STATUS2_ADOVIF_Pos)                /*!< EADC_T::STATUS2: ADOVIF Mask           */

#define EADC_STATUS2_STOVF_Pos           (25)                                              /*!< EADC_T::STATUS2: STOVF Position        */
#define EADC_STATUS2_STOVF_Msk           (0x1ul << EADC_STATUS2_STOVF_Pos)                 /*!< EADC_T::STATUS2: STOVF Mask            */

#define EADC_STATUS2_AVALID_Pos          (26)                                              /*!< EADC_T::STATUS2: AVALID Position       */
#define EADC_STATUS2_AVALID_Msk          (0x1ul << EADC_STATUS2_AVALID_Pos)                /*!< EADC_T::STATUS2: AVALID Mask           */

#define EADC_STATUS2_AOV_Pos             (27)                                              /*!< EADC_T::STATUS2: AOV Position          */
#define EADC_STATUS2_AOV_Msk             (0x1ul << EADC_STATUS2_AOV_Pos)                   /*!< EADC_T::STATUS2: AOV Mask              */

#define EADC_STATUS3_CURSPL_Pos          (0)                                               /*!< EADC_T::STATUS3: CURSPL Position       */
#define EADC_STATUS3_CURSPL_Msk          (0x1ful << EADC_STATUS3_CURSPL_Pos)               /*!< EADC_T::STATUS3: CURSPL Mask           */

#define EADC_DDAT0_RESULT_Pos            (0)                                               /*!< EADC_T::DDAT0: RESULT Position         */
#define EADC_DDAT0_RESULT_Msk            (0xfffful << EADC_DDAT0_RESULT_Pos)               /*!< EADC_T::DDAT0: RESULT Mask             */

#define EADC_DDAT0_OV_Pos                (16)                                              /*!< EADC_T::DDAT0: OV Position             */
#define EADC_DDAT0_OV_Msk                (0x1ul << EADC_DDAT0_OV_Pos)                      /*!< EADC_T::DDAT0: OV Mask                 */

#define EADC_DDAT0_VALID_Pos             (17)                                              /*!< EADC_T::DDAT0: VALID Position          */
#define EADC_DDAT0_VALID_Msk             (0x1ul << EADC_DDAT0_VALID_Pos)                   /*!< EADC_T::DDAT0: VALID Mask              */

#define EADC_DDAT1_RESULT_Pos            (0)                                               /*!< EADC_T::DDAT1: RESULT Position         */
#define EADC_DDAT1_RESULT_Msk            (0xfffful << EADC_DDAT1_RESULT_Pos)               /*!< EADC_T::DDAT1: RESULT Mask             */

#define EADC_DDAT1_OV_Pos                (16)                                              /*!< EADC_T::DDAT1: OV Position             */
#define EADC_DDAT1_OV_Msk                (0x1ul << EADC_DDAT1_OV_Pos)                      /*!< EADC_T::DDAT1: OV Mask                 */

#define EADC_DDAT1_VALID_Pos             (17)                                              /*!< EADC_T::DDAT1: VALID Position          */
#define EADC_DDAT1_VALID_Msk             (0x1ul << EADC_DDAT1_VALID_Pos)                   /*!< EADC_T::DDAT1: VALID Mask              */

#define EADC_DDAT2_RESULT_Pos            (0)                                               /*!< EADC_T::DDAT2: RESULT Position         */
#define EADC_DDAT2_RESULT_Msk            (0xfffful << EADC_DDAT2_RESULT_Pos)               /*!< EADC_T::DDAT2: RESULT Mask             */

#define EADC_DDAT2_OV_Pos                (16)                                              /*!< EADC_T::DDAT2: OV Position             */
#define EADC_DDAT2_OV_Msk                (0x1ul << EADC_DDAT2_OV_Pos)                      /*!< EADC_T::DDAT2: OV Mask                 */

#define EADC_DDAT2_VALID_Pos             (17)                                              /*!< EADC_T::DDAT2: VALID Position          */
#define EADC_DDAT2_VALID_Msk             (0x1ul << EADC_DDAT2_VALID_Pos)                   /*!< EADC_T::DDAT2: VALID Mask              */

#define EADC_DDAT3_RESULT_Pos            (0)                                               /*!< EADC_T::DDAT3: RESULT Position         */
#define EADC_DDAT3_RESULT_Msk            (0xfffful << EADC_DDAT3_RESULT_Pos)               /*!< EADC_T::DDAT3: RESULT Mask             */

#define EADC_DDAT3_OV_Pos                (16)                                              /*!< EADC_T::DDAT3: OV Position             */
#define EADC_DDAT3_OV_Msk                (0x1ul << EADC_DDAT3_OV_Pos)                      /*!< EADC_T::DDAT3: OV Mask                 */

#define EADC_DDAT3_VALID_Pos             (17)                                              /*!< EADC_T::DDAT3: VALID Position          */
#define EADC_DDAT3_VALID_Msk             (0x1ul << EADC_DDAT3_VALID_Pos)                   /*!< EADC_T::DDAT3: VALID Mask              */

#define EADC_PWRM_PWUPRDY_Pos            (0)                                               /*!< EADC_T::PWRM: PWUPRDY Position         */
#define EADC_PWRM_PWUPRDY_Msk            (0x1ul << EADC_PWRM_PWUPRDY_Pos)                  /*!< EADC_T::PWRM: PWUPRDY Mask             */

#define EADC_PWRM_PWDCALEN_Pos           (1)                                               /*!< EADC_T::PWRM: PWDCALEN Position        */
#define EADC_PWRM_PWDCALEN_Msk           (0x1ul << EADC_PWRM_PWDCALEN_Pos)                 /*!< EADC_T::PWRM: PWDCALEN Mask            */

#define EADC_PWRM_PWDMOD_Pos             (2)                                               /*!< EADC_T::PWRM: PWDMOD Position          */
#define EADC_PWRM_PWDMOD_Msk             (0x3ul << EADC_PWRM_PWDMOD_Pos)                   /*!< EADC_T::PWRM: PWDMOD Mask              */

#define EADC_PWRM_PWAWARE_Pos            (4)                                               /*!< EADC_T::PWRM: PWAWARE Position         */
#define EADC_PWRM_PWAWARE_Msk            (0x1ul << EADC_PWRM_PWAWARE_Pos)                  /*!< EADC_T::PWRM: PWAWARE Mask             */

#define EADC_PWRM_LDOSTB_Pos             (8)                                               /*!< EADC_T::PWRM: LDOSTB Position          */
#define EADC_PWRM_LDOSTB_Msk             (0xffful << EADC_PWRM_LDOSTB_Pos)                 /*!< EADC_T::PWRM: LDOSTB Mask              */

#define EADC_CALCTL_CALEN_Pos            (0)                                               /*!< EADC_T::CALCTL: CALEN Position         */
#define EADC_CALCTL_CALEN_Msk            (0x1ul << EADC_CALCTL_CALEN_Pos)                  /*!< EADC_T::CALCTL: CALEN Mask             */

#define EADC_CALCTL_CALSTART_Pos         (1)                                               /*!< EADC_T::CALCTL: CALSTART Position      */
#define EADC_CALCTL_CALSTART_Msk         (0x1ul << EADC_CALCTL_CALSTART_Pos)               /*!< EADC_T::CALCTL: CALSTART Mask          */

#define EADC_CALCTL_CALDONE_Pos          (2)                                               /*!< EADC_T::CALCTL: CALDONE Position       */
#define EADC_CALCTL_CALDONE_Msk          (0x1ul << EADC_CALCTL_CALDONE_Pos)                /*!< EADC_T::CALCTL: CALDONE Mask           */

#define EADC_CALCTL_CALSEL_Pos           (3)                                               /*!< EADC_T::CALCTL: CALSEL Position        */
#define EADC_CALCTL_CALSEL_Msk           (0x1ul << EADC_CALCTL_CALSEL_Pos)                 /*!< EADC_T::CALCTL: CALSEL Mask            */

#define EADC_CALDWRD_CALWORD_Pos         (0)                                               /*!< EADC_T::CALDWRD: CALWORD Position      */
#define EADC_CALDWRD_CALWORD_Msk         (0x7ful << EADC_CALDWRD_CALWORD_Pos)              /*!< EADC_T::CALDWRD: CALWORD Mask          */

/**@}*/ /* EADC_CONST */
/**@}*/ /* end of EADC register group */


/*---------------------- Flash Memory Controller -------------------------*/
/**
    @addtogroup FMC Flash Memory Controller(FMC)
    Memory Mapped Structure for FMC Controller
@{ */
 
typedef struct
{


/**
 * @var FMC_T::ISPCTL
 * Offset: 0x00  ISP Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ISPEN     |ISP Enable Bit (Write Protect)
 * |        |          |ISP function enable bit. Set this bit to enable ISP function.
 * |        |          |0 = ISP function Disabled.
 * |        |          |1 = ISP function Enabled.
 * |[1]     |BS        |Boot Select (Write Protect)
 * |        |          |Set/clear this bit to select next booting from LDROM/APROM, respectively
 * |        |          |This bit also functions as chip booting status flag, which can be used to check where chip booted from
 * |        |          |This bit is initiated with the inversed value of CBS in CONFIG0 after any reset is happened except CPU reset (RSTS_CPU is 1) or system reset (RSTS_SYS) is happened
 * |        |          |0 = Boot from APROM.
 * |        |          |1 = Boot from LDROM.
 * |[3]     |APUEN     |APROM Update Enable Bit (Write Protect)
 * |        |          |0 = APROM cannot be updated when the chip runs in APROM.
 * |        |          |1 = APROM can be updated when the chip runs in APROM.
 * |[4]     |CFGUEN    |Config-Bits Update By ISP Enable Bit(Write Protect)
 * |        |          |0 = ISP Disabled to update config-bits.
 * |        |          |1 = ISP Enabled to update config-bits.
 * |[5]     |LDUEN     |LDROM Update Enable Bit (Write Protect)
 * |        |          |LDROM update enable bit.
 * |        |          |0 = LDROM cannot be updated.
 * |        |          |1 = LDROM can be updated.
 * |[6]     |ISPFF     |ISP Fail Flag (Write Protect)
 * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
 * |        |          |(1) APROM writes to itself if APUEN is set to 0.
 * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
 * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
 * |        |          |(4) Destination address is illegal, such as over an available range.
 * |        |          |Note: This bit needs to be cleared by writing 1 to it.
 * @var FMC_T::ISPADDR
 * Offset: 0x04  ISP Address Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |ISPADDR   |ISP Address
 * |        |          |The I94120 series is equipped with an embedded
 * |        |          |ISPADDR[1:0] must be kept 00 for ISP 32-bit operation
 * |        |          |ISPADDR[2:0] must be kept 000 for ISP 64-bit operation.
 * |        |          |For CRC32 Checksum Calculation command, this field is the flash starting address for checksum calculation, 2 Kbytes alignment is necessary for CRC32 checksum calculation.
 * |        |          |For FLASH 32-bit Program, ISP address needs word alignment (4-byte)
 * |        |          |For FLASH 64-bit Program, ISP address needs double word alignment (8-byte).
 * @var FMC_T::ISPDAT
 * Offset: 0x08  ISP Data Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |ISPDAT    |ISP Data
 * |        |          |Write data to this register before ISP program operation.
 * |        |          |Read data from this register after ISP read operation.
 * |        |          |When ISPFF (FMC_ISPCTL[6]) is 1, ISPDAT = 0xffff_ffff
 * |        |          |For Run CRC32 Checksum Calculation command, ISPDAT is the memory size (byte) and 2 Kbytes alignment
 * |        |          |For ISP Read CRC32 Checksum command, ISPDAT is the checksum result
 * |        |          |If ISPDAT = 0x0000_0000, it means that (1) the checksum calculation is in progress, or (2) the memory range for checksum calculation is incorrect
 * @var FMC_T::ISPCMD
 * Offset: 0x0C  ISP Command Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[6:0]   |CMD       |ISP Command
 * |        |          |ISP command table is shown below:
 * |        |          |0x00= FLASH Read.
 * |        |          |0x04= Read Unique ID.
 * |        |          |0x08= Read Flash All-One Result.
 * |        |          |0x0B= Read Company ID.
 * |        |          |0x0C= Read Device ID.
 * |        |          |0x0D= Read Checksum.
 * |        |          |0x21= FLASH 32-bit Program.
 * |        |          |0x22= FLASH Page Erase. Erase page
 * |        |          |0x23= FLASH Bank Erase. Erase all pages of APROM.
 * |        |          |0x25= FLASH Block Erase Erase four pages alignment of APROM.
 * |        |          |0x27= FLASH Multi-Word Program.
 * |        |          |0x28= Run Flash All-One Verification.
 * |        |          |0x2D= Run Checksum Calculation.
 * |        |          |0x2E= Vector Remap.
 * |        |          |0x40= FLASH 64-bit Read.
 * |        |          |0x61= FLASH 64-bit Program.
 * |        |          |The other commands are invalid.
 * @var FMC_T::ISPTRG
 * Offset: 0x10  ISP Trigger Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ISPGO     |ISP Start Trigger (Write Protect)
 * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.
 * |        |          |0 = ISP operation is finished.
 * |        |          |1 = ISP is progressed.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * @var FMC_T::DFBA
 * Offset: 0x14  Data Flash Base Address
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |DFBA      |Data Flash Base Address
 * |        |          |This register indicates Data Flash start address. It is a read only register.
 * |        |          |The Data Flash is shared with APROM. the content of this register is loaded from CONFIG1
 * |        |          |This register is valid when DFEN (CONFIG0[0]) =0 .
 * @var FMC_T::FTCTL
 * Offset: 0x18  Flash Access Time Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var FMC_T::ISPSTS
 * Offset: 0x40  ISP Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ISPBUSY   |ISP Busy Flag
 * |        |          |0 = ISP operation is finished.
 * |        |          |1 = ISP is progressed.
 * |        |          |Note: The reset value of this bit is 0.
 * |[2:1]   |CBS       |Chip Boot Selection Mode
 * |        |          |This CBS field is just a copy of flash controller user configuration register CBS (CONFIG0 [7:6]).
 * |        |          |Note: The reset value of FMC_ISPSTS[3] is 0.
 * |[6]     |ISPFF     |ISP Fail Flag (Read Only)
 * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
 * |        |          |(1) APROM writes to itself if APUEN is set to 0.
 * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
 * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
 * |        |          |(4) Destination address is illegal, such as over an available range.
 * |[20:9]  |VECMAP    |Vector Page Mapping Address (Read Only)
 * |        |          |The current flash address space 0x0000_0000~0x0000_07FF is mapping to address {VECMAP[11:2], 11'h000} ~ {VECMAP[11:2], 11'h7FF}
 * |        |          |VECMAP[1:0] is needed to set 0.
 * |        |          |Note: The reset value of this field is reloaded base on BS (CONFIG0[1]).
 * |[26]    |CFGCRCF   |User-Configuration CRC CheckFlag (Read Only)
 * |        |          |This bit is set by hardware when detecting CONFIG CRC checksum is error
 * |        |          |0 = CONFIG CRC checksum is OK.
 * |        |          |1 = CONFIG CRC checksum error and force chip into LOCK mode.
 * @var FMC_T::MPDAT0
 * Offset: 0x80  ISP Multi-Word Program Data0 Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |ISPDAT0   |ISP Data 0
 * |        |          |This register is the first 32-bit data for 32-bit/64-bit/multi-word programming, and it is also the mirror of FMC_ISPDAT, both registers keep the same data
 * @var FMC_T::MPDAT1
 * Offset: 0x84  ISP Multi-Word Program Data1 Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |ISPDAT1   |ISP Data 1
 * |        |          |This register is the second 32-bit data for 64-bit/multi-word programming.
 * @var FMC_T::MPDAT2
 * Offset: 0x88  ISP Multi-Word Program Data2 Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |ISPDAT2   |ISP Data 2
 * |        |          |This register is the third 32-bit data for multi-word programming.
 * @var FMC_T::MPDAT3
 * Offset: 0x8C  ISP Multi-Word Program Data3 Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |ISPDAT3   |ISP Data 3
 * |        |          |This register is the fourth 32-bit data for multi-word programming.
 * @var FMC_T::MPSTS
 * Offset: 0xC0  ISP Multi-Word Program Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |MPBUSY    |ISP Multi-word Program Busy Flag (Read Only)
 * |        |          |Write 1 to start ISP Multi-Word program operation and this bit will be cleared to 0 by hardware automatically when ISP Multi-Word program operation is finished.
 * |        |          |This bit is the mirror of ISPGO(FMC_ISPTRG[0]).
 * |        |          |0 = ISP Multi-Word program operation is finished.
 * |        |          |1 = ISP Multi-Word program operation is progressed.
 * |[1]     |PPGO      |ISP Multi-program Status (Read Only)
 * |        |          |0 = ISP multi-word program operation is not active.
 * |        |          |1 = ISP multi-word program operation is in progress.
 * |[2]     |ISPFF     |ISP Fail Flag (Read Only)
 * |        |          |This bit is the mirror of ISPFF (FMC_ISPCTL[6]), it needs to be cleared by writing 1 to FMC_ISPCTL[6] or FMC_ISPSTS[6]
 * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
 * |        |          |(1) APROM writes to itself if APUEN is set to 0.
 * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
 * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
 * |        |          |(4) SPROM is erased/programmed if SPUEN is set to 0
 * |        |          |(5) SPROM is programmed at SPROM secured mode.
 * |        |          |(6) Page Erase command at LOCK mode with ICE connection
 * |        |          |(7) Erase or Program command at brown-out detected
 * |        |          |(8) Destination address is illegal, such as over an available range.
 * |        |          |(9) Invalid ISP commands
 * |        |          |(10) Vector address is mapping to SPROM region.
 * |[4]     |D0        |ISP DATA 0 Flag (Read Only)
 * |        |          |This bit is set when FMC_MPDAT0 is written and auto-clear to 0 when the FMC_MPDAT0 data is programmed to flash complete.
 * |        |          |0 = FMC_MPDAT0 register is empty, or program to flash complete.
 * |        |          |1 = FMC_MPDAT0 register has been written, and not program to flash complete.
 * |[5]     |D1        |ISP DATA 1 Flag (Read Only)
 * |        |          |This bit is set when FMC_MPDAT1 is written and auto-clear to 0 when the FMC_MPDAT1 data is programmed to flash complete.
 * |        |          |0 = FMC_MPDAT1 register is empty, or program to flash complete.
 * |        |          |1 = FMC_MPDAT1 register has been written, and not program to flash complete.
 * |[6]     |D2        |ISP DATA 2 Flag (Read Only)
 * |        |          |This bit is set when FMC_MPDAT2 is written and auto-clear to 0 when the FMC_MPDAT2 data is programmed to flash complete.
 * |        |          |0 = FMC_MPDAT2 register is empty, or program to flash complete.
 * |        |          |1 = FMC_MPDAT2 register has been written, and not program to flash complete.
 * |[7]     |D3        |ISP DATA 3 Flag (Read Only)
 * |        |          |This bit is set when FMC_MPDAT3 is written and auto-clear to 0 when the FMC_MPDAT3 data is programmed to flash complete.
 * |        |          |0 = FMC_MPDAT3 register is empty, or program to flash complete.
 * |        |          |1 = FMC_MPDAT3 register has been written, and not program to flash complete.
 * @var FMC_T::MPADDR
 * Offset: 0xC4  ISP Multi-Word Program Address Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |MPADDR    |ISP Multi-word Program Address
 * |        |          |MPADDR is the address of ISP multi-word program operation when ISPGO flag is 1.
 * |        |          |MPADDR will keep the final ISP address when ISP multi-word program is complete.
 */
    __IO uint32_t ISPCTL;                /*!< [0x0000] ISP Control Register                                             */
    __IO uint32_t ISPADDR;               /*!< [0x0004] ISP Address Register                                             */
    __IO uint32_t ISPDAT;                /*!< [0x0008] ISP Data Register                                                */
    __IO uint32_t ISPCMD;                /*!< [0x000c] ISP Command Register                                             */
    __IO uint32_t ISPTRG;                /*!< [0x0010] ISP Trigger Register                                             */
    __I  uint32_t DFBA;                  /*!< [0x0014] Data Flash Base Address                                          */
    __IO uint32_t FTCTL;                 /*!< [0x0018] Flash Access Time Control Register                               */
		__IO uint32_t ICPCTL;                     /*!< Offset: 0x001C   ICP Enabled Control Register                       */
//    __I  uint32_t RESERVE0[8];
__IO uint32_t RMPCON;
__I  uint32_t RESERVE0[7];
    __IO uint32_t ISPSTS;                /*!< [0x0040] ISP Status Register                                              */
    __I  uint32_t RESERVE1[15];
    __IO uint32_t MPDAT0;                /*!< [0x0080] ISP Multi-Word Program Data0 Register                            */
    __IO uint32_t MPDAT1;                /*!< [0x0084] ISP Multi-Word Program Data1 Register                            */
    __IO uint32_t MPDAT2;                /*!< [0x0088] ISP Multi-Word Program Data2 Register                            */
    __IO uint32_t MPDAT3;                /*!< [0x008c] ISP Multi-Word Program Data3 Register                            */
    __I  uint32_t RESERVE2[12];
    __I  uint32_t MPSTS;                 /*!< [0x00c0] ISP Multi-Word Program Status Register                           */
    __I  uint32_t MPADDR;                /*!< [0x00c4] ISP Multi-Word Program Address Status Register                   */

} FMC_T;

/**
    @addtogroup FMC_CONST FMC Bit Field Definition
    Constant Definitions for FMC Controller
@{ */

#define FMC_ISPCTL_ISPEN_Pos             (0)                                               /*!< FMC_T::ISPCTL: ISPEN Position          */
#define FMC_ISPCTL_ISPEN_Msk             (0x1ul << FMC_ISPCTL_ISPEN_Pos)                   /*!< FMC_T::ISPCTL: ISPEN Mask              */

#define FMC_ISPCTL_BS_Pos                (1)                                               /*!< FMC_T::ISPCTL: BS Position             */
#define FMC_ISPCTL_BS_Msk                (0x1ul << FMC_ISPCTL_BS_Pos)                      /*!< FMC_T::ISPCTL: BS Mask                 */

#define FMC_ISPCTL_APUEN_Pos             (3)                                               /*!< FMC_T::ISPCTL: APUEN Position          */
#define FMC_ISPCTL_APUEN_Msk             (0x1ul << FMC_ISPCTL_APUEN_Pos)                   /*!< FMC_T::ISPCTL: APUEN Mask              */

#define FMC_ISPCTL_CFGUEN_Pos            (4)                                               /*!< FMC_T::ISPCTL: CFGUEN Position         */
#define FMC_ISPCTL_CFGUEN_Msk            (0x1ul << FMC_ISPCTL_CFGUEN_Pos)                  /*!< FMC_T::ISPCTL: CFGUEN Mask             */

#define FMC_ISPCTL_LDUEN_Pos             (5)                                               /*!< FMC_T::ISPCTL: LDUEN Position          */
#define FMC_ISPCTL_LDUEN_Msk             (0x1ul << FMC_ISPCTL_LDUEN_Pos)                   /*!< FMC_T::ISPCTL: LDUEN Mask              */

#define FMC_ISPCTL_ISPFF_Pos             (6)                                               /*!< FMC_T::ISPCTL: ISPFF Position          */
#define FMC_ISPCTL_ISPFF_Msk             (0x1ul << FMC_ISPCTL_ISPFF_Pos)                   /*!< FMC_T::ISPCTL: ISPFF Mask              */

#define FMC_ISPADDR_ISPADDR_Pos          (0)                                               /*!< FMC_T::ISPADDR: ISPADDR Position       */
#define FMC_ISPADDR_ISPADDR_Msk          (0xfffffffful << FMC_ISPADDR_ISPADDR_Pos)         /*!< FMC_T::ISPADDR: ISPADDR Mask           */

#define FMC_ISPDAT_ISPDAT_Pos            (0)                                               /*!< FMC_T::ISPDAT: ISPDAT Position         */
#define FMC_ISPDAT_ISPDAT_Msk            (0xfffffffful << FMC_ISPDAT_ISPDAT_Pos)           /*!< FMC_T::ISPDAT: ISPDAT Mask             */

#define FMC_ISPCMD_CMD_Pos               (0)                                               /*!< FMC_T::ISPCMD: CMD Position            */
#define FMC_ISPCMD_CMD_Msk               (0x7ful << FMC_ISPCMD_CMD_Pos)                    /*!< FMC_T::ISPCMD: CMD Mask                */

#define FMC_ISPTRG_ISPGO_Pos             (0)                                               /*!< FMC_T::ISPTRG: ISPGO Position          */
#define FMC_ISPTRG_ISPGO_Msk             (0x1ul << FMC_ISPTRG_ISPGO_Pos)                   /*!< FMC_T::ISPTRG: ISPGO Mask              */

#define FMC_DFBA_DFBA_Pos                (0)                                               /*!< FMC_T::DFBA: DFBA Position             */
#define FMC_DFBA_DFBA_Msk                (0xfffffffful << FMC_DFBA_DFBA_Pos)               /*!< FMC_T::DFBA: DFBA Mask                 */

#define FMC_ISPSTS_ISPBUSY_Pos           (0)                                               /*!< FMC_T::ISPSTS: ISPBUSY Position        */
#define FMC_ISPSTS_ISPBUSY_Msk           (0x1ul << FMC_ISPSTS_ISPBUSY_Pos)                 /*!< FMC_T::ISPSTS: ISPBUSY Mask            */

#define FMC_ISPSTS_CBS_Pos               (1)                                               /*!< FMC_T::ISPSTS: CBS Position            */
#define FMC_ISPSTS_CBS_Msk               (0x3ul << FMC_ISPSTS_CBS_Pos)                     /*!< FMC_T::ISPSTS: CBS Mask                */

#define FMC_ISPSTS_ISPFF_Pos             (6)                                               /*!< FMC_T::ISPSTS: ISPFF Position          */
#define FMC_ISPSTS_ISPFF_Msk             (0x1ul << FMC_ISPSTS_ISPFF_Pos)                   /*!< FMC_T::ISPSTS: ISPFF Mask              */

#define FMC_ISPSTS_VECMAP_Pos            (9)                                               /*!< FMC_T::ISPSTS: VECMAP Position         */
#define FMC_ISPSTS_VECMAP_Msk            (0xffful << FMC_ISPSTS_VECMAP_Pos)                /*!< FMC_T::ISPSTS: VECMAP Mask             */

#define FMC_ISPSTS_CFGCRCF_Pos           (26)                                              /*!< FMC_T::ISPSTS: CFGCRCF Position        */
#define FMC_ISPSTS_CFGCRCF_Msk           (0x1ul << FMC_ISPSTS_CFGCRCF_Pos)                 /*!< FMC_T::ISPSTS: CFGCRCF Mask            */

#define FMC_MPDAT0_ISPDAT0_Pos           (0)                                               /*!< FMC_T::MPDAT0: ISPDAT0 Position        */
#define FMC_MPDAT0_ISPDAT0_Msk           (0xfffffffful << FMC_MPDAT0_ISPDAT0_Pos)          /*!< FMC_T::MPDAT0: ISPDAT0 Mask            */

#define FMC_MPDAT1_ISPDAT1_Pos           (0)                                               /*!< FMC_T::MPDAT1: ISPDAT1 Position        */
#define FMC_MPDAT1_ISPDAT1_Msk           (0xfffffffful << FMC_MPDAT1_ISPDAT1_Pos)          /*!< FMC_T::MPDAT1: ISPDAT1 Mask            */

#define FMC_MPDAT2_ISPDAT2_Pos           (0)                                               /*!< FMC_T::MPDAT2: ISPDAT2 Position        */
#define FMC_MPDAT2_ISPDAT2_Msk           (0xfffffffful << FMC_MPDAT2_ISPDAT2_Pos)          /*!< FMC_T::MPDAT2: ISPDAT2 Mask            */

#define FMC_MPDAT3_ISPDAT3_Pos           (0)                                               /*!< FMC_T::MPDAT3: ISPDAT3 Position        */
#define FMC_MPDAT3_ISPDAT3_Msk           (0xfffffffful << FMC_MPDAT3_ISPDAT3_Pos)          /*!< FMC_T::MPDAT3: ISPDAT3 Mask            */

#define FMC_MPSTS_MPBUSY_Pos             (0)                                               /*!< FMC_T::MPSTS: MPBUSY Position          */
#define FMC_MPSTS_MPBUSY_Msk             (0x1ul << FMC_MPSTS_MPBUSY_Pos)                   /*!< FMC_T::MPSTS: MPBUSY Mask              */

#define FMC_MPSTS_PPGO_Pos               (1)                                               /*!< FMC_T::MPSTS: PPGO Position            */
#define FMC_MPSTS_PPGO_Msk               (0x1ul << FMC_MPSTS_PPGO_Pos)                     /*!< FMC_T::MPSTS: PPGO Mask                */

#define FMC_MPSTS_ISPFF_Pos              (2)                                               /*!< FMC_T::MPSTS: ISPFF Position           */
#define FMC_MPSTS_ISPFF_Msk              (0x1ul << FMC_MPSTS_ISPFF_Pos)                    /*!< FMC_T::MPSTS: ISPFF Mask               */

#define FMC_MPSTS_D0_Pos                 (4)                                               /*!< FMC_T::MPSTS: D0 Position              */
#define FMC_MPSTS_D0_Msk                 (0x1ul << FMC_MPSTS_D0_Pos)                       /*!< FMC_T::MPSTS: D0 Mask                  */

#define FMC_MPSTS_D1_Pos                 (5)                                               /*!< FMC_T::MPSTS: D1 Position              */
#define FMC_MPSTS_D1_Msk                 (0x1ul << FMC_MPSTS_D1_Pos)                       /*!< FMC_T::MPSTS: D1 Mask                  */

#define FMC_MPSTS_D2_Pos                 (6)                                               /*!< FMC_T::MPSTS: D2 Position              */
#define FMC_MPSTS_D2_Msk                 (0x1ul << FMC_MPSTS_D2_Pos)                       /*!< FMC_T::MPSTS: D2 Mask                  */

#define FMC_MPSTS_D3_Pos                 (7)                                               /*!< FMC_T::MPSTS: D3 Position              */
#define FMC_MPSTS_D3_Msk                 (0x1ul << FMC_MPSTS_D3_Pos)                       /*!< FMC_T::MPSTS: D3 Mask                  */

#define FMC_MPADDR_MPADDR_Pos            (0)                                               /*!< FMC_T::MPADDR: MPADDR Position         */
#define FMC_MPADDR_MPADDR_Msk            (0xfffffffful << FMC_MPADDR_MPADDR_Pos)           /*!< FMC_T::MPADDR: MPADDR Mask             */

/**@}*/ /* FMC_CONST */
/**@}*/ /* end of FMC register group */


/*---------------------- General Purpose Input/Output Controller -------------------------*/
/**
    @addtogroup GPIO General Purpose Input/Output Controller(GPIO)
    Memory Mapped Structure for GPIO Controller
@{ */
 
typedef struct
{


/**
 * @var GPIO_T::PA_MODE
 * Offset: 0x00  PA I/O Mode Control
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |MODE0     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3:2]   |MODE1     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5:4]   |MODE2     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7:6]   |MODE3     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9:8]   |MODE4     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11:10] |MODE5     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13:12] |MODE6     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15:14] |MODE7     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[17:16] |MODE8     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[19:18] |MODE9     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[21:20] |MODE10    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[23:22] |MODE11    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[25:24] |MODE12    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[27:26] |MODE13    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[29:28] |MODE14    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[31:30] |MODE15    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA_DINOFF
 * Offset: 0x04  PA Digital Input Path Disable Control
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[16]    |DINOFF0   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[17]    |DINOFF1   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[18]    |DINOFF2   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[19]    |DINOFF3   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[20]    |DINOFF4   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[21]    |DINOFF5   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[22]    |DINOFF6   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[23]    |DINOFF7   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[24]    |DINOFF8   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[25]    |DINOFF9   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[26]    |DINOFF10  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[27]    |DINOFF11  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[28]    |DINOFF12  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[29]    |DINOFF13  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[30]    |DINOFF14  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[31]    |DINOFF15  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA_DOUT
 * Offset: 0x08  PA Data Output Value
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |DOUT0     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |DOUT1     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |DOUT2     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |DOUT3     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |DOUT4     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |DOUT5     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |DOUT6     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |DOUT7     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |DOUT8     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |DOUT9     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |DOUT10    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |DOUT11    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |DOUT12    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |DOUT13    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |DOUT14    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |DOUT15    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA_DATMSK
 * Offset: 0x0C  PA Data Output Write Mask
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |DATMSK0   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |DATMSK1   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |DATMSK2   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |DATMSK3   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |DATMSK4   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |DATMSK5   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |DATMSK6   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |DATMSK7   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |DATMSK8   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |DATMSK9   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |DATMSK10  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |DATMSK11  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |DATMSK12  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |DATMSK13  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |DATMSK14  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |DATMSK15  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA_PIN
 * Offset: 0x10  PA Pin Value
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PIN0      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |PIN1      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |PIN2      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |PIN3      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |PIN4      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |PIN5      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |PIN6      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |PIN7      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |PIN8      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |PIN9      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |PIN10     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |PIN11     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |PIN12     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |PIN13     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |PIN14     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |PIN15     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA_DBEN
 * Offset: 0x14  PA De-Bounce Enable Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |DBEN0     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |DBEN1     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |DBEN2     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |DBEN3     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |DBEN4     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |DBEN5     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |DBEN6     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |DBEN7     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |DBEN8     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |DBEN9     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |DBEN10    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |DBEN11    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |DBEN12    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |DBEN13    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |DBEN14    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |DBEN15    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA_INTTYPE
 * Offset: 0x18  PA Interrupt Trigger Type Control
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |TYPE0     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |TYPE1     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |TYPE2     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |TYPE3     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |TYPE4     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |TYPE5     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |TYPE6     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |TYPE7     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |TYPE8     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |TYPE9     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |TYPE10    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |TYPE11    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |TYPE12    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |TYPE13    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |TYPE14    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |TYPE15    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA_INTEN
 * Offset: 0x1C  PA Interrupt Enable Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |FLIEN0    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |FLIEN1    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |FLIEN2    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |FLIEN3    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |FLIEN4    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |FLIEN5    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |FLIEN6    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |FLIEN7    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |FLIEN8    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |FLIEN9    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |FLIEN10   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |FLIEN11   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |FLIEN12   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |FLIEN13   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |FLIEN14   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |FLIEN15   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[16]    |RHIEN0    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[17]    |RHIEN1    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[18]    |RHIEN2    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[19]    |RHIEN3    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[20]    |RHIEN4    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[21]    |RHIEN5    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[22]    |RHIEN6    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[23]    |RHIEN7    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[24]    |RHIEN8    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[25]    |RHIEN9    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[26]    |RHIEN10   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[27]    |RHIEN11   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[28]    |RHIEN12   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[29]    |RHIEN13   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[30]    |RHIEN14   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[31]    |RHIEN15   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA_INTSRC
 * Offset: 0x20  PA Interrupt Source Flag
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |INTSRC0   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |INTSRC1   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |INTSRC2   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |INTSRC3   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |INTSRC4   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |INTSRC5   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |INTSRC6   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |INTSRC7   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |INTSRC8   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |INTSRC9   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |INTSRC10  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |INTSRC11  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |INTSRC12  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |INTSRC13  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |INTSRC14  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |INTSRC15  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA_SMTEN
 * Offset: 0x24  PA Input Schmitt Trigger Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |SMTEN0    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |SMTEN1    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |SMTEN2    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |SMTEN3    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |SMTEN4    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |SMTEN5    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |SMTEN6    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |SMTEN7    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |SMTEN8    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |SMTEN9    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |SMTEN10   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |SMTEN11   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |SMTEN12   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |SMTEN13   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |SMTEN14   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |SMTEN15   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA_SLEWCTL
 * Offset: 0x28  PA High Slew Rate Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |HSREN0    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3:2]   |HSREN1    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5:4]   |HSREN2    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7:6]   |HSREN3    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9:8]   |HSREN4    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11:10] |HSREN5    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13:12] |HSREN6    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15:14] |HSREN7    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[17:16] |HSREN8    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[19:18] |HSREN9    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[21:20] |HSREN10   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[23:22] |HSREN11   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[25:24] |HSREN12   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[27:26] |HSREN13   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[29:28] |HSREN14   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[31:30] |HSREN15   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA_PUSEL
 * Offset: 0x30  PA Pull-up and Pull-down Selection Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |PUSEL0    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3:2]   |PUSEL1    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5:4]   |PUSEL2    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7:6]   |PUSEL3    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9:8]   |PUSEL4    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11:10] |PUSEL5    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13:12] |PUSEL6    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15:14] |PUSEL7    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[17:16] |PUSEL8    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[19:18] |PUSEL9    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[21:20] |PUSEL10   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[23:22] |PUSEL11   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[25:24] |PUSEL12   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[27:26] |PUSEL13   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[29:28] |PUSEL14   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[31:30] |PUSEL15   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PB_MODE
 * Offset: 0x40  PB I/O Mode Control
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |MODE0     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3:2]   |MODE1     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5:4]   |MODE2     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7:6]   |MODE3     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9:8]   |MODE4     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11:10] |MODE5     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13:12] |MODE6     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15:14] |MODE7     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[17:16] |MODE8     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[19:18] |MODE9     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[21:20] |MODE10    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[23:22] |MODE11    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[25:24] |MODE12    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[27:26] |MODE13    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[29:28] |MODE14    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[31:30] |MODE15    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PB_DINOFF
 * Offset: 0x44  PB Digital Input Path Disable Control
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[16]    |DINOFF0   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[17]    |DINOFF1   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[18]    |DINOFF2   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[19]    |DINOFF3   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[20]    |DINOFF4   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[21]    |DINOFF5   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[22]    |DINOFF6   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[23]    |DINOFF7   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[24]    |DINOFF8   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[25]    |DINOFF9   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[26]    |DINOFF10  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[27]    |DINOFF11  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[28]    |DINOFF12  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[29]    |DINOFF13  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[30]    |DINOFF14  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[31]    |DINOFF15  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PB_DOUT
 * Offset: 0x48  PB Data Output Value
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |DOUT0     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |DOUT1     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |DOUT2     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |DOUT3     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |DOUT4     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |DOUT5     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |DOUT6     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |DOUT7     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |DOUT8     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |DOUT9     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |DOUT10    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |DOUT11    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |DOUT12    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |DOUT13    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |DOUT14    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |DOUT15    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PB_DATMSK
 * Offset: 0x4C  PB Data Output Write Mask
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |DATMSK0   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |DATMSK1   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |DATMSK2   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |DATMSK3   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |DATMSK4   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |DATMSK5   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |DATMSK6   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |DATMSK7   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |DATMSK8   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |DATMSK9   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |DATMSK10  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |DATMSK11  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |DATMSK12  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |DATMSK13  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |DATMSK14  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |DATMSK15  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PB_PIN
 * Offset: 0x50  PB Pin Value
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PIN0      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |PIN1      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |PIN2      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |PIN3      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |PIN4      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |PIN5      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |PIN6      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |PIN7      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |PIN8      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |PIN9      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |PIN10     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |PIN11     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |PIN12     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |PIN13     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |PIN14     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |PIN15     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PB_DBEN
 * Offset: 0x54  PB De-Bounce Enable Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |DBEN0     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |DBEN1     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |DBEN2     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |DBEN3     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |DBEN4     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |DBEN5     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |DBEN6     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |DBEN7     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |DBEN8     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |DBEN9     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |DBEN10    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |DBEN11    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |DBEN12    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |DBEN13    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |DBEN14    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |DBEN15    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PB_INTTYPE
 * Offset: 0x58  PB Interrupt Trigger Type Control
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |TYPE0     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |TYPE1     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |TYPE2     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |TYPE3     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |TYPE4     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |TYPE5     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |TYPE6     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |TYPE7     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |TYPE8     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |TYPE9     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |TYPE10    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |TYPE11    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |TYPE12    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |TYPE13    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |TYPE14    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |TYPE15    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PB_INTEN
 * Offset: 0x5C  PB Interrupt Enable Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |FLIEN0    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |FLIEN1    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |FLIEN2    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |FLIEN3    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |FLIEN4    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |FLIEN5    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |FLIEN6    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |FLIEN7    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |FLIEN8    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |FLIEN9    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |FLIEN10   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |FLIEN11   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |FLIEN12   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |FLIEN13   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |FLIEN14   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |FLIEN15   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[16]    |RHIEN0    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[17]    |RHIEN1    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[18]    |RHIEN2    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[19]    |RHIEN3    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[20]    |RHIEN4    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[21]    |RHIEN5    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[22]    |RHIEN6    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[23]    |RHIEN7    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[24]    |RHIEN8    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[25]    |RHIEN9    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[26]    |RHIEN10   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[27]    |RHIEN11   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[28]    |RHIEN12   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[29]    |RHIEN13   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[30]    |RHIEN14   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[31]    |RHIEN15   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PB_INTSRC
 * Offset: 0x60  PB Interrupt Source Flag
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |INTSRC0   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |INTSRC1   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |INTSRC2   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |INTSRC3   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |INTSRC4   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |INTSRC5   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |INTSRC6   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |INTSRC7   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |INTSRC8   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |INTSRC9   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |INTSRC10  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |INTSRC11  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |INTSRC12  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |INTSRC13  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |INTSRC14  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |INTSRC15  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PB_SMTEN
 * Offset: 0x64  PB Input Schmitt Trigger Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |SMTEN0    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |SMTEN1    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |SMTEN2    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |SMTEN3    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |SMTEN4    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |SMTEN5    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |SMTEN6    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |SMTEN7    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |SMTEN8    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |SMTEN9    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |SMTEN10   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |SMTEN11   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |SMTEN12   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |SMTEN13   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |SMTEN14   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |SMTEN15   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PB_SLEWCTL
 * Offset: 0x68  PB High Slew Rate Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |HSREN0    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3:2]   |HSREN1    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5:4]   |HSREN2    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7:6]   |HSREN3    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9:8]   |HSREN4    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11:10] |HSREN5    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13:12] |HSREN6    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15:14] |HSREN7    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[17:16] |HSREN8    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[19:18] |HSREN9    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[21:20] |HSREN10   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[23:22] |HSREN11   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[25:24] |HSREN12   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[27:26] |HSREN13   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[29:28] |HSREN14   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[31:30] |HSREN15   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PB_PUSEL
 * Offset: 0x70  PB Pull-up and Pull-down Selection Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |PUSEL0    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3:2]   |PUSEL1    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5:4]   |PUSEL2    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7:6]   |PUSEL3    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9:8]   |PUSEL4    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11:10] |PUSEL5    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13:12] |PUSEL6    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15:14] |PUSEL7    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[17:16] |PUSEL8    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[19:18] |PUSEL9    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[21:20] |PUSEL10   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[23:22] |PUSEL11   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[25:24] |PUSEL12   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[27:26] |PUSEL13   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[29:28] |PUSEL14   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[31:30] |PUSEL15   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC_MODE
 * Offset: 0x80  PC I/O Mode Control
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |MODE0     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3:2]   |MODE1     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5:4]   |MODE2     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7:6]   |MODE3     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9:8]   |MODE4     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11:10] |MODE5     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13:12] |MODE6     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15:14] |MODE7     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[17:16] |MODE8     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[19:18] |MODE9     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[21:20] |MODE10    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[23:22] |MODE11    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[25:24] |MODE12    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[27:26] |MODE13    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[29:28] |MODE14    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[31:30] |MODE15    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC_DINOFF
 * Offset: 0x84  PC Digital Input Path Disable Control
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[16]    |DINOFF0   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[17]    |DINOFF1   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[18]    |DINOFF2   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[19]    |DINOFF3   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[20]    |DINOFF4   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[21]    |DINOFF5   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[22]    |DINOFF6   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[23]    |DINOFF7   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[24]    |DINOFF8   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[25]    |DINOFF9   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[26]    |DINOFF10  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[27]    |DINOFF11  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[28]    |DINOFF12  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[29]    |DINOFF13  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[30]    |DINOFF14  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[31]    |DINOFF15  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC_DOUT
 * Offset: 0x88  PC Data Output Value
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |DOUT0     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |DOUT1     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |DOUT2     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |DOUT3     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |DOUT4     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |DOUT5     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |DOUT6     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |DOUT7     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |DOUT8     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |DOUT9     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |DOUT10    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |DOUT11    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |DOUT12    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |DOUT13    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |DOUT14    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |DOUT15    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC_DATMSK
 * Offset: 0x8C  PC Data Output Write Mask
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |DATMSK0   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |DATMSK1   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |DATMSK2   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |DATMSK3   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |DATMSK4   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |DATMSK5   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |DATMSK6   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |DATMSK7   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |DATMSK8   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |DATMSK9   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |DATMSK10  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |DATMSK11  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |DATMSK12  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |DATMSK13  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |DATMSK14  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |DATMSK15  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC_PIN
 * Offset: 0x90  PC Pin Value
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PIN0      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |PIN1      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |PIN2      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |PIN3      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |PIN4      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |PIN5      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |PIN6      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |PIN7      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |PIN8      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |PIN9      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |PIN10     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |PIN11     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |PIN12     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |PIN13     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |PIN14     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |PIN15     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC_DBEN
 * Offset: 0x94  PC De-Bounce Enable Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |DBEN0     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |DBEN1     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |DBEN2     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |DBEN3     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |DBEN4     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |DBEN5     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |DBEN6     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |DBEN7     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |DBEN8     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |DBEN9     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |DBEN10    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |DBEN11    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |DBEN12    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |DBEN13    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |DBEN14    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |DBEN15    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC_INTTYPE
 * Offset: 0x98  PC Interrupt Trigger Type Control
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |TYPE0     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |TYPE1     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |TYPE2     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |TYPE3     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |TYPE4     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |TYPE5     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |TYPE6     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |TYPE7     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |TYPE8     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |TYPE9     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |TYPE10    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |TYPE11    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |TYPE12    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |TYPE13    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |TYPE14    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |TYPE15    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC_INTEN
 * Offset: 0x9C  PC Interrupt Enable Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |FLIEN0    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |FLIEN1    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |FLIEN2    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |FLIEN3    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |FLIEN4    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |FLIEN5    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |FLIEN6    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |FLIEN7    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |FLIEN8    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |FLIEN9    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |FLIEN10   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |FLIEN11   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |FLIEN12   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |FLIEN13   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |FLIEN14   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |FLIEN15   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[16]    |RHIEN0    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[17]    |RHIEN1    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[18]    |RHIEN2    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[19]    |RHIEN3    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[20]    |RHIEN4    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[21]    |RHIEN5    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[22]    |RHIEN6    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[23]    |RHIEN7    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[24]    |RHIEN8    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[25]    |RHIEN9    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[26]    |RHIEN10   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[27]    |RHIEN11   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[28]    |RHIEN12   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[29]    |RHIEN13   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[30]    |RHIEN14   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[31]    |RHIEN15   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC_INTSRC
 * Offset: 0xA0  PC Interrupt Source Flag
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |INTSRC0   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |INTSRC1   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |INTSRC2   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |INTSRC3   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |INTSRC4   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |INTSRC5   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |INTSRC6   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |INTSRC7   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |INTSRC8   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |INTSRC9   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |INTSRC10  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |INTSRC11  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |INTSRC12  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |INTSRC13  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |INTSRC14  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |INTSRC15  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC_SMTEN
 * Offset: 0xA4  PC Input Schmitt Trigger Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |SMTEN0    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |SMTEN1    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |SMTEN2    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |SMTEN3    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |SMTEN4    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |SMTEN5    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |SMTEN6    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |SMTEN7    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |SMTEN8    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |SMTEN9    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |SMTEN10   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |SMTEN11   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |SMTEN12   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |SMTEN13   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |SMTEN14   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |SMTEN15   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC_SLEWCTL
 * Offset: 0xA8  PC High Slew Rate Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |HSREN0    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3:2]   |HSREN1    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5:4]   |HSREN2    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7:6]   |HSREN3    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9:8]   |HSREN4    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11:10] |HSREN5    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13:12] |HSREN6    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15:14] |HSREN7    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[17:16] |HSREN8    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[19:18] |HSREN9    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[21:20] |HSREN10   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[23:22] |HSREN11   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[25:24] |HSREN12   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[27:26] |HSREN13   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[29:28] |HSREN14   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[31:30] |HSREN15   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC_PUSEL
 * Offset: 0xB0  PC Pull-up and Pull-down Selection Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |PUSEL0    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3:2]   |PUSEL1    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5:4]   |PUSEL2    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7:6]   |PUSEL3    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9:8]   |PUSEL4    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11:10] |PUSEL5    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13:12] |PUSEL6    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15:14] |PUSEL7    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[17:16] |PUSEL8    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[19:18] |PUSEL9    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[21:20] |PUSEL10   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[23:22] |PUSEL11   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[25:24] |PUSEL12   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[27:26] |PUSEL13   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[29:28] |PUSEL14   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[31:30] |PUSEL15   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD_MODE
 * Offset: 0xC0  PD I/O Mode Control
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |MODE0     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3:2]   |MODE1     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5:4]   |MODE2     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7:6]   |MODE3     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9:8]   |MODE4     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11:10] |MODE5     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13:12] |MODE6     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15:14] |MODE7     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[17:16] |MODE8     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[19:18] |MODE9     |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[21:20] |MODE10    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[23:22] |MODE11    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[25:24] |MODE12    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[27:26] |MODE13    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[29:28] |MODE14    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[31:30] |MODE15    |Port A-D I/O Pin[n] Mode Control
 * |        |          |Determine each I/O mode of Px.n pins.
 * |        |          |00 = Px.n is in Input mode.
 * |        |          |01 = Px.n is in Push-pull Output mode.
 * |        |          |10 = Px.n is in Open-drain Output mode.
 * |        |          |11 = Px.n is in Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of this field is defined by CIOINI (CONFIG0[10]) except PA_MODE[17:16]
 * |        |          |If CIOINI is set to 0, the reset value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on or reset period
 * |        |          |If CIOINI is set to 1, the reset value is 0x0000_0000 and all pins will be  input mode after chip powered on or reset period.
 * |        |          |Note2:
 * |        |          |The reset value of PA_MODE[17:16] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_MODE[17:16] is 0x1 and PA.8 will be push-pull output mode after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_MODE[17:16] follows CIOINI setting.
 * |        |          |Note3:
 * |        |          |The reset value of PB_MODE[31:28] is 00XXb in binary form.
 * |        |          |Note4:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD_DINOFF
 * Offset: 0xC4  PD Digital Input Path Disable Control
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[16]    |DINOFF0   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[17]    |DINOFF1   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[18]    |DINOFF2   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[19]    |DINOFF3   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[20]    |DINOFF4   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[21]    |DINOFF5   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[22]    |DINOFF6   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[23]    |DINOFF7   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[24]    |DINOFF8   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[25]    |DINOFF9   |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[26]    |DINOFF10  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[27]    |DINOFF11  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[28]    |DINOFF12  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[29]    |DINOFF13  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[30]    |DINOFF14  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[31]    |DINOFF15  |Port A-D Pin[n] Digital Input Path Disable Control
 * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled
 * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
 * |        |          |0 = Px.n digital input path Enabled.
 * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD_DOUT
 * Offset: 0xC8  PD Data Output Value
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |DOUT0     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |DOUT1     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |DOUT2     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |DOUT3     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |DOUT4     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |DOUT5     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |DOUT6     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |DOUT7     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |DOUT8     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |DOUT9     |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |DOUT10    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |DOUT11    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |DOUT12    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |DOUT13    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |DOUT14    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |DOUT15    |Port A-D Pin[n] Output Value
 * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
 * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
 * |        |          |Note1:
 * |        |          |The reset value of PA_DOUT[8] field is defined by GPA8_LOW (CONFIG0[11])
 * |        |          |If GPA8_LOW is set to 0, the reset value of PA_DOUT[8] is 0 and PA.8 pin will be drive low state after chip powered on or reset period
 * |        |          |If GPA8_LOW is set to 1, the reset value of PA_DOUT[8] is 1.
 * |        |          |Note2:
 * |        |          |The reset value of PA_DOUT[11:8] is 111Xb in binary form, the reset value of PA_DOUT[8] is based on the setting of GPA_LOW (CONFIG0[11]).
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD_DATMSK
 * Offset: 0xCC  PD Data Output Write Mask
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |DATMSK0   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |DATMSK1   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |DATMSK2   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |DATMSK3   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |DATMSK4   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |DATMSK5   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |DATMSK6   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |DATMSK7   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |DATMSK8   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |DATMSK9   |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |DATMSK10  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |DATMSK11  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |DATMSK12  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |DATMSK13  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |DATMSK14  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |DATMSK15  |Port A-D Pin[n] Data Output Write Mask
 * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit
 * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected
 * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
 * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
 * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
 * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD_PIN
 * Offset: 0xD0  PD Pin Value
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PIN0      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |PIN1      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |PIN2      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |PIN3      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |PIN4      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |PIN5      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |PIN6      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |PIN7      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |PIN8      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |PIN9      |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |PIN10     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |PIN11     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |PIN12     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |PIN13     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |PIN14     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |PIN15     |Port A-D Pin[n] Pin Value
 * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin
 * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
 * |        |          |Note1:
 * |        |          |The reset value of PB_PIN[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD_DBEN
 * Offset: 0xD4  PD De-Bounce Enable Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |DBEN0     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |DBEN1     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |DBEN2     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |DBEN3     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |DBEN4     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |DBEN5     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |DBEN6     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |DBEN7     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |DBEN8     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |DBEN9     |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |DBEN10    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |DBEN11    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |DBEN12    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |DBEN13    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |DBEN14    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |DBEN15    |Port A-D Pin[n] Input Signal De-bounce Enable Bit
 * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit
 * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt
 * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
 * |        |          |0 = Px.n de-bounce function Disabled.
 * |        |          |1 = Px.n de-bounce function Enabled.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD_INTTYPE
 * Offset: 0xD8  PD Interrupt Trigger Type Control
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |TYPE0     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |TYPE1     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |TYPE2     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |TYPE3     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |TYPE4     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |TYPE5     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |TYPE6     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |TYPE7     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |TYPE8     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |TYPE9     |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |TYPE10    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |TYPE11    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |TYPE12    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |TYPE13    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |TYPE14    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |TYPE15    |Port A-D Pin[n] Edge or Level Detection Interrupt Trigger Type Control
 * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger
 * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce
 * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
 * |        |          |0 = Edge trigger interrupt.
 * |        |          |1 = Level trigger interrupt.
 * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n])
 * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
 * |        |          |The de-bounce function is valid only for edge triggered interrupt
 * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD_INTEN
 * Offset: 0xDC  PD Interrupt Enable Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |FLIEN0    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |FLIEN1    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |FLIEN2    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |FLIEN3    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |FLIEN4    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |FLIEN5    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |FLIEN6    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |FLIEN7    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |FLIEN8    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |FLIEN9    |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |FLIEN10   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |FLIEN11   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |FLIEN12   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |FLIEN13   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |FLIEN14   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |FLIEN15   |Port A-D Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Biit
 * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
 * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
 * |        |          |0 = Px.n level low or high to low interrupt Disabled.
 * |        |          |1 = Px.n level low or high to low interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[16]    |RHIEN0    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[17]    |RHIEN1    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[18]    |RHIEN2    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[19]    |RHIEN3    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[20]    |RHIEN4    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[21]    |RHIEN5    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[22]    |RHIEN6    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[23]    |RHIEN7    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[24]    |RHIEN8    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[25]    |RHIEN9    |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[26]    |RHIEN10   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[27]    |RHIEN11   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[28]    |RHIEN12   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[29]    |RHIEN13   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[30]    |RHIEN14   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[31]    |RHIEN15   |Port A-D Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
 * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin
 * |        |          |Set bit to 1 also enable the pin wake-up function.
 * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
 * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
 * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
 * |        |          |0 = Px.n level high or low to high interrupt Disabled.
 * |        |          |1 = Px.n level high or low to high interrupt Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD_INTSRC
 * Offset: 0xE0  PD Interrupt Source Flag
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |INTSRC0   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |INTSRC1   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |INTSRC2   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |INTSRC3   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |INTSRC4   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |INTSRC5   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |INTSRC6   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |INTSRC7   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |INTSRC8   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |INTSRC9   |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |INTSRC10  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |INTSRC11  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |INTSRC12  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |INTSRC13  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |INTSRC14  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |INTSRC15  |Port A-D Pin[n] Interrupt Source Flag
 * |        |          |Write Operation :
 * |        |          |0 = No action.
 * |        |          |1 = Clear the corresponding pending interrupt.
 * |        |          |Read Operation :
 * |        |          |0 = No interrupt at Px.n.
 * |        |          |1 = Px.n generates an interrupt.
 * |        |          |Note1:
 * |        |          |The reset value of PB_INTSRC[15:8] is 0XXX_00XXb in binary form.
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD_SMTEN
 * Offset: 0xE4  PD Input Schmitt Trigger Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |SMTEN0    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[1]     |SMTEN1    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[2]     |SMTEN2    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3]     |SMTEN3    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[4]     |SMTEN4    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5]     |SMTEN5    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[6]     |SMTEN6    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7]     |SMTEN7    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[8]     |SMTEN8    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9]     |SMTEN9    |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[10]    |SMTEN10   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11]    |SMTEN11   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[12]    |SMTEN12   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13]    |SMTEN13   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[14]    |SMTEN14   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15]    |SMTEN15   |Port A-D Pin[n] Input Schmitt Trigger Enable Bit
 * |        |          |0 = Px.n input schmitt trigger function Disabled.
 * |        |          |1 = Px.n input schmitt trigger function Enabled.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD_SLEWCTL
 * Offset: 0xE8  PD High Slew Rate Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |HSREN0    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3:2]   |HSREN1    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5:4]   |HSREN2    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7:6]   |HSREN3    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9:8]   |HSREN4    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11:10] |HSREN5    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13:12] |HSREN6    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15:14] |HSREN7    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[17:16] |HSREN8    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[19:18] |HSREN9    |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[21:20] |HSREN10   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[23:22] |HSREN11   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[25:24] |HSREN12   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[27:26] |HSREN13   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[29:28] |HSREN14   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[31:30] |HSREN15   |Port A-D Pin[n] High Slew Rate Control
 * |        |          |00 = Px.n output with normal slew rate mode (maximum 40 MHz at 2.7V).
 * |        |          |01 = Px.n output with high slew rate mode (maximum 80 MHz at 2.7V).
 * |        |          |10 = Px.n output with fast slew rate mode (maximum 100 MHz at 2.7V.
 * |        |          |11 = Reserved.
 * |        |          |Note:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD_PUSEL
 * Offset: 0xF0  PD Pull-up and Pull-down Selection Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |PUSEL0    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[3:2]   |PUSEL1    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[5:4]   |PUSEL2    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[7:6]   |PUSEL3    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[9:8]   |PUSEL4    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[11:10] |PUSEL5    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[13:12] |PUSEL6    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[15:14] |PUSEL7    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[17:16] |PUSEL8    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[19:18] |PUSEL9    |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[21:20] |PUSEL10   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[23:22] |PUSEL11   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[25:24] |PUSEL12   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[27:26] |PUSEL13   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[29:28] |PUSEL14   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * |[31:30] |PUSEL15   |Port A-D Pin[n] Pull-up and Pull-down Enable Register
 * |        |          |Determine each I/O Pull-up/pull-down of Px.n pins.
 * |        |          |00 = Px.n pull-up and pull- down disable.
 * |        |          |01 = Px.n pull-up enable.
 * |        |          |10 = Px.n pull-down enable.
 * |        |          |11 = Px.n pull-up and pull-down disable.
 * |        |          |Note1:
 * |        |          |Basically, the pull-up control and pull-down control has following behavior limitation
 * |        |          |The independent pull-up control register only valid when MODEn set as tri-state and open-drain mode
 * |        |          |The independent pull-down control register only valid when MODEn set as tri-state mode
 * |        |          |When both pull-up and pull-down is set as 1 at ...tri-stateu201D mode, keep I/O in tri-state mode
 * |        |          |Note2:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::GPIO_DBCTL
 * Offset: 0x440  Interrupt De-bounce Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |DBCLKSEL  |De-bounce Sampling Cycle Selection
 * |        |          |0000 = Sample interrupt input once per 1 clocks.
 * |        |          |0001 = Sample interrupt input once per 2 clocks.
 * |        |          |0010 = Sample interrupt input once per 4 clocks.
 * |        |          |0011 = Sample interrupt input once per 8 clocks.
 * |        |          |0100 = Sample interrupt input once per 16 clocks.
 * |        |          |0101 = Sample interrupt input once per 32 clocks.
 * |        |          |0110 = Sample interrupt input once per 64 clocks.
 * |        |          |0111 = Sample interrupt input once per 128 clocks.
 * |        |          |1000 = Sample interrupt input once per 256 clocks.
 * |        |          |1001 = Sample interrupt input once per 2*256 clocks.
 * |        |          |1010 = Sample interrupt input once per 4*256 clocks.
 * |        |          |1011 = Sample interrupt input once per 8*256 clocks.
 * |        |          |1100 = Sample interrupt input once per 16*256 clocks.
 * |        |          |1101 = Sample interrupt input once per 32*256 clocks.
 * |        |          |1110 = Sample interrupt input once per 64*256 clocks.
 * |        |          |1111 = Sample interrupt input once per 128*256 clocks.
 * |[4]     |DBCLKSRC  |De-bounce Counter Clock Source Selection
 * |        |          |0 = De-bounce counter clock source is the HCLK.
 * |        |          |1 = De-bounce counter clock source is the 10 kHz internal low speed RC oscillator (LIRC).
 * |[5]     |ICLKON    |Interrupt Clock on Mode
 * |        |          |0 = Edge detection circuit is active only if I/O pin corresponding RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]) bit is set to 1.
 * |        |          |1 = All I/O pins edge detection circuit is always active after reset.
 * |        |          |Note: It is recommended to disable this bit to save system power if no special application concern.
 * @var GPIO_T::PA0_PDIO
 * Offset: 0x800  GPIO PA.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA1_PDIO
 * Offset: 0x804  GPIO PA.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA2_PDIO
 * Offset: 0x808  GPIO PA.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA3_PDIO
 * Offset: 0x80C  GPIO PA.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA4_PDIO
 * Offset: 0x810  GPIO PA.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA5_PDIO
 * Offset: 0x814  GPIO PA.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA6_PDIO
 * Offset: 0x818  GPIO PA.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA7_PDIO
 * Offset: 0x81C  GPIO PA.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA8_PDIO
 * Offset: 0x820  GPIO PA.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA9_PDIO
 * Offset: 0x824  GPIO PA.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA10_PDIO
 * Offset: 0x828  GPIO PA.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA11_PDIO
 * Offset: 0x82C  GPIO PA.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA12_PDIO
 * Offset: 0x830  GPIO PA.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA13_PDIO
 * Offset: 0x834  GPIO PA.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA14_PDIO
 * Offset: 0x838  GPIO PA.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PA15_PDIO
 * Offset: 0x83C  GPIO PA.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PBn_PDIO
 * Offset: 0x840  GPIO PB.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC0_PDIO
 * Offset: 0x880  GPIO PC.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC1_PDIO
 * Offset: 0x884  GPIO PC.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC2_PDIO
 * Offset: 0x888  GPIO PC.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC3_PDIO
 * Offset: 0x88C  GPIO PC.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC4_PDIO
 * Offset: 0x890  GPIO PC.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC5_PDIO
 * Offset: 0x894  GPIO PC.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC6_PDIO
 * Offset: 0x898  GPIO PC.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC7_PDIO
 * Offset: 0x89C  GPIO PC.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC8_PDIO
 * Offset: 0x8A0  GPIO PC.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC9_PDIO
 * Offset: 0x8A4  GPIO PC.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC10_PDIO
 * Offset: 0x8A8  GPIO PC.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC11_PDIO
 * Offset: 0x8AC  GPIO PC.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC12_PDIO
 * Offset: 0x8B0  GPIO PC.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC13_PDIO
 * Offset: 0x8B4  GPIO PC.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC14_PDIO
 * Offset: 0x8B8  GPIO PC.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PC15_PDIO
 * Offset: 0x8BC  GPIO PC.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD0_PDIO
 * Offset: 0x8C0  GPIO PD.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD1_PDIO
 * Offset: 0x8C4  GPIO PD.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD2_PDIO
 * Offset: 0x8C8  GPIO PD.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD3_PDIO
 * Offset: 0x8CC  GPIO PD.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD4_PDIO
 * Offset: 0x8D0  GPIO PD.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD5_PDIO
 * Offset: 0x8D4  GPIO PD.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD6_PDIO
 * Offset: 0x8D8  GPIO PD.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD7_PDIO
 * Offset: 0x8DC  GPIO PD.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD8_PDIO
 * Offset: 0x8E0  GPIO PD.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD9_PDIO
 * Offset: 0x8E4  GPIO PD.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD10_PDIO
 * Offset: 0x8E8  GPIO PD.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD11_PDIO
 * Offset: 0x8EC  GPIO PD.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD12_PDIO
 * Offset: 0x8F0  GPIO PD.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD13_PDIO
 * Offset: 0x8F4  GPIO PD.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD14_PDIO
 * Offset: 0x8F8  GPIO PD.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 * @var GPIO_T::PD15_PDIO
 * Offset: 0x8FC  GPIO PD.n Pin Data Input/Output Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDIO      |GPIO Px.N Pin Data Input/Output
 * |        |          |Writing this bit can control one GPIO pin output value.
 * |        |          |0 = Corresponding GPIO pin set to low.
 * |        |          |1 = Corresponding GPIO pin set to high.
 * |        |          |Read this register to get GPIO pin status.
 * |        |          |For example, writing PA0_PDIO will reflect the written value to bit DOUT (Px_DOUT[0]), reading PA0_PDIO will return the value of PIN (PA_PIN[0]).
 * |        |          |Note1:
 * |        |          |The writing operation will not be affected by register DATMSK (Px_DATMSK[n]).
 * |        |          |Note2:
 * |        |          |The reset value of PAn_PDIO[3:0], PBn_PDIO[3:0], PCn_PDIO[3:0], PDn_PDIO[3:0] are 000Xb in binary form.
 * |        |          |Note3:
 * |        |          |Max. n=15 for port A/C/D
 * |        |          |n=0..9, 12, 13, 14 for port B
 */
    __IO uint32_t PA_MODE;               /*!< [0x0000] PA I/O Mode Control                                              */
    __IO uint32_t PA_DINOFF;             /*!< [0x0004] PA Digital Input Path Disable Control                            */
    __IO uint32_t PA_DOUT;               /*!< [0x0008] PA Data Output Value                                             */
    __IO uint32_t PA_DATMSK;             /*!< [0x000c] PA Data Output Write Mask                                        */
    __I  uint32_t PA_PIN;                /*!< [0x0010] PA Pin Value                                                     */
    __IO uint32_t PA_DBEN;               /*!< [0x0014] PA De-Bounce Enable Control Register                             */
    __IO uint32_t PA_INTTYPE;            /*!< [0x0018] PA Interrupt Trigger Type Control                                */
    __IO uint32_t PA_INTEN;              /*!< [0x001c] PA Interrupt Enable Control Register                             */
    __IO uint32_t PA_INTSRC;             /*!< [0x0020] PA Interrupt Source Flag                                         */
    __IO uint32_t PA_SMTEN;              /*!< [0x0024] PA Input Schmitt Trigger Enable Register                         */
    __IO uint32_t PA_SLEWCTL;            /*!< [0x0028] PA High Slew Rate Control Register                               */
    __I  uint32_t RESERVE0[1];
    __IO uint32_t PA_PUSEL;              /*!< [0x0030] PA Pull-up and Pull-down Selection Register                      */
    __I  uint32_t RESERVE1[3];
    __IO uint32_t PB_MODE;               /*!< [0x0040] PB I/O Mode Control                                              */
    __IO uint32_t PB_DINOFF;             /*!< [0x0044] PB Digital Input Path Disable Control                            */
    __IO uint32_t PB_DOUT;               /*!< [0x0048] PB Data Output Value                                             */
    __IO uint32_t PB_DATMSK;             /*!< [0x004c] PB Data Output Write Mask                                        */
    __I  uint32_t PB_PIN;                /*!< [0x0050] PB Pin Value                                                     */
    __IO uint32_t PB_DBEN;               /*!< [0x0054] PB De-Bounce Enable Control Register                             */
    __IO uint32_t PB_INTTYPE;            /*!< [0x0058] PB Interrupt Trigger Type Control                                */
    __IO uint32_t PB_INTEN;              /*!< [0x005c] PB Interrupt Enable Control Register                             */
    __IO uint32_t PB_INTSRC;             /*!< [0x0060] PB Interrupt Source Flag                                         */
    __IO uint32_t PB_SMTEN;              /*!< [0x0064] PB Input Schmitt Trigger Enable Register                         */
    __IO uint32_t PB_SLEWCTL;            /*!< [0x0068] PB High Slew Rate Control Register                               */
    __I  uint32_t RESERVE2[1];
    __IO uint32_t PB_PUSEL;              /*!< [0x0070] PB Pull-up and Pull-down Selection Register                      */
    __I  uint32_t RESERVE3[3];
    __IO uint32_t PC_MODE;               /*!< [0x0080] PC I/O Mode Control                                              */
    __IO uint32_t PC_DINOFF;             /*!< [0x0084] PC Digital Input Path Disable Control                            */
    __IO uint32_t PC_DOUT;               /*!< [0x0088] PC Data Output Value                                             */
    __IO uint32_t PC_DATMSK;             /*!< [0x008c] PC Data Output Write Mask                                        */
    __I  uint32_t PC_PIN;                /*!< [0x0090] PC Pin Value                                                     */
    __IO uint32_t PC_DBEN;               /*!< [0x0094] PC De-Bounce Enable Control Register                             */
    __IO uint32_t PC_INTTYPE;            /*!< [0x0098] PC Interrupt Trigger Type Control                                */
    __IO uint32_t PC_INTEN;              /*!< [0x009c] PC Interrupt Enable Control Register                             */
    __IO uint32_t PC_INTSRC;             /*!< [0x00a0] PC Interrupt Source Flag                                         */
    __IO uint32_t PC_SMTEN;              /*!< [0x00a4] PC Input Schmitt Trigger Enable Register                         */
    __IO uint32_t PC_SLEWCTL;            /*!< [0x00a8] PC High Slew Rate Control Register                               */
    __I  uint32_t RESERVE4[1];
    __IO uint32_t PC_PUSEL;              /*!< [0x00b0] PC Pull-up and Pull-down Selection Register                      */
    __I  uint32_t RESERVE5[3];
    __IO uint32_t PD_MODE;               /*!< [0x00c0] PD I/O Mode Control                                              */
    __IO uint32_t PD_DINOFF;             /*!< [0x00c4] PD Digital Input Path Disable Control                            */
    __IO uint32_t PD_DOUT;               /*!< [0x00c8] PD Data Output Value                                             */
    __IO uint32_t PD_DATMSK;             /*!< [0x00cc] PD Data Output Write Mask                                        */
    __I  uint32_t PD_PIN;                /*!< [0x00d0] PD Pin Value                                                     */
    __IO uint32_t PD_DBEN;               /*!< [0x00d4] PD De-Bounce Enable Control Register                             */
    __IO uint32_t PD_INTTYPE;            /*!< [0x00d8] PD Interrupt Trigger Type Control                                */
    __IO uint32_t PD_INTEN;              /*!< [0x00dc] PD Interrupt Enable Control Register                             */
    __IO uint32_t PD_INTSRC;             /*!< [0x00e0] PD Interrupt Source Flag                                         */
    __IO uint32_t PD_SMTEN;              /*!< [0x00e4] PD Input Schmitt Trigger Enable Register                         */
    __IO uint32_t PD_SLEWCTL;            /*!< [0x00e8] PD High Slew Rate Control Register                               */
    __I  uint32_t RESERVE6[1];
    __IO uint32_t PD_PUSEL;              /*!< [0x00f0] PD Pull-up and Pull-down Selection Register                      */
    __I  uint32_t RESERVE7[211];
    __IO uint32_t GPIO_DBCTL;            /*!< [0x0440] Interrupt De-bounce Control Register                             */
    __I  uint32_t RESERVE8[239];
    __IO uint32_t PA0_PDIO;              /*!< [0x0800] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PA1_PDIO;              /*!< [0x0804] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PA2_PDIO;              /*!< [0x0808] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PA3_PDIO;              /*!< [0x080c] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PA4_PDIO;              /*!< [0x0810] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PA5_PDIO;              /*!< [0x0814] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PA6_PDIO;              /*!< [0x0818] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PA7_PDIO;              /*!< [0x081c] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PA8_PDIO;              /*!< [0x0820] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PA9_PDIO;              /*!< [0x0824] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PA10_PDIO;             /*!< [0x0828] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PA11_PDIO;             /*!< [0x082c] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PA12_PDIO;             /*!< [0x0830] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PA13_PDIO;             /*!< [0x0834] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PA14_PDIO;             /*!< [0x0838] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PA15_PDIO;             /*!< [0x083c] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PB0_PDIO;              /*!< [0x0840] GPIO PB.n Pin Data Input/Output Register                         */
    __IO uint32_t PB1_PDIO;              /*!< [0x0844] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PB2_PDIO;              /*!< [0x0848] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PB3_PDIO;              /*!< [0x084c] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PB4_PDIO;              /*!< [0x0850] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PB5_PDIO;              /*!< [0x0854] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PB6_PDIO;              /*!< [0x0858] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PB7_PDIO;              /*!< [0x085c] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PB8_PDIO;              /*!< [0x0860] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PB9_PDIO;              /*!< [0x0864] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PB10_PDIO;             /*!< [0x0868] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PB11_PDIO;             /*!< [0x086c] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PB12_PDIO;             /*!< [0x0870] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PB13_PDIO;             /*!< [0x0874] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PB14_PDIO;             /*!< [0x0878] GPIO PA.n Pin Data Input/Output Register                         */
    __IO uint32_t PB15_PDIO;             /*!< [0x087c] GPIO PA.n Pin Data Input/Output Register     										*/
    __IO uint32_t PC0_PDIO;              /*!< [0x0880] GPIO PC.n Pin Data Input/Output Register                         */
    __IO uint32_t PC1_PDIO;              /*!< [0x0884] GPIO PC.n Pin Data Input/Output Register                         */
    __IO uint32_t PC2_PDIO;              /*!< [0x0888] GPIO PC.n Pin Data Input/Output Register                         */
    __IO uint32_t PC3_PDIO;              /*!< [0x088c] GPIO PC.n Pin Data Input/Output Register                         */
    __IO uint32_t PC4_PDIO;              /*!< [0x0890] GPIO PC.n Pin Data Input/Output Register                         */
    __IO uint32_t PC5_PDIO;              /*!< [0x0894] GPIO PC.n Pin Data Input/Output Register                         */
    __IO uint32_t PC6_PDIO;              /*!< [0x0898] GPIO PC.n Pin Data Input/Output Register                         */
    __IO uint32_t PC7_PDIO;              /*!< [0x089c] GPIO PC.n Pin Data Input/Output Register                         */
    __IO uint32_t PC8_PDIO;              /*!< [0x08a0] GPIO PC.n Pin Data Input/Output Register                         */
    __IO uint32_t PC9_PDIO;              /*!< [0x08a4] GPIO PC.n Pin Data Input/Output Register                         */
    __IO uint32_t PC10_PDIO;             /*!< [0x08a8] GPIO PC.n Pin Data Input/Output Register                         */
    __IO uint32_t PC11_PDIO;             /*!< [0x08ac] GPIO PC.n Pin Data Input/Output Register                         */
    __IO uint32_t PC12_PDIO;             /*!< [0x08b0] GPIO PC.n Pin Data Input/Output Register                         */
    __IO uint32_t PC13_PDIO;             /*!< [0x08b4] GPIO PC.n Pin Data Input/Output Register                         */
    __IO uint32_t PC14_PDIO;             /*!< [0x08b8] GPIO PC.n Pin Data Input/Output Register                         */
    __IO uint32_t PC15_PDIO;             /*!< [0x08bc] GPIO PC.n Pin Data Input/Output Register                         */
    __IO uint32_t PD0_PDIO;              /*!< [0x08c0] GPIO PD.n Pin Data Input/Output Register                         */
    __IO uint32_t PD1_PDIO;              /*!< [0x08c4] GPIO PD.n Pin Data Input/Output Register                         */
    __IO uint32_t PD2_PDIO;              /*!< [0x08c8] GPIO PD.n Pin Data Input/Output Register                         */
    __IO uint32_t PD3_PDIO;              /*!< [0x08cc] GPIO PD.n Pin Data Input/Output Register                         */
    __IO uint32_t PD4_PDIO;              /*!< [0x08d0] GPIO PD.n Pin Data Input/Output Register                         */
    __IO uint32_t PD5_PDIO;              /*!< [0x08d4] GPIO PD.n Pin Data Input/Output Register                         */
    __IO uint32_t PD6_PDIO;              /*!< [0x08d8] GPIO PD.n Pin Data Input/Output Register                         */
    __IO uint32_t PD7_PDIO;              /*!< [0x08dc] GPIO PD.n Pin Data Input/Output Register                         */
    __IO uint32_t PD8_PDIO;              /*!< [0x08e0] GPIO PD.n Pin Data Input/Output Register                         */
    __IO uint32_t PD9_PDIO;              /*!< [0x08e4] GPIO PD.n Pin Data Input/Output Register                         */
    __IO uint32_t PD10_PDIO;             /*!< [0x08e8] GPIO PD.n Pin Data Input/Output Register                         */
    __IO uint32_t PD11_PDIO;             /*!< [0x08ec] GPIO PD.n Pin Data Input/Output Register                         */
    __IO uint32_t PD12_PDIO;             /*!< [0x08f0] GPIO PD.n Pin Data Input/Output Register                         */
    __IO uint32_t PD13_PDIO;             /*!< [0x08f4] GPIO PD.n Pin Data Input/Output Register                         */
    __IO uint32_t PD14_PDIO;             /*!< [0x08f8] GPIO PD.n Pin Data Input/Output Register                         */
    __IO uint32_t PD15_PDIO;             /*!< [0x08fc] GPIO PD.n Pin Data Input/Output Register                         */

} GPIO_T;

typedef struct
{
    __IO uint32_t PMD;                  /*!< Offset: 0x0000   GPIO Port Bit Mode Control                        */ 

    __IO uint32_t OFFD;                 /*!< Offset: 0x0004   GPIO Port Bit Off Digital Enable                  */

    __IO uint32_t DOUT;                 /*!< Offset: 0x0008   GPIO Port Data Output                             */

    __IO uint32_t DMASK;                /*!< Offset: 0x000C   GPIO Port Data Output Write Mask                  */

    __I  uint32_t PIN;                  /*!< Offset: 0x0010   GPIO Port Pin Value                               */

    __IO uint32_t DBEN;                 /*!< Offset: 0x0014   GPIO Port De-bounce Enable                        */

    __IO uint32_t IMD;                  /*!< Offset: 0x0018   GPIO Port Interrupt Mode Select                   */

    __IO uint32_t IEN;                  /*!< Offset: 0x001C   GPIO Port Interrupt Enable                        */

    __IO uint32_t ISRC;                 /*!< Offset: 0x0020   GPIO Port Interrupt Source Flag                   */

    __IO uint32_t TYPE;                 /*!< Offset: 0x0024   GPIO Port input Schmitt Trigger function          */

    __IO uint32_t HS;                   /*!< Offset: 0x0028   GPIO Higher Speed Control                         */

    __IO uint32_t DS;                   /*!< Offset: 0x002C   GPIO High Drive Selection                         */
		
		__IO uint32_t PUSEL;                /*!< Offset: 0x0030   PA Pull-up and Pull-down Selection                */

} GPIO1_T;
/**
    @addtogroup GPIO_CONST GPIO Bit Field Definition
    Constant Definitions for GPIO Controller
@{ */

#define GPIO_MODE_MODE0_Pos              (0)                                               /*!< GPIO_T::MODE: MODE0 Position           */
#define GPIO_MODE_MODE0_Msk              (0x3ul << GPIO_MODE_MODE0_Pos)                    /*!< GPIO_T::MODE: MODE0 Mask               */

#define GPIO_MODE_MODE1_Pos              (2)                                               /*!< GPIO_T::MODE: MODE1 Position           */
#define GPIO_MODE_MODE1_Msk              (0x3ul << GPIO_MODE_MODE1_Pos)                    /*!< GPIO_T::MODE: MODE1 Mask               */

#define GPIO_MODE_MODE2_Pos              (4)                                               /*!< GPIO_T::MODE: MODE2 Position           */
#define GPIO_MODE_MODE2_Msk              (0x3ul << GPIO_MODE_MODE2_Pos)                    /*!< GPIO_T::MODE: MODE2 Mask               */

#define GPIO_MODE_MODE3_Pos              (6)                                               /*!< GPIO_T::MODE: MODE3 Position           */
#define GPIO_MODE_MODE3_Msk              (0x3ul << GPIO_MODE_MODE3_Pos)                    /*!< GPIO_T::MODE: MODE3 Mask               */

#define GPIO_MODE_MODE4_Pos              (8)                                               /*!< GPIO_T::MODE: MODE4 Position           */
#define GPIO_MODE_MODE4_Msk              (0x3ul << GPIO_MODE_MODE4_Pos)                    /*!< GPIO_T::MODE: MODE4 Mask               */

#define GPIO_MODE_MODE5_Pos              (10)                                              /*!< GPIO_T::MODE: MODE5 Position           */
#define GPIO_MODE_MODE5_Msk              (0x3ul << GPIO_MODE_MODE5_Pos)                    /*!< GPIO_T::MODE: MODE5 Mask               */

#define GPIO_MODE_MODE6_Pos              (12)                                              /*!< GPIO_T::MODE: MODE6 Position           */
#define GPIO_MODE_MODE6_Msk              (0x3ul << GPIO_MODE_MODE6_Pos)                    /*!< GPIO_T::MODE: MODE6 Mask               */

#define GPIO_MODE_MODE7_Pos              (14)                                              /*!< GPIO_T::MODE: MODE7 Position           */
#define GPIO_MODE_MODE7_Msk              (0x3ul << GPIO_MODE_MODE7_Pos)                    /*!< GPIO_T::MODE: MODE7 Mask               */

#define GPIO_MODE_MODE8_Pos              (16)                                              /*!< GPIO_T::MODE: MODE8 Position           */
#define GPIO_MODE_MODE8_Msk              (0x3ul << GPIO_MODE_MODE8_Pos)                    /*!< GPIO_T::MODE: MODE8 Mask               */

#define GPIO_MODE_MODE9_Pos              (18)                                              /*!< GPIO_T::MODE: MODE9 Position           */
#define GPIO_MODE_MODE9_Msk              (0x3ul << GPIO_MODE_MODE9_Pos)                    /*!< GPIO_T::MODE: MODE9 Mask               */

#define GPIO_MODE_MODE10_Pos             (20)                                              /*!< GPIO_T::MODE: MODE10 Position          */
#define GPIO_MODE_MODE10_Msk             (0x3ul << GPIO_MODE_MODE10_Pos)                   /*!< GPIO_T::MODE: MODE10 Mask              */

#define GPIO_MODE_MODE11_Pos             (22)                                              /*!< GPIO_T::MODE: MODE11 Position          */
#define GPIO_MODE_MODE11_Msk             (0x3ul << GPIO_MODE_MODE11_Pos)                   /*!< GPIO_T::MODE: MODE11 Mask              */

#define GPIO_MODE_MODE12_Pos             (24)                                              /*!< GPIO_T::MODE: MODE12 Position          */
#define GPIO_MODE_MODE12_Msk             (0x3ul << GPIO_MODE_MODE12_Pos)                   /*!< GPIO_T::MODE: MODE12 Mask              */

#define GPIO_MODE_MODE13_Pos             (26)                                              /*!< GPIO_T::MODE: MODE13 Position          */
#define GPIO_MODE_MODE13_Msk             (0x3ul << GPIO_MODE_MODE13_Pos)                   /*!< GPIO_T::MODE: MODE13 Mask              */

#define GPIO_MODE_MODE14_Pos             (28)                                              /*!< GPIO_T::MODE: MODE14 Position          */
#define GPIO_MODE_MODE14_Msk             (0x3ul << GPIO_MODE_MODE14_Pos)                   /*!< GPIO_T::MODE: MODE14 Mask              */

#define GPIO_MODE_MODE15_Pos             (30)                                              /*!< GPIO_T::MODE: MODE15 Position          */
#define GPIO_MODE_MODE15_Msk             (0x3ul << GPIO_MODE_MODE15_Pos)                   /*!< GPIO_T::MODE: MODE15 Mask              */

#define GPIO_DINOFF_DINOFF0_Pos          (16)                                              /*!< GPIO_T::DINOFF: DINOFF0 Position       */
#define GPIO_DINOFF_DINOFF0_Msk          (0x1ul << GPIO_DINOFF_DINOFF0_Pos)                /*!< GPIO_T::DINOFF: DINOFF0 Mask           */

#define GPIO_DINOFF_DINOFF1_Pos          (17)                                              /*!< GPIO_T::DINOFF: DINOFF1 Position       */
#define GPIO_DINOFF_DINOFF1_Msk          (0x1ul << GPIO_DINOFF_DINOFF1_Pos)                /*!< GPIO_T::DINOFF: DINOFF1 Mask           */

#define GPIO_DINOFF_DINOFF2_Pos          (18)                                              /*!< GPIO_T::DINOFF: DINOFF2 Position       */
#define GPIO_DINOFF_DINOFF2_Msk          (0x1ul << GPIO_DINOFF_DINOFF2_Pos)                /*!< GPIO_T::DINOFF: DINOFF2 Mask           */

#define GPIO_DINOFF_DINOFF3_Pos          (19)                                              /*!< GPIO_T::DINOFF: DINOFF3 Position       */
#define GPIO_DINOFF_DINOFF3_Msk          (0x1ul << GPIO_DINOFF_DINOFF3_Pos)                /*!< GPIO_T::DINOFF: DINOFF3 Mask           */

#define GPIO_DINOFF_DINOFF4_Pos          (20)                                              /*!< GPIO_T::DINOFF: DINOFF4 Position       */
#define GPIO_DINOFF_DINOFF4_Msk          (0x1ul << GPIO_DINOFF_DINOFF4_Pos)                /*!< GPIO_T::DINOFF: DINOFF4 Mask           */

#define GPIO_DINOFF_DINOFF5_Pos          (21)                                              /*!< GPIO_T::DINOFF: DINOFF5 Position       */
#define GPIO_DINOFF_DINOFF5_Msk          (0x1ul << GPIO_DINOFF_DINOFF5_Pos)                /*!< GPIO_T::DINOFF: DINOFF5 Mask           */

#define GPIO_DINOFF_DINOFF6_Pos          (22)                                              /*!< GPIO_T::DINOFF: DINOFF6 Position       */
#define GPIO_DINOFF_DINOFF6_Msk          (0x1ul << GPIO_DINOFF_DINOFF6_Pos)                /*!< GPIO_T::DINOFF: DINOFF6 Mask           */

#define GPIO_DINOFF_DINOFF7_Pos          (23)                                              /*!< GPIO_T::DINOFF: DINOFF7 Position       */
#define GPIO_DINOFF_DINOFF7_Msk          (0x1ul << GPIO_DINOFF_DINOFF7_Pos)                /*!< GPIO_T::DINOFF: DINOFF7 Mask           */

#define GPIO_DINOFF_DINOFF8_Pos          (24)                                              /*!< GPIO_T::DINOFF: DINOFF8 Position       */
#define GPIO_DINOFF_DINOFF8_Msk          (0x1ul << GPIO_DINOFF_DINOFF8_Pos)                /*!< GPIO_T::DINOFF: DINOFF8 Mask           */

#define GPIO_DINOFF_DINOFF9_Pos          (25)                                              /*!< GPIO_T::DINOFF: DINOFF9 Position       */
#define GPIO_DINOFF_DINOFF9_Msk          (0x1ul << GPIO_DINOFF_DINOFF9_Pos)                /*!< GPIO_T::DINOFF: DINOFF9 Mask           */

#define GPIO_DINOFF_DINOFF10_Pos         (26)                                              /*!< GPIO_T::DINOFF: DINOFF10 Position      */
#define GPIO_DINOFF_DINOFF10_Msk         (0x1ul << GPIO_DINOFF_DINOFF10_Pos)               /*!< GPIO_T::DINOFF: DINOFF10 Mask          */

#define GPIO_DINOFF_DINOFF11_Pos         (27)                                              /*!< GPIO_T::DINOFF: DINOFF11 Position      */
#define GPIO_DINOFF_DINOFF11_Msk         (0x1ul << GPIO_DINOFF_DINOFF11_Pos)               /*!< GPIO_T::DINOFF: DINOFF11 Mask          */

#define GPIO_DINOFF_DINOFF12_Pos         (28)                                              /*!< GPIO_T::DINOFF: DINOFF12 Position      */
#define GPIO_DINOFF_DINOFF12_Msk         (0x1ul << GPIO_DINOFF_DINOFF12_Pos)               /*!< GPIO_T::DINOFF: DINOFF12 Mask          */

#define GPIO_DINOFF_DINOFF13_Pos         (29)                                              /*!< GPIO_T::DINOFF: DINOFF13 Position      */
#define GPIO_DINOFF_DINOFF13_Msk         (0x1ul << GPIO_DINOFF_DINOFF13_Pos)               /*!< GPIO_T::DINOFF: DINOFF13 Mask          */

#define GPIO_DINOFF_DINOFF14_Pos         (30)                                              /*!< GPIO_T::DINOFF: DINOFF14 Position      */
#define GPIO_DINOFF_DINOFF14_Msk         (0x1ul << GPIO_DINOFF_DINOFF14_Pos)               /*!< GPIO_T::DINOFF: DINOFF14 Mask          */

#define GPIO_DINOFF_DINOFF15_Pos         (31)                                              /*!< GPIO_T::DINOFF: DINOFF15 Position      */
#define GPIO_DINOFF_DINOFF15_Msk         (0x1ul << GPIO_DINOFF_DINOFF15_Pos)               /*!< GPIO_T::DINOFF: DINOFF15 Mask          */

#define GPIO_DOUT_DOUT0_Pos              (0)                                               /*!< GPIO_T::DOUT: DOUT0 Position           */
#define GPIO_DOUT_DOUT0_Msk              (0x1ul << GPIO_DOUT_DOUT0_Pos)                    /*!< GPIO_T::DOUT: DOUT0 Mask               */

#define GPIO_DOUT_DOUT1_Pos              (1)                                               /*!< GPIO_T::DOUT: DOUT1 Position           */
#define GPIO_DOUT_DOUT1_Msk              (0x1ul << GPIO_DOUT_DOUT1_Pos)                    /*!< GPIO_T::DOUT: DOUT1 Mask               */

#define GPIO_DOUT_DOUT2_Pos              (2)                                               /*!< GPIO_T::DOUT: DOUT2 Position           */
#define GPIO_DOUT_DOUT2_Msk              (0x1ul << GPIO_DOUT_DOUT2_Pos)                    /*!< GPIO_T::DOUT: DOUT2 Mask               */

#define GPIO_DOUT_DOUT3_Pos              (3)                                               /*!< GPIO_T::DOUT: DOUT3 Position           */
#define GPIO_DOUT_DOUT3_Msk              (0x1ul << GPIO_DOUT_DOUT3_Pos)                    /*!< GPIO_T::DOUT: DOUT3 Mask               */

#define GPIO_DOUT_DOUT4_Pos              (4)                                               /*!< GPIO_T::DOUT: DOUT4 Position           */
#define GPIO_DOUT_DOUT4_Msk              (0x1ul << GPIO_DOUT_DOUT4_Pos)                    /*!< GPIO_T::DOUT: DOUT4 Mask               */

#define GPIO_DOUT_DOUT5_Pos              (5)                                               /*!< GPIO_T::DOUT: DOUT5 Position           */
#define GPIO_DOUT_DOUT5_Msk              (0x1ul << GPIO_DOUT_DOUT5_Pos)                    /*!< GPIO_T::DOUT: DOUT5 Mask               */

#define GPIO_DOUT_DOUT6_Pos              (6)                                               /*!< GPIO_T::DOUT: DOUT6 Position           */
#define GPIO_DOUT_DOUT6_Msk              (0x1ul << GPIO_DOUT_DOUT6_Pos)                    /*!< GPIO_T::DOUT: DOUT6 Mask               */

#define GPIO_DOUT_DOUT7_Pos              (7)                                               /*!< GPIO_T::DOUT: DOUT7 Position           */
#define GPIO_DOUT_DOUT7_Msk              (0x1ul << GPIO_DOUT_DOUT7_Pos)                    /*!< GPIO_T::DOUT: DOUT7 Mask               */

#define GPIO_DOUT_DOUT8_Pos              (8)                                               /*!< GPIO_T::DOUT: DOUT8 Position           */
#define GPIO_DOUT_DOUT8_Msk              (0x1ul << GPIO_DOUT_DOUT8_Pos)                    /*!< GPIO_T::DOUT: DOUT8 Mask               */

#define GPIO_DOUT_DOUT9_Pos              (9)                                               /*!< GPIO_T::DOUT: DOUT9 Position           */
#define GPIO_DOUT_DOUT9_Msk              (0x1ul << GPIO_DOUT_DOUT9_Pos)                    /*!< GPIO_T::DOUT: DOUT9 Mask               */

#define GPIO_DOUT_DOUT10_Pos             (10)                                              /*!< GPIO_T::DOUT: DOUT10 Position          */
#define GPIO_DOUT_DOUT10_Msk             (0x1ul << GPIO_DOUT_DOUT10_Pos)                   /*!< GPIO_T::DOUT: DOUT10 Mask              */

#define GPIO_DOUT_DOUT11_Pos             (11)                                              /*!< GPIO_T::DOUT: DOUT11 Position          */
#define GPIO_DOUT_DOUT11_Msk             (0x1ul << GPIO_DOUT_DOUT11_Pos)                   /*!< GPIO_T::DOUT: DOUT11 Mask              */

#define GPIO_DOUT_DOUT12_Pos             (12)                                              /*!< GPIO_T::DOUT: DOUT12 Position          */
#define GPIO_DOUT_DOUT12_Msk             (0x1ul << GPIO_DOUT_DOUT12_Pos)                   /*!< GPIO_T::DOUT: DOUT12 Mask              */

#define GPIO_DOUT_DOUT13_Pos             (13)                                              /*!< GPIO_T::DOUT: DOUT13 Position          */
#define GPIO_DOUT_DOUT13_Msk             (0x1ul << GPIO_DOUT_DOUT13_Pos)                   /*!< GPIO_T::DOUT: DOUT13 Mask              */

#define GPIO_DOUT_DOUT14_Pos             (14)                                              /*!< GPIO_T::DOUT: DOUT14 Position          */
#define GPIO_DOUT_DOUT14_Msk             (0x1ul << GPIO_DOUT_DOUT14_Pos)                   /*!< GPIO_T::DOUT: DOUT14 Mask              */

#define GPIO_DOUT_DOUT15_Pos             (15)                                              /*!< GPIO_T::DOUT: DOUT15 Position          */
#define GPIO_DOUT_DOUT15_Msk             (0x1ul << GPIO_DOUT_DOUT15_Pos)                   /*!< GPIO_T::DOUT: DOUT15 Mask              */

#define GPIO_DATMSK_DATMSK0_Pos          (0)                                               /*!< GPIO_T::DATMSK: DATMSK0 Position       */
#define GPIO_DATMSK_DATMSK0_Msk          (0x1ul << GPIO_DATMSK_DATMSK0_Pos)                /*!< GPIO_T::DATMSK: DATMSK0 Mask           */

#define GPIO_DATMSK_DATMSK1_Pos          (1)                                               /*!< GPIO_T::DATMSK: DATMSK1 Position       */
#define GPIO_DATMSK_DATMSK1_Msk          (0x1ul << GPIO_DATMSK_DATMSK1_Pos)                /*!< GPIO_T::DATMSK: DATMSK1 Mask           */

#define GPIO_DATMSK_DATMSK2_Pos          (2)                                               /*!< GPIO_T::DATMSK: DATMSK2 Position       */
#define GPIO_DATMSK_DATMSK2_Msk          (0x1ul << GPIO_DATMSK_DATMSK2_Pos)                /*!< GPIO_T::DATMSK: DATMSK2 Mask           */

#define GPIO_DATMSK_DATMSK3_Pos          (3)                                               /*!< GPIO_T::DATMSK: DATMSK3 Position       */
#define GPIO_DATMSK_DATMSK3_Msk          (0x1ul << GPIO_DATMSK_DATMSK3_Pos)                /*!< GPIO_T::DATMSK: DATMSK3 Mask           */

#define GPIO_DATMSK_DATMSK4_Pos          (4)                                               /*!< GPIO_T::DATMSK: DATMSK4 Position       */
#define GPIO_DATMSK_DATMSK4_Msk          (0x1ul << GPIO_DATMSK_DATMSK4_Pos)                /*!< GPIO_T::DATMSK: DATMSK4 Mask           */

#define GPIO_DATMSK_DATMSK5_Pos          (5)                                               /*!< GPIO_T::DATMSK: DATMSK5 Position       */
#define GPIO_DATMSK_DATMSK5_Msk          (0x1ul << GPIO_DATMSK_DATMSK5_Pos)                /*!< GPIO_T::DATMSK: DATMSK5 Mask           */

#define GPIO_DATMSK_DATMSK6_Pos          (6)                                               /*!< GPIO_T::DATMSK: DATMSK6 Position       */
#define GPIO_DATMSK_DATMSK6_Msk          (0x1ul << GPIO_DATMSK_DATMSK6_Pos)                /*!< GPIO_T::DATMSK: DATMSK6 Mask           */

#define GPIO_DATMSK_DATMSK7_Pos          (7)                                               /*!< GPIO_T::DATMSK: DATMSK7 Position       */
#define GPIO_DATMSK_DATMSK7_Msk          (0x1ul << GPIO_DATMSK_DATMSK7_Pos)                /*!< GPIO_T::DATMSK: DATMSK7 Mask           */

#define GPIO_DATMSK_DATMSK8_Pos          (8)                                               /*!< GPIO_T::DATMSK: DATMSK8 Position       */
#define GPIO_DATMSK_DATMSK8_Msk          (0x1ul << GPIO_DATMSK_DATMSK8_Pos)                /*!< GPIO_T::DATMSK: DATMSK8 Mask           */

#define GPIO_DATMSK_DATMSK9_Pos          (9)                                               /*!< GPIO_T::DATMSK: DATMSK9 Position       */
#define GPIO_DATMSK_DATMSK9_Msk          (0x1ul << GPIO_DATMSK_DATMSK9_Pos)                /*!< GPIO_T::DATMSK: DATMSK9 Mask           */

#define GPIO_DATMSK_DATMSK10_Pos         (10)                                              /*!< GPIO_T::DATMSK: DATMSK10 Position      */
#define GPIO_DATMSK_DATMSK10_Msk         (0x1ul << GPIO_DATMSK_DATMSK10_Pos)               /*!< GPIO_T::DATMSK: DATMSK10 Mask          */

#define GPIO_DATMSK_DATMSK11_Pos         (11)                                              /*!< GPIO_T::DATMSK: DATMSK11 Position      */
#define GPIO_DATMSK_DATMSK11_Msk         (0x1ul << GPIO_DATMSK_DATMSK11_Pos)               /*!< GPIO_T::DATMSK: DATMSK11 Mask          */

#define GPIO_DATMSK_DATMSK12_Pos         (12)                                              /*!< GPIO_T::DATMSK: DATMSK12 Position      */
#define GPIO_DATMSK_DATMSK12_Msk         (0x1ul << GPIO_DATMSK_DATMSK12_Pos)               /*!< GPIO_T::DATMSK: DATMSK12 Mask          */

#define GPIO_DATMSK_DATMSK13_Pos         (13)                                              /*!< GPIO_T::DATMSK: DATMSK13 Position      */
#define GPIO_DATMSK_DATMSK13_Msk         (0x1ul << GPIO_DATMSK_DATMSK13_Pos)               /*!< GPIO_T::DATMSK: DATMSK13 Mask          */

#define GPIO_DATMSK_DATMSK14_Pos         (14)                                              /*!< GPIO_T::DATMSK: DATMSK14 Position      */
#define GPIO_DATMSK_DATMSK14_Msk         (0x1ul << GPIO_DATMSK_DATMSK14_Pos)               /*!< GPIO_T::DATMSK: DATMSK14 Mask          */

#define GPIO_DATMSK_DATMSK15_Pos         (15)                                              /*!< GPIO_T::DATMSK: DATMSK15 Position      */
#define GPIO_DATMSK_DATMSK15_Msk         (0x1ul << GPIO_DATMSK_DATMSK15_Pos)               /*!< GPIO_T::DATMSK: DATMSK15 Mask          */

#define GPIO_PIN_PIN0_Pos                (0)                                               /*!< GPIO_T::PIN: PIN0 Position             */
#define GPIO_PIN_PIN0_Msk                (0x1ul << GPIO_PIN_PIN0_Pos)                      /*!< GPIO_T::PIN: PIN0 Mask                 */

#define GPIO_PIN_PIN1_Pos                (1)                                               /*!< GPIO_T::PIN: PIN1 Position             */
#define GPIO_PIN_PIN1_Msk                (0x1ul << GPIO_PIN_PIN1_Pos)                      /*!< GPIO_T::PIN: PIN1 Mask                 */

#define GPIO_PIN_PIN2_Pos                (2)                                               /*!< GPIO_T::PIN: PIN2 Position             */
#define GPIO_PIN_PIN2_Msk                (0x1ul << GPIO_PIN_PIN2_Pos)                      /*!< GPIO_T::PIN: PIN2 Mask                 */

#define GPIO_PIN_PIN3_Pos                (3)                                               /*!< GPIO_T::PIN: PIN3 Position             */
#define GPIO_PIN_PIN3_Msk                (0x1ul << GPIO_PIN_PIN3_Pos)                      /*!< GPIO_T::PIN: PIN3 Mask                 */

#define GPIO_PIN_PIN4_Pos                (4)                                               /*!< GPIO_T::PIN: PIN4 Position             */
#define GPIO_PIN_PIN4_Msk                (0x1ul << GPIO_PIN_PIN4_Pos)                      /*!< GPIO_T::PIN: PIN4 Mask                 */

#define GPIO_PIN_PIN5_Pos                (5)                                               /*!< GPIO_T::PIN: PIN5 Position             */
#define GPIO_PIN_PIN5_Msk                (0x1ul << GPIO_PIN_PIN5_Pos)                      /*!< GPIO_T::PIN: PIN5 Mask                 */

#define GPIO_PIN_PIN6_Pos                (6)                                               /*!< GPIO_T::PIN: PIN6 Position             */
#define GPIO_PIN_PIN6_Msk                (0x1ul << GPIO_PIN_PIN6_Pos)                      /*!< GPIO_T::PIN: PIN6 Mask                 */

#define GPIO_PIN_PIN7_Pos                (7)                                               /*!< GPIO_T::PIN: PIN7 Position             */
#define GPIO_PIN_PIN7_Msk                (0x1ul << GPIO_PIN_PIN7_Pos)                      /*!< GPIO_T::PIN: PIN7 Mask                 */

#define GPIO_PIN_PIN8_Pos                (8)                                               /*!< GPIO_T::PIN: PIN8 Position             */
#define GPIO_PIN_PIN8_Msk                (0x1ul << GPIO_PIN_PIN8_Pos)                      /*!< GPIO_T::PIN: PIN8 Mask                 */

#define GPIO_PIN_PIN9_Pos                (9)                                               /*!< GPIO_T::PIN: PIN9 Position             */
#define GPIO_PIN_PIN9_Msk                (0x1ul << GPIO_PIN_PIN9_Pos)                      /*!< GPIO_T::PIN: PIN9 Mask                 */

#define GPIO_PIN_PIN10_Pos               (10)                                              /*!< GPIO_T::PIN: PIN10 Position            */
#define GPIO_PIN_PIN10_Msk               (0x1ul << GPIO_PIN_PIN10_Pos)                     /*!< GPIO_T::PIN: PIN10 Mask                */

#define GPIO_PIN_PIN11_Pos               (11)                                              /*!< GPIO_T::PIN: PIN11 Position            */
#define GPIO_PIN_PIN11_Msk               (0x1ul << GPIO_PIN_PIN11_Pos)                     /*!< GPIO_T::PIN: PIN11 Mask                */

#define GPIO_PIN_PIN12_Pos               (12)                                              /*!< GPIO_T::PIN: PIN12 Position            */
#define GPIO_PIN_PIN12_Msk               (0x1ul << GPIO_PIN_PIN12_Pos)                     /*!< GPIO_T::PIN: PIN12 Mask                */

#define GPIO_PIN_PIN13_Pos               (13)                                              /*!< GPIO_T::PIN: PIN13 Position            */
#define GPIO_PIN_PIN13_Msk               (0x1ul << GPIO_PIN_PIN13_Pos)                     /*!< GPIO_T::PIN: PIN13 Mask                */

#define GPIO_PIN_PIN14_Pos               (14)                                              /*!< GPIO_T::PIN: PIN14 Position            */
#define GPIO_PIN_PIN14_Msk               (0x1ul << GPIO_PIN_PIN14_Pos)                     /*!< GPIO_T::PIN: PIN14 Mask                */

#define GPIO_PIN_PIN15_Pos               (15)                                              /*!< GPIO_T::PIN: PIN15 Position            */
#define GPIO_PIN_PIN15_Msk               (0x1ul << GPIO_PIN_PIN15_Pos)                     /*!< GPIO_T::PIN: PIN15 Mask                */

#define GPIO_DBEN_DBEN0_Pos              (0)                                               /*!< GPIO_T::DBEN: DBEN0 Position           */
#define GPIO_DBEN_DBEN0_Msk              (0x1ul << GPIO_DBEN_DBEN0_Pos)                    /*!< GPIO_T::DBEN: DBEN0 Mask               */

#define GPIO_DBEN_DBEN1_Pos              (1)                                               /*!< GPIO_T::DBEN: DBEN1 Position           */
#define GPIO_DBEN_DBEN1_Msk              (0x1ul << GPIO_DBEN_DBEN1_Pos)                    /*!< GPIO_T::DBEN: DBEN1 Mask               */

#define GPIO_DBEN_DBEN2_Pos              (2)                                               /*!< GPIO_T::DBEN: DBEN2 Position           */
#define GPIO_DBEN_DBEN2_Msk              (0x1ul << GPIO_DBEN_DBEN2_Pos)                    /*!< GPIO_T::DBEN: DBEN2 Mask               */

#define GPIO_DBEN_DBEN3_Pos              (3)                                               /*!< GPIO_T::DBEN: DBEN3 Position           */
#define GPIO_DBEN_DBEN3_Msk              (0x1ul << GPIO_DBEN_DBEN3_Pos)                    /*!< GPIO_T::DBEN: DBEN3 Mask               */

#define GPIO_DBEN_DBEN4_Pos              (4)                                               /*!< GPIO_T::DBEN: DBEN4 Position           */
#define GPIO_DBEN_DBEN4_Msk              (0x1ul << GPIO_DBEN_DBEN4_Pos)                    /*!< GPIO_T::DBEN: DBEN4 Mask               */

#define GPIO_DBEN_DBEN5_Pos              (5)                                               /*!< GPIO_T::DBEN: DBEN5 Position           */
#define GPIO_DBEN_DBEN5_Msk              (0x1ul << GPIO_DBEN_DBEN5_Pos)                    /*!< GPIO_T::DBEN: DBEN5 Mask               */

#define GPIO_DBEN_DBEN6_Pos              (6)                                               /*!< GPIO_T::DBEN: DBEN6 Position           */
#define GPIO_DBEN_DBEN6_Msk              (0x1ul << GPIO_DBEN_DBEN6_Pos)                    /*!< GPIO_T::DBEN: DBEN6 Mask               */

#define GPIO_DBEN_DBEN7_Pos              (7)                                               /*!< GPIO_T::DBEN: DBEN7 Position           */
#define GPIO_DBEN_DBEN7_Msk              (0x1ul << GPIO_DBEN_DBEN7_Pos)                    /*!< GPIO_T::DBEN: DBEN7 Mask               */

#define GPIO_DBEN_DBEN8_Pos              (8)                                               /*!< GPIO_T::DBEN: DBEN8 Position           */
#define GPIO_DBEN_DBEN8_Msk              (0x1ul << GPIO_DBEN_DBEN8_Pos)                    /*!< GPIO_T::DBEN: DBEN8 Mask               */

#define GPIO_DBEN_DBEN9_Pos              (9)                                               /*!< GPIO_T::DBEN: DBEN9 Position           */
#define GPIO_DBEN_DBEN9_Msk              (0x1ul << GPIO_DBEN_DBEN9_Pos)                    /*!< GPIO_T::DBEN: DBEN9 Mask               */

#define GPIO_DBEN_DBEN10_Pos             (10)                                              /*!< GPIO_T::DBEN: DBEN10 Position          */
#define GPIO_DBEN_DBEN10_Msk             (0x1ul << GPIO_DBEN_DBEN10_Pos)                   /*!< GPIO_T::DBEN: DBEN10 Mask              */

#define GPIO_DBEN_DBEN11_Pos             (11)                                              /*!< GPIO_T::DBEN: DBEN11 Position          */
#define GPIO_DBEN_DBEN11_Msk             (0x1ul << GPIO_DBEN_DBEN11_Pos)                   /*!< GPIO_T::DBEN: DBEN11 Mask              */

#define GPIO_DBEN_DBEN12_Pos             (12)                                              /*!< GPIO_T::DBEN: DBEN12 Position          */
#define GPIO_DBEN_DBEN12_Msk             (0x1ul << GPIO_DBEN_DBEN12_Pos)                   /*!< GPIO_T::DBEN: DBEN12 Mask              */

#define GPIO_DBEN_DBEN13_Pos             (13)                                              /*!< GPIO_T::DBEN: DBEN13 Position          */
#define GPIO_DBEN_DBEN13_Msk             (0x1ul << GPIO_DBEN_DBEN13_Pos)                   /*!< GPIO_T::DBEN: DBEN13 Mask              */

#define GPIO_DBEN_DBEN14_Pos             (14)                                              /*!< GPIO_T::DBEN: DBEN14 Position          */
#define GPIO_DBEN_DBEN14_Msk             (0x1ul << GPIO_DBEN_DBEN14_Pos)                   /*!< GPIO_T::DBEN: DBEN14 Mask              */

#define GPIO_DBEN_DBEN15_Pos             (15)                                              /*!< GPIO_T::DBEN: DBEN15 Position          */
#define GPIO_DBEN_DBEN15_Msk             (0x1ul << GPIO_DBEN_DBEN15_Pos)                   /*!< GPIO_T::DBEN: DBEN15 Mask              */

#define GPIO_INTTYPE_TYPE0_Pos           (0)                                               /*!< GPIO_T::INTTYPE: TYPE0 Position        */
#define GPIO_INTTYPE_TYPE0_Msk           (0x1ul << GPIO_INTTYPE_TYPE0_Pos)                 /*!< GPIO_T::INTTYPE: TYPE0 Mask            */

#define GPIO_INTTYPE_TYPE1_Pos           (1)                                               /*!< GPIO_T::INTTYPE: TYPE1 Position        */
#define GPIO_INTTYPE_TYPE1_Msk           (0x1ul << GPIO_INTTYPE_TYPE1_Pos)                 /*!< GPIO_T::INTTYPE: TYPE1 Mask            */

#define GPIO_INTTYPE_TYPE2_Pos           (2)                                               /*!< GPIO_T::INTTYPE: TYPE2 Position        */
#define GPIO_INTTYPE_TYPE2_Msk           (0x1ul << GPIO_INTTYPE_TYPE2_Pos)                 /*!< GPIO_T::INTTYPE: TYPE2 Mask            */

#define GPIO_INTTYPE_TYPE3_Pos           (3)                                               /*!< GPIO_T::INTTYPE: TYPE3 Position        */
#define GPIO_INTTYPE_TYPE3_Msk           (0x1ul << GPIO_INTTYPE_TYPE3_Pos)                 /*!< GPIO_T::INTTYPE: TYPE3 Mask            */

#define GPIO_INTTYPE_TYPE4_Pos           (4)                                               /*!< GPIO_T::INTTYPE: TYPE4 Position        */
#define GPIO_INTTYPE_TYPE4_Msk           (0x1ul << GPIO_INTTYPE_TYPE4_Pos)                 /*!< GPIO_T::INTTYPE: TYPE4 Mask            */

#define GPIO_INTTYPE_TYPE5_Pos           (5)                                               /*!< GPIO_T::INTTYPE: TYPE5 Position        */
#define GPIO_INTTYPE_TYPE5_Msk           (0x1ul << GPIO_INTTYPE_TYPE5_Pos)                 /*!< GPIO_T::INTTYPE: TYPE5 Mask            */

#define GPIO_INTTYPE_TYPE6_Pos           (6)                                               /*!< GPIO_T::INTTYPE: TYPE6 Position        */
#define GPIO_INTTYPE_TYPE6_Msk           (0x1ul << GPIO_INTTYPE_TYPE6_Pos)                 /*!< GPIO_T::INTTYPE: TYPE6 Mask            */

#define GPIO_INTTYPE_TYPE7_Pos           (7)                                               /*!< GPIO_T::INTTYPE: TYPE7 Position        */
#define GPIO_INTTYPE_TYPE7_Msk           (0x1ul << GPIO_INTTYPE_TYPE7_Pos)                 /*!< GPIO_T::INTTYPE: TYPE7 Mask            */

#define GPIO_INTTYPE_TYPE8_Pos           (8)                                               /*!< GPIO_T::INTTYPE: TYPE8 Position        */
#define GPIO_INTTYPE_TYPE8_Msk           (0x1ul << GPIO_INTTYPE_TYPE8_Pos)                 /*!< GPIO_T::INTTYPE: TYPE8 Mask            */

#define GPIO_INTTYPE_TYPE9_Pos           (9)                                               /*!< GPIO_T::INTTYPE: TYPE9 Position        */
#define GPIO_INTTYPE_TYPE9_Msk           (0x1ul << GPIO_INTTYPE_TYPE9_Pos)                 /*!< GPIO_T::INTTYPE: TYPE9 Mask            */

#define GPIO_INTTYPE_TYPE10_Pos          (10)                                              /*!< GPIO_T::INTTYPE: TYPE10 Position       */
#define GPIO_INTTYPE_TYPE10_Msk          (0x1ul << GPIO_INTTYPE_TYPE10_Pos)                /*!< GPIO_T::INTTYPE: TYPE10 Mask           */

#define GPIO_INTTYPE_TYPE11_Pos          (11)                                              /*!< GPIO_T::INTTYPE: TYPE11 Position       */
#define GPIO_INTTYPE_TYPE11_Msk          (0x1ul << GPIO_INTTYPE_TYPE11_Pos)                /*!< GPIO_T::INTTYPE: TYPE11 Mask           */

#define GPIO_INTTYPE_TYPE12_Pos          (12)                                              /*!< GPIO_T::INTTYPE: TYPE12 Position       */
#define GPIO_INTTYPE_TYPE12_Msk          (0x1ul << GPIO_INTTYPE_TYPE12_Pos)                /*!< GPIO_T::INTTYPE: TYPE12 Mask           */

#define GPIO_INTTYPE_TYPE13_Pos          (13)                                              /*!< GPIO_T::INTTYPE: TYPE13 Position       */
#define GPIO_INTTYPE_TYPE13_Msk          (0x1ul << GPIO_INTTYPE_TYPE13_Pos)                /*!< GPIO_T::INTTYPE: TYPE13 Mask           */

#define GPIO_INTTYPE_TYPE14_Pos          (14)                                              /*!< GPIO_T::INTTYPE: TYPE14 Position       */
#define GPIO_INTTYPE_TYPE14_Msk          (0x1ul << GPIO_INTTYPE_TYPE14_Pos)                /*!< GPIO_T::INTTYPE: TYPE14 Mask           */

#define GPIO_INTTYPE_TYPE15_Pos          (15)                                              /*!< GPIO_T::INTTYPE: TYPE15 Position       */
#define GPIO_INTTYPE_TYPE15_Msk          (0x1ul << GPIO_INTTYPE_TYPE15_Pos)                /*!< GPIO_T::INTTYPE: TYPE15 Mask           */

#define GPIO_INTEN_FLIEN0_Pos            (0)                                               /*!< GPIO_T::INTEN: FLIEN0 Position         */
#define GPIO_INTEN_FLIEN0_Msk            (0x1ul << GPIO_INTEN_FLIEN0_Pos)                  /*!< GPIO_T::INTEN: FLIEN0 Mask             */

#define GPIO_INTEN_FLIEN1_Pos            (1)                                               /*!< GPIO_T::INTEN: FLIEN1 Position         */
#define GPIO_INTEN_FLIEN1_Msk            (0x1ul << GPIO_INTEN_FLIEN1_Pos)                  /*!< GPIO_T::INTEN: FLIEN1 Mask             */

#define GPIO_INTEN_FLIEN2_Pos            (2)                                               /*!< GPIO_T::INTEN: FLIEN2 Position         */
#define GPIO_INTEN_FLIEN2_Msk            (0x1ul << GPIO_INTEN_FLIEN2_Pos)                  /*!< GPIO_T::INTEN: FLIEN2 Mask             */

#define GPIO_INTEN_FLIEN3_Pos            (3)                                               /*!< GPIO_T::INTEN: FLIEN3 Position         */
#define GPIO_INTEN_FLIEN3_Msk            (0x1ul << GPIO_INTEN_FLIEN3_Pos)                  /*!< GPIO_T::INTEN: FLIEN3 Mask             */

#define GPIO_INTEN_FLIEN4_Pos            (4)                                               /*!< GPIO_T::INTEN: FLIEN4 Position         */
#define GPIO_INTEN_FLIEN4_Msk            (0x1ul << GPIO_INTEN_FLIEN4_Pos)                  /*!< GPIO_T::INTEN: FLIEN4 Mask             */

#define GPIO_INTEN_FLIEN5_Pos            (5)                                               /*!< GPIO_T::INTEN: FLIEN5 Position         */
#define GPIO_INTEN_FLIEN5_Msk            (0x1ul << GPIO_INTEN_FLIEN5_Pos)                  /*!< GPIO_T::INTEN: FLIEN5 Mask             */

#define GPIO_INTEN_FLIEN6_Pos            (6)                                               /*!< GPIO_T::INTEN: FLIEN6 Position         */
#define GPIO_INTEN_FLIEN6_Msk            (0x1ul << GPIO_INTEN_FLIEN6_Pos)                  /*!< GPIO_T::INTEN: FLIEN6 Mask             */

#define GPIO_INTEN_FLIEN7_Pos            (7)                                               /*!< GPIO_T::INTEN: FLIEN7 Position         */
#define GPIO_INTEN_FLIEN7_Msk            (0x1ul << GPIO_INTEN_FLIEN7_Pos)                  /*!< GPIO_T::INTEN: FLIEN7 Mask             */

#define GPIO_INTEN_FLIEN8_Pos            (8)                                               /*!< GPIO_T::INTEN: FLIEN8 Position         */
#define GPIO_INTEN_FLIEN8_Msk            (0x1ul << GPIO_INTEN_FLIEN8_Pos)                  /*!< GPIO_T::INTEN: FLIEN8 Mask             */

#define GPIO_INTEN_FLIEN9_Pos            (9)                                               /*!< GPIO_T::INTEN: FLIEN9 Position         */
#define GPIO_INTEN_FLIEN9_Msk            (0x1ul << GPIO_INTEN_FLIEN9_Pos)                  /*!< GPIO_T::INTEN: FLIEN9 Mask             */

#define GPIO_INTEN_FLIEN10_Pos           (10)                                              /*!< GPIO_T::INTEN: FLIEN10 Position        */
#define GPIO_INTEN_FLIEN10_Msk           (0x1ul << GPIO_INTEN_FLIEN10_Pos)                 /*!< GPIO_T::INTEN: FLIEN10 Mask            */

#define GPIO_INTEN_FLIEN11_Pos           (11)                                              /*!< GPIO_T::INTEN: FLIEN11 Position        */
#define GPIO_INTEN_FLIEN11_Msk           (0x1ul << GPIO_INTEN_FLIEN11_Pos)                 /*!< GPIO_T::INTEN: FLIEN11 Mask            */

#define GPIO_INTEN_FLIEN12_Pos           (12)                                              /*!< GPIO_T::INTEN: FLIEN12 Position        */
#define GPIO_INTEN_FLIEN12_Msk           (0x1ul << GPIO_INTEN_FLIEN12_Pos)                 /*!< GPIO_T::INTEN: FLIEN12 Mask            */

#define GPIO_INTEN_FLIEN13_Pos           (13)                                              /*!< GPIO_T::INTEN: FLIEN13 Position        */
#define GPIO_INTEN_FLIEN13_Msk           (0x1ul << GPIO_INTEN_FLIEN13_Pos)                 /*!< GPIO_T::INTEN: FLIEN13 Mask            */

#define GPIO_INTEN_FLIEN14_Pos           (14)                                              /*!< GPIO_T::INTEN: FLIEN14 Position        */
#define GPIO_INTEN_FLIEN14_Msk           (0x1ul << GPIO_INTEN_FLIEN14_Pos)                 /*!< GPIO_T::INTEN: FLIEN14 Mask            */

#define GPIO_INTEN_FLIEN15_Pos           (15)                                              /*!< GPIO_T::INTEN: FLIEN15 Position        */
#define GPIO_INTEN_FLIEN15_Msk           (0x1ul << GPIO_INTEN_FLIEN15_Pos)                 /*!< GPIO_T::INTEN: FLIEN15 Mask            */

#define GPIO_INTEN_RHIEN0_Pos            (16)                                              /*!< GPIO_T::INTEN: RHIEN0 Position         */
#define GPIO_INTEN_RHIEN0_Msk            (0x1ul << GPIO_INTEN_RHIEN0_Pos)                  /*!< GPIO_T::INTEN: RHIEN0 Mask             */

#define GPIO_INTEN_RHIEN1_Pos            (17)                                              /*!< GPIO_T::INTEN: RHIEN1 Position         */
#define GPIO_INTEN_RHIEN1_Msk            (0x1ul << GPIO_INTEN_RHIEN1_Pos)                  /*!< GPIO_T::INTEN: RHIEN1 Mask             */

#define GPIO_INTEN_RHIEN2_Pos            (18)                                              /*!< GPIO_T::INTEN: RHIEN2 Position         */
#define GPIO_INTEN_RHIEN2_Msk            (0x1ul << GPIO_INTEN_RHIEN2_Pos)                  /*!< GPIO_T::INTEN: RHIEN2 Mask             */

#define GPIO_INTEN_RHIEN3_Pos            (19)                                              /*!< GPIO_T::INTEN: RHIEN3 Position         */
#define GPIO_INTEN_RHIEN3_Msk            (0x1ul << GPIO_INTEN_RHIEN3_Pos)                  /*!< GPIO_T::INTEN: RHIEN3 Mask             */

#define GPIO_INTEN_RHIEN4_Pos            (20)                                              /*!< GPIO_T::INTEN: RHIEN4 Position         */
#define GPIO_INTEN_RHIEN4_Msk            (0x1ul << GPIO_INTEN_RHIEN4_Pos)                  /*!< GPIO_T::INTEN: RHIEN4 Mask             */

#define GPIO_INTEN_RHIEN5_Pos            (21)                                              /*!< GPIO_T::INTEN: RHIEN5 Position         */
#define GPIO_INTEN_RHIEN5_Msk            (0x1ul << GPIO_INTEN_RHIEN5_Pos)                  /*!< GPIO_T::INTEN: RHIEN5 Mask             */

#define GPIO_INTEN_RHIEN6_Pos            (22)                                              /*!< GPIO_T::INTEN: RHIEN6 Position         */
#define GPIO_INTEN_RHIEN6_Msk            (0x1ul << GPIO_INTEN_RHIEN6_Pos)                  /*!< GPIO_T::INTEN: RHIEN6 Mask             */

#define GPIO_INTEN_RHIEN7_Pos            (23)                                              /*!< GPIO_T::INTEN: RHIEN7 Position         */
#define GPIO_INTEN_RHIEN7_Msk            (0x1ul << GPIO_INTEN_RHIEN7_Pos)                  /*!< GPIO_T::INTEN: RHIEN7 Mask             */

#define GPIO_INTEN_RHIEN8_Pos            (24)                                              /*!< GPIO_T::INTEN: RHIEN8 Position         */
#define GPIO_INTEN_RHIEN8_Msk            (0x1ul << GPIO_INTEN_RHIEN8_Pos)                  /*!< GPIO_T::INTEN: RHIEN8 Mask             */

#define GPIO_INTEN_RHIEN9_Pos            (25)                                              /*!< GPIO_T::INTEN: RHIEN9 Position         */
#define GPIO_INTEN_RHIEN9_Msk            (0x1ul << GPIO_INTEN_RHIEN9_Pos)                  /*!< GPIO_T::INTEN: RHIEN9 Mask             */

#define GPIO_INTEN_RHIEN10_Pos           (26)                                              /*!< GPIO_T::INTEN: RHIEN10 Position        */
#define GPIO_INTEN_RHIEN10_Msk           (0x1ul << GPIO_INTEN_RHIEN10_Pos)                 /*!< GPIO_T::INTEN: RHIEN10 Mask            */

#define GPIO_INTEN_RHIEN11_Pos           (27)                                              /*!< GPIO_T::INTEN: RHIEN11 Position        */
#define GPIO_INTEN_RHIEN11_Msk           (0x1ul << GPIO_INTEN_RHIEN11_Pos)                 /*!< GPIO_T::INTEN: RHIEN11 Mask            */

#define GPIO_INTEN_RHIEN12_Pos           (28)                                              /*!< GPIO_T::INTEN: RHIEN12 Position        */
#define GPIO_INTEN_RHIEN12_Msk           (0x1ul << GPIO_INTEN_RHIEN12_Pos)                 /*!< GPIO_T::INTEN: RHIEN12 Mask            */

#define GPIO_INTEN_RHIEN13_Pos           (29)                                              /*!< GPIO_T::INTEN: RHIEN13 Position        */
#define GPIO_INTEN_RHIEN13_Msk           (0x1ul << GPIO_INTEN_RHIEN13_Pos)                 /*!< GPIO_T::INTEN: RHIEN13 Mask            */

#define GPIO_INTEN_RHIEN14_Pos           (30)                                              /*!< GPIO_T::INTEN: RHIEN14 Position        */
#define GPIO_INTEN_RHIEN14_Msk           (0x1ul << GPIO_INTEN_RHIEN14_Pos)                 /*!< GPIO_T::INTEN: RHIEN14 Mask            */

#define GPIO_INTEN_RHIEN15_Pos           (31)                                              /*!< GPIO_T::INTEN: RHIEN15 Position        */
#define GPIO_INTEN_RHIEN15_Msk           (0x1ul << GPIO_INTEN_RHIEN15_Pos)                 /*!< GPIO_T::INTEN: RHIEN15 Mask            */

#define GPIO_INTSRC_INTSRC0_Pos          (0)                                               /*!< GPIO_T::INTSRC: INTSRC0 Position       */
#define GPIO_INTSRC_INTSRC0_Msk          (0x1ul << GPIO_INTSRC_INTSRC0_Pos)                /*!< GPIO_T::INTSRC: INTSRC0 Mask           */

#define GPIO_INTSRC_INTSRC1_Pos          (1)                                               /*!< GPIO_T::INTSRC: INTSRC1 Position       */
#define GPIO_INTSRC_INTSRC1_Msk          (0x1ul << GPIO_INTSRC_INTSRC1_Pos)                /*!< GPIO_T::INTSRC: INTSRC1 Mask           */

#define GPIO_INTSRC_INTSRC2_Pos          (2)                                               /*!< GPIO_T::INTSRC: INTSRC2 Position       */
#define GPIO_INTSRC_INTSRC2_Msk          (0x1ul << GPIO_INTSRC_INTSRC2_Pos)                /*!< GPIO_T::INTSRC: INTSRC2 Mask           */

#define GPIO_INTSRC_INTSRC3_Pos          (3)                                               /*!< GPIO_T::INTSRC: INTSRC3 Position       */
#define GPIO_INTSRC_INTSRC3_Msk          (0x1ul << GPIO_INTSRC_INTSRC3_Pos)                /*!< GPIO_T::INTSRC: INTSRC3 Mask           */

#define GPIO_INTSRC_INTSRC4_Pos          (4)                                               /*!< GPIO_T::INTSRC: INTSRC4 Position       */
#define GPIO_INTSRC_INTSRC4_Msk          (0x1ul << GPIO_INTSRC_INTSRC4_Pos)                /*!< GPIO_T::INTSRC: INTSRC4 Mask           */

#define GPIO_INTSRC_INTSRC5_Pos          (5)                                               /*!< GPIO_T::INTSRC: INTSRC5 Position       */
#define GPIO_INTSRC_INTSRC5_Msk          (0x1ul << GPIO_INTSRC_INTSRC5_Pos)                /*!< GPIO_T::INTSRC: INTSRC5 Mask           */

#define GPIO_INTSRC_INTSRC6_Pos          (6)                                               /*!< GPIO_T::INTSRC: INTSRC6 Position       */
#define GPIO_INTSRC_INTSRC6_Msk          (0x1ul << GPIO_INTSRC_INTSRC6_Pos)                /*!< GPIO_T::INTSRC: INTSRC6 Mask           */

#define GPIO_INTSRC_INTSRC7_Pos          (7)                                               /*!< GPIO_T::INTSRC: INTSRC7 Position       */
#define GPIO_INTSRC_INTSRC7_Msk          (0x1ul << GPIO_INTSRC_INTSRC7_Pos)                /*!< GPIO_T::INTSRC: INTSRC7 Mask           */

#define GPIO_INTSRC_INTSRC8_Pos          (8)                                               /*!< GPIO_T::INTSRC: INTSRC8 Position       */
#define GPIO_INTSRC_INTSRC8_Msk          (0x1ul << GPIO_INTSRC_INTSRC8_Pos)                /*!< GPIO_T::INTSRC: INTSRC8 Mask           */

#define GPIO_INTSRC_INTSRC9_Pos          (9)                                               /*!< GPIO_T::INTSRC: INTSRC9 Position       */
#define GPIO_INTSRC_INTSRC9_Msk          (0x1ul << GPIO_INTSRC_INTSRC9_Pos)                /*!< GPIO_T::INTSRC: INTSRC9 Mask           */

#define GPIO_INTSRC_INTSRC10_Pos         (10)                                              /*!< GPIO_T::INTSRC: INTSRC10 Position      */
#define GPIO_INTSRC_INTSRC10_Msk         (0x1ul << GPIO_INTSRC_INTSRC10_Pos)               /*!< GPIO_T::INTSRC: INTSRC10 Mask          */

#define GPIO_INTSRC_INTSRC11_Pos         (11)                                              /*!< GPIO_T::INTSRC: INTSRC11 Position      */
#define GPIO_INTSRC_INTSRC11_Msk         (0x1ul << GPIO_INTSRC_INTSRC11_Pos)               /*!< GPIO_T::INTSRC: INTSRC11 Mask          */

#define GPIO_INTSRC_INTSRC12_Pos         (12)                                              /*!< GPIO_T::INTSRC: INTSRC12 Position      */
#define GPIO_INTSRC_INTSRC12_Msk         (0x1ul << GPIO_INTSRC_INTSRC12_Pos)               /*!< GPIO_T::INTSRC: INTSRC12 Mask          */

#define GPIO_INTSRC_INTSRC13_Pos         (13)                                              /*!< GPIO_T::INTSRC: INTSRC13 Position      */
#define GPIO_INTSRC_INTSRC13_Msk         (0x1ul << GPIO_INTSRC_INTSRC13_Pos)               /*!< GPIO_T::INTSRC: INTSRC13 Mask          */

#define GPIO_INTSRC_INTSRC14_Pos         (14)                                              /*!< GPIO_T::INTSRC: INTSRC14 Position      */
#define GPIO_INTSRC_INTSRC14_Msk         (0x1ul << GPIO_INTSRC_INTSRC14_Pos)               /*!< GPIO_T::INTSRC: INTSRC14 Mask          */

#define GPIO_INTSRC_INTSRC15_Pos         (15)                                              /*!< GPIO_T::INTSRC: INTSRC15 Position      */
#define GPIO_INTSRC_INTSRC15_Msk         (0x1ul << GPIO_INTSRC_INTSRC15_Pos)               /*!< GPIO_T::INTSRC: INTSRC15 Mask          */

#define GPIO_SMTEN_SMTEN0_Pos            (0)                                               /*!< GPIO_T::SMTEN: SMTEN0 Position         */
#define GPIO_SMTEN_SMTEN0_Msk            (0x1ul << GPIO_SMTEN_SMTEN0_Pos)                  /*!< GPIO_T::SMTEN: SMTEN0 Mask             */

#define GPIO_SMTEN_SMTEN1_Pos            (1)                                               /*!< GPIO_T::SMTEN: SMTEN1 Position         */
#define GPIO_SMTEN_SMTEN1_Msk            (0x1ul << GPIO_SMTEN_SMTEN1_Pos)                  /*!< GPIO_T::SMTEN: SMTEN1 Mask             */

#define GPIO_SMTEN_SMTEN2_Pos            (2)                                               /*!< GPIO_T::SMTEN: SMTEN2 Position         */
#define GPIO_SMTEN_SMTEN2_Msk            (0x1ul << GPIO_SMTEN_SMTEN2_Pos)                  /*!< GPIO_T::SMTEN: SMTEN2 Mask             */

#define GPIO_SMTEN_SMTEN3_Pos            (3)                                               /*!< GPIO_T::SMTEN: SMTEN3 Position         */
#define GPIO_SMTEN_SMTEN3_Msk            (0x1ul << GPIO_SMTEN_SMTEN3_Pos)                  /*!< GPIO_T::SMTEN: SMTEN3 Mask             */

#define GPIO_SMTEN_SMTEN4_Pos            (4)                                               /*!< GPIO_T::SMTEN: SMTEN4 Position         */
#define GPIO_SMTEN_SMTEN4_Msk            (0x1ul << GPIO_SMTEN_SMTEN4_Pos)                  /*!< GPIO_T::SMTEN: SMTEN4 Mask             */

#define GPIO_SMTEN_SMTEN5_Pos            (5)                                               /*!< GPIO_T::SMTEN: SMTEN5 Position         */
#define GPIO_SMTEN_SMTEN5_Msk            (0x1ul << GPIO_SMTEN_SMTEN5_Pos)                  /*!< GPIO_T::SMTEN: SMTEN5 Mask             */

#define GPIO_SMTEN_SMTEN6_Pos            (6)                                               /*!< GPIO_T::SMTEN: SMTEN6 Position         */
#define GPIO_SMTEN_SMTEN6_Msk            (0x1ul << GPIO_SMTEN_SMTEN6_Pos)                  /*!< GPIO_T::SMTEN: SMTEN6 Mask             */

#define GPIO_SMTEN_SMTEN7_Pos            (7)                                               /*!< GPIO_T::SMTEN: SMTEN7 Position         */
#define GPIO_SMTEN_SMTEN7_Msk            (0x1ul << GPIO_SMTEN_SMTEN7_Pos)                  /*!< GPIO_T::SMTEN: SMTEN7 Mask             */

#define GPIO_SMTEN_SMTEN8_Pos            (8)                                               /*!< GPIO_T::SMTEN: SMTEN8 Position         */
#define GPIO_SMTEN_SMTEN8_Msk            (0x1ul << GPIO_SMTEN_SMTEN8_Pos)                  /*!< GPIO_T::SMTEN: SMTEN8 Mask             */

#define GPIO_SMTEN_SMTEN9_Pos            (9)                                               /*!< GPIO_T::SMTEN: SMTEN9 Position         */
#define GPIO_SMTEN_SMTEN9_Msk            (0x1ul << GPIO_SMTEN_SMTEN9_Pos)                  /*!< GPIO_T::SMTEN: SMTEN9 Mask             */

#define GPIO_SMTEN_SMTEN10_Pos           (10)                                              /*!< GPIO_T::SMTEN: SMTEN10 Position        */
#define GPIO_SMTEN_SMTEN10_Msk           (0x1ul << GPIO_SMTEN_SMTEN10_Pos)                 /*!< GPIO_T::SMTEN: SMTEN10 Mask            */

#define GPIO_SMTEN_SMTEN11_Pos           (11)                                              /*!< GPIO_T::SMTEN: SMTEN11 Position        */
#define GPIO_SMTEN_SMTEN11_Msk           (0x1ul << GPIO_SMTEN_SMTEN11_Pos)                 /*!< GPIO_T::SMTEN: SMTEN11 Mask            */

#define GPIO_SMTEN_SMTEN12_Pos           (12)                                              /*!< GPIO_T::SMTEN: SMTEN12 Position        */
#define GPIO_SMTEN_SMTEN12_Msk           (0x1ul << GPIO_SMTEN_SMTEN12_Pos)                 /*!< GPIO_T::SMTEN: SMTEN12 Mask            */

#define GPIO_SMTEN_SMTEN13_Pos           (13)                                              /*!< GPIO_T::SMTEN: SMTEN13 Position        */
#define GPIO_SMTEN_SMTEN13_Msk           (0x1ul << GPIO_SMTEN_SMTEN13_Pos)                 /*!< GPIO_T::SMTEN: SMTEN13 Mask            */

#define GPIO_SMTEN_SMTEN14_Pos           (14)                                              /*!< GPIO_T::SMTEN: SMTEN14 Position        */
#define GPIO_SMTEN_SMTEN14_Msk           (0x1ul << GPIO_SMTEN_SMTEN14_Pos)                 /*!< GPIO_T::SMTEN: SMTEN14 Mask            */

#define GPIO_SMTEN_SMTEN15_Pos           (15)                                              /*!< GPIO_T::SMTEN: SMTEN15 Position        */
#define GPIO_SMTEN_SMTEN15_Msk           (0x1ul << GPIO_SMTEN_SMTEN15_Pos)                 /*!< GPIO_T::SMTEN: SMTEN15 Mask            */

#define GPIO_SLEWCTL_HSREN0_Pos          (0)                                               /*!< GPIO_T::SLEWCTL: HSREN0 Position       */
#define GPIO_SLEWCTL_HSREN0_Msk          (0x3ul << GPIO_SLEWCTL_HSREN0_Pos)                /*!< GPIO_T::SLEWCTL: HSREN0 Mask           */

#define GPIO_SLEWCTL_HSREN1_Pos          (2)                                               /*!< GPIO_T::SLEWCTL: HSREN1 Position       */
#define GPIO_SLEWCTL_HSREN1_Msk          (0x3ul << GPIO_SLEWCTL_HSREN1_Pos)                /*!< GPIO_T::SLEWCTL: HSREN1 Mask           */

#define GPIO_SLEWCTL_HSREN2_Pos          (4)                                               /*!< GPIO_T::SLEWCTL: HSREN2 Position       */
#define GPIO_SLEWCTL_HSREN2_Msk          (0x3ul << GPIO_SLEWCTL_HSREN2_Pos)                /*!< GPIO_T::SLEWCTL: HSREN2 Mask           */

#define GPIO_SLEWCTL_HSREN3_Pos          (6)                                               /*!< GPIO_T::SLEWCTL: HSREN3 Position       */
#define GPIO_SLEWCTL_HSREN3_Msk          (0x3ul << GPIO_SLEWCTL_HSREN3_Pos)                /*!< GPIO_T::SLEWCTL: HSREN3 Mask           */

#define GPIO_SLEWCTL_HSREN4_Pos          (8)                                               /*!< GPIO_T::SLEWCTL: HSREN4 Position       */
#define GPIO_SLEWCTL_HSREN4_Msk          (0x3ul << GPIO_SLEWCTL_HSREN4_Pos)                /*!< GPIO_T::SLEWCTL: HSREN4 Mask           */

#define GPIO_SLEWCTL_HSREN5_Pos          (10)                                              /*!< GPIO_T::SLEWCTL: HSREN5 Position       */
#define GPIO_SLEWCTL_HSREN5_Msk          (0x3ul << GPIO_SLEWCTL_HSREN5_Pos)                /*!< GPIO_T::SLEWCTL: HSREN5 Mask           */

#define GPIO_SLEWCTL_HSREN6_Pos          (12)                                              /*!< GPIO_T::SLEWCTL: HSREN6 Position       */
#define GPIO_SLEWCTL_HSREN6_Msk          (0x3ul << GPIO_SLEWCTL_HSREN6_Pos)                /*!< GPIO_T::SLEWCTL: HSREN6 Mask           */

#define GPIO_SLEWCTL_HSREN7_Pos          (14)                                              /*!< GPIO_T::SLEWCTL: HSREN7 Position       */
#define GPIO_SLEWCTL_HSREN7_Msk          (0x3ul << GPIO_SLEWCTL_HSREN7_Pos)                /*!< GPIO_T::SLEWCTL: HSREN7 Mask           */

#define GPIO_SLEWCTL_HSREN8_Pos          (16)                                              /*!< GPIO_T::SLEWCTL: HSREN8 Position       */
#define GPIO_SLEWCTL_HSREN8_Msk          (0x3ul << GPIO_SLEWCTL_HSREN8_Pos)                /*!< GPIO_T::SLEWCTL: HSREN8 Mask           */

#define GPIO_SLEWCTL_HSREN9_Pos          (18)                                              /*!< GPIO_T::SLEWCTL: HSREN9 Position       */
#define GPIO_SLEWCTL_HSREN9_Msk          (0x3ul << GPIO_SLEWCTL_HSREN9_Pos)                /*!< GPIO_T::SLEWCTL: HSREN9 Mask           */

#define GPIO_SLEWCTL_HSREN10_Pos         (20)                                              /*!< GPIO_T::SLEWCTL: HSREN10 Position      */
#define GPIO_SLEWCTL_HSREN10_Msk         (0x3ul << GPIO_SLEWCTL_HSREN10_Pos)               /*!< GPIO_T::SLEWCTL: HSREN10 Mask          */

#define GPIO_SLEWCTL_HSREN11_Pos         (22)                                              /*!< GPIO_T::SLEWCTL: HSREN11 Position      */
#define GPIO_SLEWCTL_HSREN11_Msk         (0x3ul << GPIO_SLEWCTL_HSREN11_Pos)               /*!< GPIO_T::SLEWCTL: HSREN11 Mask          */

#define GPIO_SLEWCTL_HSREN12_Pos         (24)                                              /*!< GPIO_T::SLEWCTL: HSREN12 Position      */
#define GPIO_SLEWCTL_HSREN12_Msk         (0x3ul << GPIO_SLEWCTL_HSREN12_Pos)               /*!< GPIO_T::SLEWCTL: HSREN12 Mask          */

#define GPIO_SLEWCTL_HSREN13_Pos         (26)                                              /*!< GPIO_T::SLEWCTL: HSREN13 Position      */
#define GPIO_SLEWCTL_HSREN13_Msk         (0x3ul << GPIO_SLEWCTL_HSREN13_Pos)               /*!< GPIO_T::SLEWCTL: HSREN13 Mask          */

#define GPIO_SLEWCTL_HSREN14_Pos         (28)                                              /*!< GPIO_T::SLEWCTL: HSREN14 Position      */
#define GPIO_SLEWCTL_HSREN14_Msk         (0x3ul << GPIO_SLEWCTL_HSREN14_Pos)               /*!< GPIO_T::SLEWCTL: HSREN14 Mask          */

#define GPIO_SLEWCTL_HSREN15_Pos         (30)                                              /*!< GPIO_T::SLEWCTL: HSREN15 Position      */
#define GPIO_SLEWCTL_HSREN15_Msk         (0x3ul << GPIO_SLEWCTL_HSREN15_Pos)               /*!< GPIO_T::SLEWCTL: HSREN15 Mask          */

#define GPIO_PUSEL_PUSEL0_Pos            (0)                                               /*!< GPIO_T::PUSEL: PUSEL0 Position         */
#define GPIO_PUSEL_PUSEL0_Msk            (0x3ul << GPIO_PUSEL_PUSEL0_Pos)                  /*!< GPIO_T::PUSEL: PUSEL0 Mask             */

#define GPIO_PUSEL_PUSEL1_Pos            (2)                                               /*!< GPIO_T::PUSEL: PUSEL1 Position         */
#define GPIO_PUSEL_PUSEL1_Msk            (0x3ul << GPIO_PUSEL_PUSEL1_Pos)                  /*!< GPIO_T::PUSEL: PUSEL1 Mask             */

#define GPIO_PUSEL_PUSEL2_Pos            (4)                                               /*!< GPIO_T::PUSEL: PUSEL2 Position         */
#define GPIO_PUSEL_PUSEL2_Msk            (0x3ul << GPIO_PUSEL_PUSEL2_Pos)                  /*!< GPIO_T::PUSEL: PUSEL2 Mask             */

#define GPIO_PUSEL_PUSEL3_Pos            (6)                                               /*!< GPIO_T::PUSEL: PUSEL3 Position         */
#define GPIO_PUSEL_PUSEL3_Msk            (0x3ul << GPIO_PUSEL_PUSEL3_Pos)                  /*!< GPIO_T::PUSEL: PUSEL3 Mask             */

#define GPIO_PUSEL_PUSEL4_Pos            (8)                                               /*!< GPIO_T::PUSEL: PUSEL4 Position         */
#define GPIO_PUSEL_PUSEL4_Msk            (0x3ul << GPIO_PUSEL_PUSEL4_Pos)                  /*!< GPIO_T::PUSEL: PUSEL4 Mask             */

#define GPIO_PUSEL_PUSEL5_Pos            (10)                                              /*!< GPIO_T::PUSEL: PUSEL5 Position         */
#define GPIO_PUSEL_PUSEL5_Msk            (0x3ul << GPIO_PUSEL_PUSEL5_Pos)                  /*!< GPIO_T::PUSEL: PUSEL5 Mask             */

#define GPIO_PUSEL_PUSEL6_Pos            (12)                                              /*!< GPIO_T::PUSEL: PUSEL6 Position         */
#define GPIO_PUSEL_PUSEL6_Msk            (0x3ul << GPIO_PUSEL_PUSEL6_Pos)                  /*!< GPIO_T::PUSEL: PUSEL6 Mask             */

#define GPIO_PUSEL_PUSEL7_Pos            (14)                                              /*!< GPIO_T::PUSEL: PUSEL7 Position         */
#define GPIO_PUSEL_PUSEL7_Msk            (0x3ul << GPIO_PUSEL_PUSEL7_Pos)                  /*!< GPIO_T::PUSEL: PUSEL7 Mask             */

#define GPIO_PUSEL_PUSEL8_Pos            (16)                                              /*!< GPIO_T::PUSEL: PUSEL8 Position         */
#define GPIO_PUSEL_PUSEL8_Msk            (0x3ul << GPIO_PUSEL_PUSEL8_Pos)                  /*!< GPIO_T::PUSEL: PUSEL8 Mask             */

#define GPIO_PUSEL_PUSEL9_Pos            (18)                                              /*!< GPIO_T::PUSEL: PUSEL9 Position         */
#define GPIO_PUSEL_PUSEL9_Msk            (0x3ul << GPIO_PUSEL_PUSEL9_Pos)                  /*!< GPIO_T::PUSEL: PUSEL9 Mask             */

#define GPIO_PUSEL_PUSEL10_Pos           (20)                                              /*!< GPIO_T::PUSEL: PUSEL10 Position        */
#define GPIO_PUSEL_PUSEL10_Msk           (0x3ul << GPIO_PUSEL_PUSEL10_Pos)                 /*!< GPIO_T::PUSEL: PUSEL10 Mask            */

#define GPIO_PUSEL_PUSEL11_Pos           (22)                                              /*!< GPIO_T::PUSEL: PUSEL11 Position        */
#define GPIO_PUSEL_PUSEL11_Msk           (0x3ul << GPIO_PUSEL_PUSEL11_Pos)                 /*!< GPIO_T::PUSEL: PUSEL11 Mask            */

#define GPIO_PUSEL_PUSEL12_Pos           (24)                                              /*!< GPIO_T::PUSEL: PUSEL12 Position        */
#define GPIO_PUSEL_PUSEL12_Msk           (0x3ul << GPIO_PUSEL_PUSEL12_Pos)                 /*!< GPIO_T::PUSEL: PUSEL12 Mask            */

#define GPIO_PUSEL_PUSEL13_Pos           (26)                                              /*!< GPIO_T::PUSEL: PUSEL13 Position        */
#define GPIO_PUSEL_PUSEL13_Msk           (0x3ul << GPIO_PUSEL_PUSEL13_Pos)                 /*!< GPIO_T::PUSEL: PUSEL13 Mask            */

#define GPIO_PUSEL_PUSEL14_Pos           (28)                                              /*!< GPIO_T::PUSEL: PUSEL14 Position        */
#define GPIO_PUSEL_PUSEL14_Msk           (0x3ul << GPIO_PUSEL_PUSEL14_Pos)                 /*!< GPIO_T::PUSEL: PUSEL14 Mask            */

#define GPIO_PUSEL_PUSEL15_Pos           (30)                                              /*!< GPIO_T::PUSEL: PUSEL15 Position        */
#define GPIO_PUSEL_PUSEL15_Msk           (0x3ul << GPIO_PUSEL_PUSEL15_Pos)                 /*!< GPIO_T::PUSEL: PUSEL15 Mask            */

#define GPIO_MODE_MODE0_Pos              (0)                                               /*!< GPIO_T::MODE: MODE0 Position           */
#define GPIO_MODE_MODE0_Msk              (0x3ul << GPIO_MODE_MODE0_Pos)                    /*!< GPIO_T::MODE: MODE0 Mask               */

#define GPIO_MODE_MODE1_Pos              (2)                                               /*!< GPIO_T::MODE: MODE1 Position           */
#define GPIO_MODE_MODE1_Msk              (0x3ul << GPIO_MODE_MODE1_Pos)                    /*!< GPIO_T::MODE: MODE1 Mask               */

#define GPIO_MODE_MODE2_Pos              (4)                                               /*!< GPIO_T::MODE: MODE2 Position           */
#define GPIO_MODE_MODE2_Msk              (0x3ul << GPIO_MODE_MODE2_Pos)                    /*!< GPIO_T::MODE: MODE2 Mask               */

#define GPIO_MODE_MODE3_Pos              (6)                                               /*!< GPIO_T::MODE: MODE3 Position           */
#define GPIO_MODE_MODE3_Msk              (0x3ul << GPIO_MODE_MODE3_Pos)                    /*!< GPIO_T::MODE: MODE3 Mask               */

#define GPIO_MODE_MODE4_Pos              (8)                                               /*!< GPIO_T::MODE: MODE4 Position           */
#define GPIO_MODE_MODE4_Msk              (0x3ul << GPIO_MODE_MODE4_Pos)                    /*!< GPIO_T::MODE: MODE4 Mask               */

#define GPIO_MODE_MODE5_Pos              (10)                                              /*!< GPIO_T::MODE: MODE5 Position           */
#define GPIO_MODE_MODE5_Msk              (0x3ul << GPIO_MODE_MODE5_Pos)                    /*!< GPIO_T::MODE: MODE5 Mask               */

#define GPIO_MODE_MODE6_Pos              (12)                                              /*!< GPIO_T::MODE: MODE6 Position           */
#define GPIO_MODE_MODE6_Msk              (0x3ul << GPIO_MODE_MODE6_Pos)                    /*!< GPIO_T::MODE: MODE6 Mask               */

#define GPIO_MODE_MODE7_Pos              (14)                                              /*!< GPIO_T::MODE: MODE7 Position           */
#define GPIO_MODE_MODE7_Msk              (0x3ul << GPIO_MODE_MODE7_Pos)                    /*!< GPIO_T::MODE: MODE7 Mask               */

#define GPIO_MODE_MODE8_Pos              (16)                                              /*!< GPIO_T::MODE: MODE8 Position           */
#define GPIO_MODE_MODE8_Msk              (0x3ul << GPIO_MODE_MODE8_Pos)                    /*!< GPIO_T::MODE: MODE8 Mask               */

#define GPIO_MODE_MODE9_Pos              (18)                                              /*!< GPIO_T::MODE: MODE9 Position           */
#define GPIO_MODE_MODE9_Msk              (0x3ul << GPIO_MODE_MODE9_Pos)                    /*!< GPIO_T::MODE: MODE9 Mask               */

#define GPIO_MODE_MODE10_Pos             (20)                                              /*!< GPIO_T::MODE: MODE10 Position          */
#define GPIO_MODE_MODE10_Msk             (0x3ul << GPIO_MODE_MODE10_Pos)                   /*!< GPIO_T::MODE: MODE10 Mask              */

#define GPIO_MODE_MODE11_Pos             (22)                                              /*!< GPIO_T::MODE: MODE11 Position          */
#define GPIO_MODE_MODE11_Msk             (0x3ul << GPIO_MODE_MODE11_Pos)                   /*!< GPIO_T::MODE: MODE11 Mask              */

#define GPIO_MODE_MODE12_Pos             (24)                                              /*!< GPIO_T::MODE: MODE12 Position          */
#define GPIO_MODE_MODE12_Msk             (0x3ul << GPIO_MODE_MODE12_Pos)                   /*!< GPIO_T::MODE: MODE12 Mask              */

#define GPIO_MODE_MODE13_Pos             (26)                                              /*!< GPIO_T::MODE: MODE13 Position          */
#define GPIO_MODE_MODE13_Msk             (0x3ul << GPIO_MODE_MODE13_Pos)                   /*!< GPIO_T::MODE: MODE13 Mask              */

#define GPIO_MODE_MODE14_Pos             (28)                                              /*!< GPIO_T::MODE: MODE14 Position          */
#define GPIO_MODE_MODE14_Msk             (0x3ul << GPIO_MODE_MODE14_Pos)                   /*!< GPIO_T::MODE: MODE14 Mask              */

#define GPIO_MODE_MODE15_Pos             (30)                                              /*!< GPIO_T::MODE: MODE15 Position          */
#define GPIO_MODE_MODE15_Msk             (0x3ul << GPIO_MODE_MODE15_Pos)                   /*!< GPIO_T::MODE: MODE15 Mask              */

#define GPIO_DINOFF_DINOFF0_Pos          (16)                                              /*!< GPIO_T::DINOFF: DINOFF0 Position       */
#define GPIO_DINOFF_DINOFF0_Msk          (0x1ul << GPIO_DINOFF_DINOFF0_Pos)                /*!< GPIO_T::DINOFF: DINOFF0 Mask           */

#define GPIO_DINOFF_DINOFF1_Pos          (17)                                              /*!< GPIO_T::DINOFF: DINOFF1 Position       */
#define GPIO_DINOFF_DINOFF1_Msk          (0x1ul << GPIO_DINOFF_DINOFF1_Pos)                /*!< GPIO_T::DINOFF: DINOFF1 Mask           */

#define GPIO_DINOFF_DINOFF2_Pos          (18)                                              /*!< GPIO_T::DINOFF: DINOFF2 Position       */
#define GPIO_DINOFF_DINOFF2_Msk          (0x1ul << GPIO_DINOFF_DINOFF2_Pos)                /*!< GPIO_T::DINOFF: DINOFF2 Mask           */

#define GPIO_DINOFF_DINOFF3_Pos          (19)                                              /*!< GPIO_T::DINOFF: DINOFF3 Position       */
#define GPIO_DINOFF_DINOFF3_Msk          (0x1ul << GPIO_DINOFF_DINOFF3_Pos)                /*!< GPIO_T::DINOFF: DINOFF3 Mask           */

#define GPIO_DINOFF_DINOFF4_Pos          (20)                                              /*!< GPIO_T::DINOFF: DINOFF4 Position       */
#define GPIO_DINOFF_DINOFF4_Msk          (0x1ul << GPIO_DINOFF_DINOFF4_Pos)                /*!< GPIO_T::DINOFF: DINOFF4 Mask           */

#define GPIO_DINOFF_DINOFF5_Pos          (21)                                              /*!< GPIO_T::DINOFF: DINOFF5 Position       */
#define GPIO_DINOFF_DINOFF5_Msk          (0x1ul << GPIO_DINOFF_DINOFF5_Pos)                /*!< GPIO_T::DINOFF: DINOFF5 Mask           */

#define GPIO_DINOFF_DINOFF6_Pos          (22)                                              /*!< GPIO_T::DINOFF: DINOFF6 Position       */
#define GPIO_DINOFF_DINOFF6_Msk          (0x1ul << GPIO_DINOFF_DINOFF6_Pos)                /*!< GPIO_T::DINOFF: DINOFF6 Mask           */

#define GPIO_DINOFF_DINOFF7_Pos          (23)                                              /*!< GPIO_T::DINOFF: DINOFF7 Position       */
#define GPIO_DINOFF_DINOFF7_Msk          (0x1ul << GPIO_DINOFF_DINOFF7_Pos)                /*!< GPIO_T::DINOFF: DINOFF7 Mask           */

#define GPIO_DINOFF_DINOFF8_Pos          (24)                                              /*!< GPIO_T::DINOFF: DINOFF8 Position       */
#define GPIO_DINOFF_DINOFF8_Msk          (0x1ul << GPIO_DINOFF_DINOFF8_Pos)                /*!< GPIO_T::DINOFF: DINOFF8 Mask           */

#define GPIO_DINOFF_DINOFF9_Pos          (25)                                              /*!< GPIO_T::DINOFF: DINOFF9 Position       */
#define GPIO_DINOFF_DINOFF9_Msk          (0x1ul << GPIO_DINOFF_DINOFF9_Pos)                /*!< GPIO_T::DINOFF: DINOFF9 Mask           */

#define GPIO_DINOFF_DINOFF10_Pos         (26)                                              /*!< GPIO_T::DINOFF: DINOFF10 Position      */
#define GPIO_DINOFF_DINOFF10_Msk         (0x1ul << GPIO_DINOFF_DINOFF10_Pos)               /*!< GPIO_T::DINOFF: DINOFF10 Mask          */

#define GPIO_DINOFF_DINOFF11_Pos         (27)                                              /*!< GPIO_T::DINOFF: DINOFF11 Position      */
#define GPIO_DINOFF_DINOFF11_Msk         (0x1ul << GPIO_DINOFF_DINOFF11_Pos)               /*!< GPIO_T::DINOFF: DINOFF11 Mask          */

#define GPIO_DINOFF_DINOFF12_Pos         (28)                                              /*!< GPIO_T::DINOFF: DINOFF12 Position      */
#define GPIO_DINOFF_DINOFF12_Msk         (0x1ul << GPIO_DINOFF_DINOFF12_Pos)               /*!< GPIO_T::DINOFF: DINOFF12 Mask          */

#define GPIO_DINOFF_DINOFF13_Pos         (29)                                              /*!< GPIO_T::DINOFF: DINOFF13 Position      */
#define GPIO_DINOFF_DINOFF13_Msk         (0x1ul << GPIO_DINOFF_DINOFF13_Pos)               /*!< GPIO_T::DINOFF: DINOFF13 Mask          */

#define GPIO_DINOFF_DINOFF14_Pos         (30)                                              /*!< GPIO_T::DINOFF: DINOFF14 Position      */
#define GPIO_DINOFF_DINOFF14_Msk         (0x1ul << GPIO_DINOFF_DINOFF14_Pos)               /*!< GPIO_T::DINOFF: DINOFF14 Mask          */

#define GPIO_DINOFF_DINOFF15_Pos         (31)                                              /*!< GPIO_T::DINOFF: DINOFF15 Position      */
#define GPIO_DINOFF_DINOFF15_Msk         (0x1ul << GPIO_DINOFF_DINOFF15_Pos)               /*!< GPIO_T::DINOFF: DINOFF15 Mask          */

#define GPIO_DOUT_DOUT0_Pos              (0)                                               /*!< GPIO_T::DOUT: DOUT0 Position           */
#define GPIO_DOUT_DOUT0_Msk              (0x1ul << GPIO_DOUT_DOUT0_Pos)                    /*!< GPIO_T::DOUT: DOUT0 Mask               */

#define GPIO_DOUT_DOUT1_Pos              (1)                                               /*!< GPIO_T::DOUT: DOUT1 Position           */
#define GPIO_DOUT_DOUT1_Msk              (0x1ul << GPIO_DOUT_DOUT1_Pos)                    /*!< GPIO_T::DOUT: DOUT1 Mask               */

#define GPIO_DOUT_DOUT2_Pos              (2)                                               /*!< GPIO_T::DOUT: DOUT2 Position           */
#define GPIO_DOUT_DOUT2_Msk              (0x1ul << GPIO_DOUT_DOUT2_Pos)                    /*!< GPIO_T::DOUT: DOUT2 Mask               */

#define GPIO_DOUT_DOUT3_Pos              (3)                                               /*!< GPIO_T::DOUT: DOUT3 Position           */
#define GPIO_DOUT_DOUT3_Msk              (0x1ul << GPIO_DOUT_DOUT3_Pos)                    /*!< GPIO_T::DOUT: DOUT3 Mask               */

#define GPIO_DOUT_DOUT4_Pos              (4)                                               /*!< GPIO_T::DOUT: DOUT4 Position           */
#define GPIO_DOUT_DOUT4_Msk              (0x1ul << GPIO_DOUT_DOUT4_Pos)                    /*!< GPIO_T::DOUT: DOUT4 Mask               */

#define GPIO_DOUT_DOUT5_Pos              (5)                                               /*!< GPIO_T::DOUT: DOUT5 Position           */
#define GPIO_DOUT_DOUT5_Msk              (0x1ul << GPIO_DOUT_DOUT5_Pos)                    /*!< GPIO_T::DOUT: DOUT5 Mask               */

#define GPIO_DOUT_DOUT6_Pos              (6)                                               /*!< GPIO_T::DOUT: DOUT6 Position           */
#define GPIO_DOUT_DOUT6_Msk              (0x1ul << GPIO_DOUT_DOUT6_Pos)                    /*!< GPIO_T::DOUT: DOUT6 Mask               */

#define GPIO_DOUT_DOUT7_Pos              (7)                                               /*!< GPIO_T::DOUT: DOUT7 Position           */
#define GPIO_DOUT_DOUT7_Msk              (0x1ul << GPIO_DOUT_DOUT7_Pos)                    /*!< GPIO_T::DOUT: DOUT7 Mask               */

#define GPIO_DOUT_DOUT8_Pos              (8)                                               /*!< GPIO_T::DOUT: DOUT8 Position           */
#define GPIO_DOUT_DOUT8_Msk              (0x1ul << GPIO_DOUT_DOUT8_Pos)                    /*!< GPIO_T::DOUT: DOUT8 Mask               */

#define GPIO_DOUT_DOUT9_Pos              (9)                                               /*!< GPIO_T::DOUT: DOUT9 Position           */
#define GPIO_DOUT_DOUT9_Msk              (0x1ul << GPIO_DOUT_DOUT9_Pos)                    /*!< GPIO_T::DOUT: DOUT9 Mask               */

#define GPIO_DOUT_DOUT10_Pos             (10)                                              /*!< GPIO_T::DOUT: DOUT10 Position          */
#define GPIO_DOUT_DOUT10_Msk             (0x1ul << GPIO_DOUT_DOUT10_Pos)                   /*!< GPIO_T::DOUT: DOUT10 Mask              */

#define GPIO_DOUT_DOUT11_Pos             (11)                                              /*!< GPIO_T::DOUT: DOUT11 Position          */
#define GPIO_DOUT_DOUT11_Msk             (0x1ul << GPIO_DOUT_DOUT11_Pos)                   /*!< GPIO_T::DOUT: DOUT11 Mask              */

#define GPIO_DOUT_DOUT12_Pos             (12)                                              /*!< GPIO_T::DOUT: DOUT12 Position          */
#define GPIO_DOUT_DOUT12_Msk             (0x1ul << GPIO_DOUT_DOUT12_Pos)                   /*!< GPIO_T::DOUT: DOUT12 Mask              */

#define GPIO_DOUT_DOUT13_Pos             (13)                                              /*!< GPIO_T::DOUT: DOUT13 Position          */
#define GPIO_DOUT_DOUT13_Msk             (0x1ul << GPIO_DOUT_DOUT13_Pos)                   /*!< GPIO_T::DOUT: DOUT13 Mask              */

#define GPIO_DOUT_DOUT14_Pos             (14)                                              /*!< GPIO_T::DOUT: DOUT14 Position          */
#define GPIO_DOUT_DOUT14_Msk             (0x1ul << GPIO_DOUT_DOUT14_Pos)                   /*!< GPIO_T::DOUT: DOUT14 Mask              */

#define GPIO_DOUT_DOUT15_Pos             (15)                                              /*!< GPIO_T::DOUT: DOUT15 Position          */
#define GPIO_DOUT_DOUT15_Msk             (0x1ul << GPIO_DOUT_DOUT15_Pos)                   /*!< GPIO_T::DOUT: DOUT15 Mask              */

#define GPIO_DATMSK_DATMSK0_Pos          (0)                                               /*!< GPIO_T::DATMSK: DATMSK0 Position       */
#define GPIO_DATMSK_DATMSK0_Msk          (0x1ul << GPIO_DATMSK_DATMSK0_Pos)                /*!< GPIO_T::DATMSK: DATMSK0 Mask           */

#define GPIO_DATMSK_DATMSK1_Pos          (1)                                               /*!< GPIO_T::DATMSK: DATMSK1 Position       */
#define GPIO_DATMSK_DATMSK1_Msk          (0x1ul << GPIO_DATMSK_DATMSK1_Pos)                /*!< GPIO_T::DATMSK: DATMSK1 Mask           */

#define GPIO_DATMSK_DATMSK2_Pos          (2)                                               /*!< GPIO_T::DATMSK: DATMSK2 Position       */
#define GPIO_DATMSK_DATMSK2_Msk          (0x1ul << GPIO_DATMSK_DATMSK2_Pos)                /*!< GPIO_T::DATMSK: DATMSK2 Mask           */

#define GPIO_DATMSK_DATMSK3_Pos          (3)                                               /*!< GPIO_T::DATMSK: DATMSK3 Position       */
#define GPIO_DATMSK_DATMSK3_Msk          (0x1ul << GPIO_DATMSK_DATMSK3_Pos)                /*!< GPIO_T::DATMSK: DATMSK3 Mask           */

#define GPIO_DATMSK_DATMSK4_Pos          (4)                                               /*!< GPIO_T::DATMSK: DATMSK4 Position       */
#define GPIO_DATMSK_DATMSK4_Msk          (0x1ul << GPIO_DATMSK_DATMSK4_Pos)                /*!< GPIO_T::DATMSK: DATMSK4 Mask           */

#define GPIO_DATMSK_DATMSK5_Pos          (5)                                               /*!< GPIO_T::DATMSK: DATMSK5 Position       */
#define GPIO_DATMSK_DATMSK5_Msk          (0x1ul << GPIO_DATMSK_DATMSK5_Pos)                /*!< GPIO_T::DATMSK: DATMSK5 Mask           */

#define GPIO_DATMSK_DATMSK6_Pos          (6)                                               /*!< GPIO_T::DATMSK: DATMSK6 Position       */
#define GPIO_DATMSK_DATMSK6_Msk          (0x1ul << GPIO_DATMSK_DATMSK6_Pos)                /*!< GPIO_T::DATMSK: DATMSK6 Mask           */

#define GPIO_DATMSK_DATMSK7_Pos          (7)                                               /*!< GPIO_T::DATMSK: DATMSK7 Position       */
#define GPIO_DATMSK_DATMSK7_Msk          (0x1ul << GPIO_DATMSK_DATMSK7_Pos)                /*!< GPIO_T::DATMSK: DATMSK7 Mask           */

#define GPIO_DATMSK_DATMSK8_Pos          (8)                                               /*!< GPIO_T::DATMSK: DATMSK8 Position       */
#define GPIO_DATMSK_DATMSK8_Msk          (0x1ul << GPIO_DATMSK_DATMSK8_Pos)                /*!< GPIO_T::DATMSK: DATMSK8 Mask           */

#define GPIO_DATMSK_DATMSK9_Pos          (9)                                               /*!< GPIO_T::DATMSK: DATMSK9 Position       */
#define GPIO_DATMSK_DATMSK9_Msk          (0x1ul << GPIO_DATMSK_DATMSK9_Pos)                /*!< GPIO_T::DATMSK: DATMSK9 Mask           */

#define GPIO_DATMSK_DATMSK10_Pos         (10)                                              /*!< GPIO_T::DATMSK: DATMSK10 Position      */
#define GPIO_DATMSK_DATMSK10_Msk         (0x1ul << GPIO_DATMSK_DATMSK10_Pos)               /*!< GPIO_T::DATMSK: DATMSK10 Mask          */

#define GPIO_DATMSK_DATMSK11_Pos         (11)                                              /*!< GPIO_T::DATMSK: DATMSK11 Position      */
#define GPIO_DATMSK_DATMSK11_Msk         (0x1ul << GPIO_DATMSK_DATMSK11_Pos)               /*!< GPIO_T::DATMSK: DATMSK11 Mask          */

#define GPIO_DATMSK_DATMSK12_Pos         (12)                                              /*!< GPIO_T::DATMSK: DATMSK12 Position      */
#define GPIO_DATMSK_DATMSK12_Msk         (0x1ul << GPIO_DATMSK_DATMSK12_Pos)               /*!< GPIO_T::DATMSK: DATMSK12 Mask          */

#define GPIO_DATMSK_DATMSK13_Pos         (13)                                              /*!< GPIO_T::DATMSK: DATMSK13 Position      */
#define GPIO_DATMSK_DATMSK13_Msk         (0x1ul << GPIO_DATMSK_DATMSK13_Pos)               /*!< GPIO_T::DATMSK: DATMSK13 Mask          */

#define GPIO_DATMSK_DATMSK14_Pos         (14)                                              /*!< GPIO_T::DATMSK: DATMSK14 Position      */
#define GPIO_DATMSK_DATMSK14_Msk         (0x1ul << GPIO_DATMSK_DATMSK14_Pos)               /*!< GPIO_T::DATMSK: DATMSK14 Mask          */

#define GPIO_DATMSK_DATMSK15_Pos         (15)                                              /*!< GPIO_T::DATMSK: DATMSK15 Position      */
#define GPIO_DATMSK_DATMSK15_Msk         (0x1ul << GPIO_DATMSK_DATMSK15_Pos)               /*!< GPIO_T::DATMSK: DATMSK15 Mask          */

#define GPIO_PIN_PIN0_Pos                (0)                                               /*!< GPIO_T::PIN: PIN0 Position             */
#define GPIO_PIN_PIN0_Msk                (0x1ul << GPIO_PIN_PIN0_Pos)                      /*!< GPIO_T::PIN: PIN0 Mask                 */

#define GPIO_PIN_PIN1_Pos                (1)                                               /*!< GPIO_T::PIN: PIN1 Position             */
#define GPIO_PIN_PIN1_Msk                (0x1ul << GPIO_PIN_PIN1_Pos)                      /*!< GPIO_T::PIN: PIN1 Mask                 */

#define GPIO_PIN_PIN2_Pos                (2)                                               /*!< GPIO_T::PIN: PIN2 Position             */
#define GPIO_PIN_PIN2_Msk                (0x1ul << GPIO_PIN_PIN2_Pos)                      /*!< GPIO_T::PIN: PIN2 Mask                 */

#define GPIO_PIN_PIN3_Pos                (3)                                               /*!< GPIO_T::PIN: PIN3 Position             */
#define GPIO_PIN_PIN3_Msk                (0x1ul << GPIO_PIN_PIN3_Pos)                      /*!< GPIO_T::PIN: PIN3 Mask                 */

#define GPIO_PIN_PIN4_Pos                (4)                                               /*!< GPIO_T::PIN: PIN4 Position             */
#define GPIO_PIN_PIN4_Msk                (0x1ul << GPIO_PIN_PIN4_Pos)                      /*!< GPIO_T::PIN: PIN4 Mask                 */

#define GPIO_PIN_PIN5_Pos                (5)                                               /*!< GPIO_T::PIN: PIN5 Position             */
#define GPIO_PIN_PIN5_Msk                (0x1ul << GPIO_PIN_PIN5_Pos)                      /*!< GPIO_T::PIN: PIN5 Mask                 */

#define GPIO_PIN_PIN6_Pos                (6)                                               /*!< GPIO_T::PIN: PIN6 Position             */
#define GPIO_PIN_PIN6_Msk                (0x1ul << GPIO_PIN_PIN6_Pos)                      /*!< GPIO_T::PIN: PIN6 Mask                 */

#define GPIO_PIN_PIN7_Pos                (7)                                               /*!< GPIO_T::PIN: PIN7 Position             */
#define GPIO_PIN_PIN7_Msk                (0x1ul << GPIO_PIN_PIN7_Pos)                      /*!< GPIO_T::PIN: PIN7 Mask                 */

#define GPIO_PIN_PIN8_Pos                (8)                                               /*!< GPIO_T::PIN: PIN8 Position             */
#define GPIO_PIN_PIN8_Msk                (0x1ul << GPIO_PIN_PIN8_Pos)                      /*!< GPIO_T::PIN: PIN8 Mask                 */

#define GPIO_PIN_PIN9_Pos                (9)                                               /*!< GPIO_T::PIN: PIN9 Position             */
#define GPIO_PIN_PIN9_Msk                (0x1ul << GPIO_PIN_PIN9_Pos)                      /*!< GPIO_T::PIN: PIN9 Mask                 */

#define GPIO_PIN_PIN10_Pos               (10)                                              /*!< GPIO_T::PIN: PIN10 Position            */
#define GPIO_PIN_PIN10_Msk               (0x1ul << GPIO_PIN_PIN10_Pos)                     /*!< GPIO_T::PIN: PIN10 Mask                */

#define GPIO_PIN_PIN11_Pos               (11)                                              /*!< GPIO_T::PIN: PIN11 Position            */
#define GPIO_PIN_PIN11_Msk               (0x1ul << GPIO_PIN_PIN11_Pos)                     /*!< GPIO_T::PIN: PIN11 Mask                */

#define GPIO_PIN_PIN12_Pos               (12)                                              /*!< GPIO_T::PIN: PIN12 Position            */
#define GPIO_PIN_PIN12_Msk               (0x1ul << GPIO_PIN_PIN12_Pos)                     /*!< GPIO_T::PIN: PIN12 Mask                */

#define GPIO_PIN_PIN13_Pos               (13)                                              /*!< GPIO_T::PIN: PIN13 Position            */
#define GPIO_PIN_PIN13_Msk               (0x1ul << GPIO_PIN_PIN13_Pos)                     /*!< GPIO_T::PIN: PIN13 Mask                */

#define GPIO_PIN_PIN14_Pos               (14)                                              /*!< GPIO_T::PIN: PIN14 Position            */
#define GPIO_PIN_PIN14_Msk               (0x1ul << GPIO_PIN_PIN14_Pos)                     /*!< GPIO_T::PIN: PIN14 Mask                */

#define GPIO_PIN_PIN15_Pos               (15)                                              /*!< GPIO_T::PIN: PIN15 Position            */
#define GPIO_PIN_PIN15_Msk               (0x1ul << GPIO_PIN_PIN15_Pos)                     /*!< GPIO_T::PIN: PIN15 Mask                */

#define GPIO_DBEN_DBEN0_Pos              (0)                                               /*!< GPIO_T::DBEN: DBEN0 Position           */
#define GPIO_DBEN_DBEN0_Msk              (0x1ul << GPIO_DBEN_DBEN0_Pos)                    /*!< GPIO_T::DBEN: DBEN0 Mask               */

#define GPIO_DBEN_DBEN1_Pos              (1)                                               /*!< GPIO_T::DBEN: DBEN1 Position           */
#define GPIO_DBEN_DBEN1_Msk              (0x1ul << GPIO_DBEN_DBEN1_Pos)                    /*!< GPIO_T::DBEN: DBEN1 Mask               */

#define GPIO_DBEN_DBEN2_Pos              (2)                                               /*!< GPIO_T::DBEN: DBEN2 Position           */
#define GPIO_DBEN_DBEN2_Msk              (0x1ul << GPIO_DBEN_DBEN2_Pos)                    /*!< GPIO_T::DBEN: DBEN2 Mask               */

#define GPIO_DBEN_DBEN3_Pos              (3)                                               /*!< GPIO_T::DBEN: DBEN3 Position           */
#define GPIO_DBEN_DBEN3_Msk              (0x1ul << GPIO_DBEN_DBEN3_Pos)                    /*!< GPIO_T::DBEN: DBEN3 Mask               */

#define GPIO_DBEN_DBEN4_Pos              (4)                                               /*!< GPIO_T::DBEN: DBEN4 Position           */
#define GPIO_DBEN_DBEN4_Msk              (0x1ul << GPIO_DBEN_DBEN4_Pos)                    /*!< GPIO_T::DBEN: DBEN4 Mask               */

#define GPIO_DBEN_DBEN5_Pos              (5)                                               /*!< GPIO_T::DBEN: DBEN5 Position           */
#define GPIO_DBEN_DBEN5_Msk              (0x1ul << GPIO_DBEN_DBEN5_Pos)                    /*!< GPIO_T::DBEN: DBEN5 Mask               */

#define GPIO_DBEN_DBEN6_Pos              (6)                                               /*!< GPIO_T::DBEN: DBEN6 Position           */
#define GPIO_DBEN_DBEN6_Msk              (0x1ul << GPIO_DBEN_DBEN6_Pos)                    /*!< GPIO_T::DBEN: DBEN6 Mask               */

#define GPIO_DBEN_DBEN7_Pos              (7)                                               /*!< GPIO_T::DBEN: DBEN7 Position           */
#define GPIO_DBEN_DBEN7_Msk              (0x1ul << GPIO_DBEN_DBEN7_Pos)                    /*!< GPIO_T::DBEN: DBEN7 Mask               */

#define GPIO_DBEN_DBEN8_Pos              (8)                                               /*!< GPIO_T::DBEN: DBEN8 Position           */
#define GPIO_DBEN_DBEN8_Msk              (0x1ul << GPIO_DBEN_DBEN8_Pos)                    /*!< GPIO_T::DBEN: DBEN8 Mask               */

#define GPIO_DBEN_DBEN9_Pos              (9)                                               /*!< GPIO_T::DBEN: DBEN9 Position           */
#define GPIO_DBEN_DBEN9_Msk              (0x1ul << GPIO_DBEN_DBEN9_Pos)                    /*!< GPIO_T::DBEN: DBEN9 Mask               */

#define GPIO_DBEN_DBEN10_Pos             (10)                                              /*!< GPIO_T::DBEN: DBEN10 Position          */
#define GPIO_DBEN_DBEN10_Msk             (0x1ul << GPIO_DBEN_DBEN10_Pos)                   /*!< GPIO_T::DBEN: DBEN10 Mask              */

#define GPIO_DBEN_DBEN11_Pos             (11)                                              /*!< GPIO_T::DBEN: DBEN11 Position          */
#define GPIO_DBEN_DBEN11_Msk             (0x1ul << GPIO_DBEN_DBEN11_Pos)                   /*!< GPIO_T::DBEN: DBEN11 Mask              */

#define GPIO_DBEN_DBEN12_Pos             (12)                                              /*!< GPIO_T::DBEN: DBEN12 Position          */
#define GPIO_DBEN_DBEN12_Msk             (0x1ul << GPIO_DBEN_DBEN12_Pos)                   /*!< GPIO_T::DBEN: DBEN12 Mask              */

#define GPIO_DBEN_DBEN13_Pos             (13)                                              /*!< GPIO_T::DBEN: DBEN13 Position          */
#define GPIO_DBEN_DBEN13_Msk             (0x1ul << GPIO_DBEN_DBEN13_Pos)                   /*!< GPIO_T::DBEN: DBEN13 Mask              */

#define GPIO_DBEN_DBEN14_Pos             (14)                                              /*!< GPIO_T::DBEN: DBEN14 Position          */
#define GPIO_DBEN_DBEN14_Msk             (0x1ul << GPIO_DBEN_DBEN14_Pos)                   /*!< GPIO_T::DBEN: DBEN14 Mask              */

#define GPIO_DBEN_DBEN15_Pos             (15)                                              /*!< GPIO_T::DBEN: DBEN15 Position          */
#define GPIO_DBEN_DBEN15_Msk             (0x1ul << GPIO_DBEN_DBEN15_Pos)                   /*!< GPIO_T::DBEN: DBEN15 Mask              */

#define GPIO_INTTYPE_TYPE0_Pos           (0)                                               /*!< GPIO_T::INTTYPE: TYPE0 Position        */
#define GPIO_INTTYPE_TYPE0_Msk           (0x1ul << GPIO_INTTYPE_TYPE0_Pos)                 /*!< GPIO_T::INTTYPE: TYPE0 Mask            */

#define GPIO_INTTYPE_TYPE1_Pos           (1)                                               /*!< GPIO_T::INTTYPE: TYPE1 Position        */
#define GPIO_INTTYPE_TYPE1_Msk           (0x1ul << GPIO_INTTYPE_TYPE1_Pos)                 /*!< GPIO_T::INTTYPE: TYPE1 Mask            */

#define GPIO_INTTYPE_TYPE2_Pos           (2)                                               /*!< GPIO_T::INTTYPE: TYPE2 Position        */
#define GPIO_INTTYPE_TYPE2_Msk           (0x1ul << GPIO_INTTYPE_TYPE2_Pos)                 /*!< GPIO_T::INTTYPE: TYPE2 Mask            */

#define GPIO_INTTYPE_TYPE3_Pos           (3)                                               /*!< GPIO_T::INTTYPE: TYPE3 Position        */
#define GPIO_INTTYPE_TYPE3_Msk           (0x1ul << GPIO_INTTYPE_TYPE3_Pos)                 /*!< GPIO_T::INTTYPE: TYPE3 Mask            */

#define GPIO_INTTYPE_TYPE4_Pos           (4)                                               /*!< GPIO_T::INTTYPE: TYPE4 Position        */
#define GPIO_INTTYPE_TYPE4_Msk           (0x1ul << GPIO_INTTYPE_TYPE4_Pos)                 /*!< GPIO_T::INTTYPE: TYPE4 Mask            */

#define GPIO_INTTYPE_TYPE5_Pos           (5)                                               /*!< GPIO_T::INTTYPE: TYPE5 Position        */
#define GPIO_INTTYPE_TYPE5_Msk           (0x1ul << GPIO_INTTYPE_TYPE5_Pos)                 /*!< GPIO_T::INTTYPE: TYPE5 Mask            */

#define GPIO_INTTYPE_TYPE6_Pos           (6)                                               /*!< GPIO_T::INTTYPE: TYPE6 Position        */
#define GPIO_INTTYPE_TYPE6_Msk           (0x1ul << GPIO_INTTYPE_TYPE6_Pos)                 /*!< GPIO_T::INTTYPE: TYPE6 Mask            */

#define GPIO_INTTYPE_TYPE7_Pos           (7)                                               /*!< GPIO_T::INTTYPE: TYPE7 Position        */
#define GPIO_INTTYPE_TYPE7_Msk           (0x1ul << GPIO_INTTYPE_TYPE7_Pos)                 /*!< GPIO_T::INTTYPE: TYPE7 Mask            */

#define GPIO_INTTYPE_TYPE8_Pos           (8)                                               /*!< GPIO_T::INTTYPE: TYPE8 Position        */
#define GPIO_INTTYPE_TYPE8_Msk           (0x1ul << GPIO_INTTYPE_TYPE8_Pos)                 /*!< GPIO_T::INTTYPE: TYPE8 Mask            */

#define GPIO_INTTYPE_TYPE9_Pos           (9)                                               /*!< GPIO_T::INTTYPE: TYPE9 Position        */
#define GPIO_INTTYPE_TYPE9_Msk           (0x1ul << GPIO_INTTYPE_TYPE9_Pos)                 /*!< GPIO_T::INTTYPE: TYPE9 Mask            */

#define GPIO_INTTYPE_TYPE10_Pos          (10)                                              /*!< GPIO_T::INTTYPE: TYPE10 Position       */
#define GPIO_INTTYPE_TYPE10_Msk          (0x1ul << GPIO_INTTYPE_TYPE10_Pos)                /*!< GPIO_T::INTTYPE: TYPE10 Mask           */

#define GPIO_INTTYPE_TYPE11_Pos          (11)                                              /*!< GPIO_T::INTTYPE: TYPE11 Position       */
#define GPIO_INTTYPE_TYPE11_Msk          (0x1ul << GPIO_INTTYPE_TYPE11_Pos)                /*!< GPIO_T::INTTYPE: TYPE11 Mask           */

#define GPIO_INTTYPE_TYPE12_Pos          (12)                                              /*!< GPIO_T::INTTYPE: TYPE12 Position       */
#define GPIO_INTTYPE_TYPE12_Msk          (0x1ul << GPIO_INTTYPE_TYPE12_Pos)                /*!< GPIO_T::INTTYPE: TYPE12 Mask           */

#define GPIO_INTTYPE_TYPE13_Pos          (13)                                              /*!< GPIO_T::INTTYPE: TYPE13 Position       */
#define GPIO_INTTYPE_TYPE13_Msk          (0x1ul << GPIO_INTTYPE_TYPE13_Pos)                /*!< GPIO_T::INTTYPE: TYPE13 Mask           */

#define GPIO_INTTYPE_TYPE14_Pos          (14)                                              /*!< GPIO_T::INTTYPE: TYPE14 Position       */
#define GPIO_INTTYPE_TYPE14_Msk          (0x1ul << GPIO_INTTYPE_TYPE14_Pos)                /*!< GPIO_T::INTTYPE: TYPE14 Mask           */

#define GPIO_INTTYPE_TYPE15_Pos          (15)                                              /*!< GPIO_T::INTTYPE: TYPE15 Position       */
#define GPIO_INTTYPE_TYPE15_Msk          (0x1ul << GPIO_INTTYPE_TYPE15_Pos)                /*!< GPIO_T::INTTYPE: TYPE15 Mask           */

#define GPIO_INTEN_FLIEN0_Pos            (0)                                               /*!< GPIO_T::INTEN: FLIEN0 Position         */
#define GPIO_INTEN_FLIEN0_Msk            (0x1ul << GPIO_INTEN_FLIEN0_Pos)                  /*!< GPIO_T::INTEN: FLIEN0 Mask             */

#define GPIO_INTEN_FLIEN1_Pos            (1)                                               /*!< GPIO_T::INTEN: FLIEN1 Position         */
#define GPIO_INTEN_FLIEN1_Msk            (0x1ul << GPIO_INTEN_FLIEN1_Pos)                  /*!< GPIO_T::INTEN: FLIEN1 Mask             */

#define GPIO_INTEN_FLIEN2_Pos            (2)                                               /*!< GPIO_T::INTEN: FLIEN2 Position         */
#define GPIO_INTEN_FLIEN2_Msk            (0x1ul << GPIO_INTEN_FLIEN2_Pos)                  /*!< GPIO_T::INTEN: FLIEN2 Mask             */

#define GPIO_INTEN_FLIEN3_Pos            (3)                                               /*!< GPIO_T::INTEN: FLIEN3 Position         */
#define GPIO_INTEN_FLIEN3_Msk            (0x1ul << GPIO_INTEN_FLIEN3_Pos)                  /*!< GPIO_T::INTEN: FLIEN3 Mask             */

#define GPIO_INTEN_FLIEN4_Pos            (4)                                               /*!< GPIO_T::INTEN: FLIEN4 Position         */
#define GPIO_INTEN_FLIEN4_Msk            (0x1ul << GPIO_INTEN_FLIEN4_Pos)                  /*!< GPIO_T::INTEN: FLIEN4 Mask             */

#define GPIO_INTEN_FLIEN5_Pos            (5)                                               /*!< GPIO_T::INTEN: FLIEN5 Position         */
#define GPIO_INTEN_FLIEN5_Msk            (0x1ul << GPIO_INTEN_FLIEN5_Pos)                  /*!< GPIO_T::INTEN: FLIEN5 Mask             */

#define GPIO_INTEN_FLIEN6_Pos            (6)                                               /*!< GPIO_T::INTEN: FLIEN6 Position         */
#define GPIO_INTEN_FLIEN6_Msk            (0x1ul << GPIO_INTEN_FLIEN6_Pos)                  /*!< GPIO_T::INTEN: FLIEN6 Mask             */

#define GPIO_INTEN_FLIEN7_Pos            (7)                                               /*!< GPIO_T::INTEN: FLIEN7 Position         */
#define GPIO_INTEN_FLIEN7_Msk            (0x1ul << GPIO_INTEN_FLIEN7_Pos)                  /*!< GPIO_T::INTEN: FLIEN7 Mask             */

#define GPIO_INTEN_FLIEN8_Pos            (8)                                               /*!< GPIO_T::INTEN: FLIEN8 Position         */
#define GPIO_INTEN_FLIEN8_Msk            (0x1ul << GPIO_INTEN_FLIEN8_Pos)                  /*!< GPIO_T::INTEN: FLIEN8 Mask             */

#define GPIO_INTEN_FLIEN9_Pos            (9)                                               /*!< GPIO_T::INTEN: FLIEN9 Position         */
#define GPIO_INTEN_FLIEN9_Msk            (0x1ul << GPIO_INTEN_FLIEN9_Pos)                  /*!< GPIO_T::INTEN: FLIEN9 Mask             */

#define GPIO_INTEN_FLIEN10_Pos           (10)                                              /*!< GPIO_T::INTEN: FLIEN10 Position        */
#define GPIO_INTEN_FLIEN10_Msk           (0x1ul << GPIO_INTEN_FLIEN10_Pos)                 /*!< GPIO_T::INTEN: FLIEN10 Mask            */

#define GPIO_INTEN_FLIEN11_Pos           (11)                                              /*!< GPIO_T::INTEN: FLIEN11 Position        */
#define GPIO_INTEN_FLIEN11_Msk           (0x1ul << GPIO_INTEN_FLIEN11_Pos)                 /*!< GPIO_T::INTEN: FLIEN11 Mask            */

#define GPIO_INTEN_FLIEN12_Pos           (12)                                              /*!< GPIO_T::INTEN: FLIEN12 Position        */
#define GPIO_INTEN_FLIEN12_Msk           (0x1ul << GPIO_INTEN_FLIEN12_Pos)                 /*!< GPIO_T::INTEN: FLIEN12 Mask            */

#define GPIO_INTEN_FLIEN13_Pos           (13)                                              /*!< GPIO_T::INTEN: FLIEN13 Position        */
#define GPIO_INTEN_FLIEN13_Msk           (0x1ul << GPIO_INTEN_FLIEN13_Pos)                 /*!< GPIO_T::INTEN: FLIEN13 Mask            */

#define GPIO_INTEN_FLIEN14_Pos           (14)                                              /*!< GPIO_T::INTEN: FLIEN14 Position        */
#define GPIO_INTEN_FLIEN14_Msk           (0x1ul << GPIO_INTEN_FLIEN14_Pos)                 /*!< GPIO_T::INTEN: FLIEN14 Mask            */

#define GPIO_INTEN_FLIEN15_Pos           (15)                                              /*!< GPIO_T::INTEN: FLIEN15 Position        */
#define GPIO_INTEN_FLIEN15_Msk           (0x1ul << GPIO_INTEN_FLIEN15_Pos)                 /*!< GPIO_T::INTEN: FLIEN15 Mask            */

#define GPIO_INTEN_RHIEN0_Pos            (16)                                              /*!< GPIO_T::INTEN: RHIEN0 Position         */
#define GPIO_INTEN_RHIEN0_Msk            (0x1ul << GPIO_INTEN_RHIEN0_Pos)                  /*!< GPIO_T::INTEN: RHIEN0 Mask             */

#define GPIO_INTEN_RHIEN1_Pos            (17)                                              /*!< GPIO_T::INTEN: RHIEN1 Position         */
#define GPIO_INTEN_RHIEN1_Msk            (0x1ul << GPIO_INTEN_RHIEN1_Pos)                  /*!< GPIO_T::INTEN: RHIEN1 Mask             */

#define GPIO_INTEN_RHIEN2_Pos            (18)                                              /*!< GPIO_T::INTEN: RHIEN2 Position         */
#define GPIO_INTEN_RHIEN2_Msk            (0x1ul << GPIO_INTEN_RHIEN2_Pos)                  /*!< GPIO_T::INTEN: RHIEN2 Mask             */

#define GPIO_INTEN_RHIEN3_Pos            (19)                                              /*!< GPIO_T::INTEN: RHIEN3 Position         */
#define GPIO_INTEN_RHIEN3_Msk            (0x1ul << GPIO_INTEN_RHIEN3_Pos)                  /*!< GPIO_T::INTEN: RHIEN3 Mask             */

#define GPIO_INTEN_RHIEN4_Pos            (20)                                              /*!< GPIO_T::INTEN: RHIEN4 Position         */
#define GPIO_INTEN_RHIEN4_Msk            (0x1ul << GPIO_INTEN_RHIEN4_Pos)                  /*!< GPIO_T::INTEN: RHIEN4 Mask             */

#define GPIO_INTEN_RHIEN5_Pos            (21)                                              /*!< GPIO_T::INTEN: RHIEN5 Position         */
#define GPIO_INTEN_RHIEN5_Msk            (0x1ul << GPIO_INTEN_RHIEN5_Pos)                  /*!< GPIO_T::INTEN: RHIEN5 Mask             */

#define GPIO_INTEN_RHIEN6_Pos            (22)                                              /*!< GPIO_T::INTEN: RHIEN6 Position         */
#define GPIO_INTEN_RHIEN6_Msk            (0x1ul << GPIO_INTEN_RHIEN6_Pos)                  /*!< GPIO_T::INTEN: RHIEN6 Mask             */

#define GPIO_INTEN_RHIEN7_Pos            (23)                                              /*!< GPIO_T::INTEN: RHIEN7 Position         */
#define GPIO_INTEN_RHIEN7_Msk            (0x1ul << GPIO_INTEN_RHIEN7_Pos)                  /*!< GPIO_T::INTEN: RHIEN7 Mask             */

#define GPIO_INTEN_RHIEN8_Pos            (24)                                              /*!< GPIO_T::INTEN: RHIEN8 Position         */
#define GPIO_INTEN_RHIEN8_Msk            (0x1ul << GPIO_INTEN_RHIEN8_Pos)                  /*!< GPIO_T::INTEN: RHIEN8 Mask             */

#define GPIO_INTEN_RHIEN9_Pos            (25)                                              /*!< GPIO_T::INTEN: RHIEN9 Position         */
#define GPIO_INTEN_RHIEN9_Msk            (0x1ul << GPIO_INTEN_RHIEN9_Pos)                  /*!< GPIO_T::INTEN: RHIEN9 Mask             */

#define GPIO_INTEN_RHIEN10_Pos           (26)                                              /*!< GPIO_T::INTEN: RHIEN10 Position        */
#define GPIO_INTEN_RHIEN10_Msk           (0x1ul << GPIO_INTEN_RHIEN10_Pos)                 /*!< GPIO_T::INTEN: RHIEN10 Mask            */

#define GPIO_INTEN_RHIEN11_Pos           (27)                                              /*!< GPIO_T::INTEN: RHIEN11 Position        */
#define GPIO_INTEN_RHIEN11_Msk           (0x1ul << GPIO_INTEN_RHIEN11_Pos)                 /*!< GPIO_T::INTEN: RHIEN11 Mask            */

#define GPIO_INTEN_RHIEN12_Pos           (28)                                              /*!< GPIO_T::INTEN: RHIEN12 Position        */
#define GPIO_INTEN_RHIEN12_Msk           (0x1ul << GPIO_INTEN_RHIEN12_Pos)                 /*!< GPIO_T::INTEN: RHIEN12 Mask            */

#define GPIO_INTEN_RHIEN13_Pos           (29)                                              /*!< GPIO_T::INTEN: RHIEN13 Position        */
#define GPIO_INTEN_RHIEN13_Msk           (0x1ul << GPIO_INTEN_RHIEN13_Pos)                 /*!< GPIO_T::INTEN: RHIEN13 Mask            */

#define GPIO_INTEN_RHIEN14_Pos           (30)                                              /*!< GPIO_T::INTEN: RHIEN14 Position        */
#define GPIO_INTEN_RHIEN14_Msk           (0x1ul << GPIO_INTEN_RHIEN14_Pos)                 /*!< GPIO_T::INTEN: RHIEN14 Mask            */

#define GPIO_INTEN_RHIEN15_Pos           (31)                                              /*!< GPIO_T::INTEN: RHIEN15 Position        */
#define GPIO_INTEN_RHIEN15_Msk           (0x1ul << GPIO_INTEN_RHIEN15_Pos)                 /*!< GPIO_T::INTEN: RHIEN15 Mask            */

#define GPIO_INTSRC_INTSRC0_Pos          (0)                                               /*!< GPIO_T::INTSRC: INTSRC0 Position       */
#define GPIO_INTSRC_INTSRC0_Msk          (0x1ul << GPIO_INTSRC_INTSRC0_Pos)                /*!< GPIO_T::INTSRC: INTSRC0 Mask           */

#define GPIO_INTSRC_INTSRC1_Pos          (1)                                               /*!< GPIO_T::INTSRC: INTSRC1 Position       */
#define GPIO_INTSRC_INTSRC1_Msk          (0x1ul << GPIO_INTSRC_INTSRC1_Pos)                /*!< GPIO_T::INTSRC: INTSRC1 Mask           */

#define GPIO_INTSRC_INTSRC2_Pos          (2)                                               /*!< GPIO_T::INTSRC: INTSRC2 Position       */
#define GPIO_INTSRC_INTSRC2_Msk          (0x1ul << GPIO_INTSRC_INTSRC2_Pos)                /*!< GPIO_T::INTSRC: INTSRC2 Mask           */

#define GPIO_INTSRC_INTSRC3_Pos          (3)                                               /*!< GPIO_T::INTSRC: INTSRC3 Position       */
#define GPIO_INTSRC_INTSRC3_Msk          (0x1ul << GPIO_INTSRC_INTSRC3_Pos)                /*!< GPIO_T::INTSRC: INTSRC3 Mask           */

#define GPIO_INTSRC_INTSRC4_Pos          (4)                                               /*!< GPIO_T::INTSRC: INTSRC4 Position       */
#define GPIO_INTSRC_INTSRC4_Msk          (0x1ul << GPIO_INTSRC_INTSRC4_Pos)                /*!< GPIO_T::INTSRC: INTSRC4 Mask           */

#define GPIO_INTSRC_INTSRC5_Pos          (5)                                               /*!< GPIO_T::INTSRC: INTSRC5 Position       */
#define GPIO_INTSRC_INTSRC5_Msk          (0x1ul << GPIO_INTSRC_INTSRC5_Pos)                /*!< GPIO_T::INTSRC: INTSRC5 Mask           */

#define GPIO_INTSRC_INTSRC6_Pos          (6)                                               /*!< GPIO_T::INTSRC: INTSRC6 Position       */
#define GPIO_INTSRC_INTSRC6_Msk          (0x1ul << GPIO_INTSRC_INTSRC6_Pos)                /*!< GPIO_T::INTSRC: INTSRC6 Mask           */

#define GPIO_INTSRC_INTSRC7_Pos          (7)                                               /*!< GPIO_T::INTSRC: INTSRC7 Position       */
#define GPIO_INTSRC_INTSRC7_Msk          (0x1ul << GPIO_INTSRC_INTSRC7_Pos)                /*!< GPIO_T::INTSRC: INTSRC7 Mask           */

#define GPIO_INTSRC_INTSRC8_Pos          (8)                                               /*!< GPIO_T::INTSRC: INTSRC8 Position       */
#define GPIO_INTSRC_INTSRC8_Msk          (0x1ul << GPIO_INTSRC_INTSRC8_Pos)                /*!< GPIO_T::INTSRC: INTSRC8 Mask           */

#define GPIO_INTSRC_INTSRC9_Pos          (9)                                               /*!< GPIO_T::INTSRC: INTSRC9 Position       */
#define GPIO_INTSRC_INTSRC9_Msk          (0x1ul << GPIO_INTSRC_INTSRC9_Pos)                /*!< GPIO_T::INTSRC: INTSRC9 Mask           */

#define GPIO_INTSRC_INTSRC10_Pos         (10)                                              /*!< GPIO_T::INTSRC: INTSRC10 Position      */
#define GPIO_INTSRC_INTSRC10_Msk         (0x1ul << GPIO_INTSRC_INTSRC10_Pos)               /*!< GPIO_T::INTSRC: INTSRC10 Mask          */

#define GPIO_INTSRC_INTSRC11_Pos         (11)                                              /*!< GPIO_T::INTSRC: INTSRC11 Position      */
#define GPIO_INTSRC_INTSRC11_Msk         (0x1ul << GPIO_INTSRC_INTSRC11_Pos)               /*!< GPIO_T::INTSRC: INTSRC11 Mask          */

#define GPIO_INTSRC_INTSRC12_Pos         (12)                                              /*!< GPIO_T::INTSRC: INTSRC12 Position      */
#define GPIO_INTSRC_INTSRC12_Msk         (0x1ul << GPIO_INTSRC_INTSRC12_Pos)               /*!< GPIO_T::INTSRC: INTSRC12 Mask          */

#define GPIO_INTSRC_INTSRC13_Pos         (13)                                              /*!< GPIO_T::INTSRC: INTSRC13 Position      */
#define GPIO_INTSRC_INTSRC13_Msk         (0x1ul << GPIO_INTSRC_INTSRC13_Pos)               /*!< GPIO_T::INTSRC: INTSRC13 Mask          */

#define GPIO_INTSRC_INTSRC14_Pos         (14)                                              /*!< GPIO_T::INTSRC: INTSRC14 Position      */
#define GPIO_INTSRC_INTSRC14_Msk         (0x1ul << GPIO_INTSRC_INTSRC14_Pos)               /*!< GPIO_T::INTSRC: INTSRC14 Mask          */

#define GPIO_INTSRC_INTSRC15_Pos         (15)                                              /*!< GPIO_T::INTSRC: INTSRC15 Position      */
#define GPIO_INTSRC_INTSRC15_Msk         (0x1ul << GPIO_INTSRC_INTSRC15_Pos)               /*!< GPIO_T::INTSRC: INTSRC15 Mask          */

#define GPIO_SMTEN_SMTEN0_Pos            (0)                                               /*!< GPIO_T::SMTEN: SMTEN0 Position         */
#define GPIO_SMTEN_SMTEN0_Msk            (0x1ul << GPIO_SMTEN_SMTEN0_Pos)                  /*!< GPIO_T::SMTEN: SMTEN0 Mask             */

#define GPIO_SMTEN_SMTEN1_Pos            (1)                                               /*!< GPIO_T::SMTEN: SMTEN1 Position         */
#define GPIO_SMTEN_SMTEN1_Msk            (0x1ul << GPIO_SMTEN_SMTEN1_Pos)                  /*!< GPIO_T::SMTEN: SMTEN1 Mask             */

#define GPIO_SMTEN_SMTEN2_Pos            (2)                                               /*!< GPIO_T::SMTEN: SMTEN2 Position         */
#define GPIO_SMTEN_SMTEN2_Msk            (0x1ul << GPIO_SMTEN_SMTEN2_Pos)                  /*!< GPIO_T::SMTEN: SMTEN2 Mask             */

#define GPIO_SMTEN_SMTEN3_Pos            (3)                                               /*!< GPIO_T::SMTEN: SMTEN3 Position         */
#define GPIO_SMTEN_SMTEN3_Msk            (0x1ul << GPIO_SMTEN_SMTEN3_Pos)                  /*!< GPIO_T::SMTEN: SMTEN3 Mask             */

#define GPIO_SMTEN_SMTEN4_Pos            (4)                                               /*!< GPIO_T::SMTEN: SMTEN4 Position         */
#define GPIO_SMTEN_SMTEN4_Msk            (0x1ul << GPIO_SMTEN_SMTEN4_Pos)                  /*!< GPIO_T::SMTEN: SMTEN4 Mask             */

#define GPIO_SMTEN_SMTEN5_Pos            (5)                                               /*!< GPIO_T::SMTEN: SMTEN5 Position         */
#define GPIO_SMTEN_SMTEN5_Msk            (0x1ul << GPIO_SMTEN_SMTEN5_Pos)                  /*!< GPIO_T::SMTEN: SMTEN5 Mask             */

#define GPIO_SMTEN_SMTEN6_Pos            (6)                                               /*!< GPIO_T::SMTEN: SMTEN6 Position         */
#define GPIO_SMTEN_SMTEN6_Msk            (0x1ul << GPIO_SMTEN_SMTEN6_Pos)                  /*!< GPIO_T::SMTEN: SMTEN6 Mask             */

#define GPIO_SMTEN_SMTEN7_Pos            (7)                                               /*!< GPIO_T::SMTEN: SMTEN7 Position         */
#define GPIO_SMTEN_SMTEN7_Msk            (0x1ul << GPIO_SMTEN_SMTEN7_Pos)                  /*!< GPIO_T::SMTEN: SMTEN7 Mask             */

#define GPIO_SMTEN_SMTEN8_Pos            (8)                                               /*!< GPIO_T::SMTEN: SMTEN8 Position         */
#define GPIO_SMTEN_SMTEN8_Msk            (0x1ul << GPIO_SMTEN_SMTEN8_Pos)                  /*!< GPIO_T::SMTEN: SMTEN8 Mask             */

#define GPIO_SMTEN_SMTEN9_Pos            (9)                                               /*!< GPIO_T::SMTEN: SMTEN9 Position         */
#define GPIO_SMTEN_SMTEN9_Msk            (0x1ul << GPIO_SMTEN_SMTEN9_Pos)                  /*!< GPIO_T::SMTEN: SMTEN9 Mask             */

#define GPIO_SMTEN_SMTEN10_Pos           (10)                                              /*!< GPIO_T::SMTEN: SMTEN10 Position        */
#define GPIO_SMTEN_SMTEN10_Msk           (0x1ul << GPIO_SMTEN_SMTEN10_Pos)                 /*!< GPIO_T::SMTEN: SMTEN10 Mask            */

#define GPIO_SMTEN_SMTEN11_Pos           (11)                                              /*!< GPIO_T::SMTEN: SMTEN11 Position        */
#define GPIO_SMTEN_SMTEN11_Msk           (0x1ul << GPIO_SMTEN_SMTEN11_Pos)                 /*!< GPIO_T::SMTEN: SMTEN11 Mask            */

#define GPIO_SMTEN_SMTEN12_Pos           (12)                                              /*!< GPIO_T::SMTEN: SMTEN12 Position        */
#define GPIO_SMTEN_SMTEN12_Msk           (0x1ul << GPIO_SMTEN_SMTEN12_Pos)                 /*!< GPIO_T::SMTEN: SMTEN12 Mask            */

#define GPIO_SMTEN_SMTEN13_Pos           (13)                                              /*!< GPIO_T::SMTEN: SMTEN13 Position        */
#define GPIO_SMTEN_SMTEN13_Msk           (0x1ul << GPIO_SMTEN_SMTEN13_Pos)                 /*!< GPIO_T::SMTEN: SMTEN13 Mask            */

#define GPIO_SMTEN_SMTEN14_Pos           (14)                                              /*!< GPIO_T::SMTEN: SMTEN14 Position        */
#define GPIO_SMTEN_SMTEN14_Msk           (0x1ul << GPIO_SMTEN_SMTEN14_Pos)                 /*!< GPIO_T::SMTEN: SMTEN14 Mask            */

#define GPIO_SMTEN_SMTEN15_Pos           (15)                                              /*!< GPIO_T::SMTEN: SMTEN15 Position        */
#define GPIO_SMTEN_SMTEN15_Msk           (0x1ul << GPIO_SMTEN_SMTEN15_Pos)                 /*!< GPIO_T::SMTEN: SMTEN15 Mask            */

#define GPIO_SLEWCTL_HSREN0_Pos          (0)                                               /*!< GPIO_T::SLEWCTL: HSREN0 Position       */
#define GPIO_SLEWCTL_HSREN0_Msk          (0x3ul << GPIO_SLEWCTL_HSREN0_Pos)                /*!< GPIO_T::SLEWCTL: HSREN0 Mask           */

#define GPIO_SLEWCTL_HSREN1_Pos          (2)                                               /*!< GPIO_T::SLEWCTL: HSREN1 Position       */
#define GPIO_SLEWCTL_HSREN1_Msk          (0x3ul << GPIO_SLEWCTL_HSREN1_Pos)                /*!< GPIO_T::SLEWCTL: HSREN1 Mask           */

#define GPIO_SLEWCTL_HSREN2_Pos          (4)                                               /*!< GPIO_T::SLEWCTL: HSREN2 Position       */
#define GPIO_SLEWCTL_HSREN2_Msk          (0x3ul << GPIO_SLEWCTL_HSREN2_Pos)                /*!< GPIO_T::SLEWCTL: HSREN2 Mask           */

#define GPIO_SLEWCTL_HSREN3_Pos          (6)                                               /*!< GPIO_T::SLEWCTL: HSREN3 Position       */
#define GPIO_SLEWCTL_HSREN3_Msk          (0x3ul << GPIO_SLEWCTL_HSREN3_Pos)                /*!< GPIO_T::SLEWCTL: HSREN3 Mask           */

#define GPIO_SLEWCTL_HSREN4_Pos          (8)                                               /*!< GPIO_T::SLEWCTL: HSREN4 Position       */
#define GPIO_SLEWCTL_HSREN4_Msk          (0x3ul << GPIO_SLEWCTL_HSREN4_Pos)                /*!< GPIO_T::SLEWCTL: HSREN4 Mask           */

#define GPIO_SLEWCTL_HSREN5_Pos          (10)                                              /*!< GPIO_T::SLEWCTL: HSREN5 Position       */
#define GPIO_SLEWCTL_HSREN5_Msk          (0x3ul << GPIO_SLEWCTL_HSREN5_Pos)                /*!< GPIO_T::SLEWCTL: HSREN5 Mask           */

#define GPIO_SLEWCTL_HSREN6_Pos          (12)                                              /*!< GPIO_T::SLEWCTL: HSREN6 Position       */
#define GPIO_SLEWCTL_HSREN6_Msk          (0x3ul << GPIO_SLEWCTL_HSREN6_Pos)                /*!< GPIO_T::SLEWCTL: HSREN6 Mask           */

#define GPIO_SLEWCTL_HSREN7_Pos          (14)                                              /*!< GPIO_T::SLEWCTL: HSREN7 Position       */
#define GPIO_SLEWCTL_HSREN7_Msk          (0x3ul << GPIO_SLEWCTL_HSREN7_Pos)                /*!< GPIO_T::SLEWCTL: HSREN7 Mask           */

#define GPIO_SLEWCTL_HSREN8_Pos          (16)                                              /*!< GPIO_T::SLEWCTL: HSREN8 Position       */
#define GPIO_SLEWCTL_HSREN8_Msk          (0x3ul << GPIO_SLEWCTL_HSREN8_Pos)                /*!< GPIO_T::SLEWCTL: HSREN8 Mask           */

#define GPIO_SLEWCTL_HSREN9_Pos          (18)                                              /*!< GPIO_T::SLEWCTL: HSREN9 Position       */
#define GPIO_SLEWCTL_HSREN9_Msk          (0x3ul << GPIO_SLEWCTL_HSREN9_Pos)                /*!< GPIO_T::SLEWCTL: HSREN9 Mask           */

#define GPIO_SLEWCTL_HSREN10_Pos         (20)                                              /*!< GPIO_T::SLEWCTL: HSREN10 Position      */
#define GPIO_SLEWCTL_HSREN10_Msk         (0x3ul << GPIO_SLEWCTL_HSREN10_Pos)               /*!< GPIO_T::SLEWCTL: HSREN10 Mask          */

#define GPIO_SLEWCTL_HSREN11_Pos         (22)                                              /*!< GPIO_T::SLEWCTL: HSREN11 Position      */
#define GPIO_SLEWCTL_HSREN11_Msk         (0x3ul << GPIO_SLEWCTL_HSREN11_Pos)               /*!< GPIO_T::SLEWCTL: HSREN11 Mask          */

#define GPIO_SLEWCTL_HSREN12_Pos         (24)                                              /*!< GPIO_T::SLEWCTL: HSREN12 Position      */
#define GPIO_SLEWCTL_HSREN12_Msk         (0x3ul << GPIO_SLEWCTL_HSREN12_Pos)               /*!< GPIO_T::SLEWCTL: HSREN12 Mask          */

#define GPIO_SLEWCTL_HSREN13_Pos         (26)                                              /*!< GPIO_T::SLEWCTL: HSREN13 Position      */
#define GPIO_SLEWCTL_HSREN13_Msk         (0x3ul << GPIO_SLEWCTL_HSREN13_Pos)               /*!< GPIO_T::SLEWCTL: HSREN13 Mask          */

#define GPIO_SLEWCTL_HSREN14_Pos         (28)                                              /*!< GPIO_T::SLEWCTL: HSREN14 Position      */
#define GPIO_SLEWCTL_HSREN14_Msk         (0x3ul << GPIO_SLEWCTL_HSREN14_Pos)               /*!< GPIO_T::SLEWCTL: HSREN14 Mask          */

#define GPIO_SLEWCTL_HSREN15_Pos         (30)                                              /*!< GPIO_T::SLEWCTL: HSREN15 Position      */
#define GPIO_SLEWCTL_HSREN15_Msk         (0x3ul << GPIO_SLEWCTL_HSREN15_Pos)               /*!< GPIO_T::SLEWCTL: HSREN15 Mask          */

#define GPIO_PUSEL_PUSEL0_Pos            (0)                                               /*!< GPIO_T::PUSEL: PUSEL0 Position         */
#define GPIO_PUSEL_PUSEL0_Msk            (0x3ul << GPIO_PUSEL_PUSEL0_Pos)                  /*!< GPIO_T::PUSEL: PUSEL0 Mask             */

#define GPIO_PUSEL_PUSEL1_Pos            (2)                                               /*!< GPIO_T::PUSEL: PUSEL1 Position         */
#define GPIO_PUSEL_PUSEL1_Msk            (0x3ul << GPIO_PUSEL_PUSEL1_Pos)                  /*!< GPIO_T::PUSEL: PUSEL1 Mask             */

#define GPIO_PUSEL_PUSEL2_Pos            (4)                                               /*!< GPIO_T::PUSEL: PUSEL2 Position         */
#define GPIO_PUSEL_PUSEL2_Msk            (0x3ul << GPIO_PUSEL_PUSEL2_Pos)                  /*!< GPIO_T::PUSEL: PUSEL2 Mask             */

#define GPIO_PUSEL_PUSEL3_Pos            (6)                                               /*!< GPIO_T::PUSEL: PUSEL3 Position         */
#define GPIO_PUSEL_PUSEL3_Msk            (0x3ul << GPIO_PUSEL_PUSEL3_Pos)                  /*!< GPIO_T::PUSEL: PUSEL3 Mask             */

#define GPIO_PUSEL_PUSEL4_Pos            (8)                                               /*!< GPIO_T::PUSEL: PUSEL4 Position         */
#define GPIO_PUSEL_PUSEL4_Msk            (0x3ul << GPIO_PUSEL_PUSEL4_Pos)                  /*!< GPIO_T::PUSEL: PUSEL4 Mask             */

#define GPIO_PUSEL_PUSEL5_Pos            (10)                                              /*!< GPIO_T::PUSEL: PUSEL5 Position         */
#define GPIO_PUSEL_PUSEL5_Msk            (0x3ul << GPIO_PUSEL_PUSEL5_Pos)                  /*!< GPIO_T::PUSEL: PUSEL5 Mask             */

#define GPIO_PUSEL_PUSEL6_Pos            (12)                                              /*!< GPIO_T::PUSEL: PUSEL6 Position         */
#define GPIO_PUSEL_PUSEL6_Msk            (0x3ul << GPIO_PUSEL_PUSEL6_Pos)                  /*!< GPIO_T::PUSEL: PUSEL6 Mask             */

#define GPIO_PUSEL_PUSEL7_Pos            (14)                                              /*!< GPIO_T::PUSEL: PUSEL7 Position         */
#define GPIO_PUSEL_PUSEL7_Msk            (0x3ul << GPIO_PUSEL_PUSEL7_Pos)                  /*!< GPIO_T::PUSEL: PUSEL7 Mask             */

#define GPIO_PUSEL_PUSEL8_Pos            (16)                                              /*!< GPIO_T::PUSEL: PUSEL8 Position         */
#define GPIO_PUSEL_PUSEL8_Msk            (0x3ul << GPIO_PUSEL_PUSEL8_Pos)                  /*!< GPIO_T::PUSEL: PUSEL8 Mask             */

#define GPIO_PUSEL_PUSEL9_Pos            (18)                                              /*!< GPIO_T::PUSEL: PUSEL9 Position         */
#define GPIO_PUSEL_PUSEL9_Msk            (0x3ul << GPIO_PUSEL_PUSEL9_Pos)                  /*!< GPIO_T::PUSEL: PUSEL9 Mask             */

#define GPIO_PUSEL_PUSEL10_Pos           (20)                                              /*!< GPIO_T::PUSEL: PUSEL10 Position        */
#define GPIO_PUSEL_PUSEL10_Msk           (0x3ul << GPIO_PUSEL_PUSEL10_Pos)                 /*!< GPIO_T::PUSEL: PUSEL10 Mask            */

#define GPIO_PUSEL_PUSEL11_Pos           (22)                                              /*!< GPIO_T::PUSEL: PUSEL11 Position        */
#define GPIO_PUSEL_PUSEL11_Msk           (0x3ul << GPIO_PUSEL_PUSEL11_Pos)                 /*!< GPIO_T::PUSEL: PUSEL11 Mask            */

#define GPIO_PUSEL_PUSEL12_Pos           (24)                                              /*!< GPIO_T::PUSEL: PUSEL12 Position        */
#define GPIO_PUSEL_PUSEL12_Msk           (0x3ul << GPIO_PUSEL_PUSEL12_Pos)                 /*!< GPIO_T::PUSEL: PUSEL12 Mask            */

#define GPIO_PUSEL_PUSEL13_Pos           (26)                                              /*!< GPIO_T::PUSEL: PUSEL13 Position        */
#define GPIO_PUSEL_PUSEL13_Msk           (0x3ul << GPIO_PUSEL_PUSEL13_Pos)                 /*!< GPIO_T::PUSEL: PUSEL13 Mask            */

#define GPIO_PUSEL_PUSEL14_Pos           (28)                                              /*!< GPIO_T::PUSEL: PUSEL14 Position        */
#define GPIO_PUSEL_PUSEL14_Msk           (0x3ul << GPIO_PUSEL_PUSEL14_Pos)                 /*!< GPIO_T::PUSEL: PUSEL14 Mask            */

#define GPIO_PUSEL_PUSEL15_Pos           (30)                                              /*!< GPIO_T::PUSEL: PUSEL15 Position        */
#define GPIO_PUSEL_PUSEL15_Msk           (0x3ul << GPIO_PUSEL_PUSEL15_Pos)                 /*!< GPIO_T::PUSEL: PUSEL15 Mask            */

#define GPIO_MODE_MODE0_Pos              (0)                                               /*!< GPIO_T::MODE: MODE0 Position           */
#define GPIO_MODE_MODE0_Msk              (0x3ul << GPIO_MODE_MODE0_Pos)                    /*!< GPIO_T::MODE: MODE0 Mask               */

#define GPIO_MODE_MODE1_Pos              (2)                                               /*!< GPIO_T::MODE: MODE1 Position           */
#define GPIO_MODE_MODE1_Msk              (0x3ul << GPIO_MODE_MODE1_Pos)                    /*!< GPIO_T::MODE: MODE1 Mask               */

#define GPIO_MODE_MODE2_Pos              (4)                                               /*!< GPIO_T::MODE: MODE2 Position           */
#define GPIO_MODE_MODE2_Msk              (0x3ul << GPIO_MODE_MODE2_Pos)                    /*!< GPIO_T::MODE: MODE2 Mask               */

#define GPIO_MODE_MODE3_Pos              (6)                                               /*!< GPIO_T::MODE: MODE3 Position           */
#define GPIO_MODE_MODE3_Msk              (0x3ul << GPIO_MODE_MODE3_Pos)                    /*!< GPIO_T::MODE: MODE3 Mask               */

#define GPIO_MODE_MODE4_Pos              (8)                                               /*!< GPIO_T::MODE: MODE4 Position           */
#define GPIO_MODE_MODE4_Msk              (0x3ul << GPIO_MODE_MODE4_Pos)                    /*!< GPIO_T::MODE: MODE4 Mask               */

#define GPIO_MODE_MODE5_Pos              (10)                                              /*!< GPIO_T::MODE: MODE5 Position           */
#define GPIO_MODE_MODE5_Msk              (0x3ul << GPIO_MODE_MODE5_Pos)                    /*!< GPIO_T::MODE: MODE5 Mask               */

#define GPIO_MODE_MODE6_Pos              (12)                                              /*!< GPIO_T::MODE: MODE6 Position           */
#define GPIO_MODE_MODE6_Msk              (0x3ul << GPIO_MODE_MODE6_Pos)                    /*!< GPIO_T::MODE: MODE6 Mask               */

#define GPIO_MODE_MODE7_Pos              (14)                                              /*!< GPIO_T::MODE: MODE7 Position           */
#define GPIO_MODE_MODE7_Msk              (0x3ul << GPIO_MODE_MODE7_Pos)                    /*!< GPIO_T::MODE: MODE7 Mask               */

#define GPIO_MODE_MODE8_Pos              (16)                                              /*!< GPIO_T::MODE: MODE8 Position           */
#define GPIO_MODE_MODE8_Msk              (0x3ul << GPIO_MODE_MODE8_Pos)                    /*!< GPIO_T::MODE: MODE8 Mask               */

#define GPIO_MODE_MODE9_Pos              (18)                                              /*!< GPIO_T::MODE: MODE9 Position           */
#define GPIO_MODE_MODE9_Msk              (0x3ul << GPIO_MODE_MODE9_Pos)                    /*!< GPIO_T::MODE: MODE9 Mask               */

#define GPIO_MODE_MODE10_Pos             (20)                                              /*!< GPIO_T::MODE: MODE10 Position          */
#define GPIO_MODE_MODE10_Msk             (0x3ul << GPIO_MODE_MODE10_Pos)                   /*!< GPIO_T::MODE: MODE10 Mask              */

#define GPIO_MODE_MODE11_Pos             (22)                                              /*!< GPIO_T::MODE: MODE11 Position          */
#define GPIO_MODE_MODE11_Msk             (0x3ul << GPIO_MODE_MODE11_Pos)                   /*!< GPIO_T::MODE: MODE11 Mask              */

#define GPIO_MODE_MODE12_Pos             (24)                                              /*!< GPIO_T::MODE: MODE12 Position          */
#define GPIO_MODE_MODE12_Msk             (0x3ul << GPIO_MODE_MODE12_Pos)                   /*!< GPIO_T::MODE: MODE12 Mask              */

#define GPIO_MODE_MODE13_Pos             (26)                                              /*!< GPIO_T::MODE: MODE13 Position          */
#define GPIO_MODE_MODE13_Msk             (0x3ul << GPIO_MODE_MODE13_Pos)                   /*!< GPIO_T::MODE: MODE13 Mask              */

#define GPIO_MODE_MODE14_Pos             (28)                                              /*!< GPIO_T::MODE: MODE14 Position          */
#define GPIO_MODE_MODE14_Msk             (0x3ul << GPIO_MODE_MODE14_Pos)                   /*!< GPIO_T::MODE: MODE14 Mask              */

#define GPIO_MODE_MODE15_Pos             (30)                                              /*!< GPIO_T::MODE: MODE15 Position          */
#define GPIO_MODE_MODE15_Msk             (0x3ul << GPIO_MODE_MODE15_Pos)                   /*!< GPIO_T::MODE: MODE15 Mask              */

#define GPIO_DINOFF_DINOFF0_Pos          (16)                                              /*!< GPIO_T::DINOFF: DINOFF0 Position       */
#define GPIO_DINOFF_DINOFF0_Msk          (0x1ul << GPIO_DINOFF_DINOFF0_Pos)                /*!< GPIO_T::DINOFF: DINOFF0 Mask           */

#define GPIO_DINOFF_DINOFF1_Pos          (17)                                              /*!< GPIO_T::DINOFF: DINOFF1 Position       */
#define GPIO_DINOFF_DINOFF1_Msk          (0x1ul << GPIO_DINOFF_DINOFF1_Pos)                /*!< GPIO_T::DINOFF: DINOFF1 Mask           */

#define GPIO_DINOFF_DINOFF2_Pos          (18)                                              /*!< GPIO_T::DINOFF: DINOFF2 Position       */
#define GPIO_DINOFF_DINOFF2_Msk          (0x1ul << GPIO_DINOFF_DINOFF2_Pos)                /*!< GPIO_T::DINOFF: DINOFF2 Mask           */

#define GPIO_DINOFF_DINOFF3_Pos          (19)                                              /*!< GPIO_T::DINOFF: DINOFF3 Position       */
#define GPIO_DINOFF_DINOFF3_Msk          (0x1ul << GPIO_DINOFF_DINOFF3_Pos)                /*!< GPIO_T::DINOFF: DINOFF3 Mask           */

#define GPIO_DINOFF_DINOFF4_Pos          (20)                                              /*!< GPIO_T::DINOFF: DINOFF4 Position       */
#define GPIO_DINOFF_DINOFF4_Msk          (0x1ul << GPIO_DINOFF_DINOFF4_Pos)                /*!< GPIO_T::DINOFF: DINOFF4 Mask           */

#define GPIO_DINOFF_DINOFF5_Pos          (21)                                              /*!< GPIO_T::DINOFF: DINOFF5 Position       */
#define GPIO_DINOFF_DINOFF5_Msk          (0x1ul << GPIO_DINOFF_DINOFF5_Pos)                /*!< GPIO_T::DINOFF: DINOFF5 Mask           */

#define GPIO_DINOFF_DINOFF6_Pos          (22)                                              /*!< GPIO_T::DINOFF: DINOFF6 Position       */
#define GPIO_DINOFF_DINOFF6_Msk          (0x1ul << GPIO_DINOFF_DINOFF6_Pos)                /*!< GPIO_T::DINOFF: DINOFF6 Mask           */

#define GPIO_DINOFF_DINOFF7_Pos          (23)                                              /*!< GPIO_T::DINOFF: DINOFF7 Position       */
#define GPIO_DINOFF_DINOFF7_Msk          (0x1ul << GPIO_DINOFF_DINOFF7_Pos)                /*!< GPIO_T::DINOFF: DINOFF7 Mask           */

#define GPIO_DINOFF_DINOFF8_Pos          (24)                                              /*!< GPIO_T::DINOFF: DINOFF8 Position       */
#define GPIO_DINOFF_DINOFF8_Msk          (0x1ul << GPIO_DINOFF_DINOFF8_Pos)                /*!< GPIO_T::DINOFF: DINOFF8 Mask           */

#define GPIO_DINOFF_DINOFF9_Pos          (25)                                              /*!< GPIO_T::DINOFF: DINOFF9 Position       */
#define GPIO_DINOFF_DINOFF9_Msk          (0x1ul << GPIO_DINOFF_DINOFF9_Pos)                /*!< GPIO_T::DINOFF: DINOFF9 Mask           */

#define GPIO_DINOFF_DINOFF10_Pos         (26)                                              /*!< GPIO_T::DINOFF: DINOFF10 Position      */
#define GPIO_DINOFF_DINOFF10_Msk         (0x1ul << GPIO_DINOFF_DINOFF10_Pos)               /*!< GPIO_T::DINOFF: DINOFF10 Mask          */

#define GPIO_DINOFF_DINOFF11_Pos         (27)                                              /*!< GPIO_T::DINOFF: DINOFF11 Position      */
#define GPIO_DINOFF_DINOFF11_Msk         (0x1ul << GPIO_DINOFF_DINOFF11_Pos)               /*!< GPIO_T::DINOFF: DINOFF11 Mask          */

#define GPIO_DINOFF_DINOFF12_Pos         (28)                                              /*!< GPIO_T::DINOFF: DINOFF12 Position      */
#define GPIO_DINOFF_DINOFF12_Msk         (0x1ul << GPIO_DINOFF_DINOFF12_Pos)               /*!< GPIO_T::DINOFF: DINOFF12 Mask          */

#define GPIO_DINOFF_DINOFF13_Pos         (29)                                              /*!< GPIO_T::DINOFF: DINOFF13 Position      */
#define GPIO_DINOFF_DINOFF13_Msk         (0x1ul << GPIO_DINOFF_DINOFF13_Pos)               /*!< GPIO_T::DINOFF: DINOFF13 Mask          */

#define GPIO_DINOFF_DINOFF14_Pos         (30)                                              /*!< GPIO_T::DINOFF: DINOFF14 Position      */
#define GPIO_DINOFF_DINOFF14_Msk         (0x1ul << GPIO_DINOFF_DINOFF14_Pos)               /*!< GPIO_T::DINOFF: DINOFF14 Mask          */

#define GPIO_DINOFF_DINOFF15_Pos         (31)                                              /*!< GPIO_T::DINOFF: DINOFF15 Position      */
#define GPIO_DINOFF_DINOFF15_Msk         (0x1ul << GPIO_DINOFF_DINOFF15_Pos)               /*!< GPIO_T::DINOFF: DINOFF15 Mask          */

#define GPIO_DOUT_DOUT0_Pos              (0)                                               /*!< GPIO_T::DOUT: DOUT0 Position           */
#define GPIO_DOUT_DOUT0_Msk              (0x1ul << GPIO_DOUT_DOUT0_Pos)                    /*!< GPIO_T::DOUT: DOUT0 Mask               */

#define GPIO_DOUT_DOUT1_Pos              (1)                                               /*!< GPIO_T::DOUT: DOUT1 Position           */
#define GPIO_DOUT_DOUT1_Msk              (0x1ul << GPIO_DOUT_DOUT1_Pos)                    /*!< GPIO_T::DOUT: DOUT1 Mask               */

#define GPIO_DOUT_DOUT2_Pos              (2)                                               /*!< GPIO_T::DOUT: DOUT2 Position           */
#define GPIO_DOUT_DOUT2_Msk              (0x1ul << GPIO_DOUT_DOUT2_Pos)                    /*!< GPIO_T::DOUT: DOUT2 Mask               */

#define GPIO_DOUT_DOUT3_Pos              (3)                                               /*!< GPIO_T::DOUT: DOUT3 Position           */
#define GPIO_DOUT_DOUT3_Msk              (0x1ul << GPIO_DOUT_DOUT3_Pos)                    /*!< GPIO_T::DOUT: DOUT3 Mask               */

#define GPIO_DOUT_DOUT4_Pos              (4)                                               /*!< GPIO_T::DOUT: DOUT4 Position           */
#define GPIO_DOUT_DOUT4_Msk              (0x1ul << GPIO_DOUT_DOUT4_Pos)                    /*!< GPIO_T::DOUT: DOUT4 Mask               */

#define GPIO_DOUT_DOUT5_Pos              (5)                                               /*!< GPIO_T::DOUT: DOUT5 Position           */
#define GPIO_DOUT_DOUT5_Msk              (0x1ul << GPIO_DOUT_DOUT5_Pos)                    /*!< GPIO_T::DOUT: DOUT5 Mask               */

#define GPIO_DOUT_DOUT6_Pos              (6)                                               /*!< GPIO_T::DOUT: DOUT6 Position           */
#define GPIO_DOUT_DOUT6_Msk              (0x1ul << GPIO_DOUT_DOUT6_Pos)                    /*!< GPIO_T::DOUT: DOUT6 Mask               */

#define GPIO_DOUT_DOUT7_Pos              (7)                                               /*!< GPIO_T::DOUT: DOUT7 Position           */
#define GPIO_DOUT_DOUT7_Msk              (0x1ul << GPIO_DOUT_DOUT7_Pos)                    /*!< GPIO_T::DOUT: DOUT7 Mask               */

#define GPIO_DOUT_DOUT8_Pos              (8)                                               /*!< GPIO_T::DOUT: DOUT8 Position           */
#define GPIO_DOUT_DOUT8_Msk              (0x1ul << GPIO_DOUT_DOUT8_Pos)                    /*!< GPIO_T::DOUT: DOUT8 Mask               */

#define GPIO_DOUT_DOUT9_Pos              (9)                                               /*!< GPIO_T::DOUT: DOUT9 Position           */
#define GPIO_DOUT_DOUT9_Msk              (0x1ul << GPIO_DOUT_DOUT9_Pos)                    /*!< GPIO_T::DOUT: DOUT9 Mask               */

#define GPIO_DOUT_DOUT10_Pos             (10)                                              /*!< GPIO_T::DOUT: DOUT10 Position          */
#define GPIO_DOUT_DOUT10_Msk             (0x1ul << GPIO_DOUT_DOUT10_Pos)                   /*!< GPIO_T::DOUT: DOUT10 Mask              */

#define GPIO_DOUT_DOUT11_Pos             (11)                                              /*!< GPIO_T::DOUT: DOUT11 Position          */
#define GPIO_DOUT_DOUT11_Msk             (0x1ul << GPIO_DOUT_DOUT11_Pos)                   /*!< GPIO_T::DOUT: DOUT11 Mask              */

#define GPIO_DOUT_DOUT12_Pos             (12)                                              /*!< GPIO_T::DOUT: DOUT12 Position          */
#define GPIO_DOUT_DOUT12_Msk             (0x1ul << GPIO_DOUT_DOUT12_Pos)                   /*!< GPIO_T::DOUT: DOUT12 Mask              */

#define GPIO_DOUT_DOUT13_Pos             (13)                                              /*!< GPIO_T::DOUT: DOUT13 Position          */
#define GPIO_DOUT_DOUT13_Msk             (0x1ul << GPIO_DOUT_DOUT13_Pos)                   /*!< GPIO_T::DOUT: DOUT13 Mask              */

#define GPIO_DOUT_DOUT14_Pos             (14)                                              /*!< GPIO_T::DOUT: DOUT14 Position          */
#define GPIO_DOUT_DOUT14_Msk             (0x1ul << GPIO_DOUT_DOUT14_Pos)                   /*!< GPIO_T::DOUT: DOUT14 Mask              */

#define GPIO_DOUT_DOUT15_Pos             (15)                                              /*!< GPIO_T::DOUT: DOUT15 Position          */
#define GPIO_DOUT_DOUT15_Msk             (0x1ul << GPIO_DOUT_DOUT15_Pos)                   /*!< GPIO_T::DOUT: DOUT15 Mask              */

#define GPIO_DATMSK_DATMSK0_Pos          (0)                                               /*!< GPIO_T::DATMSK: DATMSK0 Position       */
#define GPIO_DATMSK_DATMSK0_Msk          (0x1ul << GPIO_DATMSK_DATMSK0_Pos)                /*!< GPIO_T::DATMSK: DATMSK0 Mask           */

#define GPIO_DATMSK_DATMSK1_Pos          (1)                                               /*!< GPIO_T::DATMSK: DATMSK1 Position       */
#define GPIO_DATMSK_DATMSK1_Msk          (0x1ul << GPIO_DATMSK_DATMSK1_Pos)                /*!< GPIO_T::DATMSK: DATMSK1 Mask           */

#define GPIO_DATMSK_DATMSK2_Pos          (2)                                               /*!< GPIO_T::DATMSK: DATMSK2 Position       */
#define GPIO_DATMSK_DATMSK2_Msk          (0x1ul << GPIO_DATMSK_DATMSK2_Pos)                /*!< GPIO_T::DATMSK: DATMSK2 Mask           */

#define GPIO_DATMSK_DATMSK3_Pos          (3)                                               /*!< GPIO_T::DATMSK: DATMSK3 Position       */
#define GPIO_DATMSK_DATMSK3_Msk          (0x1ul << GPIO_DATMSK_DATMSK3_Pos)                /*!< GPIO_T::DATMSK: DATMSK3 Mask           */

#define GPIO_DATMSK_DATMSK4_Pos          (4)                                               /*!< GPIO_T::DATMSK: DATMSK4 Position       */
#define GPIO_DATMSK_DATMSK4_Msk          (0x1ul << GPIO_DATMSK_DATMSK4_Pos)                /*!< GPIO_T::DATMSK: DATMSK4 Mask           */

#define GPIO_DATMSK_DATMSK5_Pos          (5)                                               /*!< GPIO_T::DATMSK: DATMSK5 Position       */
#define GPIO_DATMSK_DATMSK5_Msk          (0x1ul << GPIO_DATMSK_DATMSK5_Pos)                /*!< GPIO_T::DATMSK: DATMSK5 Mask           */

#define GPIO_DATMSK_DATMSK6_Pos          (6)                                               /*!< GPIO_T::DATMSK: DATMSK6 Position       */
#define GPIO_DATMSK_DATMSK6_Msk          (0x1ul << GPIO_DATMSK_DATMSK6_Pos)                /*!< GPIO_T::DATMSK: DATMSK6 Mask           */

#define GPIO_DATMSK_DATMSK7_Pos          (7)                                               /*!< GPIO_T::DATMSK: DATMSK7 Position       */
#define GPIO_DATMSK_DATMSK7_Msk          (0x1ul << GPIO_DATMSK_DATMSK7_Pos)                /*!< GPIO_T::DATMSK: DATMSK7 Mask           */

#define GPIO_DATMSK_DATMSK8_Pos          (8)                                               /*!< GPIO_T::DATMSK: DATMSK8 Position       */
#define GPIO_DATMSK_DATMSK8_Msk          (0x1ul << GPIO_DATMSK_DATMSK8_Pos)                /*!< GPIO_T::DATMSK: DATMSK8 Mask           */

#define GPIO_DATMSK_DATMSK9_Pos          (9)                                               /*!< GPIO_T::DATMSK: DATMSK9 Position       */
#define GPIO_DATMSK_DATMSK9_Msk          (0x1ul << GPIO_DATMSK_DATMSK9_Pos)                /*!< GPIO_T::DATMSK: DATMSK9 Mask           */

#define GPIO_DATMSK_DATMSK10_Pos         (10)                                              /*!< GPIO_T::DATMSK: DATMSK10 Position      */
#define GPIO_DATMSK_DATMSK10_Msk         (0x1ul << GPIO_DATMSK_DATMSK10_Pos)               /*!< GPIO_T::DATMSK: DATMSK10 Mask          */

#define GPIO_DATMSK_DATMSK11_Pos         (11)                                              /*!< GPIO_T::DATMSK: DATMSK11 Position      */
#define GPIO_DATMSK_DATMSK11_Msk         (0x1ul << GPIO_DATMSK_DATMSK11_Pos)               /*!< GPIO_T::DATMSK: DATMSK11 Mask          */

#define GPIO_DATMSK_DATMSK12_Pos         (12)                                              /*!< GPIO_T::DATMSK: DATMSK12 Position      */
#define GPIO_DATMSK_DATMSK12_Msk         (0x1ul << GPIO_DATMSK_DATMSK12_Pos)               /*!< GPIO_T::DATMSK: DATMSK12 Mask          */

#define GPIO_DATMSK_DATMSK13_Pos         (13)                                              /*!< GPIO_T::DATMSK: DATMSK13 Position      */
#define GPIO_DATMSK_DATMSK13_Msk         (0x1ul << GPIO_DATMSK_DATMSK13_Pos)               /*!< GPIO_T::DATMSK: DATMSK13 Mask          */

#define GPIO_DATMSK_DATMSK14_Pos         (14)                                              /*!< GPIO_T::DATMSK: DATMSK14 Position      */
#define GPIO_DATMSK_DATMSK14_Msk         (0x1ul << GPIO_DATMSK_DATMSK14_Pos)               /*!< GPIO_T::DATMSK: DATMSK14 Mask          */

#define GPIO_DATMSK_DATMSK15_Pos         (15)                                              /*!< GPIO_T::DATMSK: DATMSK15 Position      */
#define GPIO_DATMSK_DATMSK15_Msk         (0x1ul << GPIO_DATMSK_DATMSK15_Pos)               /*!< GPIO_T::DATMSK: DATMSK15 Mask          */

#define GPIO_PIN_PIN0_Pos                (0)                                               /*!< GPIO_T::PIN: PIN0 Position             */
#define GPIO_PIN_PIN0_Msk                (0x1ul << GPIO_PIN_PIN0_Pos)                      /*!< GPIO_T::PIN: PIN0 Mask                 */

#define GPIO_PIN_PIN1_Pos                (1)                                               /*!< GPIO_T::PIN: PIN1 Position             */
#define GPIO_PIN_PIN1_Msk                (0x1ul << GPIO_PIN_PIN1_Pos)                      /*!< GPIO_T::PIN: PIN1 Mask                 */

#define GPIO_PIN_PIN2_Pos                (2)                                               /*!< GPIO_T::PIN: PIN2 Position             */
#define GPIO_PIN_PIN2_Msk                (0x1ul << GPIO_PIN_PIN2_Pos)                      /*!< GPIO_T::PIN: PIN2 Mask                 */

#define GPIO_PIN_PIN3_Pos                (3)                                               /*!< GPIO_T::PIN: PIN3 Position             */
#define GPIO_PIN_PIN3_Msk                (0x1ul << GPIO_PIN_PIN3_Pos)                      /*!< GPIO_T::PIN: PIN3 Mask                 */

#define GPIO_PIN_PIN4_Pos                (4)                                               /*!< GPIO_T::PIN: PIN4 Position             */
#define GPIO_PIN_PIN4_Msk                (0x1ul << GPIO_PIN_PIN4_Pos)                      /*!< GPIO_T::PIN: PIN4 Mask                 */

#define GPIO_PIN_PIN5_Pos                (5)                                               /*!< GPIO_T::PIN: PIN5 Position             */
#define GPIO_PIN_PIN5_Msk                (0x1ul << GPIO_PIN_PIN5_Pos)                      /*!< GPIO_T::PIN: PIN5 Mask                 */

#define GPIO_PIN_PIN6_Pos                (6)                                               /*!< GPIO_T::PIN: PIN6 Position             */
#define GPIO_PIN_PIN6_Msk                (0x1ul << GPIO_PIN_PIN6_Pos)                      /*!< GPIO_T::PIN: PIN6 Mask                 */

#define GPIO_PIN_PIN7_Pos                (7)                                               /*!< GPIO_T::PIN: PIN7 Position             */
#define GPIO_PIN_PIN7_Msk                (0x1ul << GPIO_PIN_PIN7_Pos)                      /*!< GPIO_T::PIN: PIN7 Mask                 */

#define GPIO_PIN_PIN8_Pos                (8)                                               /*!< GPIO_T::PIN: PIN8 Position             */
#define GPIO_PIN_PIN8_Msk                (0x1ul << GPIO_PIN_PIN8_Pos)                      /*!< GPIO_T::PIN: PIN8 Mask                 */

#define GPIO_PIN_PIN9_Pos                (9)                                               /*!< GPIO_T::PIN: PIN9 Position             */
#define GPIO_PIN_PIN9_Msk                (0x1ul << GPIO_PIN_PIN9_Pos)                      /*!< GPIO_T::PIN: PIN9 Mask                 */

#define GPIO_PIN_PIN10_Pos               (10)                                              /*!< GPIO_T::PIN: PIN10 Position            */
#define GPIO_PIN_PIN10_Msk               (0x1ul << GPIO_PIN_PIN10_Pos)                     /*!< GPIO_T::PIN: PIN10 Mask                */

#define GPIO_PIN_PIN11_Pos               (11)                                              /*!< GPIO_T::PIN: PIN11 Position            */
#define GPIO_PIN_PIN11_Msk               (0x1ul << GPIO_PIN_PIN11_Pos)                     /*!< GPIO_T::PIN: PIN11 Mask                */

#define GPIO_PIN_PIN12_Pos               (12)                                              /*!< GPIO_T::PIN: PIN12 Position            */
#define GPIO_PIN_PIN12_Msk               (0x1ul << GPIO_PIN_PIN12_Pos)                     /*!< GPIO_T::PIN: PIN12 Mask                */

#define GPIO_PIN_PIN13_Pos               (13)                                              /*!< GPIO_T::PIN: PIN13 Position            */
#define GPIO_PIN_PIN13_Msk               (0x1ul << GPIO_PIN_PIN13_Pos)                     /*!< GPIO_T::PIN: PIN13 Mask                */

#define GPIO_PIN_PIN14_Pos               (14)                                              /*!< GPIO_T::PIN: PIN14 Position            */
#define GPIO_PIN_PIN14_Msk               (0x1ul << GPIO_PIN_PIN14_Pos)                     /*!< GPIO_T::PIN: PIN14 Mask                */

#define GPIO_PIN_PIN15_Pos               (15)                                              /*!< GPIO_T::PIN: PIN15 Position            */
#define GPIO_PIN_PIN15_Msk               (0x1ul << GPIO_PIN_PIN15_Pos)                     /*!< GPIO_T::PIN: PIN15 Mask                */

#define GPIO_DBEN_DBEN0_Pos              (0)                                               /*!< GPIO_T::DBEN: DBEN0 Position           */
#define GPIO_DBEN_DBEN0_Msk              (0x1ul << GPIO_DBEN_DBEN0_Pos)                    /*!< GPIO_T::DBEN: DBEN0 Mask               */

#define GPIO_DBEN_DBEN1_Pos              (1)                                               /*!< GPIO_T::DBEN: DBEN1 Position           */
#define GPIO_DBEN_DBEN1_Msk              (0x1ul << GPIO_DBEN_DBEN1_Pos)                    /*!< GPIO_T::DBEN: DBEN1 Mask               */

#define GPIO_DBEN_DBEN2_Pos              (2)                                               /*!< GPIO_T::DBEN: DBEN2 Position           */
#define GPIO_DBEN_DBEN2_Msk              (0x1ul << GPIO_DBEN_DBEN2_Pos)                    /*!< GPIO_T::DBEN: DBEN2 Mask               */

#define GPIO_DBEN_DBEN3_Pos              (3)                                               /*!< GPIO_T::DBEN: DBEN3 Position           */
#define GPIO_DBEN_DBEN3_Msk              (0x1ul << GPIO_DBEN_DBEN3_Pos)                    /*!< GPIO_T::DBEN: DBEN3 Mask               */

#define GPIO_DBEN_DBEN4_Pos              (4)                                               /*!< GPIO_T::DBEN: DBEN4 Position           */
#define GPIO_DBEN_DBEN4_Msk              (0x1ul << GPIO_DBEN_DBEN4_Pos)                    /*!< GPIO_T::DBEN: DBEN4 Mask               */

#define GPIO_DBEN_DBEN5_Pos              (5)                                               /*!< GPIO_T::DBEN: DBEN5 Position           */
#define GPIO_DBEN_DBEN5_Msk              (0x1ul << GPIO_DBEN_DBEN5_Pos)                    /*!< GPIO_T::DBEN: DBEN5 Mask               */

#define GPIO_DBEN_DBEN6_Pos              (6)                                               /*!< GPIO_T::DBEN: DBEN6 Position           */
#define GPIO_DBEN_DBEN6_Msk              (0x1ul << GPIO_DBEN_DBEN6_Pos)                    /*!< GPIO_T::DBEN: DBEN6 Mask               */

#define GPIO_DBEN_DBEN7_Pos              (7)                                               /*!< GPIO_T::DBEN: DBEN7 Position           */
#define GPIO_DBEN_DBEN7_Msk              (0x1ul << GPIO_DBEN_DBEN7_Pos)                    /*!< GPIO_T::DBEN: DBEN7 Mask               */

#define GPIO_DBEN_DBEN8_Pos              (8)                                               /*!< GPIO_T::DBEN: DBEN8 Position           */
#define GPIO_DBEN_DBEN8_Msk              (0x1ul << GPIO_DBEN_DBEN8_Pos)                    /*!< GPIO_T::DBEN: DBEN8 Mask               */

#define GPIO_DBEN_DBEN9_Pos              (9)                                               /*!< GPIO_T::DBEN: DBEN9 Position           */
#define GPIO_DBEN_DBEN9_Msk              (0x1ul << GPIO_DBEN_DBEN9_Pos)                    /*!< GPIO_T::DBEN: DBEN9 Mask               */

#define GPIO_DBEN_DBEN10_Pos             (10)                                              /*!< GPIO_T::DBEN: DBEN10 Position          */
#define GPIO_DBEN_DBEN10_Msk             (0x1ul << GPIO_DBEN_DBEN10_Pos)                   /*!< GPIO_T::DBEN: DBEN10 Mask              */

#define GPIO_DBEN_DBEN11_Pos             (11)                                              /*!< GPIO_T::DBEN: DBEN11 Position          */
#define GPIO_DBEN_DBEN11_Msk             (0x1ul << GPIO_DBEN_DBEN11_Pos)                   /*!< GPIO_T::DBEN: DBEN11 Mask              */

#define GPIO_DBEN_DBEN12_Pos             (12)                                              /*!< GPIO_T::DBEN: DBEN12 Position          */
#define GPIO_DBEN_DBEN12_Msk             (0x1ul << GPIO_DBEN_DBEN12_Pos)                   /*!< GPIO_T::DBEN: DBEN12 Mask              */

#define GPIO_DBEN_DBEN13_Pos             (13)                                              /*!< GPIO_T::DBEN: DBEN13 Position          */
#define GPIO_DBEN_DBEN13_Msk             (0x1ul << GPIO_DBEN_DBEN13_Pos)                   /*!< GPIO_T::DBEN: DBEN13 Mask              */

#define GPIO_DBEN_DBEN14_Pos             (14)                                              /*!< GPIO_T::DBEN: DBEN14 Position          */
#define GPIO_DBEN_DBEN14_Msk             (0x1ul << GPIO_DBEN_DBEN14_Pos)                   /*!< GPIO_T::DBEN: DBEN14 Mask              */

#define GPIO_DBEN_DBEN15_Pos             (15)                                              /*!< GPIO_T::DBEN: DBEN15 Position          */
#define GPIO_DBEN_DBEN15_Msk             (0x1ul << GPIO_DBEN_DBEN15_Pos)                   /*!< GPIO_T::DBEN: DBEN15 Mask              */

#define GPIO_INTTYPE_TYPE0_Pos           (0)                                               /*!< GPIO_T::INTTYPE: TYPE0 Position        */
#define GPIO_INTTYPE_TYPE0_Msk           (0x1ul << GPIO_INTTYPE_TYPE0_Pos)                 /*!< GPIO_T::INTTYPE: TYPE0 Mask            */

#define GPIO_INTTYPE_TYPE1_Pos           (1)                                               /*!< GPIO_T::INTTYPE: TYPE1 Position        */
#define GPIO_INTTYPE_TYPE1_Msk           (0x1ul << GPIO_INTTYPE_TYPE1_Pos)                 /*!< GPIO_T::INTTYPE: TYPE1 Mask            */

#define GPIO_INTTYPE_TYPE2_Pos           (2)                                               /*!< GPIO_T::INTTYPE: TYPE2 Position        */
#define GPIO_INTTYPE_TYPE2_Msk           (0x1ul << GPIO_INTTYPE_TYPE2_Pos)                 /*!< GPIO_T::INTTYPE: TYPE2 Mask            */

#define GPIO_INTTYPE_TYPE3_Pos           (3)                                               /*!< GPIO_T::INTTYPE: TYPE3 Position        */
#define GPIO_INTTYPE_TYPE3_Msk           (0x1ul << GPIO_INTTYPE_TYPE3_Pos)                 /*!< GPIO_T::INTTYPE: TYPE3 Mask            */

#define GPIO_INTTYPE_TYPE4_Pos           (4)                                               /*!< GPIO_T::INTTYPE: TYPE4 Position        */
#define GPIO_INTTYPE_TYPE4_Msk           (0x1ul << GPIO_INTTYPE_TYPE4_Pos)                 /*!< GPIO_T::INTTYPE: TYPE4 Mask            */

#define GPIO_INTTYPE_TYPE5_Pos           (5)                                               /*!< GPIO_T::INTTYPE: TYPE5 Position        */
#define GPIO_INTTYPE_TYPE5_Msk           (0x1ul << GPIO_INTTYPE_TYPE5_Pos)                 /*!< GPIO_T::INTTYPE: TYPE5 Mask            */

#define GPIO_INTTYPE_TYPE6_Pos           (6)                                               /*!< GPIO_T::INTTYPE: TYPE6 Position        */
#define GPIO_INTTYPE_TYPE6_Msk           (0x1ul << GPIO_INTTYPE_TYPE6_Pos)                 /*!< GPIO_T::INTTYPE: TYPE6 Mask            */

#define GPIO_INTTYPE_TYPE7_Pos           (7)                                               /*!< GPIO_T::INTTYPE: TYPE7 Position        */
#define GPIO_INTTYPE_TYPE7_Msk           (0x1ul << GPIO_INTTYPE_TYPE7_Pos)                 /*!< GPIO_T::INTTYPE: TYPE7 Mask            */

#define GPIO_INTTYPE_TYPE8_Pos           (8)                                               /*!< GPIO_T::INTTYPE: TYPE8 Position        */
#define GPIO_INTTYPE_TYPE8_Msk           (0x1ul << GPIO_INTTYPE_TYPE8_Pos)                 /*!< GPIO_T::INTTYPE: TYPE8 Mask            */

#define GPIO_INTTYPE_TYPE9_Pos           (9)                                               /*!< GPIO_T::INTTYPE: TYPE9 Position        */
#define GPIO_INTTYPE_TYPE9_Msk           (0x1ul << GPIO_INTTYPE_TYPE9_Pos)                 /*!< GPIO_T::INTTYPE: TYPE9 Mask            */

#define GPIO_INTTYPE_TYPE10_Pos          (10)                                              /*!< GPIO_T::INTTYPE: TYPE10 Position       */
#define GPIO_INTTYPE_TYPE10_Msk          (0x1ul << GPIO_INTTYPE_TYPE10_Pos)                /*!< GPIO_T::INTTYPE: TYPE10 Mask           */

#define GPIO_INTTYPE_TYPE11_Pos          (11)                                              /*!< GPIO_T::INTTYPE: TYPE11 Position       */
#define GPIO_INTTYPE_TYPE11_Msk          (0x1ul << GPIO_INTTYPE_TYPE11_Pos)                /*!< GPIO_T::INTTYPE: TYPE11 Mask           */

#define GPIO_INTTYPE_TYPE12_Pos          (12)                                              /*!< GPIO_T::INTTYPE: TYPE12 Position       */
#define GPIO_INTTYPE_TYPE12_Msk          (0x1ul << GPIO_INTTYPE_TYPE12_Pos)                /*!< GPIO_T::INTTYPE: TYPE12 Mask           */

#define GPIO_INTTYPE_TYPE13_Pos          (13)                                              /*!< GPIO_T::INTTYPE: TYPE13 Position       */
#define GPIO_INTTYPE_TYPE13_Msk          (0x1ul << GPIO_INTTYPE_TYPE13_Pos)                /*!< GPIO_T::INTTYPE: TYPE13 Mask           */

#define GPIO_INTTYPE_TYPE14_Pos          (14)                                              /*!< GPIO_T::INTTYPE: TYPE14 Position       */
#define GPIO_INTTYPE_TYPE14_Msk          (0x1ul << GPIO_INTTYPE_TYPE14_Pos)                /*!< GPIO_T::INTTYPE: TYPE14 Mask           */

#define GPIO_INTTYPE_TYPE15_Pos          (15)                                              /*!< GPIO_T::INTTYPE: TYPE15 Position       */
#define GPIO_INTTYPE_TYPE15_Msk          (0x1ul << GPIO_INTTYPE_TYPE15_Pos)                /*!< GPIO_T::INTTYPE: TYPE15 Mask           */

#define GPIO_INTEN_FLIEN0_Pos            (0)                                               /*!< GPIO_T::INTEN: FLIEN0 Position         */
#define GPIO_INTEN_FLIEN0_Msk            (0x1ul << GPIO_INTEN_FLIEN0_Pos)                  /*!< GPIO_T::INTEN: FLIEN0 Mask             */

#define GPIO_INTEN_FLIEN1_Pos            (1)                                               /*!< GPIO_T::INTEN: FLIEN1 Position         */
#define GPIO_INTEN_FLIEN1_Msk            (0x1ul << GPIO_INTEN_FLIEN1_Pos)                  /*!< GPIO_T::INTEN: FLIEN1 Mask             */

#define GPIO_INTEN_FLIEN2_Pos            (2)                                               /*!< GPIO_T::INTEN: FLIEN2 Position         */
#define GPIO_INTEN_FLIEN2_Msk            (0x1ul << GPIO_INTEN_FLIEN2_Pos)                  /*!< GPIO_T::INTEN: FLIEN2 Mask             */

#define GPIO_INTEN_FLIEN3_Pos            (3)                                               /*!< GPIO_T::INTEN: FLIEN3 Position         */
#define GPIO_INTEN_FLIEN3_Msk            (0x1ul << GPIO_INTEN_FLIEN3_Pos)                  /*!< GPIO_T::INTEN: FLIEN3 Mask             */

#define GPIO_INTEN_FLIEN4_Pos            (4)                                               /*!< GPIO_T::INTEN: FLIEN4 Position         */
#define GPIO_INTEN_FLIEN4_Msk            (0x1ul << GPIO_INTEN_FLIEN4_Pos)                  /*!< GPIO_T::INTEN: FLIEN4 Mask             */

#define GPIO_INTEN_FLIEN5_Pos            (5)                                               /*!< GPIO_T::INTEN: FLIEN5 Position         */
#define GPIO_INTEN_FLIEN5_Msk            (0x1ul << GPIO_INTEN_FLIEN5_Pos)                  /*!< GPIO_T::INTEN: FLIEN5 Mask             */

#define GPIO_INTEN_FLIEN6_Pos            (6)                                               /*!< GPIO_T::INTEN: FLIEN6 Position         */
#define GPIO_INTEN_FLIEN6_Msk            (0x1ul << GPIO_INTEN_FLIEN6_Pos)                  /*!< GPIO_T::INTEN: FLIEN6 Mask             */

#define GPIO_INTEN_FLIEN7_Pos            (7)                                               /*!< GPIO_T::INTEN: FLIEN7 Position         */
#define GPIO_INTEN_FLIEN7_Msk            (0x1ul << GPIO_INTEN_FLIEN7_Pos)                  /*!< GPIO_T::INTEN: FLIEN7 Mask             */

#define GPIO_INTEN_FLIEN8_Pos            (8)                                               /*!< GPIO_T::INTEN: FLIEN8 Position         */
#define GPIO_INTEN_FLIEN8_Msk            (0x1ul << GPIO_INTEN_FLIEN8_Pos)                  /*!< GPIO_T::INTEN: FLIEN8 Mask             */

#define GPIO_INTEN_FLIEN9_Pos            (9)                                               /*!< GPIO_T::INTEN: FLIEN9 Position         */
#define GPIO_INTEN_FLIEN9_Msk            (0x1ul << GPIO_INTEN_FLIEN9_Pos)                  /*!< GPIO_T::INTEN: FLIEN9 Mask             */

#define GPIO_INTEN_FLIEN10_Pos           (10)                                              /*!< GPIO_T::INTEN: FLIEN10 Position        */
#define GPIO_INTEN_FLIEN10_Msk           (0x1ul << GPIO_INTEN_FLIEN10_Pos)                 /*!< GPIO_T::INTEN: FLIEN10 Mask            */

#define GPIO_INTEN_FLIEN11_Pos           (11)                                              /*!< GPIO_T::INTEN: FLIEN11 Position        */
#define GPIO_INTEN_FLIEN11_Msk           (0x1ul << GPIO_INTEN_FLIEN11_Pos)                 /*!< GPIO_T::INTEN: FLIEN11 Mask            */

#define GPIO_INTEN_FLIEN12_Pos           (12)                                              /*!< GPIO_T::INTEN: FLIEN12 Position        */
#define GPIO_INTEN_FLIEN12_Msk           (0x1ul << GPIO_INTEN_FLIEN12_Pos)                 /*!< GPIO_T::INTEN: FLIEN12 Mask            */

#define GPIO_INTEN_FLIEN13_Pos           (13)                                              /*!< GPIO_T::INTEN: FLIEN13 Position        */
#define GPIO_INTEN_FLIEN13_Msk           (0x1ul << GPIO_INTEN_FLIEN13_Pos)                 /*!< GPIO_T::INTEN: FLIEN13 Mask            */

#define GPIO_INTEN_FLIEN14_Pos           (14)                                              /*!< GPIO_T::INTEN: FLIEN14 Position        */
#define GPIO_INTEN_FLIEN14_Msk           (0x1ul << GPIO_INTEN_FLIEN14_Pos)                 /*!< GPIO_T::INTEN: FLIEN14 Mask            */

#define GPIO_INTEN_FLIEN15_Pos           (15)                                              /*!< GPIO_T::INTEN: FLIEN15 Position        */
#define GPIO_INTEN_FLIEN15_Msk           (0x1ul << GPIO_INTEN_FLIEN15_Pos)                 /*!< GPIO_T::INTEN: FLIEN15 Mask            */

#define GPIO_INTEN_RHIEN0_Pos            (16)                                              /*!< GPIO_T::INTEN: RHIEN0 Position         */
#define GPIO_INTEN_RHIEN0_Msk            (0x1ul << GPIO_INTEN_RHIEN0_Pos)                  /*!< GPIO_T::INTEN: RHIEN0 Mask             */

#define GPIO_INTEN_RHIEN1_Pos            (17)                                              /*!< GPIO_T::INTEN: RHIEN1 Position         */
#define GPIO_INTEN_RHIEN1_Msk            (0x1ul << GPIO_INTEN_RHIEN1_Pos)                  /*!< GPIO_T::INTEN: RHIEN1 Mask             */

#define GPIO_INTEN_RHIEN2_Pos            (18)                                              /*!< GPIO_T::INTEN: RHIEN2 Position         */
#define GPIO_INTEN_RHIEN2_Msk            (0x1ul << GPIO_INTEN_RHIEN2_Pos)                  /*!< GPIO_T::INTEN: RHIEN2 Mask             */

#define GPIO_INTEN_RHIEN3_Pos            (19)                                              /*!< GPIO_T::INTEN: RHIEN3 Position         */
#define GPIO_INTEN_RHIEN3_Msk            (0x1ul << GPIO_INTEN_RHIEN3_Pos)                  /*!< GPIO_T::INTEN: RHIEN3 Mask             */

#define GPIO_INTEN_RHIEN4_Pos            (20)                                              /*!< GPIO_T::INTEN: RHIEN4 Position         */
#define GPIO_INTEN_RHIEN4_Msk            (0x1ul << GPIO_INTEN_RHIEN4_Pos)                  /*!< GPIO_T::INTEN: RHIEN4 Mask             */

#define GPIO_INTEN_RHIEN5_Pos            (21)                                              /*!< GPIO_T::INTEN: RHIEN5 Position         */
#define GPIO_INTEN_RHIEN5_Msk            (0x1ul << GPIO_INTEN_RHIEN5_Pos)                  /*!< GPIO_T::INTEN: RHIEN5 Mask             */

#define GPIO_INTEN_RHIEN6_Pos            (22)                                              /*!< GPIO_T::INTEN: RHIEN6 Position         */
#define GPIO_INTEN_RHIEN6_Msk            (0x1ul << GPIO_INTEN_RHIEN6_Pos)                  /*!< GPIO_T::INTEN: RHIEN6 Mask             */

#define GPIO_INTEN_RHIEN7_Pos            (23)                                              /*!< GPIO_T::INTEN: RHIEN7 Position         */
#define GPIO_INTEN_RHIEN7_Msk            (0x1ul << GPIO_INTEN_RHIEN7_Pos)                  /*!< GPIO_T::INTEN: RHIEN7 Mask             */

#define GPIO_INTEN_RHIEN8_Pos            (24)                                              /*!< GPIO_T::INTEN: RHIEN8 Position         */
#define GPIO_INTEN_RHIEN8_Msk            (0x1ul << GPIO_INTEN_RHIEN8_Pos)                  /*!< GPIO_T::INTEN: RHIEN8 Mask             */

#define GPIO_INTEN_RHIEN9_Pos            (25)                                              /*!< GPIO_T::INTEN: RHIEN9 Position         */
#define GPIO_INTEN_RHIEN9_Msk            (0x1ul << GPIO_INTEN_RHIEN9_Pos)                  /*!< GPIO_T::INTEN: RHIEN9 Mask             */

#define GPIO_INTEN_RHIEN10_Pos           (26)                                              /*!< GPIO_T::INTEN: RHIEN10 Position        */
#define GPIO_INTEN_RHIEN10_Msk           (0x1ul << GPIO_INTEN_RHIEN10_Pos)                 /*!< GPIO_T::INTEN: RHIEN10 Mask            */

#define GPIO_INTEN_RHIEN11_Pos           (27)                                              /*!< GPIO_T::INTEN: RHIEN11 Position        */
#define GPIO_INTEN_RHIEN11_Msk           (0x1ul << GPIO_INTEN_RHIEN11_Pos)                 /*!< GPIO_T::INTEN: RHIEN11 Mask            */

#define GPIO_INTEN_RHIEN12_Pos           (28)                                              /*!< GPIO_T::INTEN: RHIEN12 Position        */
#define GPIO_INTEN_RHIEN12_Msk           (0x1ul << GPIO_INTEN_RHIEN12_Pos)                 /*!< GPIO_T::INTEN: RHIEN12 Mask            */

#define GPIO_INTEN_RHIEN13_Pos           (29)                                              /*!< GPIO_T::INTEN: RHIEN13 Position        */
#define GPIO_INTEN_RHIEN13_Msk           (0x1ul << GPIO_INTEN_RHIEN13_Pos)                 /*!< GPIO_T::INTEN: RHIEN13 Mask            */

#define GPIO_INTEN_RHIEN14_Pos           (30)                                              /*!< GPIO_T::INTEN: RHIEN14 Position        */
#define GPIO_INTEN_RHIEN14_Msk           (0x1ul << GPIO_INTEN_RHIEN14_Pos)                 /*!< GPIO_T::INTEN: RHIEN14 Mask            */

#define GPIO_INTEN_RHIEN15_Pos           (31)                                              /*!< GPIO_T::INTEN: RHIEN15 Position        */
#define GPIO_INTEN_RHIEN15_Msk           (0x1ul << GPIO_INTEN_RHIEN15_Pos)                 /*!< GPIO_T::INTEN: RHIEN15 Mask            */

#define GPIO_INTSRC_INTSRC0_Pos          (0)                                               /*!< GPIO_T::INTSRC: INTSRC0 Position       */
#define GPIO_INTSRC_INTSRC0_Msk          (0x1ul << GPIO_INTSRC_INTSRC0_Pos)                /*!< GPIO_T::INTSRC: INTSRC0 Mask           */

#define GPIO_INTSRC_INTSRC1_Pos          (1)                                               /*!< GPIO_T::INTSRC: INTSRC1 Position       */
#define GPIO_INTSRC_INTSRC1_Msk          (0x1ul << GPIO_INTSRC_INTSRC1_Pos)                /*!< GPIO_T::INTSRC: INTSRC1 Mask           */

#define GPIO_INTSRC_INTSRC2_Pos          (2)                                               /*!< GPIO_T::INTSRC: INTSRC2 Position       */
#define GPIO_INTSRC_INTSRC2_Msk          (0x1ul << GPIO_INTSRC_INTSRC2_Pos)                /*!< GPIO_T::INTSRC: INTSRC2 Mask           */

#define GPIO_INTSRC_INTSRC3_Pos          (3)                                               /*!< GPIO_T::INTSRC: INTSRC3 Position       */
#define GPIO_INTSRC_INTSRC3_Msk          (0x1ul << GPIO_INTSRC_INTSRC3_Pos)                /*!< GPIO_T::INTSRC: INTSRC3 Mask           */

#define GPIO_INTSRC_INTSRC4_Pos          (4)                                               /*!< GPIO_T::INTSRC: INTSRC4 Position       */
#define GPIO_INTSRC_INTSRC4_Msk          (0x1ul << GPIO_INTSRC_INTSRC4_Pos)                /*!< GPIO_T::INTSRC: INTSRC4 Mask           */

#define GPIO_INTSRC_INTSRC5_Pos          (5)                                               /*!< GPIO_T::INTSRC: INTSRC5 Position       */
#define GPIO_INTSRC_INTSRC5_Msk          (0x1ul << GPIO_INTSRC_INTSRC5_Pos)                /*!< GPIO_T::INTSRC: INTSRC5 Mask           */

#define GPIO_INTSRC_INTSRC6_Pos          (6)                                               /*!< GPIO_T::INTSRC: INTSRC6 Position       */
#define GPIO_INTSRC_INTSRC6_Msk          (0x1ul << GPIO_INTSRC_INTSRC6_Pos)                /*!< GPIO_T::INTSRC: INTSRC6 Mask           */

#define GPIO_INTSRC_INTSRC7_Pos          (7)                                               /*!< GPIO_T::INTSRC: INTSRC7 Position       */
#define GPIO_INTSRC_INTSRC7_Msk          (0x1ul << GPIO_INTSRC_INTSRC7_Pos)                /*!< GPIO_T::INTSRC: INTSRC7 Mask           */

#define GPIO_INTSRC_INTSRC8_Pos          (8)                                               /*!< GPIO_T::INTSRC: INTSRC8 Position       */
#define GPIO_INTSRC_INTSRC8_Msk          (0x1ul << GPIO_INTSRC_INTSRC8_Pos)                /*!< GPIO_T::INTSRC: INTSRC8 Mask           */

#define GPIO_INTSRC_INTSRC9_Pos          (9)                                               /*!< GPIO_T::INTSRC: INTSRC9 Position       */
#define GPIO_INTSRC_INTSRC9_Msk          (0x1ul << GPIO_INTSRC_INTSRC9_Pos)                /*!< GPIO_T::INTSRC: INTSRC9 Mask           */

#define GPIO_INTSRC_INTSRC10_Pos         (10)                                              /*!< GPIO_T::INTSRC: INTSRC10 Position      */
#define GPIO_INTSRC_INTSRC10_Msk         (0x1ul << GPIO_INTSRC_INTSRC10_Pos)               /*!< GPIO_T::INTSRC: INTSRC10 Mask          */

#define GPIO_INTSRC_INTSRC11_Pos         (11)                                              /*!< GPIO_T::INTSRC: INTSRC11 Position      */
#define GPIO_INTSRC_INTSRC11_Msk         (0x1ul << GPIO_INTSRC_INTSRC11_Pos)               /*!< GPIO_T::INTSRC: INTSRC11 Mask          */

#define GPIO_INTSRC_INTSRC12_Pos         (12)                                              /*!< GPIO_T::INTSRC: INTSRC12 Position      */
#define GPIO_INTSRC_INTSRC12_Msk         (0x1ul << GPIO_INTSRC_INTSRC12_Pos)               /*!< GPIO_T::INTSRC: INTSRC12 Mask          */

#define GPIO_INTSRC_INTSRC13_Pos         (13)                                              /*!< GPIO_T::INTSRC: INTSRC13 Position      */
#define GPIO_INTSRC_INTSRC13_Msk         (0x1ul << GPIO_INTSRC_INTSRC13_Pos)               /*!< GPIO_T::INTSRC: INTSRC13 Mask          */

#define GPIO_INTSRC_INTSRC14_Pos         (14)                                              /*!< GPIO_T::INTSRC: INTSRC14 Position      */
#define GPIO_INTSRC_INTSRC14_Msk         (0x1ul << GPIO_INTSRC_INTSRC14_Pos)               /*!< GPIO_T::INTSRC: INTSRC14 Mask          */

#define GPIO_INTSRC_INTSRC15_Pos         (15)                                              /*!< GPIO_T::INTSRC: INTSRC15 Position      */
#define GPIO_INTSRC_INTSRC15_Msk         (0x1ul << GPIO_INTSRC_INTSRC15_Pos)               /*!< GPIO_T::INTSRC: INTSRC15 Mask          */

#define GPIO_SMTEN_SMTEN0_Pos            (0)                                               /*!< GPIO_T::SMTEN: SMTEN0 Position         */
#define GPIO_SMTEN_SMTEN0_Msk            (0x1ul << GPIO_SMTEN_SMTEN0_Pos)                  /*!< GPIO_T::SMTEN: SMTEN0 Mask             */

#define GPIO_SMTEN_SMTEN1_Pos            (1)                                               /*!< GPIO_T::SMTEN: SMTEN1 Position         */
#define GPIO_SMTEN_SMTEN1_Msk            (0x1ul << GPIO_SMTEN_SMTEN1_Pos)                  /*!< GPIO_T::SMTEN: SMTEN1 Mask             */

#define GPIO_SMTEN_SMTEN2_Pos            (2)                                               /*!< GPIO_T::SMTEN: SMTEN2 Position         */
#define GPIO_SMTEN_SMTEN2_Msk            (0x1ul << GPIO_SMTEN_SMTEN2_Pos)                  /*!< GPIO_T::SMTEN: SMTEN2 Mask             */

#define GPIO_SMTEN_SMTEN3_Pos            (3)                                               /*!< GPIO_T::SMTEN: SMTEN3 Position         */
#define GPIO_SMTEN_SMTEN3_Msk            (0x1ul << GPIO_SMTEN_SMTEN3_Pos)                  /*!< GPIO_T::SMTEN: SMTEN3 Mask             */

#define GPIO_SMTEN_SMTEN4_Pos            (4)                                               /*!< GPIO_T::SMTEN: SMTEN4 Position         */
#define GPIO_SMTEN_SMTEN4_Msk            (0x1ul << GPIO_SMTEN_SMTEN4_Pos)                  /*!< GPIO_T::SMTEN: SMTEN4 Mask             */

#define GPIO_SMTEN_SMTEN5_Pos            (5)                                               /*!< GPIO_T::SMTEN: SMTEN5 Position         */
#define GPIO_SMTEN_SMTEN5_Msk            (0x1ul << GPIO_SMTEN_SMTEN5_Pos)                  /*!< GPIO_T::SMTEN: SMTEN5 Mask             */

#define GPIO_SMTEN_SMTEN6_Pos            (6)                                               /*!< GPIO_T::SMTEN: SMTEN6 Position         */
#define GPIO_SMTEN_SMTEN6_Msk            (0x1ul << GPIO_SMTEN_SMTEN6_Pos)                  /*!< GPIO_T::SMTEN: SMTEN6 Mask             */

#define GPIO_SMTEN_SMTEN7_Pos            (7)                                               /*!< GPIO_T::SMTEN: SMTEN7 Position         */
#define GPIO_SMTEN_SMTEN7_Msk            (0x1ul << GPIO_SMTEN_SMTEN7_Pos)                  /*!< GPIO_T::SMTEN: SMTEN7 Mask             */

#define GPIO_SMTEN_SMTEN8_Pos            (8)                                               /*!< GPIO_T::SMTEN: SMTEN8 Position         */
#define GPIO_SMTEN_SMTEN8_Msk            (0x1ul << GPIO_SMTEN_SMTEN8_Pos)                  /*!< GPIO_T::SMTEN: SMTEN8 Mask             */

#define GPIO_SMTEN_SMTEN9_Pos            (9)                                               /*!< GPIO_T::SMTEN: SMTEN9 Position         */
#define GPIO_SMTEN_SMTEN9_Msk            (0x1ul << GPIO_SMTEN_SMTEN9_Pos)                  /*!< GPIO_T::SMTEN: SMTEN9 Mask             */

#define GPIO_SMTEN_SMTEN10_Pos           (10)                                              /*!< GPIO_T::SMTEN: SMTEN10 Position        */
#define GPIO_SMTEN_SMTEN10_Msk           (0x1ul << GPIO_SMTEN_SMTEN10_Pos)                 /*!< GPIO_T::SMTEN: SMTEN10 Mask            */

#define GPIO_SMTEN_SMTEN11_Pos           (11)                                              /*!< GPIO_T::SMTEN: SMTEN11 Position        */
#define GPIO_SMTEN_SMTEN11_Msk           (0x1ul << GPIO_SMTEN_SMTEN11_Pos)                 /*!< GPIO_T::SMTEN: SMTEN11 Mask            */

#define GPIO_SMTEN_SMTEN12_Pos           (12)                                              /*!< GPIO_T::SMTEN: SMTEN12 Position        */
#define GPIO_SMTEN_SMTEN12_Msk           (0x1ul << GPIO_SMTEN_SMTEN12_Pos)                 /*!< GPIO_T::SMTEN: SMTEN12 Mask            */

#define GPIO_SMTEN_SMTEN13_Pos           (13)                                              /*!< GPIO_T::SMTEN: SMTEN13 Position        */
#define GPIO_SMTEN_SMTEN13_Msk           (0x1ul << GPIO_SMTEN_SMTEN13_Pos)                 /*!< GPIO_T::SMTEN: SMTEN13 Mask            */

#define GPIO_SMTEN_SMTEN14_Pos           (14)                                              /*!< GPIO_T::SMTEN: SMTEN14 Position        */
#define GPIO_SMTEN_SMTEN14_Msk           (0x1ul << GPIO_SMTEN_SMTEN14_Pos)                 /*!< GPIO_T::SMTEN: SMTEN14 Mask            */

#define GPIO_SMTEN_SMTEN15_Pos           (15)                                              /*!< GPIO_T::SMTEN: SMTEN15 Position        */
#define GPIO_SMTEN_SMTEN15_Msk           (0x1ul << GPIO_SMTEN_SMTEN15_Pos)                 /*!< GPIO_T::SMTEN: SMTEN15 Mask            */

#define GPIO_SLEWCTL_HSREN0_Pos          (0)                                               /*!< GPIO_T::SLEWCTL: HSREN0 Position       */
#define GPIO_SLEWCTL_HSREN0_Msk          (0x3ul << GPIO_SLEWCTL_HSREN0_Pos)                /*!< GPIO_T::SLEWCTL: HSREN0 Mask           */

#define GPIO_SLEWCTL_HSREN1_Pos          (2)                                               /*!< GPIO_T::SLEWCTL: HSREN1 Position       */
#define GPIO_SLEWCTL_HSREN1_Msk          (0x3ul << GPIO_SLEWCTL_HSREN1_Pos)                /*!< GPIO_T::SLEWCTL: HSREN1 Mask           */

#define GPIO_SLEWCTL_HSREN2_Pos          (4)                                               /*!< GPIO_T::SLEWCTL: HSREN2 Position       */
#define GPIO_SLEWCTL_HSREN2_Msk          (0x3ul << GPIO_SLEWCTL_HSREN2_Pos)                /*!< GPIO_T::SLEWCTL: HSREN2 Mask           */

#define GPIO_SLEWCTL_HSREN3_Pos          (6)                                               /*!< GPIO_T::SLEWCTL: HSREN3 Position       */
#define GPIO_SLEWCTL_HSREN3_Msk          (0x3ul << GPIO_SLEWCTL_HSREN3_Pos)                /*!< GPIO_T::SLEWCTL: HSREN3 Mask           */

#define GPIO_SLEWCTL_HSREN4_Pos          (8)                                               /*!< GPIO_T::SLEWCTL: HSREN4 Position       */
#define GPIO_SLEWCTL_HSREN4_Msk          (0x3ul << GPIO_SLEWCTL_HSREN4_Pos)                /*!< GPIO_T::SLEWCTL: HSREN4 Mask           */

#define GPIO_SLEWCTL_HSREN5_Pos          (10)                                              /*!< GPIO_T::SLEWCTL: HSREN5 Position       */
#define GPIO_SLEWCTL_HSREN5_Msk          (0x3ul << GPIO_SLEWCTL_HSREN5_Pos)                /*!< GPIO_T::SLEWCTL: HSREN5 Mask           */

#define GPIO_SLEWCTL_HSREN6_Pos          (12)                                              /*!< GPIO_T::SLEWCTL: HSREN6 Position       */
#define GPIO_SLEWCTL_HSREN6_Msk          (0x3ul << GPIO_SLEWCTL_HSREN6_Pos)                /*!< GPIO_T::SLEWCTL: HSREN6 Mask           */

#define GPIO_SLEWCTL_HSREN7_Pos          (14)                                              /*!< GPIO_T::SLEWCTL: HSREN7 Position       */
#define GPIO_SLEWCTL_HSREN7_Msk          (0x3ul << GPIO_SLEWCTL_HSREN7_Pos)                /*!< GPIO_T::SLEWCTL: HSREN7 Mask           */

#define GPIO_SLEWCTL_HSREN8_Pos          (16)                                              /*!< GPIO_T::SLEWCTL: HSREN8 Position       */
#define GPIO_SLEWCTL_HSREN8_Msk          (0x3ul << GPIO_SLEWCTL_HSREN8_Pos)                /*!< GPIO_T::SLEWCTL: HSREN8 Mask           */

#define GPIO_SLEWCTL_HSREN9_Pos          (18)                                              /*!< GPIO_T::SLEWCTL: HSREN9 Position       */
#define GPIO_SLEWCTL_HSREN9_Msk          (0x3ul << GPIO_SLEWCTL_HSREN9_Pos)                /*!< GPIO_T::SLEWCTL: HSREN9 Mask           */

#define GPIO_SLEWCTL_HSREN10_Pos         (20)                                              /*!< GPIO_T::SLEWCTL: HSREN10 Position      */
#define GPIO_SLEWCTL_HSREN10_Msk         (0x3ul << GPIO_SLEWCTL_HSREN10_Pos)               /*!< GPIO_T::SLEWCTL: HSREN10 Mask          */

#define GPIO_SLEWCTL_HSREN11_Pos         (22)                                              /*!< GPIO_T::SLEWCTL: HSREN11 Position      */
#define GPIO_SLEWCTL_HSREN11_Msk         (0x3ul << GPIO_SLEWCTL_HSREN11_Pos)               /*!< GPIO_T::SLEWCTL: HSREN11 Mask          */

#define GPIO_SLEWCTL_HSREN12_Pos         (24)                                              /*!< GPIO_T::SLEWCTL: HSREN12 Position      */
#define GPIO_SLEWCTL_HSREN12_Msk         (0x3ul << GPIO_SLEWCTL_HSREN12_Pos)               /*!< GPIO_T::SLEWCTL: HSREN12 Mask          */

#define GPIO_SLEWCTL_HSREN13_Pos         (26)                                              /*!< GPIO_T::SLEWCTL: HSREN13 Position      */
#define GPIO_SLEWCTL_HSREN13_Msk         (0x3ul << GPIO_SLEWCTL_HSREN13_Pos)               /*!< GPIO_T::SLEWCTL: HSREN13 Mask          */

#define GPIO_SLEWCTL_HSREN14_Pos         (28)                                              /*!< GPIO_T::SLEWCTL: HSREN14 Position      */
#define GPIO_SLEWCTL_HSREN14_Msk         (0x3ul << GPIO_SLEWCTL_HSREN14_Pos)               /*!< GPIO_T::SLEWCTL: HSREN14 Mask          */

#define GPIO_SLEWCTL_HSREN15_Pos         (30)                                              /*!< GPIO_T::SLEWCTL: HSREN15 Position      */
#define GPIO_SLEWCTL_HSREN15_Msk         (0x3ul << GPIO_SLEWCTL_HSREN15_Pos)               /*!< GPIO_T::SLEWCTL: HSREN15 Mask          */

#define GPIO_PUSEL_PUSEL0_Pos            (0)                                               /*!< GPIO_T::PUSEL: PUSEL0 Position         */
#define GPIO_PUSEL_PUSEL0_Msk            (0x3ul << GPIO_PUSEL_PUSEL0_Pos)                  /*!< GPIO_T::PUSEL: PUSEL0 Mask             */

#define GPIO_PUSEL_PUSEL1_Pos            (2)                                               /*!< GPIO_T::PUSEL: PUSEL1 Position         */
#define GPIO_PUSEL_PUSEL1_Msk            (0x3ul << GPIO_PUSEL_PUSEL1_Pos)                  /*!< GPIO_T::PUSEL: PUSEL1 Mask             */

#define GPIO_PUSEL_PUSEL2_Pos            (4)                                               /*!< GPIO_T::PUSEL: PUSEL2 Position         */
#define GPIO_PUSEL_PUSEL2_Msk            (0x3ul << GPIO_PUSEL_PUSEL2_Pos)                  /*!< GPIO_T::PUSEL: PUSEL2 Mask             */

#define GPIO_PUSEL_PUSEL3_Pos            (6)                                               /*!< GPIO_T::PUSEL: PUSEL3 Position         */
#define GPIO_PUSEL_PUSEL3_Msk            (0x3ul << GPIO_PUSEL_PUSEL3_Pos)                  /*!< GPIO_T::PUSEL: PUSEL3 Mask             */

#define GPIO_PUSEL_PUSEL4_Pos            (8)                                               /*!< GPIO_T::PUSEL: PUSEL4 Position         */
#define GPIO_PUSEL_PUSEL4_Msk            (0x3ul << GPIO_PUSEL_PUSEL4_Pos)                  /*!< GPIO_T::PUSEL: PUSEL4 Mask             */

#define GPIO_PUSEL_PUSEL5_Pos            (10)                                              /*!< GPIO_T::PUSEL: PUSEL5 Position         */
#define GPIO_PUSEL_PUSEL5_Msk            (0x3ul << GPIO_PUSEL_PUSEL5_Pos)                  /*!< GPIO_T::PUSEL: PUSEL5 Mask             */

#define GPIO_PUSEL_PUSEL6_Pos            (12)                                              /*!< GPIO_T::PUSEL: PUSEL6 Position         */
#define GPIO_PUSEL_PUSEL6_Msk            (0x3ul << GPIO_PUSEL_PUSEL6_Pos)                  /*!< GPIO_T::PUSEL: PUSEL6 Mask             */

#define GPIO_PUSEL_PUSEL7_Pos            (14)                                              /*!< GPIO_T::PUSEL: PUSEL7 Position         */
#define GPIO_PUSEL_PUSEL7_Msk            (0x3ul << GPIO_PUSEL_PUSEL7_Pos)                  /*!< GPIO_T::PUSEL: PUSEL7 Mask             */

#define GPIO_PUSEL_PUSEL8_Pos            (16)                                              /*!< GPIO_T::PUSEL: PUSEL8 Position         */
#define GPIO_PUSEL_PUSEL8_Msk            (0x3ul << GPIO_PUSEL_PUSEL8_Pos)                  /*!< GPIO_T::PUSEL: PUSEL8 Mask             */

#define GPIO_PUSEL_PUSEL9_Pos            (18)                                              /*!< GPIO_T::PUSEL: PUSEL9 Position         */
#define GPIO_PUSEL_PUSEL9_Msk            (0x3ul << GPIO_PUSEL_PUSEL9_Pos)                  /*!< GPIO_T::PUSEL: PUSEL9 Mask             */

#define GPIO_PUSEL_PUSEL10_Pos           (20)                                              /*!< GPIO_T::PUSEL: PUSEL10 Position        */
#define GPIO_PUSEL_PUSEL10_Msk           (0x3ul << GPIO_PUSEL_PUSEL10_Pos)                 /*!< GPIO_T::PUSEL: PUSEL10 Mask            */

#define GPIO_PUSEL_PUSEL11_Pos           (22)                                              /*!< GPIO_T::PUSEL: PUSEL11 Position        */
#define GPIO_PUSEL_PUSEL11_Msk           (0x3ul << GPIO_PUSEL_PUSEL11_Pos)                 /*!< GPIO_T::PUSEL: PUSEL11 Mask            */

#define GPIO_PUSEL_PUSEL12_Pos           (24)                                              /*!< GPIO_T::PUSEL: PUSEL12 Position        */
#define GPIO_PUSEL_PUSEL12_Msk           (0x3ul << GPIO_PUSEL_PUSEL12_Pos)                 /*!< GPIO_T::PUSEL: PUSEL12 Mask            */

#define GPIO_PUSEL_PUSEL13_Pos           (26)                                              /*!< GPIO_T::PUSEL: PUSEL13 Position        */
#define GPIO_PUSEL_PUSEL13_Msk           (0x3ul << GPIO_PUSEL_PUSEL13_Pos)                 /*!< GPIO_T::PUSEL: PUSEL13 Mask            */

#define GPIO_PUSEL_PUSEL14_Pos           (28)                                              /*!< GPIO_T::PUSEL: PUSEL14 Position        */
#define GPIO_PUSEL_PUSEL14_Msk           (0x3ul << GPIO_PUSEL_PUSEL14_Pos)                 /*!< GPIO_T::PUSEL: PUSEL14 Mask            */

#define GPIO_PUSEL_PUSEL15_Pos           (30)                                              /*!< GPIO_T::PUSEL: PUSEL15 Position        */
#define GPIO_PUSEL_PUSEL15_Msk           (0x3ul << GPIO_PUSEL_PUSEL15_Pos)                 /*!< GPIO_T::PUSEL: PUSEL15 Mask            */

#define GPIO_MODE_MODE0_Pos              (0)                                               /*!< GPIO_T::MODE: MODE0 Position           */
#define GPIO_MODE_MODE0_Msk              (0x3ul << GPIO_MODE_MODE0_Pos)                    /*!< GPIO_T::MODE: MODE0 Mask               */

#define GPIO_MODE_MODE1_Pos              (2)                                               /*!< GPIO_T::MODE: MODE1 Position           */
#define GPIO_MODE_MODE1_Msk              (0x3ul << GPIO_MODE_MODE1_Pos)                    /*!< GPIO_T::MODE: MODE1 Mask               */

#define GPIO_MODE_MODE2_Pos              (4)                                               /*!< GPIO_T::MODE: MODE2 Position           */
#define GPIO_MODE_MODE2_Msk              (0x3ul << GPIO_MODE_MODE2_Pos)                    /*!< GPIO_T::MODE: MODE2 Mask               */

#define GPIO_MODE_MODE3_Pos              (6)                                               /*!< GPIO_T::MODE: MODE3 Position           */
#define GPIO_MODE_MODE3_Msk              (0x3ul << GPIO_MODE_MODE3_Pos)                    /*!< GPIO_T::MODE: MODE3 Mask               */

#define GPIO_MODE_MODE4_Pos              (8)                                               /*!< GPIO_T::MODE: MODE4 Position           */
#define GPIO_MODE_MODE4_Msk              (0x3ul << GPIO_MODE_MODE4_Pos)                    /*!< GPIO_T::MODE: MODE4 Mask               */

#define GPIO_MODE_MODE5_Pos              (10)                                              /*!< GPIO_T::MODE: MODE5 Position           */
#define GPIO_MODE_MODE5_Msk              (0x3ul << GPIO_MODE_MODE5_Pos)                    /*!< GPIO_T::MODE: MODE5 Mask               */

#define GPIO_MODE_MODE6_Pos              (12)                                              /*!< GPIO_T::MODE: MODE6 Position           */
#define GPIO_MODE_MODE6_Msk              (0x3ul << GPIO_MODE_MODE6_Pos)                    /*!< GPIO_T::MODE: MODE6 Mask               */

#define GPIO_MODE_MODE7_Pos              (14)                                              /*!< GPIO_T::MODE: MODE7 Position           */
#define GPIO_MODE_MODE7_Msk              (0x3ul << GPIO_MODE_MODE7_Pos)                    /*!< GPIO_T::MODE: MODE7 Mask               */

#define GPIO_MODE_MODE8_Pos              (16)                                              /*!< GPIO_T::MODE: MODE8 Position           */
#define GPIO_MODE_MODE8_Msk              (0x3ul << GPIO_MODE_MODE8_Pos)                    /*!< GPIO_T::MODE: MODE8 Mask               */

#define GPIO_MODE_MODE9_Pos              (18)                                              /*!< GPIO_T::MODE: MODE9 Position           */
#define GPIO_MODE_MODE9_Msk              (0x3ul << GPIO_MODE_MODE9_Pos)                    /*!< GPIO_T::MODE: MODE9 Mask               */

#define GPIO_MODE_MODE10_Pos             (20)                                              /*!< GPIO_T::MODE: MODE10 Position          */
#define GPIO_MODE_MODE10_Msk             (0x3ul << GPIO_MODE_MODE10_Pos)                   /*!< GPIO_T::MODE: MODE10 Mask              */

#define GPIO_MODE_MODE11_Pos             (22)                                              /*!< GPIO_T::MODE: MODE11 Position          */
#define GPIO_MODE_MODE11_Msk             (0x3ul << GPIO_MODE_MODE11_Pos)                   /*!< GPIO_T::MODE: MODE11 Mask              */

#define GPIO_MODE_MODE12_Pos             (24)                                              /*!< GPIO_T::MODE: MODE12 Position          */
#define GPIO_MODE_MODE12_Msk             (0x3ul << GPIO_MODE_MODE12_Pos)                   /*!< GPIO_T::MODE: MODE12 Mask              */

#define GPIO_MODE_MODE13_Pos             (26)                                              /*!< GPIO_T::MODE: MODE13 Position          */
#define GPIO_MODE_MODE13_Msk             (0x3ul << GPIO_MODE_MODE13_Pos)                   /*!< GPIO_T::MODE: MODE13 Mask              */

#define GPIO_MODE_MODE14_Pos             (28)                                              /*!< GPIO_T::MODE: MODE14 Position          */
#define GPIO_MODE_MODE14_Msk             (0x3ul << GPIO_MODE_MODE14_Pos)                   /*!< GPIO_T::MODE: MODE14 Mask              */

#define GPIO_MODE_MODE15_Pos             (30)                                              /*!< GPIO_T::MODE: MODE15 Position          */
#define GPIO_MODE_MODE15_Msk             (0x3ul << GPIO_MODE_MODE15_Pos)                   /*!< GPIO_T::MODE: MODE15 Mask              */

#define GPIO_DINOFF_DINOFF0_Pos          (16)                                              /*!< GPIO_T::DINOFF: DINOFF0 Position       */
#define GPIO_DINOFF_DINOFF0_Msk          (0x1ul << GPIO_DINOFF_DINOFF0_Pos)                /*!< GPIO_T::DINOFF: DINOFF0 Mask           */

#define GPIO_DINOFF_DINOFF1_Pos          (17)                                              /*!< GPIO_T::DINOFF: DINOFF1 Position       */
#define GPIO_DINOFF_DINOFF1_Msk          (0x1ul << GPIO_DINOFF_DINOFF1_Pos)                /*!< GPIO_T::DINOFF: DINOFF1 Mask           */

#define GPIO_DINOFF_DINOFF2_Pos          (18)                                              /*!< GPIO_T::DINOFF: DINOFF2 Position       */
#define GPIO_DINOFF_DINOFF2_Msk          (0x1ul << GPIO_DINOFF_DINOFF2_Pos)                /*!< GPIO_T::DINOFF: DINOFF2 Mask           */

#define GPIO_DINOFF_DINOFF3_Pos          (19)                                              /*!< GPIO_T::DINOFF: DINOFF3 Position       */
#define GPIO_DINOFF_DINOFF3_Msk          (0x1ul << GPIO_DINOFF_DINOFF3_Pos)                /*!< GPIO_T::DINOFF: DINOFF3 Mask           */

#define GPIO_DINOFF_DINOFF4_Pos          (20)                                              /*!< GPIO_T::DINOFF: DINOFF4 Position       */
#define GPIO_DINOFF_DINOFF4_Msk          (0x1ul << GPIO_DINOFF_DINOFF4_Pos)                /*!< GPIO_T::DINOFF: DINOFF4 Mask           */

#define GPIO_DINOFF_DINOFF5_Pos          (21)                                              /*!< GPIO_T::DINOFF: DINOFF5 Position       */
#define GPIO_DINOFF_DINOFF5_Msk          (0x1ul << GPIO_DINOFF_DINOFF5_Pos)                /*!< GPIO_T::DINOFF: DINOFF5 Mask           */

#define GPIO_DINOFF_DINOFF6_Pos          (22)                                              /*!< GPIO_T::DINOFF: DINOFF6 Position       */
#define GPIO_DINOFF_DINOFF6_Msk          (0x1ul << GPIO_DINOFF_DINOFF6_Pos)                /*!< GPIO_T::DINOFF: DINOFF6 Mask           */

#define GPIO_DINOFF_DINOFF7_Pos          (23)                                              /*!< GPIO_T::DINOFF: DINOFF7 Position       */
#define GPIO_DINOFF_DINOFF7_Msk          (0x1ul << GPIO_DINOFF_DINOFF7_Pos)                /*!< GPIO_T::DINOFF: DINOFF7 Mask           */

#define GPIO_DINOFF_DINOFF8_Pos          (24)                                              /*!< GPIO_T::DINOFF: DINOFF8 Position       */
#define GPIO_DINOFF_DINOFF8_Msk          (0x1ul << GPIO_DINOFF_DINOFF8_Pos)                /*!< GPIO_T::DINOFF: DINOFF8 Mask           */

#define GPIO_DINOFF_DINOFF9_Pos          (25)                                              /*!< GPIO_T::DINOFF: DINOFF9 Position       */
#define GPIO_DINOFF_DINOFF9_Msk          (0x1ul << GPIO_DINOFF_DINOFF9_Pos)                /*!< GPIO_T::DINOFF: DINOFF9 Mask           */

#define GPIO_DINOFF_DINOFF10_Pos         (26)                                              /*!< GPIO_T::DINOFF: DINOFF10 Position      */
#define GPIO_DINOFF_DINOFF10_Msk         (0x1ul << GPIO_DINOFF_DINOFF10_Pos)               /*!< GPIO_T::DINOFF: DINOFF10 Mask          */

#define GPIO_DINOFF_DINOFF11_Pos         (27)                                              /*!< GPIO_T::DINOFF: DINOFF11 Position      */
#define GPIO_DINOFF_DINOFF11_Msk         (0x1ul << GPIO_DINOFF_DINOFF11_Pos)               /*!< GPIO_T::DINOFF: DINOFF11 Mask          */

#define GPIO_DINOFF_DINOFF12_Pos         (28)                                              /*!< GPIO_T::DINOFF: DINOFF12 Position      */
#define GPIO_DINOFF_DINOFF12_Msk         (0x1ul << GPIO_DINOFF_DINOFF12_Pos)               /*!< GPIO_T::DINOFF: DINOFF12 Mask          */

#define GPIO_DINOFF_DINOFF13_Pos         (29)                                              /*!< GPIO_T::DINOFF: DINOFF13 Position      */
#define GPIO_DINOFF_DINOFF13_Msk         (0x1ul << GPIO_DINOFF_DINOFF13_Pos)               /*!< GPIO_T::DINOFF: DINOFF13 Mask          */

#define GPIO_DINOFF_DINOFF14_Pos         (30)                                              /*!< GPIO_T::DINOFF: DINOFF14 Position      */
#define GPIO_DINOFF_DINOFF14_Msk         (0x1ul << GPIO_DINOFF_DINOFF14_Pos)               /*!< GPIO_T::DINOFF: DINOFF14 Mask          */

#define GPIO_DINOFF_DINOFF15_Pos         (31)                                              /*!< GPIO_T::DINOFF: DINOFF15 Position      */
#define GPIO_DINOFF_DINOFF15_Msk         (0x1ul << GPIO_DINOFF_DINOFF15_Pos)               /*!< GPIO_T::DINOFF: DINOFF15 Mask          */

#define GPIO_DOUT_DOUT0_Pos              (0)                                               /*!< GPIO_T::DOUT: DOUT0 Position           */
#define GPIO_DOUT_DOUT0_Msk              (0x1ul << GPIO_DOUT_DOUT0_Pos)                    /*!< GPIO_T::DOUT: DOUT0 Mask               */

#define GPIO_DOUT_DOUT1_Pos              (1)                                               /*!< GPIO_T::DOUT: DOUT1 Position           */
#define GPIO_DOUT_DOUT1_Msk              (0x1ul << GPIO_DOUT_DOUT1_Pos)                    /*!< GPIO_T::DOUT: DOUT1 Mask               */

#define GPIO_DOUT_DOUT2_Pos              (2)                                               /*!< GPIO_T::DOUT: DOUT2 Position           */
#define GPIO_DOUT_DOUT2_Msk              (0x1ul << GPIO_DOUT_DOUT2_Pos)                    /*!< GPIO_T::DOUT: DOUT2 Mask               */

#define GPIO_DOUT_DOUT3_Pos              (3)                                               /*!< GPIO_T::DOUT: DOUT3 Position           */
#define GPIO_DOUT_DOUT3_Msk              (0x1ul << GPIO_DOUT_DOUT3_Pos)                    /*!< GPIO_T::DOUT: DOUT3 Mask               */

#define GPIO_DOUT_DOUT4_Pos              (4)                                               /*!< GPIO_T::DOUT: DOUT4 Position           */
#define GPIO_DOUT_DOUT4_Msk              (0x1ul << GPIO_DOUT_DOUT4_Pos)                    /*!< GPIO_T::DOUT: DOUT4 Mask               */

#define GPIO_DOUT_DOUT5_Pos              (5)                                               /*!< GPIO_T::DOUT: DOUT5 Position           */
#define GPIO_DOUT_DOUT5_Msk              (0x1ul << GPIO_DOUT_DOUT5_Pos)                    /*!< GPIO_T::DOUT: DOUT5 Mask               */

#define GPIO_DOUT_DOUT6_Pos              (6)                                               /*!< GPIO_T::DOUT: DOUT6 Position           */
#define GPIO_DOUT_DOUT6_Msk              (0x1ul << GPIO_DOUT_DOUT6_Pos)                    /*!< GPIO_T::DOUT: DOUT6 Mask               */

#define GPIO_DOUT_DOUT7_Pos              (7)                                               /*!< GPIO_T::DOUT: DOUT7 Position           */
#define GPIO_DOUT_DOUT7_Msk              (0x1ul << GPIO_DOUT_DOUT7_Pos)                    /*!< GPIO_T::DOUT: DOUT7 Mask               */

#define GPIO_DOUT_DOUT8_Pos              (8)                                               /*!< GPIO_T::DOUT: DOUT8 Position           */
#define GPIO_DOUT_DOUT8_Msk              (0x1ul << GPIO_DOUT_DOUT8_Pos)                    /*!< GPIO_T::DOUT: DOUT8 Mask               */

#define GPIO_DOUT_DOUT9_Pos              (9)                                               /*!< GPIO_T::DOUT: DOUT9 Position           */
#define GPIO_DOUT_DOUT9_Msk              (0x1ul << GPIO_DOUT_DOUT9_Pos)                    /*!< GPIO_T::DOUT: DOUT9 Mask               */

#define GPIO_DOUT_DOUT10_Pos             (10)                                              /*!< GPIO_T::DOUT: DOUT10 Position          */
#define GPIO_DOUT_DOUT10_Msk             (0x1ul << GPIO_DOUT_DOUT10_Pos)                   /*!< GPIO_T::DOUT: DOUT10 Mask              */

#define GPIO_DOUT_DOUT11_Pos             (11)                                              /*!< GPIO_T::DOUT: DOUT11 Position          */
#define GPIO_DOUT_DOUT11_Msk             (0x1ul << GPIO_DOUT_DOUT11_Pos)                   /*!< GPIO_T::DOUT: DOUT11 Mask              */

#define GPIO_DOUT_DOUT12_Pos             (12)                                              /*!< GPIO_T::DOUT: DOUT12 Position          */
#define GPIO_DOUT_DOUT12_Msk             (0x1ul << GPIO_DOUT_DOUT12_Pos)                   /*!< GPIO_T::DOUT: DOUT12 Mask              */

#define GPIO_DOUT_DOUT13_Pos             (13)                                              /*!< GPIO_T::DOUT: DOUT13 Position          */
#define GPIO_DOUT_DOUT13_Msk             (0x1ul << GPIO_DOUT_DOUT13_Pos)                   /*!< GPIO_T::DOUT: DOUT13 Mask              */

#define GPIO_DOUT_DOUT14_Pos             (14)                                              /*!< GPIO_T::DOUT: DOUT14 Position          */
#define GPIO_DOUT_DOUT14_Msk             (0x1ul << GPIO_DOUT_DOUT14_Pos)                   /*!< GPIO_T::DOUT: DOUT14 Mask              */

#define GPIO_DOUT_DOUT15_Pos             (15)                                              /*!< GPIO_T::DOUT: DOUT15 Position          */
#define GPIO_DOUT_DOUT15_Msk             (0x1ul << GPIO_DOUT_DOUT15_Pos)                   /*!< GPIO_T::DOUT: DOUT15 Mask              */

#define GPIO_DATMSK_DATMSK0_Pos          (0)                                               /*!< GPIO_T::DATMSK: DATMSK0 Position       */
#define GPIO_DATMSK_DATMSK0_Msk          (0x1ul << GPIO_DATMSK_DATMSK0_Pos)                /*!< GPIO_T::DATMSK: DATMSK0 Mask           */

#define GPIO_DATMSK_DATMSK1_Pos          (1)                                               /*!< GPIO_T::DATMSK: DATMSK1 Position       */
#define GPIO_DATMSK_DATMSK1_Msk          (0x1ul << GPIO_DATMSK_DATMSK1_Pos)                /*!< GPIO_T::DATMSK: DATMSK1 Mask           */

#define GPIO_DATMSK_DATMSK2_Pos          (2)                                               /*!< GPIO_T::DATMSK: DATMSK2 Position       */
#define GPIO_DATMSK_DATMSK2_Msk          (0x1ul << GPIO_DATMSK_DATMSK2_Pos)                /*!< GPIO_T::DATMSK: DATMSK2 Mask           */

#define GPIO_DATMSK_DATMSK3_Pos          (3)                                               /*!< GPIO_T::DATMSK: DATMSK3 Position       */
#define GPIO_DATMSK_DATMSK3_Msk          (0x1ul << GPIO_DATMSK_DATMSK3_Pos)                /*!< GPIO_T::DATMSK: DATMSK3 Mask           */

#define GPIO_DATMSK_DATMSK4_Pos          (4)                                               /*!< GPIO_T::DATMSK: DATMSK4 Position       */
#define GPIO_DATMSK_DATMSK4_Msk          (0x1ul << GPIO_DATMSK_DATMSK4_Pos)                /*!< GPIO_T::DATMSK: DATMSK4 Mask           */

#define GPIO_DATMSK_DATMSK5_Pos          (5)                                               /*!< GPIO_T::DATMSK: DATMSK5 Position       */
#define GPIO_DATMSK_DATMSK5_Msk          (0x1ul << GPIO_DATMSK_DATMSK5_Pos)                /*!< GPIO_T::DATMSK: DATMSK5 Mask           */

#define GPIO_DATMSK_DATMSK6_Pos          (6)                                               /*!< GPIO_T::DATMSK: DATMSK6 Position       */
#define GPIO_DATMSK_DATMSK6_Msk          (0x1ul << GPIO_DATMSK_DATMSK6_Pos)                /*!< GPIO_T::DATMSK: DATMSK6 Mask           */

#define GPIO_DATMSK_DATMSK7_Pos          (7)                                               /*!< GPIO_T::DATMSK: DATMSK7 Position       */
#define GPIO_DATMSK_DATMSK7_Msk          (0x1ul << GPIO_DATMSK_DATMSK7_Pos)                /*!< GPIO_T::DATMSK: DATMSK7 Mask           */

#define GPIO_DATMSK_DATMSK8_Pos          (8)                                               /*!< GPIO_T::DATMSK: DATMSK8 Position       */
#define GPIO_DATMSK_DATMSK8_Msk          (0x1ul << GPIO_DATMSK_DATMSK8_Pos)                /*!< GPIO_T::DATMSK: DATMSK8 Mask           */

#define GPIO_DATMSK_DATMSK9_Pos          (9)                                               /*!< GPIO_T::DATMSK: DATMSK9 Position       */
#define GPIO_DATMSK_DATMSK9_Msk          (0x1ul << GPIO_DATMSK_DATMSK9_Pos)                /*!< GPIO_T::DATMSK: DATMSK9 Mask           */

#define GPIO_DATMSK_DATMSK10_Pos         (10)                                              /*!< GPIO_T::DATMSK: DATMSK10 Position      */
#define GPIO_DATMSK_DATMSK10_Msk         (0x1ul << GPIO_DATMSK_DATMSK10_Pos)               /*!< GPIO_T::DATMSK: DATMSK10 Mask          */

#define GPIO_DATMSK_DATMSK11_Pos         (11)                                              /*!< GPIO_T::DATMSK: DATMSK11 Position      */
#define GPIO_DATMSK_DATMSK11_Msk         (0x1ul << GPIO_DATMSK_DATMSK11_Pos)               /*!< GPIO_T::DATMSK: DATMSK11 Mask          */

#define GPIO_DATMSK_DATMSK12_Pos         (12)                                              /*!< GPIO_T::DATMSK: DATMSK12 Position      */
#define GPIO_DATMSK_DATMSK12_Msk         (0x1ul << GPIO_DATMSK_DATMSK12_Pos)               /*!< GPIO_T::DATMSK: DATMSK12 Mask          */

#define GPIO_DATMSK_DATMSK13_Pos         (13)                                              /*!< GPIO_T::DATMSK: DATMSK13 Position      */
#define GPIO_DATMSK_DATMSK13_Msk         (0x1ul << GPIO_DATMSK_DATMSK13_Pos)               /*!< GPIO_T::DATMSK: DATMSK13 Mask          */

#define GPIO_DATMSK_DATMSK14_Pos         (14)                                              /*!< GPIO_T::DATMSK: DATMSK14 Position      */
#define GPIO_DATMSK_DATMSK14_Msk         (0x1ul << GPIO_DATMSK_DATMSK14_Pos)               /*!< GPIO_T::DATMSK: DATMSK14 Mask          */

#define GPIO_DATMSK_DATMSK15_Pos         (15)                                              /*!< GPIO_T::DATMSK: DATMSK15 Position      */
#define GPIO_DATMSK_DATMSK15_Msk         (0x1ul << GPIO_DATMSK_DATMSK15_Pos)               /*!< GPIO_T::DATMSK: DATMSK15 Mask          */

#define GPIO_PIN_PIN0_Pos                (0)                                               /*!< GPIO_T::PIN: PIN0 Position             */
#define GPIO_PIN_PIN0_Msk                (0x1ul << GPIO_PIN_PIN0_Pos)                      /*!< GPIO_T::PIN: PIN0 Mask                 */

#define GPIO_PIN_PIN1_Pos                (1)                                               /*!< GPIO_T::PIN: PIN1 Position             */
#define GPIO_PIN_PIN1_Msk                (0x1ul << GPIO_PIN_PIN1_Pos)                      /*!< GPIO_T::PIN: PIN1 Mask                 */

#define GPIO_PIN_PIN2_Pos                (2)                                               /*!< GPIO_T::PIN: PIN2 Position             */
#define GPIO_PIN_PIN2_Msk                (0x1ul << GPIO_PIN_PIN2_Pos)                      /*!< GPIO_T::PIN: PIN2 Mask                 */

#define GPIO_PIN_PIN3_Pos                (3)                                               /*!< GPIO_T::PIN: PIN3 Position             */
#define GPIO_PIN_PIN3_Msk                (0x1ul << GPIO_PIN_PIN3_Pos)                      /*!< GPIO_T::PIN: PIN3 Mask                 */

#define GPIO_PIN_PIN4_Pos                (4)                                               /*!< GPIO_T::PIN: PIN4 Position             */
#define GPIO_PIN_PIN4_Msk                (0x1ul << GPIO_PIN_PIN4_Pos)                      /*!< GPIO_T::PIN: PIN4 Mask                 */

#define GPIO_PIN_PIN5_Pos                (5)                                               /*!< GPIO_T::PIN: PIN5 Position             */
#define GPIO_PIN_PIN5_Msk                (0x1ul << GPIO_PIN_PIN5_Pos)                      /*!< GPIO_T::PIN: PIN5 Mask                 */

#define GPIO_PIN_PIN6_Pos                (6)                                               /*!< GPIO_T::PIN: PIN6 Position             */
#define GPIO_PIN_PIN6_Msk                (0x1ul << GPIO_PIN_PIN6_Pos)                      /*!< GPIO_T::PIN: PIN6 Mask                 */

#define GPIO_PIN_PIN7_Pos                (7)                                               /*!< GPIO_T::PIN: PIN7 Position             */
#define GPIO_PIN_PIN7_Msk                (0x1ul << GPIO_PIN_PIN7_Pos)                      /*!< GPIO_T::PIN: PIN7 Mask                 */

#define GPIO_PIN_PIN8_Pos                (8)                                               /*!< GPIO_T::PIN: PIN8 Position             */
#define GPIO_PIN_PIN8_Msk                (0x1ul << GPIO_PIN_PIN8_Pos)                      /*!< GPIO_T::PIN: PIN8 Mask                 */

#define GPIO_PIN_PIN9_Pos                (9)                                               /*!< GPIO_T::PIN: PIN9 Position             */
#define GPIO_PIN_PIN9_Msk                (0x1ul << GPIO_PIN_PIN9_Pos)                      /*!< GPIO_T::PIN: PIN9 Mask                 */

#define GPIO_PIN_PIN10_Pos               (10)                                              /*!< GPIO_T::PIN: PIN10 Position            */
#define GPIO_PIN_PIN10_Msk               (0x1ul << GPIO_PIN_PIN10_Pos)                     /*!< GPIO_T::PIN: PIN10 Mask                */

#define GPIO_PIN_PIN11_Pos               (11)                                              /*!< GPIO_T::PIN: PIN11 Position            */
#define GPIO_PIN_PIN11_Msk               (0x1ul << GPIO_PIN_PIN11_Pos)                     /*!< GPIO_T::PIN: PIN11 Mask                */

#define GPIO_PIN_PIN12_Pos               (12)                                              /*!< GPIO_T::PIN: PIN12 Position            */
#define GPIO_PIN_PIN12_Msk               (0x1ul << GPIO_PIN_PIN12_Pos)                     /*!< GPIO_T::PIN: PIN12 Mask                */

#define GPIO_PIN_PIN13_Pos               (13)                                              /*!< GPIO_T::PIN: PIN13 Position            */
#define GPIO_PIN_PIN13_Msk               (0x1ul << GPIO_PIN_PIN13_Pos)                     /*!< GPIO_T::PIN: PIN13 Mask                */

#define GPIO_PIN_PIN14_Pos               (14)                                              /*!< GPIO_T::PIN: PIN14 Position            */
#define GPIO_PIN_PIN14_Msk               (0x1ul << GPIO_PIN_PIN14_Pos)                     /*!< GPIO_T::PIN: PIN14 Mask                */

#define GPIO_PIN_PIN15_Pos               (15)                                              /*!< GPIO_T::PIN: PIN15 Position            */
#define GPIO_PIN_PIN15_Msk               (0x1ul << GPIO_PIN_PIN15_Pos)                     /*!< GPIO_T::PIN: PIN15 Mask                */

#define GPIO_DBEN_DBEN0_Pos              (0)                                               /*!< GPIO_T::DBEN: DBEN0 Position           */
#define GPIO_DBEN_DBEN0_Msk              (0x1ul << GPIO_DBEN_DBEN0_Pos)                    /*!< GPIO_T::DBEN: DBEN0 Mask               */

#define GPIO_DBEN_DBEN1_Pos              (1)                                               /*!< GPIO_T::DBEN: DBEN1 Position           */
#define GPIO_DBEN_DBEN1_Msk              (0x1ul << GPIO_DBEN_DBEN1_Pos)                    /*!< GPIO_T::DBEN: DBEN1 Mask               */

#define GPIO_DBEN_DBEN2_Pos              (2)                                               /*!< GPIO_T::DBEN: DBEN2 Position           */
#define GPIO_DBEN_DBEN2_Msk              (0x1ul << GPIO_DBEN_DBEN2_Pos)                    /*!< GPIO_T::DBEN: DBEN2 Mask               */

#define GPIO_DBEN_DBEN3_Pos              (3)                                               /*!< GPIO_T::DBEN: DBEN3 Position           */
#define GPIO_DBEN_DBEN3_Msk              (0x1ul << GPIO_DBEN_DBEN3_Pos)                    /*!< GPIO_T::DBEN: DBEN3 Mask               */

#define GPIO_DBEN_DBEN4_Pos              (4)                                               /*!< GPIO_T::DBEN: DBEN4 Position           */
#define GPIO_DBEN_DBEN4_Msk              (0x1ul << GPIO_DBEN_DBEN4_Pos)                    /*!< GPIO_T::DBEN: DBEN4 Mask               */

#define GPIO_DBEN_DBEN5_Pos              (5)                                               /*!< GPIO_T::DBEN: DBEN5 Position           */
#define GPIO_DBEN_DBEN5_Msk              (0x1ul << GPIO_DBEN_DBEN5_Pos)                    /*!< GPIO_T::DBEN: DBEN5 Mask               */

#define GPIO_DBEN_DBEN6_Pos              (6)                                               /*!< GPIO_T::DBEN: DBEN6 Position           */
#define GPIO_DBEN_DBEN6_Msk              (0x1ul << GPIO_DBEN_DBEN6_Pos)                    /*!< GPIO_T::DBEN: DBEN6 Mask               */

#define GPIO_DBEN_DBEN7_Pos              (7)                                               /*!< GPIO_T::DBEN: DBEN7 Position           */
#define GPIO_DBEN_DBEN7_Msk              (0x1ul << GPIO_DBEN_DBEN7_Pos)                    /*!< GPIO_T::DBEN: DBEN7 Mask               */

#define GPIO_DBEN_DBEN8_Pos              (8)                                               /*!< GPIO_T::DBEN: DBEN8 Position           */
#define GPIO_DBEN_DBEN8_Msk              (0x1ul << GPIO_DBEN_DBEN8_Pos)                    /*!< GPIO_T::DBEN: DBEN8 Mask               */

#define GPIO_DBEN_DBEN9_Pos              (9)                                               /*!< GPIO_T::DBEN: DBEN9 Position           */
#define GPIO_DBEN_DBEN9_Msk              (0x1ul << GPIO_DBEN_DBEN9_Pos)                    /*!< GPIO_T::DBEN: DBEN9 Mask               */

#define GPIO_DBEN_DBEN10_Pos             (10)                                              /*!< GPIO_T::DBEN: DBEN10 Position          */
#define GPIO_DBEN_DBEN10_Msk             (0x1ul << GPIO_DBEN_DBEN10_Pos)                   /*!< GPIO_T::DBEN: DBEN10 Mask              */

#define GPIO_DBEN_DBEN11_Pos             (11)                                              /*!< GPIO_T::DBEN: DBEN11 Position          */
#define GPIO_DBEN_DBEN11_Msk             (0x1ul << GPIO_DBEN_DBEN11_Pos)                   /*!< GPIO_T::DBEN: DBEN11 Mask              */

#define GPIO_DBEN_DBEN12_Pos             (12)                                              /*!< GPIO_T::DBEN: DBEN12 Position          */
#define GPIO_DBEN_DBEN12_Msk             (0x1ul << GPIO_DBEN_DBEN12_Pos)                   /*!< GPIO_T::DBEN: DBEN12 Mask              */

#define GPIO_DBEN_DBEN13_Pos             (13)                                              /*!< GPIO_T::DBEN: DBEN13 Position          */
#define GPIO_DBEN_DBEN13_Msk             (0x1ul << GPIO_DBEN_DBEN13_Pos)                   /*!< GPIO_T::DBEN: DBEN13 Mask              */

#define GPIO_DBEN_DBEN14_Pos             (14)                                              /*!< GPIO_T::DBEN: DBEN14 Position          */
#define GPIO_DBEN_DBEN14_Msk             (0x1ul << GPIO_DBEN_DBEN14_Pos)                   /*!< GPIO_T::DBEN: DBEN14 Mask              */

#define GPIO_DBEN_DBEN15_Pos             (15)                                              /*!< GPIO_T::DBEN: DBEN15 Position          */
#define GPIO_DBEN_DBEN15_Msk             (0x1ul << GPIO_DBEN_DBEN15_Pos)                   /*!< GPIO_T::DBEN: DBEN15 Mask              */

#define GPIO_INTTYPE_TYPE0_Pos           (0)                                               /*!< GPIO_T::INTTYPE: TYPE0 Position        */
#define GPIO_INTTYPE_TYPE0_Msk           (0x1ul << GPIO_INTTYPE_TYPE0_Pos)                 /*!< GPIO_T::INTTYPE: TYPE0 Mask            */

#define GPIO_INTTYPE_TYPE1_Pos           (1)                                               /*!< GPIO_T::INTTYPE: TYPE1 Position        */
#define GPIO_INTTYPE_TYPE1_Msk           (0x1ul << GPIO_INTTYPE_TYPE1_Pos)                 /*!< GPIO_T::INTTYPE: TYPE1 Mask            */

#define GPIO_INTTYPE_TYPE2_Pos           (2)                                               /*!< GPIO_T::INTTYPE: TYPE2 Position        */
#define GPIO_INTTYPE_TYPE2_Msk           (0x1ul << GPIO_INTTYPE_TYPE2_Pos)                 /*!< GPIO_T::INTTYPE: TYPE2 Mask            */

#define GPIO_INTTYPE_TYPE3_Pos           (3)                                               /*!< GPIO_T::INTTYPE: TYPE3 Position        */
#define GPIO_INTTYPE_TYPE3_Msk           (0x1ul << GPIO_INTTYPE_TYPE3_Pos)                 /*!< GPIO_T::INTTYPE: TYPE3 Mask            */

#define GPIO_INTTYPE_TYPE4_Pos           (4)                                               /*!< GPIO_T::INTTYPE: TYPE4 Position        */
#define GPIO_INTTYPE_TYPE4_Msk           (0x1ul << GPIO_INTTYPE_TYPE4_Pos)                 /*!< GPIO_T::INTTYPE: TYPE4 Mask            */

#define GPIO_INTTYPE_TYPE5_Pos           (5)                                               /*!< GPIO_T::INTTYPE: TYPE5 Position        */
#define GPIO_INTTYPE_TYPE5_Msk           (0x1ul << GPIO_INTTYPE_TYPE5_Pos)                 /*!< GPIO_T::INTTYPE: TYPE5 Mask            */

#define GPIO_INTTYPE_TYPE6_Pos           (6)                                               /*!< GPIO_T::INTTYPE: TYPE6 Position        */
#define GPIO_INTTYPE_TYPE6_Msk           (0x1ul << GPIO_INTTYPE_TYPE6_Pos)                 /*!< GPIO_T::INTTYPE: TYPE6 Mask            */

#define GPIO_INTTYPE_TYPE7_Pos           (7)                                               /*!< GPIO_T::INTTYPE: TYPE7 Position        */
#define GPIO_INTTYPE_TYPE7_Msk           (0x1ul << GPIO_INTTYPE_TYPE7_Pos)                 /*!< GPIO_T::INTTYPE: TYPE7 Mask            */

#define GPIO_INTTYPE_TYPE8_Pos           (8)                                               /*!< GPIO_T::INTTYPE: TYPE8 Position        */
#define GPIO_INTTYPE_TYPE8_Msk           (0x1ul << GPIO_INTTYPE_TYPE8_Pos)                 /*!< GPIO_T::INTTYPE: TYPE8 Mask            */

#define GPIO_INTTYPE_TYPE9_Pos           (9)                                               /*!< GPIO_T::INTTYPE: TYPE9 Position        */
#define GPIO_INTTYPE_TYPE9_Msk           (0x1ul << GPIO_INTTYPE_TYPE9_Pos)                 /*!< GPIO_T::INTTYPE: TYPE9 Mask            */

#define GPIO_INTTYPE_TYPE10_Pos          (10)                                              /*!< GPIO_T::INTTYPE: TYPE10 Position       */
#define GPIO_INTTYPE_TYPE10_Msk          (0x1ul << GPIO_INTTYPE_TYPE10_Pos)                /*!< GPIO_T::INTTYPE: TYPE10 Mask           */

#define GPIO_INTTYPE_TYPE11_Pos          (11)                                              /*!< GPIO_T::INTTYPE: TYPE11 Position       */
#define GPIO_INTTYPE_TYPE11_Msk          (0x1ul << GPIO_INTTYPE_TYPE11_Pos)                /*!< GPIO_T::INTTYPE: TYPE11 Mask           */

#define GPIO_INTTYPE_TYPE12_Pos          (12)                                              /*!< GPIO_T::INTTYPE: TYPE12 Position       */
#define GPIO_INTTYPE_TYPE12_Msk          (0x1ul << GPIO_INTTYPE_TYPE12_Pos)                /*!< GPIO_T::INTTYPE: TYPE12 Mask           */

#define GPIO_INTTYPE_TYPE13_Pos          (13)                                              /*!< GPIO_T::INTTYPE: TYPE13 Position       */
#define GPIO_INTTYPE_TYPE13_Msk          (0x1ul << GPIO_INTTYPE_TYPE13_Pos)                /*!< GPIO_T::INTTYPE: TYPE13 Mask           */

#define GPIO_INTTYPE_TYPE14_Pos          (14)                                              /*!< GPIO_T::INTTYPE: TYPE14 Position       */
#define GPIO_INTTYPE_TYPE14_Msk          (0x1ul << GPIO_INTTYPE_TYPE14_Pos)                /*!< GPIO_T::INTTYPE: TYPE14 Mask           */

#define GPIO_INTTYPE_TYPE15_Pos          (15)                                              /*!< GPIO_T::INTTYPE: TYPE15 Position       */
#define GPIO_INTTYPE_TYPE15_Msk          (0x1ul << GPIO_INTTYPE_TYPE15_Pos)                /*!< GPIO_T::INTTYPE: TYPE15 Mask           */

#define GPIO_INTEN_FLIEN0_Pos            (0)                                               /*!< GPIO_T::INTEN: FLIEN0 Position         */
#define GPIO_INTEN_FLIEN0_Msk            (0x1ul << GPIO_INTEN_FLIEN0_Pos)                  /*!< GPIO_T::INTEN: FLIEN0 Mask             */

#define GPIO_INTEN_FLIEN1_Pos            (1)                                               /*!< GPIO_T::INTEN: FLIEN1 Position         */
#define GPIO_INTEN_FLIEN1_Msk            (0x1ul << GPIO_INTEN_FLIEN1_Pos)                  /*!< GPIO_T::INTEN: FLIEN1 Mask             */

#define GPIO_INTEN_FLIEN2_Pos            (2)                                               /*!< GPIO_T::INTEN: FLIEN2 Position         */
#define GPIO_INTEN_FLIEN2_Msk            (0x1ul << GPIO_INTEN_FLIEN2_Pos)                  /*!< GPIO_T::INTEN: FLIEN2 Mask             */

#define GPIO_INTEN_FLIEN3_Pos            (3)                                               /*!< GPIO_T::INTEN: FLIEN3 Position         */
#define GPIO_INTEN_FLIEN3_Msk            (0x1ul << GPIO_INTEN_FLIEN3_Pos)                  /*!< GPIO_T::INTEN: FLIEN3 Mask             */

#define GPIO_INTEN_FLIEN4_Pos            (4)                                               /*!< GPIO_T::INTEN: FLIEN4 Position         */
#define GPIO_INTEN_FLIEN4_Msk            (0x1ul << GPIO_INTEN_FLIEN4_Pos)                  /*!< GPIO_T::INTEN: FLIEN4 Mask             */

#define GPIO_INTEN_FLIEN5_Pos            (5)                                               /*!< GPIO_T::INTEN: FLIEN5 Position         */
#define GPIO_INTEN_FLIEN5_Msk            (0x1ul << GPIO_INTEN_FLIEN5_Pos)                  /*!< GPIO_T::INTEN: FLIEN5 Mask             */

#define GPIO_INTEN_FLIEN6_Pos            (6)                                               /*!< GPIO_T::INTEN: FLIEN6 Position         */
#define GPIO_INTEN_FLIEN6_Msk            (0x1ul << GPIO_INTEN_FLIEN6_Pos)                  /*!< GPIO_T::INTEN: FLIEN6 Mask             */

#define GPIO_INTEN_FLIEN7_Pos            (7)                                               /*!< GPIO_T::INTEN: FLIEN7 Position         */
#define GPIO_INTEN_FLIEN7_Msk            (0x1ul << GPIO_INTEN_FLIEN7_Pos)                  /*!< GPIO_T::INTEN: FLIEN7 Mask             */

#define GPIO_INTEN_FLIEN8_Pos            (8)                                               /*!< GPIO_T::INTEN: FLIEN8 Position         */
#define GPIO_INTEN_FLIEN8_Msk            (0x1ul << GPIO_INTEN_FLIEN8_Pos)                  /*!< GPIO_T::INTEN: FLIEN8 Mask             */

#define GPIO_INTEN_FLIEN9_Pos            (9)                                               /*!< GPIO_T::INTEN: FLIEN9 Position         */
#define GPIO_INTEN_FLIEN9_Msk            (0x1ul << GPIO_INTEN_FLIEN9_Pos)                  /*!< GPIO_T::INTEN: FLIEN9 Mask             */

#define GPIO_INTEN_FLIEN10_Pos           (10)                                              /*!< GPIO_T::INTEN: FLIEN10 Position        */
#define GPIO_INTEN_FLIEN10_Msk           (0x1ul << GPIO_INTEN_FLIEN10_Pos)                 /*!< GPIO_T::INTEN: FLIEN10 Mask            */

#define GPIO_INTEN_FLIEN11_Pos           (11)                                              /*!< GPIO_T::INTEN: FLIEN11 Position        */
#define GPIO_INTEN_FLIEN11_Msk           (0x1ul << GPIO_INTEN_FLIEN11_Pos)                 /*!< GPIO_T::INTEN: FLIEN11 Mask            */

#define GPIO_INTEN_FLIEN12_Pos           (12)                                              /*!< GPIO_T::INTEN: FLIEN12 Position        */
#define GPIO_INTEN_FLIEN12_Msk           (0x1ul << GPIO_INTEN_FLIEN12_Pos)                 /*!< GPIO_T::INTEN: FLIEN12 Mask            */

#define GPIO_INTEN_FLIEN13_Pos           (13)                                              /*!< GPIO_T::INTEN: FLIEN13 Position        */
#define GPIO_INTEN_FLIEN13_Msk           (0x1ul << GPIO_INTEN_FLIEN13_Pos)                 /*!< GPIO_T::INTEN: FLIEN13 Mask            */

#define GPIO_INTEN_FLIEN14_Pos           (14)                                              /*!< GPIO_T::INTEN: FLIEN14 Position        */
#define GPIO_INTEN_FLIEN14_Msk           (0x1ul << GPIO_INTEN_FLIEN14_Pos)                 /*!< GPIO_T::INTEN: FLIEN14 Mask            */

#define GPIO_INTEN_FLIEN15_Pos           (15)                                              /*!< GPIO_T::INTEN: FLIEN15 Position        */
#define GPIO_INTEN_FLIEN15_Msk           (0x1ul << GPIO_INTEN_FLIEN15_Pos)                 /*!< GPIO_T::INTEN: FLIEN15 Mask            */

#define GPIO_INTEN_RHIEN0_Pos            (16)                                              /*!< GPIO_T::INTEN: RHIEN0 Position         */
#define GPIO_INTEN_RHIEN0_Msk            (0x1ul << GPIO_INTEN_RHIEN0_Pos)                  /*!< GPIO_T::INTEN: RHIEN0 Mask             */

#define GPIO_INTEN_RHIEN1_Pos            (17)                                              /*!< GPIO_T::INTEN: RHIEN1 Position         */
#define GPIO_INTEN_RHIEN1_Msk            (0x1ul << GPIO_INTEN_RHIEN1_Pos)                  /*!< GPIO_T::INTEN: RHIEN1 Mask             */

#define GPIO_INTEN_RHIEN2_Pos            (18)                                              /*!< GPIO_T::INTEN: RHIEN2 Position         */
#define GPIO_INTEN_RHIEN2_Msk            (0x1ul << GPIO_INTEN_RHIEN2_Pos)                  /*!< GPIO_T::INTEN: RHIEN2 Mask             */

#define GPIO_INTEN_RHIEN3_Pos            (19)                                              /*!< GPIO_T::INTEN: RHIEN3 Position         */
#define GPIO_INTEN_RHIEN3_Msk            (0x1ul << GPIO_INTEN_RHIEN3_Pos)                  /*!< GPIO_T::INTEN: RHIEN3 Mask             */

#define GPIO_INTEN_RHIEN4_Pos            (20)                                              /*!< GPIO_T::INTEN: RHIEN4 Position         */
#define GPIO_INTEN_RHIEN4_Msk            (0x1ul << GPIO_INTEN_RHIEN4_Pos)                  /*!< GPIO_T::INTEN: RHIEN4 Mask             */

#define GPIO_INTEN_RHIEN5_Pos            (21)                                              /*!< GPIO_T::INTEN: RHIEN5 Position         */
#define GPIO_INTEN_RHIEN5_Msk            (0x1ul << GPIO_INTEN_RHIEN5_Pos)                  /*!< GPIO_T::INTEN: RHIEN5 Mask             */

#define GPIO_INTEN_RHIEN6_Pos            (22)                                              /*!< GPIO_T::INTEN: RHIEN6 Position         */
#define GPIO_INTEN_RHIEN6_Msk            (0x1ul << GPIO_INTEN_RHIEN6_Pos)                  /*!< GPIO_T::INTEN: RHIEN6 Mask             */

#define GPIO_INTEN_RHIEN7_Pos            (23)                                              /*!< GPIO_T::INTEN: RHIEN7 Position         */
#define GPIO_INTEN_RHIEN7_Msk            (0x1ul << GPIO_INTEN_RHIEN7_Pos)                  /*!< GPIO_T::INTEN: RHIEN7 Mask             */

#define GPIO_INTEN_RHIEN8_Pos            (24)                                              /*!< GPIO_T::INTEN: RHIEN8 Position         */
#define GPIO_INTEN_RHIEN8_Msk            (0x1ul << GPIO_INTEN_RHIEN8_Pos)                  /*!< GPIO_T::INTEN: RHIEN8 Mask             */

#define GPIO_INTEN_RHIEN9_Pos            (25)                                              /*!< GPIO_T::INTEN: RHIEN9 Position         */
#define GPIO_INTEN_RHIEN9_Msk            (0x1ul << GPIO_INTEN_RHIEN9_Pos)                  /*!< GPIO_T::INTEN: RHIEN9 Mask             */

#define GPIO_INTEN_RHIEN10_Pos           (26)                                              /*!< GPIO_T::INTEN: RHIEN10 Position        */
#define GPIO_INTEN_RHIEN10_Msk           (0x1ul << GPIO_INTEN_RHIEN10_Pos)                 /*!< GPIO_T::INTEN: RHIEN10 Mask            */

#define GPIO_INTEN_RHIEN11_Pos           (27)                                              /*!< GPIO_T::INTEN: RHIEN11 Position        */
#define GPIO_INTEN_RHIEN11_Msk           (0x1ul << GPIO_INTEN_RHIEN11_Pos)                 /*!< GPIO_T::INTEN: RHIEN11 Mask            */

#define GPIO_INTEN_RHIEN12_Pos           (28)                                              /*!< GPIO_T::INTEN: RHIEN12 Position        */
#define GPIO_INTEN_RHIEN12_Msk           (0x1ul << GPIO_INTEN_RHIEN12_Pos)                 /*!< GPIO_T::INTEN: RHIEN12 Mask            */

#define GPIO_INTEN_RHIEN13_Pos           (29)                                              /*!< GPIO_T::INTEN: RHIEN13 Position        */
#define GPIO_INTEN_RHIEN13_Msk           (0x1ul << GPIO_INTEN_RHIEN13_Pos)                 /*!< GPIO_T::INTEN: RHIEN13 Mask            */

#define GPIO_INTEN_RHIEN14_Pos           (30)                                              /*!< GPIO_T::INTEN: RHIEN14 Position        */
#define GPIO_INTEN_RHIEN14_Msk           (0x1ul << GPIO_INTEN_RHIEN14_Pos)                 /*!< GPIO_T::INTEN: RHIEN14 Mask            */

#define GPIO_INTEN_RHIEN15_Pos           (31)                                              /*!< GPIO_T::INTEN: RHIEN15 Position        */
#define GPIO_INTEN_RHIEN15_Msk           (0x1ul << GPIO_INTEN_RHIEN15_Pos)                 /*!< GPIO_T::INTEN: RHIEN15 Mask            */

#define GPIO_INTSRC_INTSRC0_Pos          (0)                                               /*!< GPIO_T::INTSRC: INTSRC0 Position       */
#define GPIO_INTSRC_INTSRC0_Msk          (0x1ul << GPIO_INTSRC_INTSRC0_Pos)                /*!< GPIO_T::INTSRC: INTSRC0 Mask           */

#define GPIO_INTSRC_INTSRC1_Pos          (1)                                               /*!< GPIO_T::INTSRC: INTSRC1 Position       */
#define GPIO_INTSRC_INTSRC1_Msk          (0x1ul << GPIO_INTSRC_INTSRC1_Pos)                /*!< GPIO_T::INTSRC: INTSRC1 Mask           */

#define GPIO_INTSRC_INTSRC2_Pos          (2)                                               /*!< GPIO_T::INTSRC: INTSRC2 Position       */
#define GPIO_INTSRC_INTSRC2_Msk          (0x1ul << GPIO_INTSRC_INTSRC2_Pos)                /*!< GPIO_T::INTSRC: INTSRC2 Mask           */

#define GPIO_INTSRC_INTSRC3_Pos          (3)                                               /*!< GPIO_T::INTSRC: INTSRC3 Position       */
#define GPIO_INTSRC_INTSRC3_Msk          (0x1ul << GPIO_INTSRC_INTSRC3_Pos)                /*!< GPIO_T::INTSRC: INTSRC3 Mask           */

#define GPIO_INTSRC_INTSRC4_Pos          (4)                                               /*!< GPIO_T::INTSRC: INTSRC4 Position       */
#define GPIO_INTSRC_INTSRC4_Msk          (0x1ul << GPIO_INTSRC_INTSRC4_Pos)                /*!< GPIO_T::INTSRC: INTSRC4 Mask           */

#define GPIO_INTSRC_INTSRC5_Pos          (5)                                               /*!< GPIO_T::INTSRC: INTSRC5 Position       */
#define GPIO_INTSRC_INTSRC5_Msk          (0x1ul << GPIO_INTSRC_INTSRC5_Pos)                /*!< GPIO_T::INTSRC: INTSRC5 Mask           */

#define GPIO_INTSRC_INTSRC6_Pos          (6)                                               /*!< GPIO_T::INTSRC: INTSRC6 Position       */
#define GPIO_INTSRC_INTSRC6_Msk          (0x1ul << GPIO_INTSRC_INTSRC6_Pos)                /*!< GPIO_T::INTSRC: INTSRC6 Mask           */

#define GPIO_INTSRC_INTSRC7_Pos          (7)                                               /*!< GPIO_T::INTSRC: INTSRC7 Position       */
#define GPIO_INTSRC_INTSRC7_Msk          (0x1ul << GPIO_INTSRC_INTSRC7_Pos)                /*!< GPIO_T::INTSRC: INTSRC7 Mask           */

#define GPIO_INTSRC_INTSRC8_Pos          (8)                                               /*!< GPIO_T::INTSRC: INTSRC8 Position       */
#define GPIO_INTSRC_INTSRC8_Msk          (0x1ul << GPIO_INTSRC_INTSRC8_Pos)                /*!< GPIO_T::INTSRC: INTSRC8 Mask           */

#define GPIO_INTSRC_INTSRC9_Pos          (9)                                               /*!< GPIO_T::INTSRC: INTSRC9 Position       */
#define GPIO_INTSRC_INTSRC9_Msk          (0x1ul << GPIO_INTSRC_INTSRC9_Pos)                /*!< GPIO_T::INTSRC: INTSRC9 Mask           */

#define GPIO_INTSRC_INTSRC10_Pos         (10)                                              /*!< GPIO_T::INTSRC: INTSRC10 Position      */
#define GPIO_INTSRC_INTSRC10_Msk         (0x1ul << GPIO_INTSRC_INTSRC10_Pos)               /*!< GPIO_T::INTSRC: INTSRC10 Mask          */

#define GPIO_INTSRC_INTSRC11_Pos         (11)                                              /*!< GPIO_T::INTSRC: INTSRC11 Position      */
#define GPIO_INTSRC_INTSRC11_Msk         (0x1ul << GPIO_INTSRC_INTSRC11_Pos)               /*!< GPIO_T::INTSRC: INTSRC11 Mask          */

#define GPIO_INTSRC_INTSRC12_Pos         (12)                                              /*!< GPIO_T::INTSRC: INTSRC12 Position      */
#define GPIO_INTSRC_INTSRC12_Msk         (0x1ul << GPIO_INTSRC_INTSRC12_Pos)               /*!< GPIO_T::INTSRC: INTSRC12 Mask          */

#define GPIO_INTSRC_INTSRC13_Pos         (13)                                              /*!< GPIO_T::INTSRC: INTSRC13 Position      */
#define GPIO_INTSRC_INTSRC13_Msk         (0x1ul << GPIO_INTSRC_INTSRC13_Pos)               /*!< GPIO_T::INTSRC: INTSRC13 Mask          */

#define GPIO_INTSRC_INTSRC14_Pos         (14)                                              /*!< GPIO_T::INTSRC: INTSRC14 Position      */
#define GPIO_INTSRC_INTSRC14_Msk         (0x1ul << GPIO_INTSRC_INTSRC14_Pos)               /*!< GPIO_T::INTSRC: INTSRC14 Mask          */

#define GPIO_INTSRC_INTSRC15_Pos         (15)                                              /*!< GPIO_T::INTSRC: INTSRC15 Position      */
#define GPIO_INTSRC_INTSRC15_Msk         (0x1ul << GPIO_INTSRC_INTSRC15_Pos)               /*!< GPIO_T::INTSRC: INTSRC15 Mask          */

#define GPIO_SMTEN_SMTEN0_Pos            (0)                                               /*!< GPIO_T::SMTEN: SMTEN0 Position         */
#define GPIO_SMTEN_SMTEN0_Msk            (0x1ul << GPIO_SMTEN_SMTEN0_Pos)                  /*!< GPIO_T::SMTEN: SMTEN0 Mask             */

#define GPIO_SMTEN_SMTEN1_Pos            (1)                                               /*!< GPIO_T::SMTEN: SMTEN1 Position         */
#define GPIO_SMTEN_SMTEN1_Msk            (0x1ul << GPIO_SMTEN_SMTEN1_Pos)                  /*!< GPIO_T::SMTEN: SMTEN1 Mask             */

#define GPIO_SMTEN_SMTEN2_Pos            (2)                                               /*!< GPIO_T::SMTEN: SMTEN2 Position         */
#define GPIO_SMTEN_SMTEN2_Msk            (0x1ul << GPIO_SMTEN_SMTEN2_Pos)                  /*!< GPIO_T::SMTEN: SMTEN2 Mask             */

#define GPIO_SMTEN_SMTEN3_Pos            (3)                                               /*!< GPIO_T::SMTEN: SMTEN3 Position         */
#define GPIO_SMTEN_SMTEN3_Msk            (0x1ul << GPIO_SMTEN_SMTEN3_Pos)                  /*!< GPIO_T::SMTEN: SMTEN3 Mask             */

#define GPIO_SMTEN_SMTEN4_Pos            (4)                                               /*!< GPIO_T::SMTEN: SMTEN4 Position         */
#define GPIO_SMTEN_SMTEN4_Msk            (0x1ul << GPIO_SMTEN_SMTEN4_Pos)                  /*!< GPIO_T::SMTEN: SMTEN4 Mask             */

#define GPIO_SMTEN_SMTEN5_Pos            (5)                                               /*!< GPIO_T::SMTEN: SMTEN5 Position         */
#define GPIO_SMTEN_SMTEN5_Msk            (0x1ul << GPIO_SMTEN_SMTEN5_Pos)                  /*!< GPIO_T::SMTEN: SMTEN5 Mask             */

#define GPIO_SMTEN_SMTEN6_Pos            (6)                                               /*!< GPIO_T::SMTEN: SMTEN6 Position         */
#define GPIO_SMTEN_SMTEN6_Msk            (0x1ul << GPIO_SMTEN_SMTEN6_Pos)                  /*!< GPIO_T::SMTEN: SMTEN6 Mask             */

#define GPIO_SMTEN_SMTEN7_Pos            (7)                                               /*!< GPIO_T::SMTEN: SMTEN7 Position         */
#define GPIO_SMTEN_SMTEN7_Msk            (0x1ul << GPIO_SMTEN_SMTEN7_Pos)                  /*!< GPIO_T::SMTEN: SMTEN7 Mask             */

#define GPIO_SMTEN_SMTEN8_Pos            (8)                                               /*!< GPIO_T::SMTEN: SMTEN8 Position         */
#define GPIO_SMTEN_SMTEN8_Msk            (0x1ul << GPIO_SMTEN_SMTEN8_Pos)                  /*!< GPIO_T::SMTEN: SMTEN8 Mask             */

#define GPIO_SMTEN_SMTEN9_Pos            (9)                                               /*!< GPIO_T::SMTEN: SMTEN9 Position         */
#define GPIO_SMTEN_SMTEN9_Msk            (0x1ul << GPIO_SMTEN_SMTEN9_Pos)                  /*!< GPIO_T::SMTEN: SMTEN9 Mask             */

#define GPIO_SMTEN_SMTEN10_Pos           (10)                                              /*!< GPIO_T::SMTEN: SMTEN10 Position        */
#define GPIO_SMTEN_SMTEN10_Msk           (0x1ul << GPIO_SMTEN_SMTEN10_Pos)                 /*!< GPIO_T::SMTEN: SMTEN10 Mask            */

#define GPIO_SMTEN_SMTEN11_Pos           (11)                                              /*!< GPIO_T::SMTEN: SMTEN11 Position        */
#define GPIO_SMTEN_SMTEN11_Msk           (0x1ul << GPIO_SMTEN_SMTEN11_Pos)                 /*!< GPIO_T::SMTEN: SMTEN11 Mask            */

#define GPIO_SMTEN_SMTEN12_Pos           (12)                                              /*!< GPIO_T::SMTEN: SMTEN12 Position        */
#define GPIO_SMTEN_SMTEN12_Msk           (0x1ul << GPIO_SMTEN_SMTEN12_Pos)                 /*!< GPIO_T::SMTEN: SMTEN12 Mask            */

#define GPIO_SMTEN_SMTEN13_Pos           (13)                                              /*!< GPIO_T::SMTEN: SMTEN13 Position        */
#define GPIO_SMTEN_SMTEN13_Msk           (0x1ul << GPIO_SMTEN_SMTEN13_Pos)                 /*!< GPIO_T::SMTEN: SMTEN13 Mask            */

#define GPIO_SMTEN_SMTEN14_Pos           (14)                                              /*!< GPIO_T::SMTEN: SMTEN14 Position        */
#define GPIO_SMTEN_SMTEN14_Msk           (0x1ul << GPIO_SMTEN_SMTEN14_Pos)                 /*!< GPIO_T::SMTEN: SMTEN14 Mask            */

#define GPIO_SMTEN_SMTEN15_Pos           (15)                                              /*!< GPIO_T::SMTEN: SMTEN15 Position        */
#define GPIO_SMTEN_SMTEN15_Msk           (0x1ul << GPIO_SMTEN_SMTEN15_Pos)                 /*!< GPIO_T::SMTEN: SMTEN15 Mask            */

#define GPIO_SLEWCTL_HSREN0_Pos          (0)                                               /*!< GPIO_T::SLEWCTL: HSREN0 Position       */
#define GPIO_SLEWCTL_HSREN0_Msk          (0x3ul << GPIO_SLEWCTL_HSREN0_Pos)                /*!< GPIO_T::SLEWCTL: HSREN0 Mask           */

#define GPIO_SLEWCTL_HSREN1_Pos          (2)                                               /*!< GPIO_T::SLEWCTL: HSREN1 Position       */
#define GPIO_SLEWCTL_HSREN1_Msk          (0x3ul << GPIO_SLEWCTL_HSREN1_Pos)                /*!< GPIO_T::SLEWCTL: HSREN1 Mask           */

#define GPIO_SLEWCTL_HSREN2_Pos          (4)                                               /*!< GPIO_T::SLEWCTL: HSREN2 Position       */
#define GPIO_SLEWCTL_HSREN2_Msk          (0x3ul << GPIO_SLEWCTL_HSREN2_Pos)                /*!< GPIO_T::SLEWCTL: HSREN2 Mask           */

#define GPIO_SLEWCTL_HSREN3_Pos          (6)                                               /*!< GPIO_T::SLEWCTL: HSREN3 Position       */
#define GPIO_SLEWCTL_HSREN3_Msk          (0x3ul << GPIO_SLEWCTL_HSREN3_Pos)                /*!< GPIO_T::SLEWCTL: HSREN3 Mask           */

#define GPIO_SLEWCTL_HSREN4_Pos          (8)                                               /*!< GPIO_T::SLEWCTL: HSREN4 Position       */
#define GPIO_SLEWCTL_HSREN4_Msk          (0x3ul << GPIO_SLEWCTL_HSREN4_Pos)                /*!< GPIO_T::SLEWCTL: HSREN4 Mask           */

#define GPIO_SLEWCTL_HSREN5_Pos          (10)                                              /*!< GPIO_T::SLEWCTL: HSREN5 Position       */
#define GPIO_SLEWCTL_HSREN5_Msk          (0x3ul << GPIO_SLEWCTL_HSREN5_Pos)                /*!< GPIO_T::SLEWCTL: HSREN5 Mask           */

#define GPIO_SLEWCTL_HSREN6_Pos          (12)                                              /*!< GPIO_T::SLEWCTL: HSREN6 Position       */
#define GPIO_SLEWCTL_HSREN6_Msk          (0x3ul << GPIO_SLEWCTL_HSREN6_Pos)                /*!< GPIO_T::SLEWCTL: HSREN6 Mask           */

#define GPIO_SLEWCTL_HSREN7_Pos          (14)                                              /*!< GPIO_T::SLEWCTL: HSREN7 Position       */
#define GPIO_SLEWCTL_HSREN7_Msk          (0x3ul << GPIO_SLEWCTL_HSREN7_Pos)                /*!< GPIO_T::SLEWCTL: HSREN7 Mask           */

#define GPIO_SLEWCTL_HSREN8_Pos          (16)                                              /*!< GPIO_T::SLEWCTL: HSREN8 Position       */
#define GPIO_SLEWCTL_HSREN8_Msk          (0x3ul << GPIO_SLEWCTL_HSREN8_Pos)                /*!< GPIO_T::SLEWCTL: HSREN8 Mask           */

#define GPIO_SLEWCTL_HSREN9_Pos          (18)                                              /*!< GPIO_T::SLEWCTL: HSREN9 Position       */
#define GPIO_SLEWCTL_HSREN9_Msk          (0x3ul << GPIO_SLEWCTL_HSREN9_Pos)                /*!< GPIO_T::SLEWCTL: HSREN9 Mask           */

#define GPIO_SLEWCTL_HSREN10_Pos         (20)                                              /*!< GPIO_T::SLEWCTL: HSREN10 Position      */
#define GPIO_SLEWCTL_HSREN10_Msk         (0x3ul << GPIO_SLEWCTL_HSREN10_Pos)               /*!< GPIO_T::SLEWCTL: HSREN10 Mask          */

#define GPIO_SLEWCTL_HSREN11_Pos         (22)                                              /*!< GPIO_T::SLEWCTL: HSREN11 Position      */
#define GPIO_SLEWCTL_HSREN11_Msk         (0x3ul << GPIO_SLEWCTL_HSREN11_Pos)               /*!< GPIO_T::SLEWCTL: HSREN11 Mask          */

#define GPIO_SLEWCTL_HSREN12_Pos         (24)                                              /*!< GPIO_T::SLEWCTL: HSREN12 Position      */
#define GPIO_SLEWCTL_HSREN12_Msk         (0x3ul << GPIO_SLEWCTL_HSREN12_Pos)               /*!< GPIO_T::SLEWCTL: HSREN12 Mask          */

#define GPIO_SLEWCTL_HSREN13_Pos         (26)                                              /*!< GPIO_T::SLEWCTL: HSREN13 Position      */
#define GPIO_SLEWCTL_HSREN13_Msk         (0x3ul << GPIO_SLEWCTL_HSREN13_Pos)               /*!< GPIO_T::SLEWCTL: HSREN13 Mask          */

#define GPIO_SLEWCTL_HSREN14_Pos         (28)                                              /*!< GPIO_T::SLEWCTL: HSREN14 Position      */
#define GPIO_SLEWCTL_HSREN14_Msk         (0x3ul << GPIO_SLEWCTL_HSREN14_Pos)               /*!< GPIO_T::SLEWCTL: HSREN14 Mask          */

#define GPIO_SLEWCTL_HSREN15_Pos         (30)                                              /*!< GPIO_T::SLEWCTL: HSREN15 Position      */
#define GPIO_SLEWCTL_HSREN15_Msk         (0x3ul << GPIO_SLEWCTL_HSREN15_Pos)               /*!< GPIO_T::SLEWCTL: HSREN15 Mask          */

#define GPIO_PUSEL_PUSEL0_Pos            (0)                                               /*!< GPIO_T::PUSEL: PUSEL0 Position         */
#define GPIO_PUSEL_PUSEL0_Msk            (0x3ul << GPIO_PUSEL_PUSEL0_Pos)                  /*!< GPIO_T::PUSEL: PUSEL0 Mask             */

#define GPIO_PUSEL_PUSEL1_Pos            (2)                                               /*!< GPIO_T::PUSEL: PUSEL1 Position         */
#define GPIO_PUSEL_PUSEL1_Msk            (0x3ul << GPIO_PUSEL_PUSEL1_Pos)                  /*!< GPIO_T::PUSEL: PUSEL1 Mask             */

#define GPIO_PUSEL_PUSEL2_Pos            (4)                                               /*!< GPIO_T::PUSEL: PUSEL2 Position         */
#define GPIO_PUSEL_PUSEL2_Msk            (0x3ul << GPIO_PUSEL_PUSEL2_Pos)                  /*!< GPIO_T::PUSEL: PUSEL2 Mask             */

#define GPIO_PUSEL_PUSEL3_Pos            (6)                                               /*!< GPIO_T::PUSEL: PUSEL3 Position         */
#define GPIO_PUSEL_PUSEL3_Msk            (0x3ul << GPIO_PUSEL_PUSEL3_Pos)                  /*!< GPIO_T::PUSEL: PUSEL3 Mask             */

#define GPIO_PUSEL_PUSEL4_Pos            (8)                                               /*!< GPIO_T::PUSEL: PUSEL4 Position         */
#define GPIO_PUSEL_PUSEL4_Msk            (0x3ul << GPIO_PUSEL_PUSEL4_Pos)                  /*!< GPIO_T::PUSEL: PUSEL4 Mask             */

#define GPIO_PUSEL_PUSEL5_Pos            (10)                                              /*!< GPIO_T::PUSEL: PUSEL5 Position         */
#define GPIO_PUSEL_PUSEL5_Msk            (0x3ul << GPIO_PUSEL_PUSEL5_Pos)                  /*!< GPIO_T::PUSEL: PUSEL5 Mask             */

#define GPIO_PUSEL_PUSEL6_Pos            (12)                                              /*!< GPIO_T::PUSEL: PUSEL6 Position         */
#define GPIO_PUSEL_PUSEL6_Msk            (0x3ul << GPIO_PUSEL_PUSEL6_Pos)                  /*!< GPIO_T::PUSEL: PUSEL6 Mask             */

#define GPIO_PUSEL_PUSEL7_Pos            (14)                                              /*!< GPIO_T::PUSEL: PUSEL7 Position         */
#define GPIO_PUSEL_PUSEL7_Msk            (0x3ul << GPIO_PUSEL_PUSEL7_Pos)                  /*!< GPIO_T::PUSEL: PUSEL7 Mask             */

#define GPIO_PUSEL_PUSEL8_Pos            (16)                                              /*!< GPIO_T::PUSEL: PUSEL8 Position         */
#define GPIO_PUSEL_PUSEL8_Msk            (0x3ul << GPIO_PUSEL_PUSEL8_Pos)                  /*!< GPIO_T::PUSEL: PUSEL8 Mask             */

#define GPIO_PUSEL_PUSEL9_Pos            (18)                                              /*!< GPIO_T::PUSEL: PUSEL9 Position         */
#define GPIO_PUSEL_PUSEL9_Msk            (0x3ul << GPIO_PUSEL_PUSEL9_Pos)                  /*!< GPIO_T::PUSEL: PUSEL9 Mask             */

#define GPIO_PUSEL_PUSEL10_Pos           (20)                                              /*!< GPIO_T::PUSEL: PUSEL10 Position        */
#define GPIO_PUSEL_PUSEL10_Msk           (0x3ul << GPIO_PUSEL_PUSEL10_Pos)                 /*!< GPIO_T::PUSEL: PUSEL10 Mask            */

#define GPIO_PUSEL_PUSEL11_Pos           (22)                                              /*!< GPIO_T::PUSEL: PUSEL11 Position        */
#define GPIO_PUSEL_PUSEL11_Msk           (0x3ul << GPIO_PUSEL_PUSEL11_Pos)                 /*!< GPIO_T::PUSEL: PUSEL11 Mask            */

#define GPIO_PUSEL_PUSEL12_Pos           (24)                                              /*!< GPIO_T::PUSEL: PUSEL12 Position        */
#define GPIO_PUSEL_PUSEL12_Msk           (0x3ul << GPIO_PUSEL_PUSEL12_Pos)                 /*!< GPIO_T::PUSEL: PUSEL12 Mask            */

#define GPIO_PUSEL_PUSEL13_Pos           (26)                                              /*!< GPIO_T::PUSEL: PUSEL13 Position        */
#define GPIO_PUSEL_PUSEL13_Msk           (0x3ul << GPIO_PUSEL_PUSEL13_Pos)                 /*!< GPIO_T::PUSEL: PUSEL13 Mask            */

#define GPIO_PUSEL_PUSEL14_Pos           (28)                                              /*!< GPIO_T::PUSEL: PUSEL14 Position        */
#define GPIO_PUSEL_PUSEL14_Msk           (0x3ul << GPIO_PUSEL_PUSEL14_Pos)                 /*!< GPIO_T::PUSEL: PUSEL14 Mask            */

#define GPIO_PUSEL_PUSEL15_Pos           (30)                                              /*!< GPIO_T::PUSEL: PUSEL15 Position        */
#define GPIO_PUSEL_PUSEL15_Msk           (0x3ul << GPIO_PUSEL_PUSEL15_Pos)                 /*!< GPIO_T::PUSEL: PUSEL15 Mask            */

#define GPIO_DBCTL_DBCLKSEL_Pos          (0)                                               /*!< GPIO_T::DBCTL: DBCLKSEL Position       */
#define GPIO_DBCTL_DBCLKSEL_Msk          (0xful << GPIO_DBCTL_DBCLKSEL_Pos)                /*!< GPIO_T::DBCTL: DBCLKSEL Mask           */

#define GPIO_DBCTL_DBCLKSRC_Pos          (4)                                               /*!< GPIO_T::DBCTL: DBCLKSRC Position       */
#define GPIO_DBCTL_DBCLKSRC_Msk          (0x1ul << GPIO_DBCTL_DBCLKSRC_Pos)                /*!< GPIO_T::DBCTL: DBCLKSRC Mask           */

#define GPIO_DBCTL_ICLKON_Pos            (5)                                               /*!< GPIO_T::DBCTL: ICLKON Position         */
#define GPIO_DBCTL_ICLKON_Msk            (0x1ul << GPIO_DBCTL_ICLKON_Pos)                  /*!< GPIO_T::DBCTL: ICLKON Mask             */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

#define GPIO_PDIO_PDIO_Pos               (0)                                               /*!< GPIO_T::PDIO: PDIO Position            */
#define GPIO_PDIO_PDIO_Msk               (0x1ul << GPIO_PDIO_PDIO_Pos)                     /*!< GPIO_T::PDIO: PDIO Mask                */

/**@}*/ /* GPIO_CONST */
/**@}*/ /* end of GPIO register group */


/*---------------------- Inter-IC Bus Controller -------------------------*/
/**
    @addtogroup I2C Inter-IC Bus Controller(I2C)
    Memory Mapped Structure for I2C Controller
@{ */
 
typedef struct
{


/**
 * @var I2C_T::CTL
 * Offset: 0x00  I2C Control Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[2]     |AA        |Assert Acknowledge Control
 * |        |          |When AA =1 prior to address or data is received, an acknowledged (low level to SDA) will be returned during the acknowledge clock pulse on the SCL line when 1.) A slave is acknowledging the address sent from master, 2.) The receiver devices are acknowledging the data sent by transmitter
 * |        |          |When AA=0 prior to address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse on the SCL line
 * |[3]     |SI        |I2C Interrupt Flag
 * |        |          |When a new I2C state is present in the I2C_STATUS register, the SI flag is set by hardware
 * |        |          |If bit INTEN (I2C_CTL [7]) is set, the I2C interrupt is requested
 * |        |          |SI must be cleared by software
 * |        |          |Clear SI by writing 1 to this bit.
 * |        |          |For ACKMEN is set in slave read mode, the SI flag is set in 8th clock period for user to confirm the acknowledge bit and 9th clock period for user to read the data in the data buffer.
 * |[4]     |STO       |I2C STOP Control
 * |        |          |In Master mode, setting STO to transmit a STOP condition to bus then I2C controller will check the bus condition if a STOP condition is detected
 * |        |          |This bit will be cleared by hardware automatically.
 * |[5]     |STA       |I2C START Control
 * |        |          |Setting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free
 * |        |          |This bit will be cleared by hardware automatically.
 * |[6]     |I2CEN     |I2C Controller Enable Bit
 * |        |          |Set to enable I2C serial function controller
 * |        |          |When I2CEN=1 the I2C serial function enable
 * |        |          |The multi-function pin function must set to SDA, and SCL of I2C function first.
 * |        |          |0 = I2C controller Disabled.
 * |        |          |1 = I2C controller Enabled.
 * |[7]     |INTEN     |Enable Interrupt
 * |        |          |0 = I2C interrupt Disabled.
 * |        |          |1 = I2C interrupt Enabled.
 * @var I2C_T::ADDR0
 * Offset: 0x04  I2C Slave Address Register0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |GC        |General Call Function
 * |        |          |0 = General Call Function Disabled.
 * |        |          |1 = General Call Function Enabled.
 * |[10:1]  |ADDR      |I2C Address
 * |        |          |The content of this register is irrelevant when I2C is in Master mode
 * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address
 * |        |          |The I2C hardware will react if either of the address is matched.
 * @var I2C_T::DAT
 * Offset: 0x08  I2C Data Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[7:0]   |DAT       |I2C Data
 * |        |          |Bit [7:0] is located with the 8-bit transferred/received data of I2C serial port.
 * @var I2C_T::STATUS
 * Offset: 0x0C  I2C Status Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[7:0]   |STATUS    |I2C Status
 * |        |          |The three least significant bits are always 0
 * |        |          |The five most significant bits contain the status code
 * |        |          |There are 28 possible status codes
 * |        |          |When the content of I2C_STATUS is F8H, no serial interrupt is requested
 * |        |          |Others I2C_STATUS values correspond to defined I2C states
 * |        |          |When each of these states is entered, a status interrupt is requested (SI = 1)
 * |        |          |A valid status code is present in I2C_STATUS one cycle after SI is set by hardware and is still present one cycle after SI has been reset by software
 * |        |          |In addition, states 00H stands for a Bus Error
 * |        |          |A Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame
 * |        |          |Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.
 * @var I2C_T::CLKDIV
 * Offset: 0x10  I2C Clock Divided Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[9:0]   |DIVIDER   |I2C Clock Divided
 * |        |          |Indicates the I2C clock rate: Data Baud Rate of I2C = (system clock) / (4x (I2C_CLKDIV+1)).
 * |        |          |Note: The minimum value of I2C_CLKDIV is 4.
 * @var I2C_T::TOCTL
 * Offset: 0x14  I2C Time-out Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |TOIF      |Time-out Flag
 * |        |          |This bit is set by hardware when I2C time-out happened and it can interrupt CPU if I2C interrupt enable bit (INTEN) is set to 1.
 * |        |          |Note: Software can write 1 to clear this bit.
 * |[1]     |TOCDIV4   |Time-out Counter Input Clock Divided by 4
 * |        |          |When Enabled, The time-out period is extend 4 times.
 * |        |          |0 = Time-out period is extend 4 times Disabled.
 * |        |          |1 = Time-out period is extend 4 times Enabled.
 * |[2]     |TOCEN     |Time-out Counter Enable Bit
 * |        |          |When Enabled, the 14-bit time-out counter will start counting when SI is clear
 * |        |          |Setting flag SI to '1' will reset counter and re-start up counting after SI is cleared.
 * |        |          |0 = Time-out counter Disabled.
 * |        |          |1 = Time-out counter Enabled.
 * @var I2C_T::ADDR1
 * Offset: 0x18  I2C Slave Address Register1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |GC        |General Call Function
 * |        |          |0 = General Call Function Disabled.
 * |        |          |1 = General Call Function Enabled.
 * |[10:1]  |ADDR      |I2C Address
 * |        |          |The content of this register is irrelevant when I2C is in Master mode
 * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address
 * |        |          |The I2C hardware will react if either of the address is matched.
 * @var I2C_T::ADDR2
 * Offset: 0x1C  I2C Slave Address Register2
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |GC        |General Call Function
 * |        |          |0 = General Call Function Disabled.
 * |        |          |1 = General Call Function Enabled.
 * |[10:1]  |ADDR      |I2C Address
 * |        |          |The content of this register is irrelevant when I2C is in Master mode
 * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address
 * |        |          |The I2C hardware will react if either of the address is matched.
 * @var I2C_T::ADDR3
 * Offset: 0x20  I2C Slave Address Register3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |GC        |General Call Function
 * |        |          |0 = General Call Function Disabled.
 * |        |          |1 = General Call Function Enabled.
 * |[10:1]  |ADDR      |I2C Address
 * |        |          |The content of this register is irrelevant when I2C is in Master mode
 * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address
 * |        |          |The I2C hardware will react if either of the address is matched.
 * @var I2C_T::ADDRMSK0
 * Offset: 0x24  I2C Slave Address Mask Register0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[10:1]  |ADDRMSK   |I2C Address Mask
 * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
 * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
 * |        |          |I2C bus controllers support multiple address recognition with four address mask register
 * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care
 * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
 * @var I2C_T::ADDRMSK1
 * Offset: 0x28  I2C Slave Address Mask Register1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[10:1]  |ADDRMSK   |I2C Address Mask
 * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
 * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
 * |        |          |I2C bus controllers support multiple address recognition with four address mask register
 * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care
 * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
 * @var I2C_T::ADDRMSK2
 * Offset: 0x2C  I2C Slave Address Mask Register2
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[10:1]  |ADDRMSK   |I2C Address Mask
 * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
 * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
 * |        |          |I2C bus controllers support multiple address recognition with four address mask register
 * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care
 * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
 * @var I2C_T::ADDRMSK3
 * Offset: 0x30  I2C Slave Address Mask Register3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[10:1]  |ADDRMSK   |I2C Address Mask
 * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
 * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
 * |        |          |I2C bus controllers support multiple address recognition with four address mask register
 * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care
 * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
 * @var I2C_T::WKCTL
 * Offset: 0x3C  I2C Wake-up Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |WKEN      |I2C Wake-up Enable Bit
 * |        |          |0 = I2C wake-up function Disabled.
 * |        |          |1= I2C wake-up function Enabled.
 * |[7]     |NHDBUSEN  |I2C No Hold BUS Enable Bit
 * |        |          |0 = I2C don't hold bus after wake-up disable.
 * |        |          |1= I2C don't hold bus after wake-up enable.
 * |        |          |Note: I2C controller could response when WKIF event is not clear, it may cause error data transmitted or received
 * |        |          |If data transmitted or received when WKIF event is not clear, user must reset I2C controller and execute the original operation again.
 * @var I2C_T::WKSTS
 * Offset: 0x40  I2C Wake-up Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |WKIF      |I2C Wake-up Flag
 * |        |          |When chip is woken up from Power-down mode by I2C, this bit is set to 1
 * |        |          |Software can write 1 to clear this bit.
 * |[1]     |WKAKDONE  |Wakeup Address Frame Acknowledge Bit Done
 * |        |          |0 = The ACK bit cycle of address match frame isn't done.
 * |        |          |1 = The ACK bit cycle of address match frame is done in power-down.
 * |        |          |Note: This bit can't release WKIF. Software can write 1 to clear this bit.
 * |[2]     |WRSTSWK   |Read/Write Status Bit in Address Wakeup Frame
 * |        |          |0 = Write command be record on the address match wakeup frame.
 * |        |          |1 = Read command be record on the address match wakeup frame.
 * |        |          |Note: This bit will be cleared when software can write 1 to WKAKDONE bit.
 * @var I2C_T::CTL1
 * Offset: 0x44  I2C Control Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |TXPDMAEN  |PDMA Transmit Channel Available
 * |        |          |0 = Transmit PDMA function disable.
 * |        |          |1 = Transmit PDMA function enable. 
 * |[1]     |RXPDMAEN  |PDMA Receive Channel Available
 * |        |          |0 = Receive PDMA function disable.
 * |        |          |1 = Receive PDMA function enable. 
 * |[2]     |PDMARST   |PDMA Reset
 * |        |          |0 = No effect.
 * |        |          |1 = Reset the I2C request to PDMA. This bit will be cleared to 0 automatically. 
 * |[3]     |OVRIEN    |I2C over Run Interrupt Control Bit
 * |        |          |Setting OVRIEN to logic 1 will send a interrupt to system when the TWOFF bit is enabled and there is over run event in received buffer.
 * |[4]     |UDRIEN    |I2C Under Run Interrupt Control Bit
 * |        |          |Setting UDRIEN to logic 1 will send a interrupt to system when the TWOFF bit is enabled and there is under run event happened in transmitted buffer.
 * |[5]     |TWOBUFEN  |Two-level BUFFER Enable Bit
 * |        |          |0 = Two-level buffer Disabled.
 * |        |          |1 = Two-level buffer Enabled.
 * |        |          |Set to enable the two-level buffer for I2C transmitted or received buffer
 * |        |          |It is used to improve the performance of the I2C bus
 * |        |          |If this bit is set = 1, the control bit of STA for repeat start or STO bit should be set after the current SI is clear
 * |        |          |For example: if there are 4 data shall be transmitted and then stop it
 * |        |          |The STO bit shall be set after the 3rd data's SI event being clear
 * |        |          |In this time, the 4th data can be transmitted and the I2C stop after the 4th data transmission done.
 * |[6]     |BUFRST    |Two-level BUFFER Reset
 * |        |          |0 = No effect.
 * |        |          |1 = Reset the related counters, two-level buffer state machine, and the content of data buffer.
 * |[7]     |NSTRETCH  |No Stretch on the I2C Bus
 * |        |          |0 = The I2C SCL bus is stretched by hardware if the SI is not cleared in master mode.
 * |        |          |1 = The I2C SCL bus is not stretched by hardware if the SI is not cleared in master mode.
 * |[8]     |PDMASTR   |PDMA Stretch Bit
 * |        |          |0 = I2C send STOP automatically after PDMA transfer done. (only master TX)
 * |        |          |1 = I2C SCL bus is stretched by hardware after PDMA transfer done if the SI is not cleared
 * |        |          |(only master TX)
 * |[9]     |ADDR10EN  |Address 10-bit Function Enable
 * |        |          |0 = Address match 10-bit function is disabled.
 * |        |          |1 = Address match 10-bit function is enabled. 
 * @var I2C_T::STATUS1
 * Offset: 0x48  I2C Status Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ADMAT0    |I2C Address 0 Match Status Register
 * |        |          |When address 0 is matched, hardware will inform which address used
 * |        |          |This bit will set to 1, and software can write 1 to clear this bit.
 * |[1]     |ADMAT1    |I2C Address 1 Match Status Register
 * |        |          |When address 1 is matched, hardware will inform which address used
 * |        |          |This bit will set to 1, and software can write 1 to clear this bit.
 * |[2]     |ADMAT2    |I2C Address 2 Match Status Register
 * |        |          |When address 2 is matched, hardware will inform which address used
 * |        |          |This bit will set to 1, and software can write 1 to clear this bit.
 * |[3]     |ADMAT3    |I2C Address 3 Match Status Register
 * |        |          |When address 3 is matched, hardware will inform which address used
 * |        |          |This bit will set to 1, and software can write 1 to clear this bit.
 * |[4]     |FULL      |TWO-lEVEL BUFFER FULL
 * |        |          |This bit indicates two-level buffer TX or RX full or not when the TWOBUFEN = 1.
 * |        |          |This bit is set when POINTER is equal to 2
 * |        |          |Note:This bit is read only.
 * |[5]     |EMPTY     |TWO-lEVEL BUFFER EMPTY
 * |        |          |This bit indicates two-level buffer TX or RX empty or not when the TWOBUFEN = 1.
 * |        |          |This bit is set when POINTER is equal to 0.
 * |        |          |Note:This bit is read only.
 * |[6]     |OVR       |I2C over Run Status Bit
 * |        |          |This bit indicates the received two-level buffer TX or RX is over run when the TWOBUFEN = 1.
 * |        |          |Note:This bit is read only.
 * |[7]     |UDR       |I2C Under Run Status Bit
 * |        |          |This bit indicates the transmitted two-level buffer TX or RX is under run when the TWOBUFEN = 1.
 * |        |          |Note:This bit is read only.
 * |[8]     |ONBUSY    |On Bus Busy
 * |        |          |Indicates that a communication is in progress on the bus
 * |        |          |It is set by hardware when a START condition is detected
 * |        |          |It is cleared by hardware when a STOP condition is detected.
 * |        |          |0 = The bus is IDLE (both SCLK and SDA High).
 * |        |          |1 = The bus is busy.
 * |        |          |Note:This bit is read only.
 * @var I2C_T::TMCTL
 * Offset: 0x4C  I2C Timing Configure Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[5:0]   |STCTL     |Setup Time Configure Control Register
 * |        |          |This field is used to generate a delay timing between SDA falling edge and SCL rising edge in transmission mode.
 * |        |          |The delay setup time is numbers of peripheral clock = STCTL x PCLK.
 * |        |          |Note: Setup time setting should not make SCL output less than three PCLKs.
 * |[11:6]  |HTCTL     |Hold Time Configure Control Register
 * |        |          |This field is used to generate the delay timing between SCL falling edge and SDA rising edge in transmission mode.
 * |        |          |The delay hold time is numbers of peripheral clock = HTCTL x PCLK.
 * @var I2C_T::BUSCTL
 * Offset: 0x50  I2C Bus Management Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ACKMEN    |Acknowledge Control by Manual
 * |        |          |In order to allow ACK control in slave reception including the command and data, slave byte control mode must be enabled by setting the ACKMEN bit.
 * |        |          |0 = Slave byte control Disabled.
 * |        |          |1 = Slave byte control Enabled
 * |        |          |The 9th bit can response the ACK or NACK according the received data by user
 * |        |          |When the byte is received, stretching the SCLK signal low between the 8th and 9th SCLK pulse.
 * |        |          |Note: If the BMDEN =1 and this bit is enabled, the information of I2C_STATUS will be fixed as 0xF0 in slave receive condition.
 * |[1]     |PECEN     |Packet Error Checking Calculation Enable Bit
 * |        |          |0 = Packet Error Checking Calculation Disabled.
 * |        |          |1 = Packet Error Checking Calculation Enabled.
 * |[2]     |BMDEN     |Bus Management Device Default Address Enable Bit
 * |        |          |0 = Device default address Disable
 * |        |          |When the address 0'b1100001x coming and the both of BMDEN and ACKMEN are enabled, the device responses NACKed
 * |        |          |1 = Device default address Enabled
 * |        |          |When the address 0'b1100001x coming and the both of BMDEN and ACKMEN are enabled, the device responses ACKed.
 * |[3]     |BMHEN     |Bus Management Host Enable Bit
 * |        |          |0 = Host function Disabled.
 * |        |          |1 = Host function Enabled.
 * |[4]     |ALERTEN   |Bus Management Alert Enable Bit
 * |        |          |Device Mode (BMHEN =0).
 * |        |          |0 = Release the I2Cn_SMBAL pin high and Alert Response Header disabled: 0001100x followed by NACK if both of BMDEN and ACKMEN are enabled.
 * |        |          |1 = Drive I2Cn_SMBAL pin low and Alert Response Address Header enables: 0001100x followed by ACK if both of BMDEN and ACKMEN are enabled.
 * |        |          |Host Mode (BMHEN =1).
 * |        |          |0 = I2Cn_SMBAL pin not supported.
 * |        |          |1 = I2Cn_SMBAL pin supported.
 * |[5]     |SCTLOSTS  |Suspend/Control Data Output Status
 * |        |          |0 = The output of I2Cn_SMBSUS pin is low.
 * |        |          |1 = The output of I2Cn_SMBSUS pin is high.
 * |[6]     |SCTLOEN   |Suspend or Control Pin Output Enable Bit
 * |        |          |0 = The I2Cn_SMBSUS pin in input.
 * |        |          |1 = The output enable is active on the I2Cn_SMBSUS pin.
 * |[7]     |BUSEN     |BUS Enable Bit
 * |        |          |0 = The system management function is Disabled.
 * |        |          |1 = The system management function is Enable.
 * |        |          |Note: When the bit is enabled, the internal 14-bit counter is used to calculate the time out event of clock low condition.
 * |[8]     |PECTXEN   |Packet Error Checking Byte Transmission/Reception
 * |        |          |0 = No PEC transfer.
 * |        |          |1 = PEC transmission is requested.
 * |        |          |Note: 1.This bit has no effect in slave mode when ACKMEN =0.
 * |[9]     |TIDLE     |Timer Check in Idle State
 * |        |          |The BUSTOUT is used to calculate the time-out of clock low in bus active and the idle period in bus Idle
 * |        |          |This bit is used to define which condition is enabled.
 * |        |          |0 = The BUSTOUT is used to calculate the clock low period in bus active.
 * |        |          |1 = The BUSTOUT is used to calculate the IDLE period in bus Idle.
 * |        |          |Note: The BUSY (I2C_BUSSTS[0]) indicate the current bus state.
 * |[10]    |PECCLR    |PEC Clear at Repeat Start
 * |        |          |The calculation of PEC starts when PECEN is set to 1 and it is clear when the STA or STO bit is detected
 * |        |          |This PECCLR bit is used to enable the condition of REPEAT START can clear the PEC calculation.
 * |        |          |0 = The PEC calculation is cleared by ...Repeat Startu201D function is Disabled.
 * |        |          |1 = The PEC calculation is cleared by ...Repeat Startu201D function is Enabled.
 * |[11]    |ACKM9SI   |Acknowledge Manual Enable Extra SI Interrupt
 * |        |          |0 = There is no SI interrupt in the 9th clock cycle when the BUSEN =1 and ACKMEN =1.
 * |        |          |1 = There is SI interrupt in the 9th clock cycle when the BUSEN =1 and ACKMEN =1. 
 * |[12]    |BCDIEN    |Packet Error Checking Byte Count Done Interrupt Enable Bit
 * |        |          |0 = Indicates the byte count done interrupt is Disabled.
 * |        |          |1 = Indicates the byte count done interrupt is Enabled.
 * |        |          |Note: This bit is used in PECEN =1.
 * |[13]    |PECDIEN   |Packet Error Checking Byte Transfer Done Interrupt Enable Bit
 * |        |          |0 = Indicates the PEC transfer done interrupt is Disabled.
 * |        |          |1 = Indicates the PEC transfer done interrupt is Enabled.
 * |        |          |Note: This bit is used in PECEN =1.
 * @var I2C_T::BUSTCTL
 * Offset: 0x54  I2C Bus Management Timer Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BUSTOEN   |Bus Time Out Enable Bit
 * |        |          |0 = Indicates the bus clock low time-out detection is Disabled.
 * |        |          |1 = Indicates the bus clock low time-out detection is Enabled (bus clock is low for more than TTime-out (in BIDLE=0) or high more than TTime-out(in BIDLE =1)
 * |[1]     |CLKTOEN   |Cumulative Clock Low Time Out Enable Bit
 * |        |          |0 = Indicates the cumulative clock low time-out detection is Disabled.
 * |        |          |1 = Indicates the cumulative clock low time-out detection is Enabled.
 * |        |          |For Master, it calculates the period from START to ACK
 * |        |          |For Slave, it calculates the period from START to STOP
 * |[2]     |BUSTOIEN  |Time-out Interrupt Enable Bit
 * |        |          |BUSY =1.
 * |        |          |0 = Indicates the SCLK low time-out interrupt is Disabled.
 * |        |          |1 = Indicates the SCLK low time-out interrupt is Enabled.
 * |        |          |BUSY =0.
 * |        |          |0 = Indicates the bus IDLE time-out interrupt is Disabled.
 * |        |          |1 = Indicates the bus IDLE time-out interrupt is Enabled.
 * |[3]     |CLKTOIEN  |Extended Clock Time Out Interrupt Enable Bit
 * |        |          |0 = Indicates the clock time out interrupt is Disabled.
 * |        |          |1 = Indicates the clock time out interrupt is Enabled.
 * |[4]     |TORSTEN   |Time Out Reset Enable Bit
 * |        |          |0 = Indicates the I2C state machine reset is Disable.
 * |        |          |1 = Indicates the I2C state machine reset is Enable. (The clock and data bus will be released to high)
 * @var I2C_T::BUSSTS
 * Offset: 0x58  I2C Bus Management Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BUSY      |Bus Busy
 * |        |          |Indicates that a communication is in progress on the bus
 * |        |          |It is set by hardware when a START condition is detected
 * |        |          |It is cleared by hardware when a STOP condition is detected
 * |        |          |0 = The bus is IDLE (both SCLK and SDA High).
 * |        |          |1 = The bus is busy.
 * |[1]     |BCDONE    |Byte Count Transmission/Receive Done
 * |        |          |0 = Indicates the byte count transmission/ receive is not finished when the PECEN is set.
 * |        |          |1 = Indicates the byte count transmission/ receive is finished when the PECEN is set.
 * |        |          |Note: Software can write 1 to clear this bit.
 * |[2]     |PECERR    |PEC Error in Reception
 * |        |          |0 = Indicates the PEC value equal the received PEC data packet.
 * |        |          |1 = Indicates the PEC value doesn't match the receive PEC data packet.
 * |        |          |Note: Software can write 1 to clear this bit.
 * |[3]     |ALERT     |SMBus Alert Status
 * |        |          |Device Mode (BMHEN =0).
 * |        |          |0 = Indicates I2Cn_SMBAL pin state is low.
 * |        |          |1 = Indicates I2Cn_SMBAL pin state is high.
 * |        |          |Host Mode (BMHEN =1).
 * |        |          |0 = No SMBALERT event.
 * |        |          |1 = Indicates there is SMBALERT event (falling edge) is detected in I2Cn_SMBAL pin when the BMHEN = 1 (SMBus host configuration) and the ALERTEN = 1.
 * |        |          |Note: 1
 * |        |          |The I2Cn_SMBAL pin is an open-drain pin, the pull-high resistor is must in the system
 * |        |          |2
 * |        |          |Software can write 1 to clear this bit.
 * |[4]     |SCTLDIN   |Bus Suspend or Control Signal Input Status
 * |        |          |0 = The input status of I2Cn_SMBSUS pin is 0.
 * |        |          |1 = The input status of I2Cn_SMBSUS pin is 1.
 * |[5]     |BUSTO     |Bus Time-out Status
 * |        |          |0 = Indicates that there is no any time-out or external clock time-out.
 * |        |          |1 = Indicates that a time-out or external clock time-out occurred.
 * |        |          |In bus busy, the bit indicates the total clock low time-out event occurred otherwise, it indicates the bus idle time-out event occurred.
 * |        |          |Note: Software can write 1 to clear this bit.
 * |[6]     |CLKTO     |Clock Low Cumulate Time-out Status
 * |        |          |0 = Indicates that the cumulative clock low is no any time-out.
 * |        |          |1 = Indicates that the cumulative clock low time-out occurred.
 * |        |          |Note: Software can write 1 to clear this bit.
 * |[7]     |PECDONE   |PEC Byte Transmission/Receive Done
 * |        |          |0 = Indicates the PEC transmission/ receive is not finished when the PECEN is set.
 * |        |          |1 = Indicates the PEC transmission/ receive is finished when the PECEN is set.
 * |        |          |Note: Software can write 1 to clear this bit.
 * @var I2C_T::PKTSIZE
 * Offset: 0x5C  I2C Packet Error Checking Byte Number Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:0]   |PLDSIZE   |Transfer Byte Number
 * |        |          |The transmission or receive byte number in one transaction when the PECEN is set
 * |        |          |The maximum transaction or receive byte is 256 Bytes.
 * |        |          |Notice: The byte number counting includes address, command code, and data frame.
 * @var I2C_T::PKTCRC
 * Offset: 0x60  I2C Packet Error Checking Byte Value Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[7:0]   |PECCRC    |Packet Error Checking Byte Value
 * |        |          |This byte indicates the packet error checking content after transmission or receive byte count by using the C(x) = X8 + X2 + X + 1
 * |        |          |It is read only.
 * @var I2C_T::BUSTOUT
 * Offset: 0x64  I2C Bus Management Timer Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[7:0]   |BUSTO     |Bus Management Time-out Value
 * |        |          |Indicate the bus time-out value in bus is IDLE or SCLK low.
 * |        |          |Note: If the user wants to revise the value of BUSTOUT, the TORSTEN (I2C_BUSTCTL[4]) bit shall be set to 1 and clear to 0 first in the BUSEN(I2C_BUSCTL[7]) is set.
 * @var I2C_T::CLKTOUT
 * Offset: 0x68  I2C Bus Management Clock Low Timer Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[7:0]   |CLKTO     |Bus Clock Low Timer
 * |        |          |The field is used to configure the cumulative clock extension time-out.
 * |        |          |Note: If the user wants to revise the value of CLKLTOUT, the TORSTEN bit shall be set to 1 and clear to 0 first in the BUSEN is set.
 * @var I2C_T::VERSION
 * Offset: 0xFFC  I2C Version Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |MINOR     |I2C RTL Design MINOR Version Number
 * |        |          |Minor version number is dependent on ECO version control
 * |        |          |0x0000: (current Minor Version Number)
 * |[23:16] |SUB       |I2C RTL Design MINOR Version Number
 * |        |          |Sub version number is relative to key feature
 * |        |          |0x02: (current Sub Version Number) u2013add SMBUS
 * |[31:24] |MAJOR     |I2C RTL Design MAJOR Version Number
 * |        |          |Major version number is correlated to Product Line
 * |        |          |0x02: (current Major Version Number)
 */
    __IO uint32_t CTL;                   /*!< [0x0000] I2C Control Register 0                                           */
    __IO uint32_t ADDR0;                 /*!< [0x0004] I2C Slave Address Register0                                      */
    __IO uint32_t DAT;                   /*!< [0x0008] I2C Data Register                                                */
    __I  uint32_t STATUS;                /*!< [0x000c] I2C Status Register 0                                            */
    __IO uint32_t CLKDIV;                /*!< [0x0010] I2C Clock Divided Register                                       */
    __IO uint32_t TOCTL;                 /*!< [0x0014] I2C Time-out Control Register                                    */
    __IO uint32_t ADDR1;                 /*!< [0x0018] I2C Slave Address Register1                                      */
    __IO uint32_t ADDR2;                 /*!< [0x001c] I2C Slave Address Register2                                      */
    __IO uint32_t ADDR3;                 /*!< [0x0020] I2C Slave Address Register3                                      */
    __IO uint32_t ADDRMSK0;              /*!< [0x0024] I2C Slave Address Mask Register0                                 */
    __IO uint32_t ADDRMSK1;              /*!< [0x0028] I2C Slave Address Mask Register1                                 */
    __IO uint32_t ADDRMSK2;              /*!< [0x002c] I2C Slave Address Mask Register2                                 */
    __IO uint32_t ADDRMSK3;              /*!< [0x0030] I2C Slave Address Mask Register3                                 */
    __I  uint32_t RESERVE0[2];
    __IO uint32_t WKCTL;                 /*!< [0x003c] I2C Wake-up Control Register                                     */
    __IO uint32_t WKSTS;                 /*!< [0x0040] I2C Wake-up Status Register                                      */
    __IO uint32_t CTL1;                  /*!< [0x0044] I2C Control Register 1                                           */
    __IO uint32_t STATUS1;               /*!< [0x0048] I2C Status Register 1                                            */
    __IO uint32_t TMCTL;                 /*!< [0x004c] I2C Timing Configure Control Register                            */
    __IO uint32_t BUSCTL;                /*!< [0x0050] I2C Bus Management Control Register                              */
    __IO uint32_t BUSTCTL;               /*!< [0x0054] I2C Bus Management Timer Control Register                        */
    __IO uint32_t BUSSTS;                /*!< [0x0058] I2C Bus Management Status Register                               */
    __IO uint32_t PKTSIZE;               /*!< [0x005c] I2C Packet Error Checking Byte Number Register                   */
    __I  uint32_t PKTCRC;                /*!< [0x0060] I2C Packet Error Checking Byte Value Register                    */
    __IO uint32_t BUSTOUT;               /*!< [0x0064] I2C Bus Management Timer Register                                */
    __IO uint32_t CLKTOUT;               /*!< [0x0068] I2C Bus Management Clock Low Timer Register                      */
    __I  uint32_t RESERVE1[996];
    __I  uint32_t VERSION;               /*!< [0x0ffc] I2C Version Control Register                                     */

} I2C_T;

/**
    @addtogroup I2C_CONST I2C Bit Field Definition
    Constant Definitions for I2C Controller
@{ */

#define I2C_CTL_AA_Pos                   (2)                                               /*!< I2C_T::CTL: AA Position                */
#define I2C_CTL_AA_Msk                   (0x1ul << I2C_CTL_AA_Pos)                         /*!< I2C_T::CTL: AA Mask                    */

#define I2C_CTL_SI_Pos                   (3)                                               /*!< I2C_T::CTL: SI Position                */
#define I2C_CTL_SI_Msk                   (0x1ul << I2C_CTL_SI_Pos)                         /*!< I2C_T::CTL: SI Mask                    */

#define I2C_CTL_STO_Pos                  (4)                                               /*!< I2C_T::CTL: STO Position               */
#define I2C_CTL_STO_Msk                  (0x1ul << I2C_CTL_STO_Pos)                        /*!< I2C_T::CTL: STO Mask                   */

#define I2C_CTL_STA_Pos                  (5)                                               /*!< I2C_T::CTL: STA Position               */
#define I2C_CTL_STA_Msk                  (0x1ul << I2C_CTL_STA_Pos)                        /*!< I2C_T::CTL: STA Mask                   */

#define I2C_CTL_I2CEN_Pos                (6)                                               /*!< I2C_T::CTL: I2CEN Position             */
#define I2C_CTL_I2CEN_Msk                (0x1ul << I2C_CTL_I2CEN_Pos)                      /*!< I2C_T::CTL: I2CEN Mask                 */

#define I2C_CTL_INTEN_Pos                (7)                                               /*!< I2C_T::CTL: INTEN Position             */
#define I2C_CTL_INTEN_Msk                (0x1ul << I2C_CTL_INTEN_Pos)                      /*!< I2C_T::CTL: INTEN Mask                 */

#define I2C_ADDR0_GC_Pos                 (0)                                               /*!< I2C_T::ADDR0: GC Position              */
#define I2C_ADDR0_GC_Msk                 (0x1ul << I2C_ADDR0_GC_Pos)                       /*!< I2C_T::ADDR0: GC Mask                  */

#define I2C_ADDR0_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR0: ADDR Position            */
#define I2C_ADDR0_ADDR_Msk               (0x3fful << I2C_ADDR0_ADDR_Pos)                   /*!< I2C_T::ADDR0: ADDR Mask                */

#define I2C_DAT_DAT_Pos                  (0)                                               /*!< I2C_T::DAT: DAT Position               */
#define I2C_DAT_DAT_Msk                  (0xfful << I2C_DAT_DAT_Pos)                       /*!< I2C_T::DAT: DAT Mask                   */

#define I2C_STATUS_STATUS_Pos            (0)                                               /*!< I2C_T::STATUS: STATUS Position         */
#define I2C_STATUS_STATUS_Msk            (0xfful << I2C_STATUS_STATUS_Pos)                 /*!< I2C_T::STATUS: STATUS Mask             */

#define I2C_CLKDIV_DIVIDER_Pos           (0)                                               /*!< I2C_T::CLKDIV: DIVIDER Position        */
#define I2C_CLKDIV_DIVIDER_Msk           (0x3fful << I2C_CLKDIV_DIVIDER_Pos)               /*!< I2C_T::CLKDIV: DIVIDER Mask            */

#define I2C_TOCTL_TOIF_Pos               (0)                                               /*!< I2C_T::TOCTL: TOIF Position            */
#define I2C_TOCTL_TOIF_Msk               (0x1ul << I2C_TOCTL_TOIF_Pos)                     /*!< I2C_T::TOCTL: TOIF Mask                */

#define I2C_TOCTL_TOCDIV4_Pos            (1)                                               /*!< I2C_T::TOCTL: TOCDIV4 Position         */
#define I2C_TOCTL_TOCDIV4_Msk            (0x1ul << I2C_TOCTL_TOCDIV4_Pos)                  /*!< I2C_T::TOCTL: TOCDIV4 Mask             */

#define I2C_TOCTL_TOCEN_Pos              (2)                                               /*!< I2C_T::TOCTL: TOCEN Position           */
#define I2C_TOCTL_TOCEN_Msk              (0x1ul << I2C_TOCTL_TOCEN_Pos)                    /*!< I2C_T::TOCTL: TOCEN Mask               */

#define I2C_ADDR1_GC_Pos                 (0)                                               /*!< I2C_T::ADDR1: GC Position              */
#define I2C_ADDR1_GC_Msk                 (0x1ul << I2C_ADDR1_GC_Pos)                       /*!< I2C_T::ADDR1: GC Mask                  */

#define I2C_ADDR1_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR1: ADDR Position            */
#define I2C_ADDR1_ADDR_Msk               (0x3fful << I2C_ADDR1_ADDR_Pos)                   /*!< I2C_T::ADDR1: ADDR Mask                */

#define I2C_ADDR2_GC_Pos                 (0)                                               /*!< I2C_T::ADDR2: GC Position              */
#define I2C_ADDR2_GC_Msk                 (0x1ul << I2C_ADDR2_GC_Pos)                       /*!< I2C_T::ADDR2: GC Mask                  */

#define I2C_ADDR2_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR2: ADDR Position            */
#define I2C_ADDR2_ADDR_Msk               (0x3fful << I2C_ADDR2_ADDR_Pos)                   /*!< I2C_T::ADDR2: ADDR Mask                */

#define I2C_ADDR3_GC_Pos                 (0)                                               /*!< I2C_T::ADDR3: GC Position              */
#define I2C_ADDR3_GC_Msk                 (0x1ul << I2C_ADDR3_GC_Pos)                       /*!< I2C_T::ADDR3: GC Mask                  */

#define I2C_ADDR3_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR3: ADDR Position            */
#define I2C_ADDR3_ADDR_Msk               (0x3fful << I2C_ADDR3_ADDR_Pos)                   /*!< I2C_T::ADDR3: ADDR Mask                */

#define I2C_ADDRMSK0_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK0: ADDRMSK Position      */
#define I2C_ADDRMSK0_ADDRMSK_Msk         (0x3fful << I2C_ADDRMSK0_ADDRMSK_Pos)             /*!< I2C_T::ADDRMSK0: ADDRMSK Mask          */

#define I2C_ADDRMSK1_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK1: ADDRMSK Position      */
#define I2C_ADDRMSK1_ADDRMSK_Msk         (0x3fful << I2C_ADDRMSK1_ADDRMSK_Pos)             /*!< I2C_T::ADDRMSK1: ADDRMSK Mask          */

#define I2C_ADDRMSK2_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK2: ADDRMSK Position      */
#define I2C_ADDRMSK2_ADDRMSK_Msk         (0x3fful << I2C_ADDRMSK2_ADDRMSK_Pos)             /*!< I2C_T::ADDRMSK2: ADDRMSK Mask          */

#define I2C_ADDRMSK3_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK3: ADDRMSK Position      */
#define I2C_ADDRMSK3_ADDRMSK_Msk         (0x3fful << I2C_ADDRMSK3_ADDRMSK_Pos)             /*!< I2C_T::ADDRMSK3: ADDRMSK Mask          */

#define I2C_WKCTL_WKEN_Pos               (0)                                               /*!< I2C_T::WKCTL: WKEN Position            */
#define I2C_WKCTL_WKEN_Msk               (0x1ul << I2C_WKCTL_WKEN_Pos)                     /*!< I2C_T::WKCTL: WKEN Mask                */

#define I2C_WKCTL_NHDBUSEN_Pos           (7)                                               /*!< I2C_T::WKCTL: NHDBUSEN Position        */
#define I2C_WKCTL_NHDBUSEN_Msk           (0x1ul << I2C_WKCTL_NHDBUSEN_Pos)                 /*!< I2C_T::WKCTL: NHDBUSEN Mask            */

#define I2C_WKSTS_WKIF_Pos               (0)                                               /*!< I2C_T::WKSTS: WKIF Position            */
#define I2C_WKSTS_WKIF_Msk               (0x1ul << I2C_WKSTS_WKIF_Pos)                     /*!< I2C_T::WKSTS: WKIF Mask                */

#define I2C_WKSTS_WKAKDONE_Pos           (1)                                               /*!< I2C_T::WKSTS: WKAKDONE Position        */
#define I2C_WKSTS_WKAKDONE_Msk           (0x1ul << I2C_WKSTS_WKAKDONE_Pos)                 /*!< I2C_T::WKSTS: WKAKDONE Mask            */

#define I2C_WKSTS_WRSTSWK_Pos            (2)                                               /*!< I2C_T::WKSTS: WRSTSWK Position         */
#define I2C_WKSTS_WRSTSWK_Msk            (0x1ul << I2C_WKSTS_WRSTSWK_Pos)                  /*!< I2C_T::WKSTS: WRSTSWK Mask             */

#define I2C_CTL1_TXPDMAEN_Pos            (0)                                               /*!< I2C_T::CTL1: TXPDMAEN Position         */
#define I2C_CTL1_TXPDMAEN_Msk            (0x1ul << I2C_CTL1_TXPDMAEN_Pos)                  /*!< I2C_T::CTL1: TXPDMAEN Mask             */

#define I2C_CTL1_RXPDMAEN_Pos            (1)                                               /*!< I2C_T::CTL1: RXPDMAEN Position         */
#define I2C_CTL1_RXPDMAEN_Msk            (0x1ul << I2C_CTL1_RXPDMAEN_Pos)                  /*!< I2C_T::CTL1: RXPDMAEN Mask             */

#define I2C_CTL1_PDMARST_Pos             (2)                                               /*!< I2C_T::CTL1: PDMARST Position          */
#define I2C_CTL1_PDMARST_Msk             (0x1ul << I2C_CTL1_PDMARST_Pos)                   /*!< I2C_T::CTL1: PDMARST Mask              */

#define I2C_CTL1_OVRIEN_Pos              (3)                                               /*!< I2C_T::CTL1: OVRIEN Position           */
#define I2C_CTL1_OVRIEN_Msk              (0x1ul << I2C_CTL1_OVRIEN_Pos)                    /*!< I2C_T::CTL1: OVRIEN Mask               */

#define I2C_CTL1_UDRIEN_Pos              (4)                                               /*!< I2C_T::CTL1: UDRIEN Position           */
#define I2C_CTL1_UDRIEN_Msk              (0x1ul << I2C_CTL1_UDRIEN_Pos)                    /*!< I2C_T::CTL1: UDRIEN Mask               */

#define I2C_CTL1_TWOBUFEN_Pos            (5)                                               /*!< I2C_T::CTL1: TWOBUFEN Position         */
#define I2C_CTL1_TWOBUFEN_Msk            (0x1ul << I2C_CTL1_TWOBUFEN_Pos)                  /*!< I2C_T::CTL1: TWOBUFEN Mask             */

#define I2C_CTL1_BUFRST_Pos              (6)                                               /*!< I2C_T::CTL1: BUFRST Position           */
#define I2C_CTL1_BUFRST_Msk              (0x1ul << I2C_CTL1_BUFRST_Pos)                    /*!< I2C_T::CTL1: BUFRST Mask               */

#define I2C_CTL1_NSTRETCH_Pos            (7)                                               /*!< I2C_T::CTL1: NSTRETCH Position         */
#define I2C_CTL1_NSTRETCH_Msk            (0x1ul << I2C_CTL1_NSTRETCH_Pos)                  /*!< I2C_T::CTL1: NSTRETCH Mask             */

#define I2C_CTL1_PDMASTR_Pos             (8)                                               /*!< I2C_T::CTL1: PDMASTR Position          */
#define I2C_CTL1_PDMASTR_Msk             (0x1ul << I2C_CTL1_PDMASTR_Pos)                   /*!< I2C_T::CTL1: PDMASTR Mask              */

#define I2C_CTL1_ADDR10EN_Pos            (9)                                               /*!< I2C_T::CTL1: ADDR10EN Position         */
#define I2C_CTL1_ADDR10EN_Msk            (0x1ul << I2C_CTL1_ADDR10EN_Pos)                  /*!< I2C_T::CTL1: ADDR10EN Mask             */

#define I2C_STATUS1_ADMAT0_Pos           (0)                                               /*!< I2C_T::STATUS1: ADMAT0 Position        */
#define I2C_STATUS1_ADMAT0_Msk           (0x1ul << I2C_STATUS1_ADMAT0_Pos)                 /*!< I2C_T::STATUS1: ADMAT0 Mask            */

#define I2C_STATUS1_ADMAT1_Pos           (1)                                               /*!< I2C_T::STATUS1: ADMAT1 Position        */
#define I2C_STATUS1_ADMAT1_Msk           (0x1ul << I2C_STATUS1_ADMAT1_Pos)                 /*!< I2C_T::STATUS1: ADMAT1 Mask            */

#define I2C_STATUS1_ADMAT2_Pos           (2)                                               /*!< I2C_T::STATUS1: ADMAT2 Position        */
#define I2C_STATUS1_ADMAT2_Msk           (0x1ul << I2C_STATUS1_ADMAT2_Pos)                 /*!< I2C_T::STATUS1: ADMAT2 Mask            */

#define I2C_STATUS1_ADMAT3_Pos           (3)                                               /*!< I2C_T::STATUS1: ADMAT3 Position        */
#define I2C_STATUS1_ADMAT3_Msk           (0x1ul << I2C_STATUS1_ADMAT3_Pos)                 /*!< I2C_T::STATUS1: ADMAT3 Mask            */

#define I2C_STATUS1_FULL_Pos             (4)                                               /*!< I2C_T::STATUS1: FULL Position          */
#define I2C_STATUS1_FULL_Msk             (0x1ul << I2C_STATUS1_FULL_Pos)                   /*!< I2C_T::STATUS1: FULL Mask              */

#define I2C_STATUS1_EMPTY_Pos            (5)                                               /*!< I2C_T::STATUS1: EMPTY Position         */
#define I2C_STATUS1_EMPTY_Msk            (0x1ul << I2C_STATUS1_EMPTY_Pos)                  /*!< I2C_T::STATUS1: EMPTY Mask             */

#define I2C_STATUS1_OVR_Pos              (6)                                               /*!< I2C_T::STATUS1: OVR Position           */
#define I2C_STATUS1_OVR_Msk              (0x1ul << I2C_STATUS1_OVR_Pos)                    /*!< I2C_T::STATUS1: OVR Mask               */

#define I2C_STATUS1_UDR_Pos              (7)                                               /*!< I2C_T::STATUS1: UDR Position           */
#define I2C_STATUS1_UDR_Msk              (0x1ul << I2C_STATUS1_UDR_Pos)                    /*!< I2C_T::STATUS1: UDR Mask               */

#define I2C_STATUS1_ONBUSY_Pos           (8)                                               /*!< I2C_T::STATUS1: ONBUSY Position        */
#define I2C_STATUS1_ONBUSY_Msk           (0x1ul << I2C_STATUS1_ONBUSY_Pos)                 /*!< I2C_T::STATUS1: ONBUSY Mask            */

#define I2C_TMCTL_STCTL_Pos              (0)                                               /*!< I2C_T::TMCTL: STCTL Position           */
#define I2C_TMCTL_STCTL_Msk              (0x3ful << I2C_TMCTL_STCTL_Pos)                   /*!< I2C_T::TMCTL: STCTL Mask               */

#define I2C_TMCTL_HTCTL_Pos              (6)                                               /*!< I2C_T::TMCTL: HTCTL Position           */
#define I2C_TMCTL_HTCTL_Msk              (0x3ful << I2C_TMCTL_HTCTL_Pos)                   /*!< I2C_T::TMCTL: HTCTL Mask               */

#define I2C_BUSCTL_ACKMEN_Pos            (0)                                               /*!< I2C_T::BUSCTL: ACKMEN Position         */
#define I2C_BUSCTL_ACKMEN_Msk            (0x1ul << I2C_BUSCTL_ACKMEN_Pos)                  /*!< I2C_T::BUSCTL: ACKMEN Mask             */

#define I2C_BUSCTL_PECEN_Pos             (1)                                               /*!< I2C_T::BUSCTL: PECEN Position          */
#define I2C_BUSCTL_PECEN_Msk             (0x1ul << I2C_BUSCTL_PECEN_Pos)                   /*!< I2C_T::BUSCTL: PECEN Mask              */

#define I2C_BUSCTL_BMDEN_Pos             (2)                                               /*!< I2C_T::BUSCTL: BMDEN Position          */
#define I2C_BUSCTL_BMDEN_Msk             (0x1ul << I2C_BUSCTL_BMDEN_Pos)                   /*!< I2C_T::BUSCTL: BMDEN Mask              */

#define I2C_BUSCTL_BMHEN_Pos             (3)                                               /*!< I2C_T::BUSCTL: BMHEN Position          */
#define I2C_BUSCTL_BMHEN_Msk             (0x1ul << I2C_BUSCTL_BMHEN_Pos)                   /*!< I2C_T::BUSCTL: BMHEN Mask              */

#define I2C_BUSCTL_ALERTEN_Pos           (4)                                               /*!< I2C_T::BUSCTL: ALERTEN Position        */
#define I2C_BUSCTL_ALERTEN_Msk           (0x1ul << I2C_BUSCTL_ALERTEN_Pos)                 /*!< I2C_T::BUSCTL: ALERTEN Mask            */

#define I2C_BUSCTL_SCTLOSTS_Pos          (5)                                               /*!< I2C_T::BUSCTL: SCTLOSTS Position       */
#define I2C_BUSCTL_SCTLOSTS_Msk          (0x1ul << I2C_BUSCTL_SCTLOSTS_Pos)                /*!< I2C_T::BUSCTL: SCTLOSTS Mask           */

#define I2C_BUSCTL_SCTLOEN_Pos           (6)                                               /*!< I2C_T::BUSCTL: SCTLOEN Position        */
#define I2C_BUSCTL_SCTLOEN_Msk           (0x1ul << I2C_BUSCTL_SCTLOEN_Pos)                 /*!< I2C_T::BUSCTL: SCTLOEN Mask            */

#define I2C_BUSCTL_BUSEN_Pos             (7)                                               /*!< I2C_T::BUSCTL: BUSEN Position          */
#define I2C_BUSCTL_BUSEN_Msk             (0x1ul << I2C_BUSCTL_BUSEN_Pos)                   /*!< I2C_T::BUSCTL: BUSEN Mask              */

#define I2C_BUSCTL_PECTXEN_Pos           (8)                                               /*!< I2C_T::BUSCTL: PECTXEN Position        */
#define I2C_BUSCTL_PECTXEN_Msk           (0x1ul << I2C_BUSCTL_PECTXEN_Pos)                 /*!< I2C_T::BUSCTL: PECTXEN Mask            */

#define I2C_BUSCTL_TIDLE_Pos             (9)                                               /*!< I2C_T::BUSCTL: TIDLE Position          */
#define I2C_BUSCTL_TIDLE_Msk             (0x1ul << I2C_BUSCTL_TIDLE_Pos)                   /*!< I2C_T::BUSCTL: TIDLE Mask              */

#define I2C_BUSCTL_PECCLR_Pos            (10)                                              /*!< I2C_T::BUSCTL: PECCLR Position         */
#define I2C_BUSCTL_PECCLR_Msk            (0x1ul << I2C_BUSCTL_PECCLR_Pos)                  /*!< I2C_T::BUSCTL: PECCLR Mask             */

#define I2C_BUSCTL_ACKM9SI_Pos           (11)                                              /*!< I2C_T::BUSCTL: ACKM9SI Position        */
#define I2C_BUSCTL_ACKM9SI_Msk           (0x1ul << I2C_BUSCTL_ACKM9SI_Pos)                 /*!< I2C_T::BUSCTL: ACKM9SI Mask            */

#define I2C_BUSCTL_BCDIEN_Pos            (12)                                              /*!< I2C_T::BUSCTL: BCDIEN Position         */
#define I2C_BUSCTL_BCDIEN_Msk            (0x1ul << I2C_BUSCTL_BCDIEN_Pos)                  /*!< I2C_T::BUSCTL: BCDIEN Mask             */

#define I2C_BUSCTL_PECDIEN_Pos           (13)                                              /*!< I2C_T::BUSCTL: PECDIEN Position        */
#define I2C_BUSCTL_PECDIEN_Msk           (0x1ul << I2C_BUSCTL_PECDIEN_Pos)                 /*!< I2C_T::BUSCTL: PECDIEN Mask            */

#define I2C_BUSTCTL_BUSTOEN_Pos          (0)                                               /*!< I2C_T::BUSTCTL: BUSTOEN Position       */
#define I2C_BUSTCTL_BUSTOEN_Msk          (0x1ul << I2C_BUSTCTL_BUSTOEN_Pos)                /*!< I2C_T::BUSTCTL: BUSTOEN Mask           */

#define I2C_BUSTCTL_CLKTOEN_Pos          (1)                                               /*!< I2C_T::BUSTCTL: CLKTOEN Position       */
#define I2C_BUSTCTL_CLKTOEN_Msk          (0x1ul << I2C_BUSTCTL_CLKTOEN_Pos)                /*!< I2C_T::BUSTCTL: CLKTOEN Mask           */

#define I2C_BUSTCTL_BUSTOIEN_Pos         (2)                                               /*!< I2C_T::BUSTCTL: BUSTOIEN Position      */
#define I2C_BUSTCTL_BUSTOIEN_Msk         (0x1ul << I2C_BUSTCTL_BUSTOIEN_Pos)               /*!< I2C_T::BUSTCTL: BUSTOIEN Mask          */

#define I2C_BUSTCTL_CLKTOIEN_Pos         (3)                                               /*!< I2C_T::BUSTCTL: CLKTOIEN Position      */
#define I2C_BUSTCTL_CLKTOIEN_Msk         (0x1ul << I2C_BUSTCTL_CLKTOIEN_Pos)               /*!< I2C_T::BUSTCTL: CLKTOIEN Mask          */

#define I2C_BUSTCTL_TORSTEN_Pos          (4)                                               /*!< I2C_T::BUSTCTL: TORSTEN Position       */
#define I2C_BUSTCTL_TORSTEN_Msk          (0x1ul << I2C_BUSTCTL_TORSTEN_Pos)                /*!< I2C_T::BUSTCTL: TORSTEN Mask           */

#define I2C_BUSSTS_BUSY_Pos              (0)                                               /*!< I2C_T::BUSSTS: BUSY Position           */
#define I2C_BUSSTS_BUSY_Msk              (0x1ul << I2C_BUSSTS_BUSY_Pos)                    /*!< I2C_T::BUSSTS: BUSY Mask               */

#define I2C_BUSSTS_BCDONE_Pos            (1)                                               /*!< I2C_T::BUSSTS: BCDONE Position         */
#define I2C_BUSSTS_BCDONE_Msk            (0x1ul << I2C_BUSSTS_BCDONE_Pos)                  /*!< I2C_T::BUSSTS: BCDONE Mask             */

#define I2C_BUSSTS_PECERR_Pos            (2)                                               /*!< I2C_T::BUSSTS: PECERR Position         */
#define I2C_BUSSTS_PECERR_Msk            (0x1ul << I2C_BUSSTS_PECERR_Pos)                  /*!< I2C_T::BUSSTS: PECERR Mask             */

#define I2C_BUSSTS_ALERT_Pos             (3)                                               /*!< I2C_T::BUSSTS: ALERT Position          */
#define I2C_BUSSTS_ALERT_Msk             (0x1ul << I2C_BUSSTS_ALERT_Pos)                   /*!< I2C_T::BUSSTS: ALERT Mask              */

#define I2C_BUSSTS_SCTLDIN_Pos           (4)                                               /*!< I2C_T::BUSSTS: SCTLDIN Position        */
#define I2C_BUSSTS_SCTLDIN_Msk           (0x1ul << I2C_BUSSTS_SCTLDIN_Pos)                 /*!< I2C_T::BUSSTS: SCTLDIN Mask            */

#define I2C_BUSSTS_BUSTO_Pos             (5)                                               /*!< I2C_T::BUSSTS: BUSTO Position          */
#define I2C_BUSSTS_BUSTO_Msk             (0x1ul << I2C_BUSSTS_BUSTO_Pos)                   /*!< I2C_T::BUSSTS: BUSTO Mask              */

#define I2C_BUSSTS_CLKTO_Pos             (6)                                               /*!< I2C_T::BUSSTS: CLKTO Position          */
#define I2C_BUSSTS_CLKTO_Msk             (0x1ul << I2C_BUSSTS_CLKTO_Pos)                   /*!< I2C_T::BUSSTS: CLKTO Mask              */

#define I2C_BUSSTS_PECDONE_Pos           (7)                                               /*!< I2C_T::BUSSTS: PECDONE Position        */
#define I2C_BUSSTS_PECDONE_Msk           (0x1ul << I2C_BUSSTS_PECDONE_Pos)                 /*!< I2C_T::BUSSTS: PECDONE Mask            */

#define I2C_PKTSIZE_PLDSIZE_Pos          (0)                                               /*!< I2C_T::PKTSIZE: PLDSIZE Position       */
#define I2C_PKTSIZE_PLDSIZE_Msk          (0x1fful << I2C_PKTSIZE_PLDSIZE_Pos)              /*!< I2C_T::PKTSIZE: PLDSIZE Mask           */

#define I2C_PKTCRC_PECCRC_Pos            (0)                                               /*!< I2C_T::PKTCRC: PECCRC Position         */
#define I2C_PKTCRC_PECCRC_Msk            (0xfful << I2C_PKTCRC_PECCRC_Pos)                 /*!< I2C_T::PKTCRC: PECCRC Mask             */

#define I2C_BUSTOUT_BUSTO_Pos            (0)                                               /*!< I2C_T::BUSTOUT: BUSTO Position         */
#define I2C_BUSTOUT_BUSTO_Msk            (0xfful << I2C_BUSTOUT_BUSTO_Pos)                 /*!< I2C_T::BUSTOUT: BUSTO Mask             */

#define I2C_CLKTOUT_CLKTO_Pos            (0)                                               /*!< I2C_T::CLKTOUT: CLKTO Position         */
#define I2C_CLKTOUT_CLKTO_Msk            (0xfful << I2C_CLKTOUT_CLKTO_Pos)                 /*!< I2C_T::CLKTOUT: CLKTO Mask             */

#define I2C_VERSION_MINOR_Pos            (0)                                               /*!< I2C_T::VERSION: MINOR Position         */
#define I2C_VERSION_MINOR_Msk            (0xfffful << I2C_VERSION_MINOR_Pos)               /*!< I2C_T::VERSION: MINOR Mask             */

#define I2C_VERSION_SUB_Pos              (16)                                              /*!< I2C_T::VERSION: SUB Position           */
#define I2C_VERSION_SUB_Msk              (0xfful << I2C_VERSION_SUB_Pos)                   /*!< I2C_T::VERSION: SUB Mask               */

#define I2C_VERSION_MAJOR_Pos            (24)                                              /*!< I2C_T::VERSION: MAJOR Position         */
#define I2C_VERSION_MAJOR_Msk            (0xfful << I2C_VERSION_MAJOR_Pos)                 /*!< I2C_T::VERSION: MAJOR Mask             */

/**@}*/ /* I2C_CONST */
/**@}*/ /* end of I2C register group */


/*---------------------- I2S Interface Controller -------------------------*/
/**
    @addtogroup I2S I2S Interface Controller(I2S)
    Memory Mapped Structure for I2S Controller
@{ */
 
typedef struct
{


/**
 * @var I2S_T::CTL0
 * Offset: 0x00  I2S Control Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |I2SEN     |I2S Controller Enable Control
 * |        |          |0 = I2S controller Disabled.
 * |        |          |1 = I2S controller Enabled.
 * |[1]     |TXEN      |Transmit Enable Control
 * |        |          |0 = Data transmission Disabled.
 * |        |          |1 = Data transmission Enabled.
 * |[2]     |RXEN      |Receive Enable Control
 * |        |          |0 = Data receiving Disabled.
 * |        |          |1 = Data receiving Enabled.
 * |[3]     |MUTE      |Transmit Mute Enable Control
 * |        |          |0 = Transmit data is shifted from buffer.
 * |        |          |1 = Send zero on transmit channel.
 * |[5:4]   |DATWIDTH  |Data Width
 * |        |          |This bit field is used to define the bit-width of data word in each audio channel
 * |        |          |00 = The bit-width of data word is 8-bit.
 * |        |          |01 = The bit-width of data word is 16-bit.
 * |        |          |10 = The bit-width of data word is 24-bit.
 * |        |          |11 = The bit-width of data word is 32-bit.
 * |[6]     |MONO      |Monaural Data Control
 * |        |          |0 = Data is stereo format.
 * |        |          |1 = Data is monaural format.
 * |        |          |Note: when chip records data, RXLCH (I2S_CTL0[23]) indicates which channel data will be saved if monaural format is selected.
 * |[7]     |ORDER     |Stereo Data Order in FIFO
 * |        |          |In 8-bit/16-bit data width, this bit is used to select whether the even or odd channel data is stored in higher byte
 * |        |          |In 24-bit data width, this is used to select the left/right alignment method of audio data which is stored in data memory consisted of 32-bit FIFO entries.
 * |        |          |0 = Even channel data at high byte in 8-bit/16-bit data width.
 * |        |          |LSB of 24-bit audio data in each channel is aligned to right side in 32-bit FIFO entries.
 * |        |          |1 = Even channel data at low byte.
 * |        |          | MSB of 24-bit audio data in each channel is aligned to left side in 32-bit FIFO entries.
 * |[8]     |SLAVE     |Slave Mode Enable Control
 * |        |          |0 = Master mode.
 * |        |          |1 = Slave mode.
 * |        |          |Note: I2S can operate as master or slave
 * |        |          |For Master mode, I2S0_BCLK and I2S0_LRCLK pins are output mode and send out bit clock to Audio CODEC chip
 * |        |          |In Slave mode, I2S0_BCLK and I2S0_LRCLK pins are input mode and I2S0_BCLK and I2S0_LRCLK signals are received from outer Audio CODEC chip.
 * |[15]    |MCLKEN    |Master Clock Enable Control
 * |        |          |If MCLKEN is set to 1, I2S controller will generate master clock on I2S0_MCLK pin for external audio devices.
 * |        |          |0 = Master clock Disabled.
 * |        |          |1 = Master clock Enabled.
 * |[18]    |TXFBCLR   |Transmit FIFO Buffer Clear
 * |        |          |0 = No Effect.
 * |        |          |1 = Clear TX FIFO.
 * |        |          |Note1: Write 1 to clear transmit FIFO, internal pointer is reset to FIFO start point, and TXCNT (I2S_STATUS1[12:8]) returns 0 and transmit FIFO becomes empty but data in transmit FIFO is not changed.
 * |        |          |Note2: This bit is clear by hardware automatically, read it return zero.
 * |[19]    |RXFBCLR   |Receive FIFO Buffer Clear
 * |        |          |0 = No Effect.
 * |        |          |1 = Clear RX FIFO.
 * |        |          |Note1: Write 1 to clear receive FIFO, internal pointer is reset to FIFO start point, and RXCNT (I2S_STATUS1[20:16]) returns 0 and receive FIFO becomes empty.
 * |        |          |Note2: This bit is cleared by hardware automatically, read it return zero.
 * |[20]    |TXPDMAEN  |Transmit PDMA Enable Control
 * |        |          |0 = Transmit PDMA function Disabled.
 * |        |          |1 = Transmit PDMA function Enabled.
 * |[21]    |RXPDMAEN  |Receive PDMA Enable Control
 * |        |          |0 = Receiver PDMA function Disabled.
 * |        |          |1 = Receiver PDMA function Enabled.
 * |[23]    |RXLCH     |Receive Left Channel Enable Control
 * |        |          |When monaural format is selected (MONO = 1), I2S will receive channel1 data if RXLCH is set to 0, and receive channel0 data if RXLCH is set to 1.
 * |        |          |0 = Receives channel1 data in MONO mode.
 * |        |          |1 = Receives channel0 data in MONO mode.
 * |[26:24] |FORMAT    |Data Format Selection
 * |        |          |000 = I2S standard data format.
 * |        |          |001 = I2S with MSB justified.
 * |        |          |010 = I2S with LSB justified.
 * |        |          |011 = Reserved.
 * |        |          |100 = PCM standard data format.
 * |        |          |101 = PCM with MSB justified.
 * |        |          |110 = PCM with LSB justified.
 * |        |          |111 = Reserved.
 * |[27]    |PCMSYNC   |PCM Synchronization Pulse Length Selection
 * |        |          |This bit field is used to select the high pulse length of frame synchronization signal in PCM protocol
 * |        |          |0 = One BCLK period.
 * |        |          |1 = One channel period.
 * |        |          |Note: This bit is only available in master mode
 * |[29:28] |CHWIDTH   |Channel Width
 * |        |          |This bit fields are used to define the length of audio channel
 * |        |          |If CHWIDTH < DATWIDTH, the hardware will set the real channel length as the bit-width of audio data which is defined by DATWIDTH.
 * |        |          |00 = The bit-width of each audio channel is 8-bit.
 * |        |          |01 = The bit-width of each audio channel is 16-bit.
 * |        |          |10 = The bit-width of each audio channel is 24-bit.
 * |        |          |11 = The bit-width of each audio channel is 32-bit.
 * |[31:30] |TDMCHNUM  |TDM Channel Number
 * |        |          |This bit fields are used to define the TDM channel number in one audio frame while PCM mode (FORMAT[2] = 1).
 * |        |          |00 = 2 channels in audio frame.
 * |        |          |01 = 4 channels in audio frame.
 * |        |          |10 = 6 channels in audio frame.
 * |        |          |11 = 8 channels in audio frame.
 * @var I2S_T::CLKDIV
 * Offset: 0x04  I2S Clock Divider Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[5:0]   |MCLKDIV   |Master Clock Divider
 * |        |          |If chip external crystal frequency is (2xMCLKDIV)*256fs then software can program these bits to generate 256fs clock frequency to audio codec chip
 * |        |          |If MCLKDIV is set to 0, MCLK is the same as external clock input.
 * |        |          |For example, sampling rate is 24 kHz and chip external crystal clock is 12.288 MHz, set MCLKDIV = 1.
 * |        |          |F_MCLK = F_I2SCLK/(2x(MCLKDIV)) (When MCLKDIV is >= 1 ).
 * |        |          |F_MCLK = F_I2SCLK (When MCLKDIV is set to 0 ).
 * |        |          |Note: F_MCLK is the frequency of MCLK, and F_I2SCLK is the frequency of the I2S_CLK
 * |[16:8]  |BCLKDIV   |Bit Clock Divider
 * |        |          |The I2S controller will generate bit clock in Master mode
 * |        |          |Software can program these bit fields to generate sampling rate clock frequency.
 * |        |          |F_BCLK= F_I2SCLK / (2*(BCLKDIV + 1)).
 * |        |          |Note: F_BCLK is the frequency of BCLK and F_I2SCLK is the frequency of I2S_CLK
 * @var I2S_T::IEN
 * Offset: 0x08  I2S Interrupt Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |RXUDFIEN  |Receive FIFO Underflow Interrupt E Enable Control
 * |        |          |0 = Interrupt Disabled.
 * |        |          |1 = Interrupt Enabled.
 * |        |          |Note: If software reads receive FIFO when it is empty then RXUDIF (I2S_STATUS0[8]) flag is set to 1.
 * |[1]     |RXOVFIEN  |Receive FIFO Overflow Interrupt Enable Control
 * |        |          |0 = Interrupt Disabled.
 * |        |          |1 = Interrupt Enabled.
 * |        |          |Note: Interrupt occurs if this bit is set to 1 and RXOVIF (I2S_STATUS0[9]) flag is set to 1
 * |[2]     |RXTHIEN   |Receive FIFO Threshold Level Interrupt Enable Control
 * |        |          |0 = Interrupt Disabled.
 * |        |          |1 = Interrupt Enabled.
 * |        |          |Note: When data word in receive FIFO is equal or higher than RXTH (I2S_CTL1[19:16]) and the RXTHIF (I2S_STATUS0[10]) bit is set to 1
 * |        |          |If RXTHIEN bit is enabled, interrupt occur.
 * |[8]     |TXUDFIEN  |Transmit FIFO Underflow Interrupt Enable Control
 * |        |          |0 = Interrupt Disabled.
 * |        |          |1 = Interrupt Enabled.
 * |        |          |Note: Interrupt occur if this bit is set to 1 and TXUDIF (I2S_STATUS0[16]) flag is set to 1.
 * |[9]     |TXOVFIEN  |Transmit FIFO Overflow Interrupt Enable Control
 * |        |          |0 = Interrupt Disabled.
 * |        |          |1 = Interrupt Enabled.
 * |        |          |Note: Interrupt occurs if this bit is set to 1 and TXOVIF (I2S_STATUS0[17]) flag is set to 1
 * |[10]    |TXTHIEN   |Transmit FIFO Threshold Level Interrupt Enable Control
 * |        |          |0 = Interrupt Disabled.
 * |        |          |1 = Interrupt Enabled.
 * |        |          |Note: Interrupt occurs if this bit is set to 1 and data words in transmit FIFO is less than TXTH (I2S_CTL1[11:8]).
 * |[16]    |CH0ZCIEN  |Channel0 Zero-cross Interrupt Enable Control
 * |        |          |0 = Interrupt Disabled.
 * |        |          |1 = Interrupt Enabled.
 * |        |          |Note1: Interrupt occurs if this bit is set to 1 and channel0 zero-cross
 * |        |          |Note2: Channel0 also means left audio channel while I2S (FORMAT[2]=0) or 2-channel PCM mode.
 * |[17]    |CH1ZCIEN  |Channel1 Zero-cross Interrupt Enable Control
 * |        |          |0 = Interrupt Disabled.
 * |        |          |1 = Interrupt Enabled.
 * |        |          |Note1: Interrupt occurs if this bit is set to 1 and channel1 zero-cross
 * |        |          |Note2: Channel1 also means right audio channel while I2S (FORMAT[2]=0) or 2-channel PCM mode.
 * |[18]    |CH2ZCIEN  |Channel2 Zero-cross Interrupt Enable Control
 * |        |          |0 = Interrupt Disabled.
 * |        |          |1 = Interrupt Enabled.
 * |        |          |Note1: Interrupt occurs if this bit is set to 1 and channel2 zero-cross
 * |        |          |Note2: This bit is available while multi-channel PCM mode and TDMCHNUM (I2S_CTL0[31:30]) = 0x1, 0x2, 0x3.
 * |[19]    |CH3ZCIEN  |Channel3 Zero-cross Interrupt Enable Control
 * |        |          |0 = Interrupt Disabled.
 * |        |          |1 = Interrupt Enabled.
 * |        |          |Note1: Interrupt occurs if this bit is set to 1 and channel3 zero-cross
 * |        |          |Note2: This bit is available while multi-channel PCM mode and TDMCHNUM (I2S_CTL0[31:30]) = 0x1, 0x2, 0x3.
 * |[20]    |CH4ZCIEN  |Channel4 Zero-cross Interrupt Enable Control
 * |        |          |0 = Interrupt Disabled.
 * |        |          |1 = Interrupt Enabled.
 * |        |          |Note1: Interrupt occurs if this bit is set to 1 and channel4 zero-cross
 * |        |          |Note2: This bit is available while multi-channel PCM mode and TDMCHNUM (I2S_CTL0[31:30]) = 0x1, 0x2, 0x3.
 * |[21]    |CH5ZCIEN  |Channel5 Zero-cross Interrupt Enable Control
 * |        |          |0 = Interrupt Disabled.
 * |        |          |1 = Interrupt Enabled.
 * |        |          |Note1: Interrupt occurs if this bit is set to 1 and channel5 zero-cross
 * |        |          |Note2: This bit is available while multi-channel PCM mode and TDMCHNUM (I2S_CTL0[31:30]) = 0x1, 0x2, 0x3.
 * |[22]    |CH6ZCIEN  |Channel6 Zero-cross Interrupt Enable Control
 * |        |          |0 = Interrupt Disabled.
 * |        |          |1 = Interrupt Enabled.
 * |        |          |Note1: Interrupt occurs if this bit is set to 1 and channel6 zero-cross
 * |        |          |Note2: This bit is available while multi-channel PCM mode and TDMCHNUM (I2S_CTL0[31:30]) = 0x1, 0x2, 0x3.
 * |[23]    |CH7ZCIEN  |Channel7 Zero-cross Interrupt Enable Control
 * |        |          |0 = Interrupt Disabled.
 * |        |          |1 = Interrupt Enabled.
 * |        |          |Note1: Interrupt occurs if this bit is set to 1 and channel7 zero-cross
 * |        |          |Note2: This bit is available while multi-channel PCM mode and TDMCHNUM (I2S_CTL0[31:30]) = 0x1, 0x2, 0x3.
 * @var I2S_T::STATUS0
 * Offset: 0x0C  I2S Status Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |I2SINT    |I2S Interrupt Flag (Read Only)
 * |        |          |0 = No I2S interrupt.
 * |        |          |1 = I2S interrupt.
 * |        |          |Note: It is wire-OR of I2STXINT and I2SRXINT bits.
 * |[1]     |I2SRXINT  |I2S Receive Interrupt (Read Only)
 * |        |          |0 = No receive interrupt.
 * |        |          |1 = Receive interrupt.
 * |[2]     |I2STXINT  |I2S Transmit Interrupt (Read Only)
 * |        |          |0 = No transmit interrupt.
 * |        |          |1 = Transmit interrupt.
 * |[5:3]   |DATACH    |Transmission Data Channel (Read Only)
 * |        |          |This bit fields are used to indicate which audio channel is current transmit data belong.
 * |        |          |000 = channel0 (means left channel while 2-channel I2S/PCM mode).
 * |        |          |001 = channel1 (means right channel while 2-channel I2S/PCM mode).
 * |        |          |010 = channel2 (available while 4-channel TDM PCM mode).
 * |        |          |011 = channel3 (available while 4-channel TDM PCM mode).
 * |        |          |100 = channel4 (available while 6-channel TDM PCM mode).
 * |        |          |101 = channel5 (available while 6-channel TDM PCM mode).
 * |        |          |110 = channel6 (available while 8-channel TDM PCM mode).
 * |        |          |111 = channel7 (available while 8-channel TDM PCM mode).
 * |[8]     |RXUDIF    |Receive FIFO Underflow Interrupt Flag
 * |        |          |0 = No underflow occur.
 * |        |          |1 = Underflow occur.
 * |        |          |Note1: When receive FIFO is empty, and software reads the receive FIFO again
 * |        |          |This bit will be set to 1, and it indicates underflow situation occurs.
 * |        |          |Note2: Write 1 to clear this bit to zero
 * |[9]     |RXOVIF    |Receive FIFO Overflow Interrupt Flag
 * |        |          |0 = No overflow occur.
 * |        |          |1 = Overflow occur.
 * |        |          |Note1: When receive FIFO is full and receive hardware attempt to write data into receive FIFO then this bit is set to 1, data in 1st buffer is overwrote.
 * |        |          |Note2: Write 1 to clear this bit to 0.
 * |[10]    |RXTHIF    |Receive FIFO Threshold Interrupt Flag (Read Only)
 * |        |          |0 = Data word(s) in FIFO is not higher than threshold level.
 * |        |          |1 = Data word(s) in FIFO is higher than threshold level.
 * |        |          |Note: When data word(s) in receive FIFO is higher than threshold value set in RXTH (I2S_CTL1[19:16]) the RXTHIF bit becomes to 1
 * |        |          |It keeps at 1 till RXCNT (I2S_STATUS1[20:16]) is not higher than RXTH (I2S_CTL1[19:16]) after software read RXFIFO register.
 * |[11]    |RXFULL    |Receive FIFO Full (Read Only)
 * |        |          |0 = Not full.
 * |        |          |1 = Full.
 * |        |          |Note: This bit reflects data words number in receive FIFO is 12.
 * |[12]    |RXEMPTY   |Receive FIFO Empty (Read Only)
 * |        |          |0 = Not empty.
 * |        |          |1 = Empty.
 * |        |          |Note: This bit reflects data words number in receive FIFO is zero
 * |[16]    |TXUDIF    |Transmit FIFO Underflow Interrupt Flag
 * |        |          |0 = No underflow.
 * |        |          |1 = Underflow.
 * |        |          |Note1: This bit will be set to 1 when shift logic hardware read data from transmitting FIFO and the filling data level in transmitting FIFO is not enough for one audio frame.
 * |        |          |Note2: Write 1 to clear this bit to 0.
 * |[17]    |TXOVIF    |Transmit FIFO Overflow Interrupt Flag
 * |        |          |0 = No overflow.
 * |        |          |1 = Overflow.
 * |        |          |Note1: Write data to transmit FIFO when it is full and this bit set to 1
 * |        |          |Note2: Write 1 to clear this bit to 0.
 * |[18]    |TXTHIF    |Transmit FIFO Threshold Interrupt Flag (Read Only)
 * |        |          |0 = Data word(s) in FIFO is higher than threshold level.
 * |        |          |1 = Data word(s) in FIFO is equal or lower than threshold level.
 * |        |          |Note: When data word(s) in transmit FIFO is equal or lower than threshold value set in TXTH (I2S_CTL1[11:8]) the TXTHIF bit becomes to 1
 * |        |          |It keeps at 1 till TXCNT (I2S_STATUS1[12:8]) is higher than TXTH (I2S_CTL1[11:8]) after software write TXFIFO register.
 * |[19]    |TXFULL    |Transmit FIFO Full (Read Only)
 * |        |          |This bit reflect data word number in transmit FIFO is 12
 * |        |          |0 = Not full.
 * |        |          |1 = Full.
 * |[20]    |TXEMPTY   |Transmit FIFO Empty (Read Only)
 * |        |          |This bit reflect data word number in transmit FIFO is zero
 * |        |          |0 = Not empty.
 * |        |          |1 = Empty.
 * |[21]    |TXBUSY    |Transmit Busy (Read Only)
 * |        |          |0 = Transmit shift buffer is empty.
 * |        |          |1 = Transmit shift buffer is busy.
 * |        |          |Note: This bit is cleared to 0 when all data in transmit FIFO and shift buffer is shifted out
 * |        |          |And set to 1 when 1st data is load to shift buffer
 * @var I2S_T::TXFIFO
 * Offset: 0x10  I2S Transmit FIFO Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |TXFIFO    |Transmit FIFO Bits
 * |        |          |I2S contains 16 words (16x32 bit) data buffer for data transmit
 * |        |          |Write data to this register to prepare data for transmit
 * |        |          |The remaining word number is indicated by TXCNT (I2S_STATUS1[12:8]).
 * @var I2S_T::RXFIFO
 * Offset: 0x14  I2S Receive FIFO Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |RXFIFO    |Receive FIFO Bits
 * |        |          |I2S contains 16 words (16x32 bit) data buffer for data receive
 * |        |          |Read this register to get data in FIFO
 * |        |          |The remaining data word number is indicated by RXCNT (I2S_STATUS1[20:16]).
 * @var I2S_T::CTL1
 * Offset: 0x20  I2S Control Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CH0ZCEN   |Channel0 Zero-cross Detection Enable Control
 * |        |          |0 = channel0 zero-cross detect Disabled.
 * |        |          |1 = channel0 zero-cross detect Enabled.
 * |        |          |Note1: Channel0 also means left audio channel while I2S (FORMAT[2]=0) or 2-channel PCM mode.
 * |        |          |Note2: If this bit is set to 1, when channel0 data sign bit change or next shift data bits are all zero then CH0ZCIF(I2S_STATUS1[0]) flag is set to 1.
 * |        |          |Note3: If CH0ZCIF Flag is set to 1, the channel0 will be mute.
 * |[1]     |CH1ZCEN   |Channel1 Zero-cross Detect Enable Control
 * |        |          |0 = channel1 zero-cross detect Disabled.
 * |        |          |1 = channel1 zero-cross detect Enabled.
 * |        |          |Note1: Channel1 also means right audio channel while I2S (FORMAT[2]=0) or 2-channel PCM mode.
 * |        |          |Note2: If this bit is set to 1, when channel1 data sign bit change or next shift data bits are all zero then CH1ZCIF(I2S_STATUS1[1]) flag is set to 1.
 * |        |          |Note3: If CH1ZCIF Flag is set to 1, the channel1 will be mute.
 * |[2]     |CH2ZCEN   |Channel2 Zero-cross Detect Enable Control
 * |        |          |0 = channel2 zero-cross detect Disabled.
 * |        |          |1 = channel2 zero-cross detect Enabled.
 * |        |          |Note1: This bit is available while multi-channel PCM mode and TDMCHNUM (I2S_CTL0[31:30]) = 0x1, 0x2, 0x3.
 * |        |          |Note2: If this bit is set to 1, when channel2 data sign bit change or next shift data bits are all zero then CH2ZCIF(I2S_STATUS1[2]) flag is set to 1.
 * |        |          |Note3: If CH2ZCIF Flag is set to 1, the channel2 will be mute.
 * |[3]     |CH3ZCEN   |Channel3 Zero-cross Detect Enable Control
 * |        |          |0 = channel3 zero-cross detect Disabled.
 * |        |          |1 = channel3 zero-cross detect Enabled.
 * |        |          |Note1: This bit is available while multi-channel PCM mode and TDMCHNUM (I2S_CTL0[31:30]) = 0x1, 0x2, 0x3.
 * |        |          |Note2: If this bit is set to 1, when channel3 data sign bit change or next shift data bits are all zero then CH3ZCIF(I2S_STATUS1[3]) flag is set to 1.
 * |        |          |Note3: If CH3ZCIF Flag is set to 1, the channel3 will be mute.
 * |[4]     |CH4ZCEN   |Channel4 Zero-cross Detect Enable Control
 * |        |          |0 = channel4 zero-cross detect Disabled.
 * |        |          |1 = channel4 zero-cross detect Enabled.
 * |        |          |Note1: This bit is available while multi-channel PCM mode and TDMCHNUM (I2S_CTL0[31:30]) = 0x1, 0x2, 0x3.
 * |        |          |Note2: If this bit is set to 1, when channel4 data sign bit change or next shift data bits are all zero then CH4ZCIF(I2S_STATUS1[4]) flag is set to 1.
 * |        |          |Note3: If CH4ZCIF Flag is set to 1, the channel4 will be mute.
 * |[5]     |CH5ZCEN   |Channel5 Zero-cross Detect Enable Control
 * |        |          |0 = channel5 zero-cross detect Disabled.
 * |        |          |1 = channel5 zero-cross detect Enabled.
 * |        |          |Note1: This bit is available while multi-channel PCM mode and TDMCHNUM (I2S_CTL0[31:30]) = 0x1, 0x2, 0x3.
 * |        |          |Note2: If this bit is set to 1, when channel5 data sign bit change or next shift data bits are all zero then CH5ZCIF(I2S_STATUS1[5]) flag is set to 1.
 * |        |          |Note3: If CH5ZCIF Flag is set to 1, the channel5 will be mute.
 * |[6]     |CH6ZCEN   |Channel6 Zero-cross Detect Enable Control
 * |        |          |0 = channel6 zero-cross detect Disabled.
 * |        |          |1 = channel6 zero-cross detect Enabled.
 * |        |          |Note1: This bit is available while multi-channel PCM mode and TDMCHNUM (I2S_CTL0[31:30]) = 0x1, 0x2, 0x3.
 * |        |          |Note2: If this bit is set to 1, when channel6 data sign bit change or next shift data bits are all zero then CH6ZCIF(I2S_STATUS1[6]) flag is set to 1.
 * |        |          |Note3: If CH6ZCIF Flag is set to 1, the channel6 will be mute.
 * |[7]     |CH7ZCEN   |Channel7 Zero-cross Detect Enable Control
 * |        |          |0 = channel7 zero-cross detect Disabled.
 * |        |          |1 = channel7 zero-cross detect Enabled.
 * |        |          |Note1: This bit is available while multi-channel PCM mode and TDMCHNUM (I2S_CTL0[31:30]) = 0x1, 0x2, 0x3.
 * |        |          |Note2: If this bit is set to 1, when channel7 data sign bit change or next shift data bits are all zero then CH7ZCIF (I2S_STATUS1[7]) flag is set to 1.
 * |        |          |Note3: If CH7ZCIF Flag is set to 1, the channel7 will be mute.
 * |[11:8]  |TXTH      |Transmit FIFO Threshold Level
 * |        |          |0000 = 0 data word in transmit FIFO.
 * |        |          |0001 = 1 data word in transmit FIFO.
 * |        |          |0010 = 2 data words in transmit FIFO.
 * |        |          |...
 * |        |          |1110 = 14 data words in transmit FIFO.
 * |        |          |1111 = 15 data words in transmit FIFO.
 * |        |          |Note: If remain data word number in transmit FIFO is the same or less than threshold level then TXTHIF (I2S_STATUS0[18]) flag is set.
 * |[19:16] |RXTH      |Receive FIFO Threshold Level
 * |        |          |0000 = 1 data word in receive FIFO.
 * |        |          |0001 = 2 data words in receive FIFO.
 * |        |          |0010 = 3 data words in receive FIFO.
 * |        |          |...
 * |        |          |1110 = 15 data words in receive FIFO.
 * |        |          |1111 = 16 data words in receive FIFO.
 * |        |          |Note: When received data word number in receive buffer is greater than threshold level then RXTHIF (I2S_STATUS0[10]) flag is set.
 * |[24]    |PBWIDTH   |Peripheral Bus Data Width Selection
 * |        |          |This bit is used to choice the available data width of APB bus
 * |        |          |It must be set to 1 while PDMA function is enable and it is set to 16-bit transmission mode
 * |        |          |0 = 32 bits data width.
 * |        |          |1 = 16 bits data width.
 * |        |          |Note1: If PBWIDTH=1, the low 16 bits of 32-bit data bus are available.
 * |        |          |Note2: If PBWIDTH=1, the transmitting FIFO level will be increased after two FIFO write operations.
 * |        |          |Note3: If PBWIDTH=1, the receiving FIFO level will be decreased after two FIFO read operations.
 * |[25]    |PB16ORD   |FIFO Read/Write Order in 16-bit Width of Peripheral Bus
 * |        |          |When PBWIDTH = 1, the data FIFO will be increased or decreased by two peripheral bus access
 * |        |          |This bit is used to select the order of FIFO access operations to meet the 32-bit transmitting/receiving FIFO entries.
 * |        |          |0 = Low 16-bit read/write access first.
 * |        |          |1 = High 16-bit read/write access first.
 * |        |          |Note: This bit is available while PBWIDTH = 1.
 * @var I2S_T::STATUS1
 * Offset: 0x24  I2S Status Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CH0ZCIF   |Channel0 Zero-cross Interrupt Flag
 * |        |          |It indicates channel0 next sample data sign bit is changed or all data bits are zero.
 * |        |          |0 = No zero-cross in channel0.
 * |        |          |1 = Channel0 zero-cross is detected.
 * |        |          |Note1: Write 1 to clear this bit to 0.
 * |        |          |Note2: Channel0 also means left audio channel while I2S (FORMAT[2]=0) or 2-channel PCM mode.
 * |[1]     |CH1ZCIF   |Channel1 Zero-cross Interrupt Flag
 * |        |          |It indicates channel1 next sample data sign bit is changed or all data bits are zero.
 * |        |          |0 = No zero-cross in channel1.
 * |        |          |1 = Channel1 zero-cross is detected.
 * |        |          |Note1: Write 1 to clear this bit to 0.
 * |        |          |Note2: Channel1 also means right audio channel while I2S (FORMAT[2]=0) or 2-channel PCM mode.
 * |[2]     |CH2ZCIF   |Channel2 Zero-cross Interrupt Flag
 * |        |          |It indicates channel2 next sample data sign bit is changed or all data bits are zero.
 * |        |          |0 = No zero-cross in channel2.
 * |        |          |1 = Channel2 zero-cross is detected.
 * |        |          |Note1: Write 1 to clear this bit to 0.
 * |        |          |Note2: This bit is available while multi-channel PCM mode and TDMCHNUM (I2S_CTL0[31:30]) = 0x1, 0x2, 0x3.
 * |[3]     |CH3ZCIF   |Channel3 Zero-cross Interrupt Flag
 * |        |          |It indicates channel3 next sample data sign bit is changed or all data bits are zero.
 * |        |          |0 = No zero-cross in channel3.
 * |        |          |1 = Channel3 zero-cross is detected.
 * |        |          |Note1: Write 1 to clear this bit to 0.
 * |        |          |Note2: This bit is available while multi-channel PCM mode and TDMCHNUM (I2S_CTL0[31:30]) = 0x1, 0x2, 0x3.
 * |[4]     |CH4ZCIF   |Channel4 Zero-cross Interrupt Flag
 * |        |          |It indicates channel4 next sample data sign bit is changed or all data bits are zero.
 * |        |          |0 = No zero-cross in channel4.
 * |        |          |1 = Channel4 zero-cross is detected.
 * |        |          |Note1: Write 1 to clear this bit to 0.
 * |        |          |Note2: This bit is available while multi-channel PCM mode and TDMCHNUM (I2S_CTL0[31:30]) = 0x1, 0x2, 0x3.
 * |[5]     |CH5ZCIF   |Channel5 Zero-cross Interrupt Flag
 * |        |          |It indicates channel5 next sample data sign bit is changed or all data bits are zero.
 * |        |          |0 = No zero-cross in channel5.
 * |        |          |1 = Channel5 zero-cross is detected.
 * |        |          |Note1: Write 1 to clear this bit to 0.
 * |        |          |Note2: This bit is available while multi-channel PCM mode and TDMCHNUM (I2S_CTL0[31:30]) = 0x1, 0x2, 0x3.
 * |[6]     |CH6ZCIF   |Channel6 Zero-cross Interrupt Flag
 * |        |          |It indicates channel6 next sample data sign bit is changed or all data bits are zero.
 * |        |          |0 = No zero-cross in channel6.
 * |        |          |1 = Channel6 zero-cross is detected.
 * |        |          |Note1: Write 1 to clear this bit to 0.
 * |        |          |Note2: This bit is available while multi-channel PCM mode and TDMCHNUM (I2S_CTL0[31:30]) = 0x1, 0x2, 0x3.
 * |[7]     |CH7ZCIF   |Channel7 Zero-cross Interrupt Flag
 * |        |          |It indicates channel7 next sample data sign bit is changed or all data bits are zero.
 * |        |          |0 = No zero-cross in channel7.
 * |        |          |1 = Channel7 zero-cross is detected.
 * |        |          |Note1: Write 1 to clear this bit to 0.
 * |        |          |Note2: This bit is available while multi-channel PCM mode and TDMCHNUM (I2S_CTL0[31:30]) = 0x1, 0x2, 0x3.
 * |[12:8]  |TXCNT     |Transmit FIFO Level (Read Only)
 * |        |          |These bits indicate word number in transmit FIFO
 * |        |          |00000 = No data.
 * |        |          |00001 = 1 word in transmit FIFO.
 * |        |          |00010 = 2 words in transmit FIFO.
 * |        |          |...
 * |        |          |01110 = 14 words in transmit FIFO.
 * |        |          |01111 = 15 words in transmit FIFO.
 * |        |          |10000 = 16 words in transmit FIFO.
 * |        |          |Others are reserved.
 * |[20:16] |RXCNT     |Receive FIFO Level (Read Only)
 * |        |          |These bits indicate word number in receive FIFO
 * |        |          |00000 = No data.
 * |        |          |00001 = 1 word in receive FIFO.
 * |        |          |00010 = 2 words in receive FIFO.
 * |        |          |...
 * |        |          |01110 = 14 words in receive FIFO.
 * |        |          |01111 = 15 words in receive FIFO.
 * |        |          |10000 = 16 words in receive FIFO.
 * |        |          |Others are reserved.
 */
    __IO uint32_t CTL0;                  /*!< [0x0000] I2S Control Register 0                                           */
    __IO uint32_t CLKDIV;                /*!< [0x0004] I2S Clock Divider Register                                       */
    __IO uint32_t IEN;                   /*!< [0x0008] I2S Interrupt Enable Register                                    */
    __IO uint32_t STATUS0;               /*!< [0x000c] I2S Status Register 0                                            */
    __O  uint32_t TXFIFO;                /*!< [0x0010] I2S Transmit FIFO Register                                       */
    __I  uint32_t RXFIFO;                /*!< [0x0014] I2S Receive FIFO Register                                        */
    __I  uint32_t RESERVE0[2];
    __IO uint32_t CTL1;                  /*!< [0x0020] I2S Control Register 1                                           */
    __IO uint32_t STATUS1;               /*!< [0x0024] I2S Status Register 1                                            */

} I2S_T;

/**
    @addtogroup I2S_CONST I2S Bit Field Definition
    Constant Definitions for I2S Controller
@{ */

#define I2S_CTL0_I2SEN_Pos               (0)                                               /*!< I2S_T::CTL0: I2SEN Position            */
#define I2S_CTL0_I2SEN_Msk               (0x1ul << I2S_CTL0_I2SEN_Pos)                     /*!< I2S_T::CTL0: I2SEN Mask                */

#define I2S_CTL0_TXEN_Pos                (1)                                               /*!< I2S_T::CTL0: TXEN Position             */
#define I2S_CTL0_TXEN_Msk                (0x1ul << I2S_CTL0_TXEN_Pos)                      /*!< I2S_T::CTL0: TXEN Mask                 */

#define I2S_CTL0_RXEN_Pos                (2)                                               /*!< I2S_T::CTL0: RXEN Position             */
#define I2S_CTL0_RXEN_Msk                (0x1ul << I2S_CTL0_RXEN_Pos)                      /*!< I2S_T::CTL0: RXEN Mask                 */

#define I2S_CTL0_MUTE_Pos                (3)                                               /*!< I2S_T::CTL0: MUTE Position             */
#define I2S_CTL0_MUTE_Msk                (0x1ul << I2S_CTL0_MUTE_Pos)                      /*!< I2S_T::CTL0: MUTE Mask                 */

#define I2S_CTL0_DATWIDTH_Pos            (4)                                               /*!< I2S_T::CTL0: DATWIDTH Position         */
#define I2S_CTL0_DATWIDTH_Msk            (0x3ul << I2S_CTL0_DATWIDTH_Pos)                  /*!< I2S_T::CTL0: DATWIDTH Mask             */

#define I2S_CTL0_MONO_Pos                (6)                                               /*!< I2S_T::CTL0: MONO Position             */
#define I2S_CTL0_MONO_Msk                (0x1ul << I2S_CTL0_MONO_Pos)                      /*!< I2S_T::CTL0: MONO Mask                 */

#define I2S_CTL0_ORDER_Pos               (7)                                               /*!< I2S_T::CTL0: ORDER Position            */
#define I2S_CTL0_ORDER_Msk               (0x1ul << I2S_CTL0_ORDER_Pos)                     /*!< I2S_T::CTL0: ORDER Mask                */

#define I2S_CTL0_SLAVE_Pos               (8)                                               /*!< I2S_T::CTL0: SLAVE Position            */
#define I2S_CTL0_SLAVE_Msk               (0x1ul << I2S_CTL0_SLAVE_Pos)                     /*!< I2S_T::CTL0: SLAVE Mask                */

#define I2S_CTL0_MCLKEN_Pos              (15)                                              /*!< I2S_T::CTL0: MCLKEN Position           */
#define I2S_CTL0_MCLKEN_Msk              (0x1ul << I2S_CTL0_MCLKEN_Pos)                    /*!< I2S_T::CTL0: MCLKEN Mask               */

#define I2S_CTL0_TXFBCLR_Pos             (18)                                              /*!< I2S_T::CTL0: TXFBCLR Position          */
#define I2S_CTL0_TXFBCLR_Msk             (0x1ul << I2S_CTL0_TXFBCLR_Pos)                   /*!< I2S_T::CTL0: TXFBCLR Mask              */

#define I2S_CTL0_RXFBCLR_Pos             (19)                                              /*!< I2S_T::CTL0: RXFBCLR Position          */
#define I2S_CTL0_RXFBCLR_Msk             (0x1ul << I2S_CTL0_RXFBCLR_Pos)                   /*!< I2S_T::CTL0: RXFBCLR Mask              */

#define I2S_CTL0_TXPDMAEN_Pos            (20)                                              /*!< I2S_T::CTL0: TXPDMAEN Position         */
#define I2S_CTL0_TXPDMAEN_Msk            (0x1ul << I2S_CTL0_TXPDMAEN_Pos)                  /*!< I2S_T::CTL0: TXPDMAEN Mask             */

#define I2S_CTL0_RXPDMAEN_Pos            (21)                                              /*!< I2S_T::CTL0: RXPDMAEN Position         */
#define I2S_CTL0_RXPDMAEN_Msk            (0x1ul << I2S_CTL0_RXPDMAEN_Pos)                  /*!< I2S_T::CTL0: RXPDMAEN Mask             */

#define I2S_CTL0_RXLCH_Pos               (23)                                              /*!< I2S_T::CTL0: RXLCH Position            */
#define I2S_CTL0_RXLCH_Msk               (0x1ul << I2S_CTL0_RXLCH_Pos)                     /*!< I2S_T::CTL0: RXLCH Mask                */

#define I2S_CTL0_FORMAT_Pos              (24)                                              /*!< I2S_T::CTL0: FORMAT Position           */
#define I2S_CTL0_FORMAT_Msk              (0x7ul << I2S_CTL0_FORMAT_Pos)                    /*!< I2S_T::CTL0: FORMAT Mask               */

#define I2S_CTL0_PCMSYNC_Pos             (27)                                              /*!< I2S_T::CTL0: PCMSYNC Position          */
#define I2S_CTL0_PCMSYNC_Msk             (0x1ul << I2S_CTL0_PCMSYNC_Pos)                   /*!< I2S_T::CTL0: PCMSYNC Mask              */

#define I2S_CTL0_CHWIDTH_Pos             (28)                                              /*!< I2S_T::CTL0: CHWIDTH Position          */
#define I2S_CTL0_CHWIDTH_Msk             (0x3ul << I2S_CTL0_CHWIDTH_Pos)                   /*!< I2S_T::CTL0: CHWIDTH Mask              */

#define I2S_CTL0_TDMCHNUM_Pos            (30)                                              /*!< I2S_T::CTL0: TDMCHNUM Position         */
#define I2S_CTL0_TDMCHNUM_Msk            (0x3ul << I2S_CTL0_TDMCHNUM_Pos)                  /*!< I2S_T::CTL0: TDMCHNUM Mask             */

#define I2S_CLKDIV_MCLKDIV_Pos           (0)                                               /*!< I2S_T::CLKDIV: MCLKDIV Position        */
#define I2S_CLKDIV_MCLKDIV_Msk           (0x3ful << I2S_CLKDIV_MCLKDIV_Pos)                /*!< I2S_T::CLKDIV: MCLKDIV Mask            */

#define I2S_CLKDIV_BCLKDIV_Pos           (8)                                               /*!< I2S_T::CLKDIV: BCLKDIV Position        */
#define I2S_CLKDIV_BCLKDIV_Msk           (0x1fful << I2S_CLKDIV_BCLKDIV_Pos)               /*!< I2S_T::CLKDIV: BCLKDIV Mask            */

#define I2S_IEN_RXUDFIEN_Pos             (0)                                               /*!< I2S_T::IEN: RXUDFIEN Position          */
#define I2S_IEN_RXUDFIEN_Msk             (0x1ul << I2S_IEN_RXUDFIEN_Pos)                   /*!< I2S_T::IEN: RXUDFIEN Mask              */

#define I2S_IEN_RXOVFIEN_Pos             (1)                                               /*!< I2S_T::IEN: RXOVFIEN Position          */
#define I2S_IEN_RXOVFIEN_Msk             (0x1ul << I2S_IEN_RXOVFIEN_Pos)                   /*!< I2S_T::IEN: RXOVFIEN Mask              */

#define I2S_IEN_RXTHIEN_Pos              (2)                                               /*!< I2S_T::IEN: RXTHIEN Position           */
#define I2S_IEN_RXTHIEN_Msk              (0x1ul << I2S_IEN_RXTHIEN_Pos)                    /*!< I2S_T::IEN: RXTHIEN Mask               */

#define I2S_IEN_TXUDFIEN_Pos             (8)                                               /*!< I2S_T::IEN: TXUDFIEN Position          */
#define I2S_IEN_TXUDFIEN_Msk             (0x1ul << I2S_IEN_TXUDFIEN_Pos)                   /*!< I2S_T::IEN: TXUDFIEN Mask              */

#define I2S_IEN_TXOVFIEN_Pos             (9)                                               /*!< I2S_T::IEN: TXOVFIEN Position          */
#define I2S_IEN_TXOVFIEN_Msk             (0x1ul << I2S_IEN_TXOVFIEN_Pos)                   /*!< I2S_T::IEN: TXOVFIEN Mask              */

#define I2S_IEN_TXTHIEN_Pos              (10)                                              /*!< I2S_T::IEN: TXTHIEN Position           */
#define I2S_IEN_TXTHIEN_Msk              (0x1ul << I2S_IEN_TXTHIEN_Pos)                    /*!< I2S_T::IEN: TXTHIEN Mask               */

#define I2S_IEN_CH0ZCIEN_Pos             (16)                                              /*!< I2S_T::IEN: CH0ZCIEN Position          */
#define I2S_IEN_CH0ZCIEN_Msk             (0x1ul << I2S_IEN_CH0ZCIEN_Pos)                   /*!< I2S_T::IEN: CH0ZCIEN Mask              */

#define I2S_IEN_CH1ZCIEN_Pos             (17)                                              /*!< I2S_T::IEN: CH1ZCIEN Position          */
#define I2S_IEN_CH1ZCIEN_Msk             (0x1ul << I2S_IEN_CH1ZCIEN_Pos)                   /*!< I2S_T::IEN: CH1ZCIEN Mask              */

#define I2S_IEN_CH2ZCIEN_Pos             (18)                                              /*!< I2S_T::IEN: CH2ZCIEN Position          */
#define I2S_IEN_CH2ZCIEN_Msk             (0x1ul << I2S_IEN_CH2ZCIEN_Pos)                   /*!< I2S_T::IEN: CH2ZCIEN Mask              */

#define I2S_IEN_CH3ZCIEN_Pos             (19)                                              /*!< I2S_T::IEN: CH3ZCIEN Position          */
#define I2S_IEN_CH3ZCIEN_Msk             (0x1ul << I2S_IEN_CH3ZCIEN_Pos)                   /*!< I2S_T::IEN: CH3ZCIEN Mask              */

#define I2S_IEN_CH4ZCIEN_Pos             (20)                                              /*!< I2S_T::IEN: CH4ZCIEN Position          */
#define I2S_IEN_CH4ZCIEN_Msk             (0x1ul << I2S_IEN_CH4ZCIEN_Pos)                   /*!< I2S_T::IEN: CH4ZCIEN Mask              */

#define I2S_IEN_CH5ZCIEN_Pos             (21)                                              /*!< I2S_T::IEN: CH5ZCIEN Position          */
#define I2S_IEN_CH5ZCIEN_Msk             (0x1ul << I2S_IEN_CH5ZCIEN_Pos)                   /*!< I2S_T::IEN: CH5ZCIEN Mask              */

#define I2S_IEN_CH6ZCIEN_Pos             (22)                                              /*!< I2S_T::IEN: CH6ZCIEN Position          */
#define I2S_IEN_CH6ZCIEN_Msk             (0x1ul << I2S_IEN_CH6ZCIEN_Pos)                   /*!< I2S_T::IEN: CH6ZCIEN Mask              */

#define I2S_IEN_CH7ZCIEN_Pos             (23)                                              /*!< I2S_T::IEN: CH7ZCIEN Position          */
#define I2S_IEN_CH7ZCIEN_Msk             (0x1ul << I2S_IEN_CH7ZCIEN_Pos)                   /*!< I2S_T::IEN: CH7ZCIEN Mask              */

#define I2S_STATUS0_I2SINT_Pos           (0)                                               /*!< I2S_T::STATUS0: I2SINT Position        */
#define I2S_STATUS0_I2SINT_Msk           (0x1ul << I2S_STATUS0_I2SINT_Pos)                 /*!< I2S_T::STATUS0: I2SINT Mask            */

#define I2S_STATUS0_I2SRXINT_Pos         (1)                                               /*!< I2S_T::STATUS0: I2SRXINT Position      */
#define I2S_STATUS0_I2SRXINT_Msk         (0x1ul << I2S_STATUS0_I2SRXINT_Pos)               /*!< I2S_T::STATUS0: I2SRXINT Mask          */

#define I2S_STATUS0_I2STXINT_Pos         (2)                                               /*!< I2S_T::STATUS0: I2STXINT Position      */
#define I2S_STATUS0_I2STXINT_Msk         (0x1ul << I2S_STATUS0_I2STXINT_Pos)               /*!< I2S_T::STATUS0: I2STXINT Mask          */

#define I2S_STATUS0_DATACH_Pos           (3)                                               /*!< I2S_T::STATUS0: DATACH Position        */
#define I2S_STATUS0_DATACH_Msk           (0x7ul << I2S_STATUS0_DATACH_Pos)                 /*!< I2S_T::STATUS0: DATACH Mask            */

#define I2S_STATUS0_RXUDIF_Pos           (8)                                               /*!< I2S_T::STATUS0: RXUDIF Position        */
#define I2S_STATUS0_RXUDIF_Msk           (0x1ul << I2S_STATUS0_RXUDIF_Pos)                 /*!< I2S_T::STATUS0: RXUDIF Mask            */

#define I2S_STATUS0_RXOVIF_Pos           (9)                                               /*!< I2S_T::STATUS0: RXOVIF Position        */
#define I2S_STATUS0_RXOVIF_Msk           (0x1ul << I2S_STATUS0_RXOVIF_Pos)                 /*!< I2S_T::STATUS0: RXOVIF Mask            */

#define I2S_STATUS0_RXTHIF_Pos           (10)                                              /*!< I2S_T::STATUS0: RXTHIF Position        */
#define I2S_STATUS0_RXTHIF_Msk           (0x1ul << I2S_STATUS0_RXTHIF_Pos)                 /*!< I2S_T::STATUS0: RXTHIF Mask            */

#define I2S_STATUS0_RXFULL_Pos           (11)                                              /*!< I2S_T::STATUS0: RXFULL Position        */
#define I2S_STATUS0_RXFULL_Msk           (0x1ul << I2S_STATUS0_RXFULL_Pos)                 /*!< I2S_T::STATUS0: RXFULL Mask            */

#define I2S_STATUS0_RXEMPTY_Pos          (12)                                              /*!< I2S_T::STATUS0: RXEMPTY Position       */
#define I2S_STATUS0_RXEMPTY_Msk          (0x1ul << I2S_STATUS0_RXEMPTY_Pos)                /*!< I2S_T::STATUS0: RXEMPTY Mask           */

#define I2S_STATUS0_TXUDIF_Pos           (16)                                              /*!< I2S_T::STATUS0: TXUDIF Position        */
#define I2S_STATUS0_TXUDIF_Msk           (0x1ul << I2S_STATUS0_TXUDIF_Pos)                 /*!< I2S_T::STATUS0: TXUDIF Mask            */

#define I2S_STATUS0_TXOVIF_Pos           (17)                                              /*!< I2S_T::STATUS0: TXOVIF Position        */
#define I2S_STATUS0_TXOVIF_Msk           (0x1ul << I2S_STATUS0_TXOVIF_Pos)                 /*!< I2S_T::STATUS0: TXOVIF Mask            */

#define I2S_STATUS0_TXTHIF_Pos           (18)                                              /*!< I2S_T::STATUS0: TXTHIF Position        */
#define I2S_STATUS0_TXTHIF_Msk           (0x1ul << I2S_STATUS0_TXTHIF_Pos)                 /*!< I2S_T::STATUS0: TXTHIF Mask            */

#define I2S_STATUS0_TXFULL_Pos           (19)                                              /*!< I2S_T::STATUS0: TXFULL Position        */
#define I2S_STATUS0_TXFULL_Msk           (0x1ul << I2S_STATUS0_TXFULL_Pos)                 /*!< I2S_T::STATUS0: TXFULL Mask            */

#define I2S_STATUS0_TXEMPTY_Pos          (20)                                              /*!< I2S_T::STATUS0: TXEMPTY Position       */
#define I2S_STATUS0_TXEMPTY_Msk          (0x1ul << I2S_STATUS0_TXEMPTY_Pos)                /*!< I2S_T::STATUS0: TXEMPTY Mask           */

#define I2S_STATUS0_TXBUSY_Pos           (21)                                              /*!< I2S_T::STATUS0: TXBUSY Position        */
#define I2S_STATUS0_TXBUSY_Msk           (0x1ul << I2S_STATUS0_TXBUSY_Pos)                 /*!< I2S_T::STATUS0: TXBUSY Mask            */

#define I2S_TXFIFO_TXFIFO_Pos            (0)                                               /*!< I2S_T::TXFIFO: TXFIFO Position         */
#define I2S_TXFIFO_TXFIFO_Msk            (0xfffffffful << I2S_TXFIFO_TXFIFO_Pos)           /*!< I2S_T::TXFIFO: TXFIFO Mask             */

#define I2S_RXFIFO_RXFIFO_Pos            (0)                                               /*!< I2S_T::RXFIFO: RXFIFO Position         */
#define I2S_RXFIFO_RXFIFO_Msk            (0xfffffffful << I2S_RXFIFO_RXFIFO_Pos)           /*!< I2S_T::RXFIFO: RXFIFO Mask             */

#define I2S_CTL1_CH0ZCEN_Pos             (0)                                               /*!< I2S_T::CTL1: CH0ZCEN Position          */
#define I2S_CTL1_CH0ZCEN_Msk             (0x1ul << I2S_CTL1_CH0ZCEN_Pos)                   /*!< I2S_T::CTL1: CH0ZCEN Mask              */

#define I2S_CTL1_CH1ZCEN_Pos             (1)                                               /*!< I2S_T::CTL1: CH1ZCEN Position          */
#define I2S_CTL1_CH1ZCEN_Msk             (0x1ul << I2S_CTL1_CH1ZCEN_Pos)                   /*!< I2S_T::CTL1: CH1ZCEN Mask              */

#define I2S_CTL1_CH2ZCEN_Pos             (2)                                               /*!< I2S_T::CTL1: CH2ZCEN Position          */
#define I2S_CTL1_CH2ZCEN_Msk             (0x1ul << I2S_CTL1_CH2ZCEN_Pos)                   /*!< I2S_T::CTL1: CH2ZCEN Mask              */

#define I2S_CTL1_CH3ZCEN_Pos             (3)                                               /*!< I2S_T::CTL1: CH3ZCEN Position          */
#define I2S_CTL1_CH3ZCEN_Msk             (0x1ul << I2S_CTL1_CH3ZCEN_Pos)                   /*!< I2S_T::CTL1: CH3ZCEN Mask              */

#define I2S_CTL1_CH4ZCEN_Pos             (4)                                               /*!< I2S_T::CTL1: CH4ZCEN Position          */
#define I2S_CTL1_CH4ZCEN_Msk             (0x1ul << I2S_CTL1_CH4ZCEN_Pos)                   /*!< I2S_T::CTL1: CH4ZCEN Mask              */

#define I2S_CTL1_CH5ZCEN_Pos             (5)                                               /*!< I2S_T::CTL1: CH5ZCEN Position          */
#define I2S_CTL1_CH5ZCEN_Msk             (0x1ul << I2S_CTL1_CH5ZCEN_Pos)                   /*!< I2S_T::CTL1: CH5ZCEN Mask              */

#define I2S_CTL1_CH6ZCEN_Pos             (6)                                               /*!< I2S_T::CTL1: CH6ZCEN Position          */
#define I2S_CTL1_CH6ZCEN_Msk             (0x1ul << I2S_CTL1_CH6ZCEN_Pos)                   /*!< I2S_T::CTL1: CH6ZCEN Mask              */

#define I2S_CTL1_CH7ZCEN_Pos             (7)                                               /*!< I2S_T::CTL1: CH7ZCEN Position          */
#define I2S_CTL1_CH7ZCEN_Msk             (0x1ul << I2S_CTL1_CH7ZCEN_Pos)                   /*!< I2S_T::CTL1: CH7ZCEN Mask              */

#define I2S_CTL1_TXTH_Pos                (8)                                               /*!< I2S_T::CTL1: TXTH Position             */
#define I2S_CTL1_TXTH_Msk                (0xful << I2S_CTL1_TXTH_Pos)                      /*!< I2S_T::CTL1: TXTH Mask                 */

#define I2S_CTL1_RXTH_Pos                (16)                                              /*!< I2S_T::CTL1: RXTH Position             */
#define I2S_CTL1_RXTH_Msk                (0xful << I2S_CTL1_RXTH_Pos)                      /*!< I2S_T::CTL1: RXTH Mask                 */

#define I2S_CTL1_PBWIDTH_Pos             (24)                                              /*!< I2S_T::CTL1: PBWIDTH Position          */
#define I2S_CTL1_PBWIDTH_Msk             (0x1ul << I2S_CTL1_PBWIDTH_Pos)                   /*!< I2S_T::CTL1: PBWIDTH Mask              */

#define I2S_CTL1_PB16ORD_Pos             (25)                                              /*!< I2S_T::CTL1: PB16ORD Position          */
#define I2S_CTL1_PB16ORD_Msk             (0x1ul << I2S_CTL1_PB16ORD_Pos)                   /*!< I2S_T::CTL1: PB16ORD Mask              */

#define I2S_STATUS1_CH0ZCIF_Pos          (0)                                               /*!< I2S_T::STATUS1: CH0ZCIF Position       */
#define I2S_STATUS1_CH0ZCIF_Msk          (0x1ul << I2S_STATUS1_CH0ZCIF_Pos)                /*!< I2S_T::STATUS1: CH0ZCIF Mask           */

#define I2S_STATUS1_CH1ZCIF_Pos          (1)                                               /*!< I2S_T::STATUS1: CH1ZCIF Position       */
#define I2S_STATUS1_CH1ZCIF_Msk          (0x1ul << I2S_STATUS1_CH1ZCIF_Pos)                /*!< I2S_T::STATUS1: CH1ZCIF Mask           */

#define I2S_STATUS1_CH2ZCIF_Pos          (2)                                               /*!< I2S_T::STATUS1: CH2ZCIF Position       */
#define I2S_STATUS1_CH2ZCIF_Msk          (0x1ul << I2S_STATUS1_CH2ZCIF_Pos)                /*!< I2S_T::STATUS1: CH2ZCIF Mask           */

#define I2S_STATUS1_CH3ZCIF_Pos          (3)                                               /*!< I2S_T::STATUS1: CH3ZCIF Position       */
#define I2S_STATUS1_CH3ZCIF_Msk          (0x1ul << I2S_STATUS1_CH3ZCIF_Pos)                /*!< I2S_T::STATUS1: CH3ZCIF Mask           */

#define I2S_STATUS1_CH4ZCIF_Pos          (4)                                               /*!< I2S_T::STATUS1: CH4ZCIF Position       */
#define I2S_STATUS1_CH4ZCIF_Msk          (0x1ul << I2S_STATUS1_CH4ZCIF_Pos)                /*!< I2S_T::STATUS1: CH4ZCIF Mask           */

#define I2S_STATUS1_CH5ZCIF_Pos          (5)                                               /*!< I2S_T::STATUS1: CH5ZCIF Position       */
#define I2S_STATUS1_CH5ZCIF_Msk          (0x1ul << I2S_STATUS1_CH5ZCIF_Pos)                /*!< I2S_T::STATUS1: CH5ZCIF Mask           */

#define I2S_STATUS1_CH6ZCIF_Pos          (6)                                               /*!< I2S_T::STATUS1: CH6ZCIF Position       */
#define I2S_STATUS1_CH6ZCIF_Msk          (0x1ul << I2S_STATUS1_CH6ZCIF_Pos)                /*!< I2S_T::STATUS1: CH6ZCIF Mask           */

#define I2S_STATUS1_CH7ZCIF_Pos          (7)                                               /*!< I2S_T::STATUS1: CH7ZCIF Position       */
#define I2S_STATUS1_CH7ZCIF_Msk          (0x1ul << I2S_STATUS1_CH7ZCIF_Pos)                /*!< I2S_T::STATUS1: CH7ZCIF Mask           */

#define I2S_STATUS1_TXCNT_Pos            (8)                                               /*!< I2S_T::STATUS1: TXCNT Position         */
#define I2S_STATUS1_TXCNT_Msk            (0x1ful << I2S_STATUS1_TXCNT_Pos)                 /*!< I2S_T::STATUS1: TXCNT Mask             */

#define I2S_STATUS1_RXCNT_Pos            (16)                                              /*!< I2S_T::STATUS1: RXCNT Position         */
#define I2S_STATUS1_RXCNT_Msk            (0x1ful << I2S_STATUS1_RXCNT_Pos)                 /*!< I2S_T::STATUS1: RXCNT Mask             */

/**@}*/ /* I2S_CONST */
/**@}*/ /* end of I2S register group */


/*---------------------- NMI Controller -------------------------*/
/**
    @addtogroup NMI NMI Controller(NMI)
    Memory Mapped Structure for NMI Controller
@{ */
 
typedef struct
{


/**
 * @var NMI_T::NMIEN
 * Offset: 0x00  NMI Source Interrupt Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BODOUT    |BOD NMI Source Enable (Write Protect)
 * |        |          |0 = BOD NMI source Disabled.
 * |        |          |1 = BOD NMI source Enabled.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[1]     |IRC_INT   |IRC TRIM NMI Source Enable (Write Protect)
 * |        |          |0 = IRC TRIM NMI source Disabled.
 * |        |          |1 = IRC TRIM NMI source Enabled.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[2]     |PWRWU_INT |Power-down Mode Wake-up NMI Source Enable (Write Protect)
 * |        |          |0 = Power-down mode wake-up NMI source Disabled.
 * |        |          |1 = Power-down mode wake-up NMI source Enabled.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[3]     |SRAM_PERR |SRAM ParityCheck Error NMI Source Enable (Write Protect)
 * |        |          |0 = SRAM parity check error NMI source Disabled.
 * |        |          |1 = SRAM parity check error NMI source Enabled.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[4]     |CLKFAIL   |Clock Fail Detected NMI Source Enable (Write Protect)
 * |        |          |0 = Clock fail detected interrupt NMI source Disabled.
 * |        |          |1 = Clock fail detected interrupt NMI source Enabled.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[6]     |RTC_INT   |RTC NMI Source Enable (Write Protect)
 * |        |          |0 = RTC NMI source Disabled.
 * |        |          |1 = RTC NMI source Enabled.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[8]     |EINT0     |External Interrupt 0 NMI Source Enable (Write Protect)
 * |        |          |0 = External interrupt 0 NMI source Disabled.
 * |        |          |1 = External interrupt 0 NMI source Enabled.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[9]     |EINT1     |External Interrupt 1 NMI Source Enable (Write Protect)
 * |        |          |0 = External interrupt 1 NMI source Disabled.
 * |        |          |1 = External interrupt 1 NMI source Enabled.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[10]    |EINT2     |External Interrupt 2 NMI Source Enable (Write Protect)
 * |        |          |0 = External interrupt 2 NMI source Disabled.
 * |        |          |1 = External interrupt 2 NMI source Enabled.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[11]    |EINT3     |External Interrupt 3 NMI Source Enable (Write Protect)
 * |        |          |0 = External interrupt 3 NMI source Disabled.
 * |        |          |1 = External interrupt 3 NMI source Enabled.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[12]    |EINT4     |External Interrupt 4 NMI Source Enable (Write Protect)
 * |        |          |0 = External interrupt 4 NMI source Disabled.
 * |        |          |1 = External interrupt 4 NMI source Enabled.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[13]    |EINT5     |External Interrupt 5 NMI Source Enable (Write Protect[AlvinLiao1])
 * |        |          |0 = External interrupt 5 NMI source Disabled.
 * |        |          |1 = External interrupt 5 NMI source Enabled.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |        |          |[AlvinLiao1]TBD
 * |[14]    |UART0_INT |UART0 NMI Source Enable (Write Protect)
 * |        |          |0 = UART0 NMI source Disabled.
 * |        |          |1 = UART0 NMI source Enabled.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * @var NMI_T::NMISTS
 * Offset: 0x04  NMI source interrupt Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BODOUT    |BOD Interrupt Flag (Read Only)
 * |        |          |0 = BOD interrupt is deasserted.
 * |        |          |1 = BOD interrupt is asserted.
 * |[1]     |IRC_INT   |IRC TRIM Interrupt Flag (Read Only)
 * |        |          |0 = HIRC TRIM interrupt is deasserted.
 * |        |          |1 = HIRC TRIM interrupt is asserted. 
 * |[2]     |PWRWU_INT |Power-down Mode Wake-up Interrupt Flag (Read Only)
 * |        |          |0 = Power-down mode wake-up interrupt is deasserted.
 * |        |          |1 = Power-down mode wake-up interrupt is asserted. 
 * |[3]     |SRAM_PERR |SRAM ParityCheck Error Interrupt Flag (Read Only)
 * |        |          |0 = SRAM parity check error interrupt is deasserted.
 * |        |          |1 = SRAM parity check error interrupt is asserted. 
 * |[4]     |CLKFAIL   |Clock Fail Detected Interrupt Flag (Read Only)
 * |        |          |0 = Clock fail detected interrupt is deasserted.
 * |        |          |1 = Clock fail detected interrupt is asserted. 
 * |[6]     |RTC_INT   |RTC Interrupt Flag (Read Only)
 * |        |          |0 = RTC interrupt is deasserted.
 * |        |          |1 = RTC interrupt is asserted.
 * |[8]     |EINT0     |External Interrupt 0 Interrupt Flag (Read Only)
 * |        |          |0 = External Interrupt 0 interrupt is deasserted.
 * |        |          |1 = External Interrupt 0 interrupt is asserted.
 * |[9]     |EINT1     |External Interrupt 1 Interrupt Flag (Read Only)
 * |        |          |0 = External Interrupt 1 interrupt is deasserted.
 * |        |          |1 = External Interrupt 1 interrupt is asserted. 
 * |[10]    |EINT2     |External Interrupt 2 Interrupt Flag (Read Only)
 * |        |          |0 = External Interrupt 2 interrupt is deasserted.
 * |        |          |1 = External Interrupt 2 interrupt is asserted.
 * |[11]    |EINT3     |External Interrupt 3 Interrupt Flag (Read Only)
 * |        |          |0 = External Interrupt 3 interrupt is deasserted.
 * |        |          |1 = External Interrupt 3 interrupt is asserted.
 * |[12]    |EINT4     |External Interrupt 4 Interrupt Flag (Read Only)
 * |        |          |0 = External Interrupt 4 interrupt is deasserted.
 * |        |          |1 = External Interrupt 4 interrupt is asserted.
 * |[13]    |EINT5     |External Interrupt 5 Interrupt Flag (Read Only)
 * |        |          |0 = External Interrupt 5 interrupt is deasserted.
 * |        |          |1 = External Interrupt 5 interrupt is asserted.
 * |[14]    |UART0_INT |UART0 Interrupt Flag (Read Only)
 * |        |          |0 = UART1 interrupt is deasserted.
 * |        |          |1 = UART1 interrupt is asserted.
 */
    __IO uint32_t NMIEN;                 /*!< [0x0000] NMI Source Interrupt Enable Register                             */
    __I  uint32_t NMISTS;                /*!< [0x0004] NMI source interrupt Status Register                             */

} NMI_T;

/**
    @addtogroup NMI_CONST NMI Bit Field Definition
    Constant Definitions for NMI Controller
@{ */

#define NMI_NMIEN_BODOUT_Pos             (0)                                               /*!< NMI_T::NMIEN: BODOUT Position          */
#define NMI_NMIEN_BODOUT_Msk             (0x1ul << NMI_NMIEN_BODOUT_Pos)                   /*!< NMI_T::NMIEN: BODOUT Mask              */

#define NMI_NMIEN_IRC_INT_Pos            (1)                                               /*!< NMI_T::NMIEN: IRC_INT Position         */
#define NMI_NMIEN_IRC_INT_Msk            (0x1ul << NMI_NMIEN_IRC_INT_Pos)                  /*!< NMI_T::NMIEN: IRC_INT Mask             */

#define NMI_NMIEN_PWRWU_INT_Pos          (2)                                               /*!< NMI_T::NMIEN: PWRWU_INT Position       */
#define NMI_NMIEN_PWRWU_INT_Msk          (0x1ul << NMI_NMIEN_PWRWU_INT_Pos)                /*!< NMI_T::NMIEN: PWRWU_INT Mask           */

#define NMI_NMIEN_SRAM_PERR_Pos          (3)                                               /*!< NMI_T::NMIEN: SRAM_PERR Position       */
#define NMI_NMIEN_SRAM_PERR_Msk          (0x1ul << NMI_NMIEN_SRAM_PERR_Pos)                /*!< NMI_T::NMIEN: SRAM_PERR Mask           */

#define NMI_NMIEN_CLKFAIL_Pos            (4)                                               /*!< NMI_T::NMIEN: CLKFAIL Position         */
#define NMI_NMIEN_CLKFAIL_Msk            (0x1ul << NMI_NMIEN_CLKFAIL_Pos)                  /*!< NMI_T::NMIEN: CLKFAIL Mask             */

#define NMI_NMIEN_RTC_INT_Pos            (6)                                               /*!< NMI_T::NMIEN: RTC_INT Position         */
#define NMI_NMIEN_RTC_INT_Msk            (0x1ul << NMI_NMIEN_RTC_INT_Pos)                  /*!< NMI_T::NMIEN: RTC_INT Mask             */

#define NMI_NMIEN_EINT0_Pos              (8)                                               /*!< NMI_T::NMIEN: EINT0 Position           */
#define NMI_NMIEN_EINT0_Msk              (0x1ul << NMI_NMIEN_EINT0_Pos)                    /*!< NMI_T::NMIEN: EINT0 Mask               */

#define NMI_NMIEN_EINT1_Pos              (9)                                               /*!< NMI_T::NMIEN: EINT1 Position           */
#define NMI_NMIEN_EINT1_Msk              (0x1ul << NMI_NMIEN_EINT1_Pos)                    /*!< NMI_T::NMIEN: EINT1 Mask               */

#define NMI_NMIEN_EINT2_Pos              (10)                                              /*!< NMI_T::NMIEN: EINT2 Position           */
#define NMI_NMIEN_EINT2_Msk              (0x1ul << NMI_NMIEN_EINT2_Pos)                    /*!< NMI_T::NMIEN: EINT2 Mask               */

#define NMI_NMIEN_EINT3_Pos              (11)                                              /*!< NMI_T::NMIEN: EINT3 Position           */
#define NMI_NMIEN_EINT3_Msk              (0x1ul << NMI_NMIEN_EINT3_Pos)                    /*!< NMI_T::NMIEN: EINT3 Mask               */

#define NMI_NMIEN_EINT4_Pos              (12)                                              /*!< NMI_T::NMIEN: EINT4 Position           */
#define NMI_NMIEN_EINT4_Msk              (0x1ul << NMI_NMIEN_EINT4_Pos)                    /*!< NMI_T::NMIEN: EINT4 Mask               */

#define NMI_NMIEN_EINT5_Pos              (13)                                              /*!< NMI_T::NMIEN: EINT5 Position           */
#define NMI_NMIEN_EINT5_Msk              (0x1ul << NMI_NMIEN_EINT5_Pos)                    /*!< NMI_T::NMIEN: EINT5 Mask               */

#define NMI_NMIEN_UART0_INT_Pos          (14)                                              /*!< NMI_T::NMIEN: UART0_INT Position       */
#define NMI_NMIEN_UART0_INT_Msk          (0x1ul << NMI_NMIEN_UART0_INT_Pos)                /*!< NMI_T::NMIEN: UART0_INT Mask           */

#define NMI_NMISTS_BODOUT_Pos            (0)                                               /*!< NMI_T::NMISTS: BODOUT Position         */
#define NMI_NMISTS_BODOUT_Msk            (0x1ul << NMI_NMISTS_BODOUT_Pos)                  /*!< NMI_T::NMISTS: BODOUT Mask             */

#define NMI_NMISTS_IRC_INT_Pos           (1)                                               /*!< NMI_T::NMISTS: IRC_INT Position        */
#define NMI_NMISTS_IRC_INT_Msk           (0x1ul << NMI_NMISTS_IRC_INT_Pos)                 /*!< NMI_T::NMISTS: IRC_INT Mask            */

#define NMI_NMISTS_PWRWU_INT_Pos         (2)                                               /*!< NMI_T::NMISTS: PWRWU_INT Position      */
#define NMI_NMISTS_PWRWU_INT_Msk         (0x1ul << NMI_NMISTS_PWRWU_INT_Pos)               /*!< NMI_T::NMISTS: PWRWU_INT Mask          */

#define NMI_NMISTS_SRAM_PERR_Pos         (3)                                               /*!< NMI_T::NMISTS: SRAM_PERR Position      */
#define NMI_NMISTS_SRAM_PERR_Msk         (0x1ul << NMI_NMISTS_SRAM_PERR_Pos)               /*!< NMI_T::NMISTS: SRAM_PERR Mask          */

#define NMI_NMISTS_CLKFAIL_Pos           (4)                                               /*!< NMI_T::NMISTS: CLKFAIL Position        */
#define NMI_NMISTS_CLKFAIL_Msk           (0x1ul << NMI_NMISTS_CLKFAIL_Pos)                 /*!< NMI_T::NMISTS: CLKFAIL Mask            */

#define NMI_NMISTS_RTC_INT_Pos           (6)                                               /*!< NMI_T::NMISTS: RTC_INT Position        */
#define NMI_NMISTS_RTC_INT_Msk           (0x1ul << NMI_NMISTS_RTC_INT_Pos)                 /*!< NMI_T::NMISTS: RTC_INT Mask            */

#define NMI_NMISTS_EINT0_Pos             (8)                                               /*!< NMI_T::NMISTS: EINT0 Position          */
#define NMI_NMISTS_EINT0_Msk             (0x1ul << NMI_NMISTS_EINT0_Pos)                   /*!< NMI_T::NMISTS: EINT0 Mask              */

#define NMI_NMISTS_EINT1_Pos             (9)                                               /*!< NMI_T::NMISTS: EINT1 Position          */
#define NMI_NMISTS_EINT1_Msk             (0x1ul << NMI_NMISTS_EINT1_Pos)                   /*!< NMI_T::NMISTS: EINT1 Mask              */

#define NMI_NMISTS_EINT2_Pos             (10)                                              /*!< NMI_T::NMISTS: EINT2 Position          */
#define NMI_NMISTS_EINT2_Msk             (0x1ul << NMI_NMISTS_EINT2_Pos)                   /*!< NMI_T::NMISTS: EINT2 Mask              */

#define NMI_NMISTS_EINT3_Pos             (11)                                              /*!< NMI_T::NMISTS: EINT3 Position          */
#define NMI_NMISTS_EINT3_Msk             (0x1ul << NMI_NMISTS_EINT3_Pos)                   /*!< NMI_T::NMISTS: EINT3 Mask              */

#define NMI_NMISTS_EINT4_Pos             (12)                                              /*!< NMI_T::NMISTS: EINT4 Position          */
#define NMI_NMISTS_EINT4_Msk             (0x1ul << NMI_NMISTS_EINT4_Pos)                   /*!< NMI_T::NMISTS: EINT4 Mask              */

#define NMI_NMISTS_EINT5_Pos             (13)                                              /*!< NMI_T::NMISTS: EINT5 Position          */
#define NMI_NMISTS_EINT5_Msk             (0x1ul << NMI_NMISTS_EINT5_Pos)                   /*!< NMI_T::NMISTS: EINT5 Mask              */

#define NMI_NMISTS_UART0_INT_Pos         (14)                                              /*!< NMI_T::NMISTS: UART0_INT Position      */
#define NMI_NMISTS_UART0_INT_Msk         (0x1ul << NMI_NMISTS_UART0_INT_Pos)               /*!< NMI_T::NMISTS: UART0_INT Mask          */

/**@}*/ /* NMI_CONST */
/**@}*/ /* end of NMI register group */



/**
    @addtogroup NVIC_CONST NVIC Bit Field Definition
    Constant Definitions for NVIC Controller
@{ */

/**@}*/ /* NVIC_CONST */
/**@}*/ /* end of NVIC register group */


/*---------------------- Peripheral Direct Memory Access Controller -------------------------*/
/**
    @addtogroup PDMA Peripheral Direct Memory Access Controller(PDMA)
    Memory Mapped Structure for PDMA Controller
@{ */
 
typedef struct
{


/**
 * @var PDMA_T::DSCT0_CTL
 * Offset: 0x00  Descriptor Table Control Register of PDMA Channel 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |OPMODE    |PDMA Operation Mode Selection
 * |        |          |00 = Idle state: Channel is stopped or this table is complete, when PDMA finish channel table task, OPMODE will be cleared to idle state automatically.
 * |        |          |01 = Basic mode: The descriptor table only has one task
 * |        |          |When this task is finished, the PDMA_INTSTS[n] will be asserted.
 * |        |          |10 = Scatter-Gather mode: When operating in this mode, user must give the next descriptor table address in PDMA_DSCT_NEXT register; PDMA controller will ignore this task, then load the next task to execute.
 * |        |          |11 = Reserved.
 * |        |          |Note: Before filling transfer task in the Descriptor Table, user must check if the descriptor table is complete.
 * |[2]     |TXTYPE    |Transfer Type
 * |        |          |0 = Burst transfer type.
 * |        |          |1 = Single transfer type.
 * |[6:4]   |BURSIZE   |Burst Size
 * |        |          |This field is used for peripheral to determine the burst size or used for determine the re-arbitration size.
 * |        |          |000 = 128 Transfers.
 * |        |          |001 = 64 Transfers.
 * |        |          |010 = 32 Transfers.
 * |        |          |011 = 16 Transfers.
 * |        |          |100 = 8 Transfers.
 * |        |          |101 = 4 Transfers.
 * |        |          |110 = 2 Transfers.
 * |        |          |111 = 1 Transfers.
 * |        |          |Note: This field is only useful in burst transfer type.
 * |[9:8]   |SAINC     |Source Address Increment
 * |        |          |This field is used to set the source address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[11:10] |DAINC     |Destination Address Increment
 * |        |          |This field is used to set the destination address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[13:12] |TXWIDTH   |Transfer Width Selection
 * |        |          |This field is used for transfer width.
 * |        |          |00 = One byte (8 bit) is transferred for every operation.
 * |        |          |01= One half-word (16 bit) is transferred for every operation.
 * |        |          |10 = One word (32-bit) is transferred for every operation.
 * |        |          |11 = Reserved.
 * |        |          |Note: The PDMA transfer source address (PDMA_DSCT_SA) and PDMA transfer destination address (PDMA_DSCT_DA) should be alignment under the TXWIDTH selection
 * |[14]    |TXACK     |Transfer Acknowledge Selection
 * |        |          |0 = transfer ack when transfer done.
 * |        |          |1 = transfer ack when PDMA get transfer data.
 * |[15]    |STRIDEEN  |Stride Mode Enable Bit
 * |        |          |0 = Stride transfer mode Disabled.
 * |        |          |1 = Stride transfer mode Enabled.
 * |[31:16] |TXCNT     |Transfer Count
 * |        |          |The TXCNT represents the required number of PDMA transfer, the real transfer count is (TXCNT + 1); The maximum transfer count is 16384 , every transfer may be byte, half-word or word that is dependent on TXWIDTH field.
 * |        |          |Note: When PDMA finish each transfer data, this field will be decrease immediately.
 * @var PDMA_T::DSCT0_SA
 * Offset: 0x04  Source Address Register of PDMA Channel 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |SA        |PDMA Transfer Source Address Register
 * |        |          |This field indicates a 32-bit source address of PDMA controller.
 * @var PDMA_T::DSCT0_DA
 * Offset: 0x08  Destination Address Register of PDMA Channel 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |DA        |PDMA Transfer Destination Address Register
 * |        |          |This field indicates a 32-bit destination address of PDMA controller.
 * @var PDMA_T::DSCT0_NEXT
 * Offset: 0x0C  First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:2]  |NEXT      |PDMA Next Descriptor Table Offset Address Register
 * |        |          |This field indicates the offset of next descriptor table address in system memory
 * |        |          |The system memory based address is 0x2000_0000 (PDMA_SCATBA), if the next descriptor table is 0x2000_0100, then this field must fill in 0x0100.
 * |        |          |Note1: The next descriptor table address must be word boundary.
 * |        |          |Note2: Before filled transfer task in the descriptor table, user must check if the descriptor table is complete.
 * @var PDMA_T::DSCT1_CTL
 * Offset: 0x10  Descriptor Table Control Register of PDMA Channel 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |OPMODE    |PDMA Operation Mode Selection
 * |        |          |00 = Idle state: Channel is stopped or this table is complete, when PDMA finish channel table task, OPMODE will be cleared to idle state automatically.
 * |        |          |01 = Basic mode: The descriptor table only has one task
 * |        |          |When this task is finished, the PDMA_INTSTS[n] will be asserted.
 * |        |          |10 = Scatter-Gather mode: When operating in this mode, user must give the next descriptor table address in PDMA_DSCT_NEXT register; PDMA controller will ignore this task, then load the next task to execute.
 * |        |          |11 = Reserved.
 * |        |          |Note: Before filling transfer task in the Descriptor Table, user must check if the descriptor table is complete.
 * |[2]     |TXTYPE    |Transfer Type
 * |        |          |0 = Burst transfer type.
 * |        |          |1 = Single transfer type.
 * |[6:4]   |BURSIZE   |Burst Size
 * |        |          |This field is used for peripheral to determine the burst size or used for determine the re-arbitration size.
 * |        |          |000 = 128 Transfers.
 * |        |          |001 = 64 Transfers.
 * |        |          |010 = 32 Transfers.
 * |        |          |011 = 16 Transfers.
 * |        |          |100 = 8 Transfers.
 * |        |          |101 = 4 Transfers.
 * |        |          |110 = 2 Transfers.
 * |        |          |111 = 1 Transfers.
 * |        |          |Note: This field is only useful in burst transfer type.
 * |[9:8]   |SAINC     |Source Address Increment
 * |        |          |This field is used to set the source address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[11:10] |DAINC     |Destination Address Increment
 * |        |          |This field is used to set the destination address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[13:12] |TXWIDTH   |Transfer Width Selection
 * |        |          |This field is used for transfer width.
 * |        |          |00 = One byte (8 bit) is transferred for every operation.
 * |        |          |01= One half-word (16 bit) is transferred for every operation.
 * |        |          |10 = One word (32-bit) is transferred for every operation.
 * |        |          |11 = Reserved.
 * |        |          |Note: The PDMA transfer source address (PDMA_DSCT_SA) and PDMA transfer destination address (PDMA_DSCT_DA) should be alignment under the TXWIDTH selection
 * |[14]    |TXACK     |Transfer Acknowledge Selection
 * |        |          |0 = transfer ack when transfer done.
 * |        |          |1 = transfer ack when PDMA get transfer data.
 * |[15]    |STRIDEEN  |Stride Mode Enable Bit
 * |        |          |0 = Stride transfer mode Disabled.
 * |        |          |1 = Stride transfer mode Enabled.
 * |[31:16] |TXCNT     |Transfer Count
 * |        |          |The TXCNT represents the required number of PDMA transfer, the real transfer count is (TXCNT + 1); The maximum transfer count is 16384 , every transfer may be byte, half-word or word that is dependent on TXWIDTH field.
 * |        |          |Note: When PDMA finish each transfer data, this field will be decrease immediately.
 * @var PDMA_T::DSCT1_SA
 * Offset: 0x14  Source Address Register of PDMA Channel 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |SA        |PDMA Transfer Source Address Register
 * |        |          |This field indicates a 32-bit source address of PDMA controller.
 * @var PDMA_T::DSCT1_DA
 * Offset: 0x18  Destination Address Register of PDMA Channel 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |DA        |PDMA Transfer Destination Address Register
 * |        |          |This field indicates a 32-bit destination address of PDMA controller.
 * @var PDMA_T::DSCT1_NEXT
 * Offset: 0x1C  First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:2]  |NEXT      |PDMA Next Descriptor Table Offset Address Register
 * |        |          |This field indicates the offset of next descriptor table address in system memory
 * |        |          |The system memory based address is 0x2000_0000 (PDMA_SCATBA), if the next descriptor table is 0x2000_0100, then this field must fill in 0x0100.
 * |        |          |Note1: The next descriptor table address must be word boundary.
 * |        |          |Note2: Before filled transfer task in the descriptor table, user must check if the descriptor table is complete.
 * @var PDMA_T::DSCT2_CTL
 * Offset: 0x20  Descriptor Table Control Register of PDMA Channel 2
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |OPMODE    |PDMA Operation Mode Selection
 * |        |          |00 = Idle state: Channel is stopped or this table is complete, when PDMA finish channel table task, OPMODE will be cleared to idle state automatically.
 * |        |          |01 = Basic mode: The descriptor table only has one task
 * |        |          |When this task is finished, the PDMA_INTSTS[n] will be asserted.
 * |        |          |10 = Scatter-Gather mode: When operating in this mode, user must give the next descriptor table address in PDMA_DSCT_NEXT register; PDMA controller will ignore this task, then load the next task to execute.
 * |        |          |11 = Reserved.
 * |        |          |Note: Before filling transfer task in the Descriptor Table, user must check if the descriptor table is complete.
 * |[2]     |TXTYPE    |Transfer Type
 * |        |          |0 = Burst transfer type.
 * |        |          |1 = Single transfer type.
 * |[6:4]   |BURSIZE   |Burst Size
 * |        |          |This field is used for peripheral to determine the burst size or used for determine the re-arbitration size.
 * |        |          |000 = 128 Transfers.
 * |        |          |001 = 64 Transfers.
 * |        |          |010 = 32 Transfers.
 * |        |          |011 = 16 Transfers.
 * |        |          |100 = 8 Transfers.
 * |        |          |101 = 4 Transfers.
 * |        |          |110 = 2 Transfers.
 * |        |          |111 = 1 Transfers.
 * |        |          |Note: This field is only useful in burst transfer type.
 * |[9:8]   |SAINC     |Source Address Increment
 * |        |          |This field is used to set the source address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[11:10] |DAINC     |Destination Address Increment
 * |        |          |This field is used to set the destination address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[13:12] |TXWIDTH   |Transfer Width Selection
 * |        |          |This field is used for transfer width.
 * |        |          |00 = One byte (8 bit) is transferred for every operation.
 * |        |          |01= One half-word (16 bit) is transferred for every operation.
 * |        |          |10 = One word (32-bit) is transferred for every operation.
 * |        |          |11 = Reserved.
 * |        |          |Note: The PDMA transfer source address (PDMA_DSCT_SA) and PDMA transfer destination address (PDMA_DSCT_DA) should be alignment under the TXWIDTH selection
 * |[14]    |TXACK     |Transfer Acknowledge Selection
 * |        |          |0 = transfer ack when transfer done.
 * |        |          |1 = transfer ack when PDMA get transfer data.
 * |[15]    |STRIDEEN  |Stride Mode Enable Bit
 * |        |          |0 = Stride transfer mode Disabled.
 * |        |          |1 = Stride transfer mode Enabled.
 * |[31:16] |TXCNT     |Transfer Count
 * |        |          |The TXCNT represents the required number of PDMA transfer, the real transfer count is (TXCNT + 1); The maximum transfer count is 16384 , every transfer may be byte, half-word or word that is dependent on TXWIDTH field.
 * |        |          |Note: When PDMA finish each transfer data, this field will be decrease immediately.
 * @var PDMA_T::DSCT2_SA
 * Offset: 0x24  Source Address Register of PDMA Channel 2
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |SA        |PDMA Transfer Source Address Register
 * |        |          |This field indicates a 32-bit source address of PDMA controller.
 * @var PDMA_T::DSCT2_DA
 * Offset: 0x28  Destination Address Register of PDMA Channel 2
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |DA        |PDMA Transfer Destination Address Register
 * |        |          |This field indicates a 32-bit destination address of PDMA controller.
 * @var PDMA_T::DSCT2_NEXT
 * Offset: 0x2C  First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 2
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:2]  |NEXT      |PDMA Next Descriptor Table Offset Address Register
 * |        |          |This field indicates the offset of next descriptor table address in system memory
 * |        |          |The system memory based address is 0x2000_0000 (PDMA_SCATBA), if the next descriptor table is 0x2000_0100, then this field must fill in 0x0100.
 * |        |          |Note1: The next descriptor table address must be word boundary.
 * |        |          |Note2: Before filled transfer task in the descriptor table, user must check if the descriptor table is complete.
 * @var PDMA_T::DSCT3_CTL
 * Offset: 0x30  Descriptor Table Control Register of PDMA Channel 3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |OPMODE    |PDMA Operation Mode Selection
 * |        |          |00 = Idle state: Channel is stopped or this table is complete, when PDMA finish channel table task, OPMODE will be cleared to idle state automatically.
 * |        |          |01 = Basic mode: The descriptor table only has one task
 * |        |          |When this task is finished, the PDMA_INTSTS[n] will be asserted.
 * |        |          |10 = Scatter-Gather mode: When operating in this mode, user must give the next descriptor table address in PDMA_DSCT_NEXT register; PDMA controller will ignore this task, then load the next task to execute.
 * |        |          |11 = Reserved.
 * |        |          |Note: Before filling transfer task in the Descriptor Table, user must check if the descriptor table is complete.
 * |[2]     |TXTYPE    |Transfer Type
 * |        |          |0 = Burst transfer type.
 * |        |          |1 = Single transfer type.
 * |[6:4]   |BURSIZE   |Burst Size
 * |        |          |This field is used for peripheral to determine the burst size or used for determine the re-arbitration size.
 * |        |          |000 = 128 Transfers.
 * |        |          |001 = 64 Transfers.
 * |        |          |010 = 32 Transfers.
 * |        |          |011 = 16 Transfers.
 * |        |          |100 = 8 Transfers.
 * |        |          |101 = 4 Transfers.
 * |        |          |110 = 2 Transfers.
 * |        |          |111 = 1 Transfers.
 * |        |          |Note: This field is only useful in burst transfer type.
 * |[9:8]   |SAINC     |Source Address Increment
 * |        |          |This field is used to set the source address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[11:10] |DAINC     |Destination Address Increment
 * |        |          |This field is used to set the destination address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[13:12] |TXWIDTH   |Transfer Width Selection
 * |        |          |This field is used for transfer width.
 * |        |          |00 = One byte (8 bit) is transferred for every operation.
 * |        |          |01= One half-word (16 bit) is transferred for every operation.
 * |        |          |10 = One word (32-bit) is transferred for every operation.
 * |        |          |11 = Reserved.
 * |        |          |Note: The PDMA transfer source address (PDMA_DSCT_SA) and PDMA transfer destination address (PDMA_DSCT_DA) should be alignment under the TXWIDTH selection
 * |[14]    |TXACK     |Transfer Acknowledge Selection
 * |        |          |0 = transfer ack when transfer done.
 * |        |          |1 = transfer ack when PDMA get transfer data.
 * |[15]    |STRIDEEN  |Stride Mode Enable Bit
 * |        |          |0 = Stride transfer mode Disabled.
 * |        |          |1 = Stride transfer mode Enabled.
 * |[31:16] |TXCNT     |Transfer Count
 * |        |          |The TXCNT represents the required number of PDMA transfer, the real transfer count is (TXCNT + 1); The maximum transfer count is 16384 , every transfer may be byte, half-word or word that is dependent on TXWIDTH field.
 * |        |          |Note: When PDMA finish each transfer data, this field will be decrease immediately.
 * @var PDMA_T::DSCT3_SA
 * Offset: 0x34  Source Address Register of PDMA Channel 3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |SA        |PDMA Transfer Source Address Register
 * |        |          |This field indicates a 32-bit source address of PDMA controller.
 * @var PDMA_T::DSCT3_DA
 * Offset: 0x38  Destination Address Register of PDMA Channel 3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |DA        |PDMA Transfer Destination Address Register
 * |        |          |This field indicates a 32-bit destination address of PDMA controller.
 * @var PDMA_T::DSCT3_NEXT
 * Offset: 0x3C  First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:2]  |NEXT      |PDMA Next Descriptor Table Offset Address Register
 * |        |          |This field indicates the offset of next descriptor table address in system memory
 * |        |          |The system memory based address is 0x2000_0000 (PDMA_SCATBA), if the next descriptor table is 0x2000_0100, then this field must fill in 0x0100.
 * |        |          |Note1: The next descriptor table address must be word boundary.
 * |        |          |Note2: Before filled transfer task in the descriptor table, user must check if the descriptor table is complete.
 * @var PDMA_T::DSCT4_CTL
 * Offset: 0x40  Descriptor Table Control Register of PDMA Channel 4
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |OPMODE    |PDMA Operation Mode Selection
 * |        |          |00 = Idle state: Channel is stopped or this table is complete, when PDMA finish channel table task, OPMODE will be cleared to idle state automatically.
 * |        |          |01 = Basic mode: The descriptor table only has one task
 * |        |          |When this task is finished, the PDMA_INTSTS[n] will be asserted.
 * |        |          |10 = Scatter-Gather mode: When operating in this mode, user must give the next descriptor table address in PDMA_DSCT_NEXT register; PDMA controller will ignore this task, then load the next task to execute.
 * |        |          |11 = Reserved.
 * |        |          |Note: Before filling transfer task in the Descriptor Table, user must check if the descriptor table is complete.
 * |[2]     |TXTYPE    |Transfer Type
 * |        |          |0 = Burst transfer type.
 * |        |          |1 = Single transfer type.
 * |[6:4]   |BURSIZE   |Burst Size
 * |        |          |This field is used for peripheral to determine the burst size or used for determine the re-arbitration size.
 * |        |          |000 = 128 Transfers.
 * |        |          |001 = 64 Transfers.
 * |        |          |010 = 32 Transfers.
 * |        |          |011 = 16 Transfers.
 * |        |          |100 = 8 Transfers.
 * |        |          |101 = 4 Transfers.
 * |        |          |110 = 2 Transfers.
 * |        |          |111 = 1 Transfers.
 * |        |          |Note: This field is only useful in burst transfer type.
 * |[9:8]   |SAINC     |Source Address Increment
 * |        |          |This field is used to set the source address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[11:10] |DAINC     |Destination Address Increment
 * |        |          |This field is used to set the destination address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[13:12] |TXWIDTH   |Transfer Width Selection
 * |        |          |This field is used for transfer width.
 * |        |          |00 = One byte (8 bit) is transferred for every operation.
 * |        |          |01= One half-word (16 bit) is transferred for every operation.
 * |        |          |10 = One word (32-bit) is transferred for every operation.
 * |        |          |11 = Reserved.
 * |        |          |Note: The PDMA transfer source address (PDMA_DSCT_SA) and PDMA transfer destination address (PDMA_DSCT_DA) should be alignment under the TXWIDTH selection
 * |[14]    |TXACK     |Transfer Acknowledge Selection
 * |        |          |0 = transfer ack when transfer done.
 * |        |          |1 = transfer ack when PDMA get transfer data.
 * |[15]    |STRIDEEN  |Stride Mode Enable Bit
 * |        |          |0 = Stride transfer mode Disabled.
 * |        |          |1 = Stride transfer mode Enabled.
 * |[31:16] |TXCNT     |Transfer Count
 * |        |          |The TXCNT represents the required number of PDMA transfer, the real transfer count is (TXCNT + 1); The maximum transfer count is 16384 , every transfer may be byte, half-word or word that is dependent on TXWIDTH field.
 * |        |          |Note: When PDMA finish each transfer data, this field will be decrease immediately.
 * @var PDMA_T::DSCT4_SA
 * Offset: 0x44  Source Address Register of PDMA Channel 4
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |SA        |PDMA Transfer Source Address Register
 * |        |          |This field indicates a 32-bit source address of PDMA controller.
 * @var PDMA_T::DSCT4_DA
 * Offset: 0x48  Destination Address Register of PDMA Channel 4
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |DA        |PDMA Transfer Destination Address Register
 * |        |          |This field indicates a 32-bit destination address of PDMA controller.
 * @var PDMA_T::DSCT4_NEXT
 * Offset: 0x4C  First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 4
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:2]  |NEXT      |PDMA Next Descriptor Table Offset Address Register
 * |        |          |This field indicates the offset of next descriptor table address in system memory
 * |        |          |The system memory based address is 0x2000_0000 (PDMA_SCATBA), if the next descriptor table is 0x2000_0100, then this field must fill in 0x0100.
 * |        |          |Note1: The next descriptor table address must be word boundary.
 * |        |          |Note2: Before filled transfer task in the descriptor table, user must check if the descriptor table is complete.
 * @var PDMA_T::DSCT5_CTL
 * Offset: 0x50  Descriptor Table Control Register of PDMA Channel 5
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |OPMODE    |PDMA Operation Mode Selection
 * |        |          |00 = Idle state: Channel is stopped or this table is complete, when PDMA finish channel table task, OPMODE will be cleared to idle state automatically.
 * |        |          |01 = Basic mode: The descriptor table only has one task
 * |        |          |When this task is finished, the PDMA_INTSTS[n] will be asserted.
 * |        |          |10 = Scatter-Gather mode: When operating in this mode, user must give the next descriptor table address in PDMA_DSCT_NEXT register; PDMA controller will ignore this task, then load the next task to execute.
 * |        |          |11 = Reserved.
 * |        |          |Note: Before filling transfer task in the Descriptor Table, user must check if the descriptor table is complete.
 * |[2]     |TXTYPE    |Transfer Type
 * |        |          |0 = Burst transfer type.
 * |        |          |1 = Single transfer type.
 * |[6:4]   |BURSIZE   |Burst Size
 * |        |          |This field is used for peripheral to determine the burst size or used for determine the re-arbitration size.
 * |        |          |000 = 128 Transfers.
 * |        |          |001 = 64 Transfers.
 * |        |          |010 = 32 Transfers.
 * |        |          |011 = 16 Transfers.
 * |        |          |100 = 8 Transfers.
 * |        |          |101 = 4 Transfers.
 * |        |          |110 = 2 Transfers.
 * |        |          |111 = 1 Transfers.
 * |        |          |Note: This field is only useful in burst transfer type.
 * |[9:8]   |SAINC     |Source Address Increment
 * |        |          |This field is used to set the source address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[11:10] |DAINC     |Destination Address Increment
 * |        |          |This field is used to set the destination address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[13:12] |TXWIDTH   |Transfer Width Selection
 * |        |          |This field is used for transfer width.
 * |        |          |00 = One byte (8 bit) is transferred for every operation.
 * |        |          |01= One half-word (16 bit) is transferred for every operation.
 * |        |          |10 = One word (32-bit) is transferred for every operation.
 * |        |          |11 = Reserved.
 * |        |          |Note: The PDMA transfer source address (PDMA_DSCT_SA) and PDMA transfer destination address (PDMA_DSCT_DA) should be alignment under the TXWIDTH selection
 * |[14]    |TXACK     |Transfer Acknowledge Selection
 * |        |          |0 = transfer ack when transfer done.
 * |        |          |1 = transfer ack when PDMA get transfer data.
 * |[15]    |STRIDEEN  |Stride Mode Enable Bit
 * |        |          |0 = Stride transfer mode Disabled.
 * |        |          |1 = Stride transfer mode Enabled.
 * |[31:16] |TXCNT     |Transfer Count
 * |        |          |The TXCNT represents the required number of PDMA transfer, the real transfer count is (TXCNT + 1); The maximum transfer count is 16384 , every transfer may be byte, half-word or word that is dependent on TXWIDTH field.
 * |        |          |Note: When PDMA finish each transfer data, this field will be decrease immediately.
 * @var PDMA_T::DSCT5_SA
 * Offset: 0x54  Source Address Register of PDMA Channel 5
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |SA        |PDMA Transfer Source Address Register
 * |        |          |This field indicates a 32-bit source address of PDMA controller.
 * @var PDMA_T::DSCT5_DA
 * Offset: 0x58  Destination Address Register of PDMA Channel 5
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |DA        |PDMA Transfer Destination Address Register
 * |        |          |This field indicates a 32-bit destination address of PDMA controller.
 * @var PDMA_T::DSCT5_NEXT
 * Offset: 0x5C  First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 5
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:2]  |NEXT      |PDMA Next Descriptor Table Offset Address Register
 * |        |          |This field indicates the offset of next descriptor table address in system memory
 * |        |          |The system memory based address is 0x2000_0000 (PDMA_SCATBA), if the next descriptor table is 0x2000_0100, then this field must fill in 0x0100.
 * |        |          |Note1: The next descriptor table address must be word boundary.
 * |        |          |Note2: Before filled transfer task in the descriptor table, user must check if the descriptor table is complete.
 * @var PDMA_T::DSCT6_CTL
 * Offset: 0x60  Descriptor Table Control Register of PDMA Channel 6
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |OPMODE    |PDMA Operation Mode Selection
 * |        |          |00 = Idle state: Channel is stopped or this table is complete, when PDMA finish channel table task, OPMODE will be cleared to idle state automatically.
 * |        |          |01 = Basic mode: The descriptor table only has one task
 * |        |          |When this task is finished, the PDMA_INTSTS[n] will be asserted.
 * |        |          |10 = Scatter-Gather mode: When operating in this mode, user must give the next descriptor table address in PDMA_DSCT_NEXT register; PDMA controller will ignore this task, then load the next task to execute.
 * |        |          |11 = Reserved.
 * |        |          |Note: Before filling transfer task in the Descriptor Table, user must check if the descriptor table is complete.
 * |[2]     |TXTYPE    |Transfer Type
 * |        |          |0 = Burst transfer type.
 * |        |          |1 = Single transfer type.
 * |[6:4]   |BURSIZE   |Burst Size
 * |        |          |This field is used for peripheral to determine the burst size or used for determine the re-arbitration size.
 * |        |          |000 = 128 Transfers.
 * |        |          |001 = 64 Transfers.
 * |        |          |010 = 32 Transfers.
 * |        |          |011 = 16 Transfers.
 * |        |          |100 = 8 Transfers.
 * |        |          |101 = 4 Transfers.
 * |        |          |110 = 2 Transfers.
 * |        |          |111 = 1 Transfers.
 * |        |          |Note: This field is only useful in burst transfer type.
 * |[9:8]   |SAINC     |Source Address Increment
 * |        |          |This field is used to set the source address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[11:10] |DAINC     |Destination Address Increment
 * |        |          |This field is used to set the destination address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[13:12] |TXWIDTH   |Transfer Width Selection
 * |        |          |This field is used for transfer width.
 * |        |          |00 = One byte (8 bit) is transferred for every operation.
 * |        |          |01= One half-word (16 bit) is transferred for every operation.
 * |        |          |10 = One word (32-bit) is transferred for every operation.
 * |        |          |11 = Reserved.
 * |        |          |Note: The PDMA transfer source address (PDMA_DSCT_SA) and PDMA transfer destination address (PDMA_DSCT_DA) should be alignment under the TXWIDTH selection
 * |[14]    |TXACK     |Transfer Acknowledge Selection
 * |        |          |0 = transfer ack when transfer done.
 * |        |          |1 = transfer ack when PDMA get transfer data.
 * |[15]    |STRIDEEN  |Stride Mode Enable Bit
 * |        |          |0 = Stride transfer mode Disabled.
 * |        |          |1 = Stride transfer mode Enabled.
 * |[31:16] |TXCNT     |Transfer Count
 * |        |          |The TXCNT represents the required number of PDMA transfer, the real transfer count is (TXCNT + 1); The maximum transfer count is 16384 , every transfer may be byte, half-word or word that is dependent on TXWIDTH field.
 * |        |          |Note: When PDMA finish each transfer data, this field will be decrease immediately.
 * @var PDMA_T::DSCT6_SA
 * Offset: 0x64  Source Address Register of PDMA Channel 6
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |SA        |PDMA Transfer Source Address Register
 * |        |          |This field indicates a 32-bit source address of PDMA controller.
 * @var PDMA_T::DSCT6_DA
 * Offset: 0x68  Destination Address Register of PDMA Channel 6
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |DA        |PDMA Transfer Destination Address Register
 * |        |          |This field indicates a 32-bit destination address of PDMA controller.
 * @var PDMA_T::DSCT6_NEXT
 * Offset: 0x6C  First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 6
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:2]  |NEXT      |PDMA Next Descriptor Table Offset Address Register
 * |        |          |This field indicates the offset of next descriptor table address in system memory
 * |        |          |The system memory based address is 0x2000_0000 (PDMA_SCATBA), if the next descriptor table is 0x2000_0100, then this field must fill in 0x0100.
 * |        |          |Note1: The next descriptor table address must be word boundary.
 * |        |          |Note2: Before filled transfer task in the descriptor table, user must check if the descriptor table is complete.
 * @var PDMA_T::DSCT7_CTL
 * Offset: 0x70  Descriptor Table Control Register of PDMA Channel 7
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |OPMODE    |PDMA Operation Mode Selection
 * |        |          |00 = Idle state: Channel is stopped or this table is complete, when PDMA finish channel table task, OPMODE will be cleared to idle state automatically.
 * |        |          |01 = Basic mode: The descriptor table only has one task
 * |        |          |When this task is finished, the PDMA_INTSTS[n] will be asserted.
 * |        |          |10 = Scatter-Gather mode: When operating in this mode, user must give the next descriptor table address in PDMA_DSCT_NEXT register; PDMA controller will ignore this task, then load the next task to execute.
 * |        |          |11 = Reserved.
 * |        |          |Note: Before filling transfer task in the Descriptor Table, user must check if the descriptor table is complete.
 * |[2]     |TXTYPE    |Transfer Type
 * |        |          |0 = Burst transfer type.
 * |        |          |1 = Single transfer type.
 * |[6:4]   |BURSIZE   |Burst Size
 * |        |          |This field is used for peripheral to determine the burst size or used for determine the re-arbitration size.
 * |        |          |000 = 128 Transfers.
 * |        |          |001 = 64 Transfers.
 * |        |          |010 = 32 Transfers.
 * |        |          |011 = 16 Transfers.
 * |        |          |100 = 8 Transfers.
 * |        |          |101 = 4 Transfers.
 * |        |          |110 = 2 Transfers.
 * |        |          |111 = 1 Transfers.
 * |        |          |Note: This field is only useful in burst transfer type.
 * |[9:8]   |SAINC     |Source Address Increment
 * |        |          |This field is used to set the source address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[11:10] |DAINC     |Destination Address Increment
 * |        |          |This field is used to set the destination address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[13:12] |TXWIDTH   |Transfer Width Selection
 * |        |          |This field is used for transfer width.
 * |        |          |00 = One byte (8 bit) is transferred for every operation.
 * |        |          |01= One half-word (16 bit) is transferred for every operation.
 * |        |          |10 = One word (32-bit) is transferred for every operation.
 * |        |          |11 = Reserved.
 * |        |          |Note: The PDMA transfer source address (PDMA_DSCT_SA) and PDMA transfer destination address (PDMA_DSCT_DA) should be alignment under the TXWIDTH selection
 * |[14]    |TXACK     |Transfer Acknowledge Selection
 * |        |          |0 = transfer ack when transfer done.
 * |        |          |1 = transfer ack when PDMA get transfer data.
 * |[15]    |STRIDEEN  |Stride Mode Enable Bit
 * |        |          |0 = Stride transfer mode Disabled.
 * |        |          |1 = Stride transfer mode Enabled.
 * |[31:16] |TXCNT     |Transfer Count
 * |        |          |The TXCNT represents the required number of PDMA transfer, the real transfer count is (TXCNT + 1); The maximum transfer count is 16384 , every transfer may be byte, half-word or word that is dependent on TXWIDTH field.
 * |        |          |Note: When PDMA finish each transfer data, this field will be decrease immediately.
 * @var PDMA_T::DSCT7_SA
 * Offset: 0x74  Source Address Register of PDMA Channel 7
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |SA        |PDMA Transfer Source Address Register
 * |        |          |This field indicates a 32-bit source address of PDMA controller.
 * @var PDMA_T::DSCT7_DA
 * Offset: 0x78  Destination Address Register of PDMA Channel 7
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |DA        |PDMA Transfer Destination Address Register
 * |        |          |This field indicates a 32-bit destination address of PDMA controller.
 * @var PDMA_T::DSCT7_NEXT
 * Offset: 0x7C  First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 7
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:2]  |NEXT      |PDMA Next Descriptor Table Offset Address Register
 * |        |          |This field indicates the offset of next descriptor table address in system memory
 * |        |          |The system memory based address is 0x2000_0000 (PDMA_SCATBA), if the next descriptor table is 0x2000_0100, then this field must fill in 0x0100.
 * |        |          |Note1: The next descriptor table address must be word boundary.
 * |        |          |Note2: Before filled transfer task in the descriptor table, user must check if the descriptor table is complete.
 * @var PDMA_T::DSCT8_CTL
 * Offset: 0x80  Descriptor Table Control Register of PDMA Channel 8
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |OPMODE    |PDMA Operation Mode Selection
 * |        |          |00 = Idle state: Channel is stopped or this table is complete, when PDMA finish channel table task, OPMODE will be cleared to idle state automatically.
 * |        |          |01 = Basic mode: The descriptor table only has one task
 * |        |          |When this task is finished, the PDMA_INTSTS[n] will be asserted.
 * |        |          |10 = Scatter-Gather mode: When operating in this mode, user must give the next descriptor table address in PDMA_DSCT_NEXT register; PDMA controller will ignore this task, then load the next task to execute.
 * |        |          |11 = Reserved.
 * |        |          |Note: Before filling transfer task in the Descriptor Table, user must check if the descriptor table is complete.
 * |[2]     |TXTYPE    |Transfer Type
 * |        |          |0 = Burst transfer type.
 * |        |          |1 = Single transfer type.
 * |[6:4]   |BURSIZE   |Burst Size
 * |        |          |This field is used for peripheral to determine the burst size or used for determine the re-arbitration size.
 * |        |          |000 = 128 Transfers.
 * |        |          |001 = 64 Transfers.
 * |        |          |010 = 32 Transfers.
 * |        |          |011 = 16 Transfers.
 * |        |          |100 = 8 Transfers.
 * |        |          |101 = 4 Transfers.
 * |        |          |110 = 2 Transfers.
 * |        |          |111 = 1 Transfers.
 * |        |          |Note: This field is only useful in burst transfer type.
 * |[9:8]   |SAINC     |Source Address Increment
 * |        |          |This field is used to set the source address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[11:10] |DAINC     |Destination Address Increment
 * |        |          |This field is used to set the destination address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[13:12] |TXWIDTH   |Transfer Width Selection
 * |        |          |This field is used for transfer width.
 * |        |          |00 = One byte (8 bit) is transferred for every operation.
 * |        |          |01= One half-word (16 bit) is transferred for every operation.
 * |        |          |10 = One word (32-bit) is transferred for every operation.
 * |        |          |11 = Reserved.
 * |        |          |Note: The PDMA transfer source address (PDMA_DSCT_SA) and PDMA transfer destination address (PDMA_DSCT_DA) should be alignment under the TXWIDTH selection
 * |[14]    |TXACK     |Transfer Acknowledge Selection
 * |        |          |0 = transfer ack when transfer done.
 * |        |          |1 = transfer ack when PDMA get transfer data.
 * |[15]    |STRIDEEN  |Stride Mode Enable Bit
 * |        |          |0 = Stride transfer mode Disabled.
 * |        |          |1 = Stride transfer mode Enabled.
 * |[31:16] |TXCNT     |Transfer Count
 * |        |          |The TXCNT represents the required number of PDMA transfer, the real transfer count is (TXCNT + 1); The maximum transfer count is 16384 , every transfer may be byte, half-word or word that is dependent on TXWIDTH field.
 * |        |          |Note: When PDMA finish each transfer data, this field will be decrease immediately.
 * @var PDMA_T::DSCT8_SA
 * Offset: 0x84  Source Address Register of PDMA Channel 8
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |SA        |PDMA Transfer Source Address Register
 * |        |          |This field indicates a 32-bit source address of PDMA controller.
 * @var PDMA_T::DSCT8_DA
 * Offset: 0x88  Destination Address Register of PDMA Channel 8
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |DA        |PDMA Transfer Destination Address Register
 * |        |          |This field indicates a 32-bit destination address of PDMA controller.
 * @var PDMA_T::DSCT8_NEXT
 * Offset: 0x8C  First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 8
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:2]  |NEXT      |PDMA Next Descriptor Table Offset Address Register
 * |        |          |This field indicates the offset of next descriptor table address in system memory
 * |        |          |The system memory based address is 0x2000_0000 (PDMA_SCATBA), if the next descriptor table is 0x2000_0100, then this field must fill in 0x0100.
 * |        |          |Note1: The next descriptor table address must be word boundary.
 * |        |          |Note2: Before filled transfer task in the descriptor table, user must check if the descriptor table is complete.
 * @var PDMA_T::DSCT9_CTL
 * Offset: 0x90  Descriptor Table Control Register of PDMA Channel 9
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |OPMODE    |PDMA Operation Mode Selection
 * |        |          |00 = Idle state: Channel is stopped or this table is complete, when PDMA finish channel table task, OPMODE will be cleared to idle state automatically.
 * |        |          |01 = Basic mode: The descriptor table only has one task
 * |        |          |When this task is finished, the PDMA_INTSTS[n] will be asserted.
 * |        |          |10 = Scatter-Gather mode: When operating in this mode, user must give the next descriptor table address in PDMA_DSCT_NEXT register; PDMA controller will ignore this task, then load the next task to execute.
 * |        |          |11 = Reserved.
 * |        |          |Note: Before filling transfer task in the Descriptor Table, user must check if the descriptor table is complete.
 * |[2]     |TXTYPE    |Transfer Type
 * |        |          |0 = Burst transfer type.
 * |        |          |1 = Single transfer type.
 * |[6:4]   |BURSIZE   |Burst Size
 * |        |          |This field is used for peripheral to determine the burst size or used for determine the re-arbitration size.
 * |        |          |000 = 128 Transfers.
 * |        |          |001 = 64 Transfers.
 * |        |          |010 = 32 Transfers.
 * |        |          |011 = 16 Transfers.
 * |        |          |100 = 8 Transfers.
 * |        |          |101 = 4 Transfers.
 * |        |          |110 = 2 Transfers.
 * |        |          |111 = 1 Transfers.
 * |        |          |Note: This field is only useful in burst transfer type.
 * |[9:8]   |SAINC     |Source Address Increment
 * |        |          |This field is used to set the source address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[11:10] |DAINC     |Destination Address Increment
 * |        |          |This field is used to set the destination address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[13:12] |TXWIDTH   |Transfer Width Selection
 * |        |          |This field is used for transfer width.
 * |        |          |00 = One byte (8 bit) is transferred for every operation.
 * |        |          |01= One half-word (16 bit) is transferred for every operation.
 * |        |          |10 = One word (32-bit) is transferred for every operation.
 * |        |          |11 = Reserved.
 * |        |          |Note: The PDMA transfer source address (PDMA_DSCT_SA) and PDMA transfer destination address (PDMA_DSCT_DA) should be alignment under the TXWIDTH selection
 * |[14]    |TXACK     |Transfer Acknowledge Selection
 * |        |          |0 = transfer ack when transfer done.
 * |        |          |1 = transfer ack when PDMA get transfer data.
 * |[15]    |STRIDEEN  |Stride Mode Enable Bit
 * |        |          |0 = Stride transfer mode Disabled.
 * |        |          |1 = Stride transfer mode Enabled.
 * |[31:16] |TXCNT     |Transfer Count
 * |        |          |The TXCNT represents the required number of PDMA transfer, the real transfer count is (TXCNT + 1); The maximum transfer count is 16384 , every transfer may be byte, half-word or word that is dependent on TXWIDTH field.
 * |        |          |Note: When PDMA finish each transfer data, this field will be decrease immediately.
 * @var PDMA_T::DSCT9_SA
 * Offset: 0x94  Source Address Register of PDMA Channel 9
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |SA        |PDMA Transfer Source Address Register
 * |        |          |This field indicates a 32-bit source address of PDMA controller.
 * @var PDMA_T::DSCT9_DA
 * Offset: 0x98  Destination Address Register of PDMA Channel 9
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |DA        |PDMA Transfer Destination Address Register
 * |        |          |This field indicates a 32-bit destination address of PDMA controller.
 * @var PDMA_T::DSCT9_NEXT
 * Offset: 0x9C  First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 9
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:2]  |NEXT      |PDMA Next Descriptor Table Offset Address Register
 * |        |          |This field indicates the offset of next descriptor table address in system memory
 * |        |          |The system memory based address is 0x2000_0000 (PDMA_SCATBA), if the next descriptor table is 0x2000_0100, then this field must fill in 0x0100.
 * |        |          |Note1: The next descriptor table address must be word boundary.
 * |        |          |Note2: Before filled transfer task in the descriptor table, user must check if the descriptor table is complete.
 * @var PDMA_T::DSCT10_CTL
 * Offset: 0xA0  Descriptor Table Control Register of PDMA Channel 10
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |OPMODE    |PDMA Operation Mode Selection
 * |        |          |00 = Idle state: Channel is stopped or this table is complete, when PDMA finish channel table task, OPMODE will be cleared to idle state automatically.
 * |        |          |01 = Basic mode: The descriptor table only has one task
 * |        |          |When this task is finished, the PDMA_INTSTS[n] will be asserted.
 * |        |          |10 = Scatter-Gather mode: When operating in this mode, user must give the next descriptor table address in PDMA_DSCT_NEXT register; PDMA controller will ignore this task, then load the next task to execute.
 * |        |          |11 = Reserved.
 * |        |          |Note: Before filling transfer task in the Descriptor Table, user must check if the descriptor table is complete.
 * |[2]     |TXTYPE    |Transfer Type
 * |        |          |0 = Burst transfer type.
 * |        |          |1 = Single transfer type.
 * |[6:4]   |BURSIZE   |Burst Size
 * |        |          |This field is used for peripheral to determine the burst size or used for determine the re-arbitration size.
 * |        |          |000 = 128 Transfers.
 * |        |          |001 = 64 Transfers.
 * |        |          |010 = 32 Transfers.
 * |        |          |011 = 16 Transfers.
 * |        |          |100 = 8 Transfers.
 * |        |          |101 = 4 Transfers.
 * |        |          |110 = 2 Transfers.
 * |        |          |111 = 1 Transfers.
 * |        |          |Note: This field is only useful in burst transfer type.
 * |[9:8]   |SAINC     |Source Address Increment
 * |        |          |This field is used to set the source address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[11:10] |DAINC     |Destination Address Increment
 * |        |          |This field is used to set the destination address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[13:12] |TXWIDTH   |Transfer Width Selection
 * |        |          |This field is used for transfer width.
 * |        |          |00 = One byte (8 bit) is transferred for every operation.
 * |        |          |01= One half-word (16 bit) is transferred for every operation.
 * |        |          |10 = One word (32-bit) is transferred for every operation.
 * |        |          |11 = Reserved.
 * |        |          |Note: The PDMA transfer source address (PDMA_DSCT_SA) and PDMA transfer destination address (PDMA_DSCT_DA) should be alignment under the TXWIDTH selection
 * |[14]    |TXACK     |Transfer Acknowledge Selection
 * |        |          |0 = transfer ack when transfer done.
 * |        |          |1 = transfer ack when PDMA get transfer data.
 * |[15]    |STRIDEEN  |Stride Mode Enable Bit
 * |        |          |0 = Stride transfer mode Disabled.
 * |        |          |1 = Stride transfer mode Enabled.
 * |[31:16] |TXCNT     |Transfer Count
 * |        |          |The TXCNT represents the required number of PDMA transfer, the real transfer count is (TXCNT + 1); The maximum transfer count is 16384 , every transfer may be byte, half-word or word that is dependent on TXWIDTH field.
 * |        |          |Note: When PDMA finish each transfer data, this field will be decrease immediately.
 * @var PDMA_T::DSCT10_SA
 * Offset: 0xA4  Source Address Register of PDMA Channel 10
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |SA        |PDMA Transfer Source Address Register
 * |        |          |This field indicates a 32-bit source address of PDMA controller.
 * @var PDMA_T::DSCT10_DA
 * Offset: 0xA8  Destination Address Register of PDMA Channel 10
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |DA        |PDMA Transfer Destination Address Register
 * |        |          |This field indicates a 32-bit destination address of PDMA controller.
 * @var PDMA_T::DSCT10_NEXT
 * Offset: 0xAC  First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 10
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:2]  |NEXT      |PDMA Next Descriptor Table Offset Address Register
 * |        |          |This field indicates the offset of next descriptor table address in system memory
 * |        |          |The system memory based address is 0x2000_0000 (PDMA_SCATBA), if the next descriptor table is 0x2000_0100, then this field must fill in 0x0100.
 * |        |          |Note1: The next descriptor table address must be word boundary.
 * |        |          |Note2: Before filled transfer task in the descriptor table, user must check if the descriptor table is complete.
 * @var PDMA_T::DSCT11_CTL
 * Offset: 0xB0  Descriptor Table Control Register of PDMA Channel 11
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |OPMODE    |PDMA Operation Mode Selection
 * |        |          |00 = Idle state: Channel is stopped or this table is complete, when PDMA finish channel table task, OPMODE will be cleared to idle state automatically.
 * |        |          |01 = Basic mode: The descriptor table only has one task
 * |        |          |When this task is finished, the PDMA_INTSTS[n] will be asserted.
 * |        |          |10 = Scatter-Gather mode: When operating in this mode, user must give the next descriptor table address in PDMA_DSCT_NEXT register; PDMA controller will ignore this task, then load the next task to execute.
 * |        |          |11 = Reserved.
 * |        |          |Note: Before filling transfer task in the Descriptor Table, user must check if the descriptor table is complete.
 * |[2]     |TXTYPE    |Transfer Type
 * |        |          |0 = Burst transfer type.
 * |        |          |1 = Single transfer type.
 * |[6:4]   |BURSIZE   |Burst Size
 * |        |          |This field is used for peripheral to determine the burst size or used for determine the re-arbitration size.
 * |        |          |000 = 128 Transfers.
 * |        |          |001 = 64 Transfers.
 * |        |          |010 = 32 Transfers.
 * |        |          |011 = 16 Transfers.
 * |        |          |100 = 8 Transfers.
 * |        |          |101 = 4 Transfers.
 * |        |          |110 = 2 Transfers.
 * |        |          |111 = 1 Transfers.
 * |        |          |Note: This field is only useful in burst transfer type.
 * |[9:8]   |SAINC     |Source Address Increment
 * |        |          |This field is used to set the source address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[11:10] |DAINC     |Destination Address Increment
 * |        |          |This field is used to set the destination address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[13:12] |TXWIDTH   |Transfer Width Selection
 * |        |          |This field is used for transfer width.
 * |        |          |00 = One byte (8 bit) is transferred for every operation.
 * |        |          |01= One half-word (16 bit) is transferred for every operation.
 * |        |          |10 = One word (32-bit) is transferred for every operation.
 * |        |          |11 = Reserved.
 * |        |          |Note: The PDMA transfer source address (PDMA_DSCT_SA) and PDMA transfer destination address (PDMA_DSCT_DA) should be alignment under the TXWIDTH selection
 * |[14]    |TXACK     |Transfer Acknowledge Selection
 * |        |          |0 = transfer ack when transfer done.
 * |        |          |1 = transfer ack when PDMA get transfer data.
 * |[15]    |STRIDEEN  |Stride Mode Enable Bit
 * |        |          |0 = Stride transfer mode Disabled.
 * |        |          |1 = Stride transfer mode Enabled.
 * |[31:16] |TXCNT     |Transfer Count
 * |        |          |The TXCNT represents the required number of PDMA transfer, the real transfer count is (TXCNT + 1); The maximum transfer count is 16384 , every transfer may be byte, half-word or word that is dependent on TXWIDTH field.
 * |        |          |Note: When PDMA finish each transfer data, this field will be decrease immediately.
 * @var PDMA_T::DSCT11_SA
 * Offset: 0xB4  Source Address Register of PDMA Channel 11
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |SA        |PDMA Transfer Source Address Register
 * |        |          |This field indicates a 32-bit source address of PDMA controller.
 * @var PDMA_T::DSCT11_DA
 * Offset: 0xB8  Destination Address Register of PDMA Channel 11
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |DA        |PDMA Transfer Destination Address Register
 * |        |          |This field indicates a 32-bit destination address of PDMA controller.
 * @var PDMA_T::DSCT11_NEXT
 * Offset: 0xBC  First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 11
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:2]  |NEXT      |PDMA Next Descriptor Table Offset Address Register
 * |        |          |This field indicates the offset of next descriptor table address in system memory
 * |        |          |The system memory based address is 0x2000_0000 (PDMA_SCATBA), if the next descriptor table is 0x2000_0100, then this field must fill in 0x0100.
 * |        |          |Note1: The next descriptor table address must be word boundary.
 * |        |          |Note2: Before filled transfer task in the descriptor table, user must check if the descriptor table is complete.
 * @var PDMA_T::DSCT12_CTL
 * Offset: 0xC0  Descriptor Table Control Register of PDMA Channel 12
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |OPMODE    |PDMA Operation Mode Selection
 * |        |          |00 = Idle state: Channel is stopped or this table is complete, when PDMA finish channel table task, OPMODE will be cleared to idle state automatically.
 * |        |          |01 = Basic mode: The descriptor table only has one task
 * |        |          |When this task is finished, the PDMA_INTSTS[n] will be asserted.
 * |        |          |10 = Scatter-Gather mode: When operating in this mode, user must give the next descriptor table address in PDMA_DSCT_NEXT register; PDMA controller will ignore this task, then load the next task to execute.
 * |        |          |11 = Reserved.
 * |        |          |Note: Before filling transfer task in the Descriptor Table, user must check if the descriptor table is complete.
 * |[2]     |TXTYPE    |Transfer Type
 * |        |          |0 = Burst transfer type.
 * |        |          |1 = Single transfer type.
 * |[6:4]   |BURSIZE   |Burst Size
 * |        |          |This field is used for peripheral to determine the burst size or used for determine the re-arbitration size.
 * |        |          |000 = 128 Transfers.
 * |        |          |001 = 64 Transfers.
 * |        |          |010 = 32 Transfers.
 * |        |          |011 = 16 Transfers.
 * |        |          |100 = 8 Transfers.
 * |        |          |101 = 4 Transfers.
 * |        |          |110 = 2 Transfers.
 * |        |          |111 = 1 Transfers.
 * |        |          |Note: This field is only useful in burst transfer type.
 * |[9:8]   |SAINC     |Source Address Increment
 * |        |          |This field is used to set the source address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[11:10] |DAINC     |Destination Address Increment
 * |        |          |This field is used to set the destination address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[13:12] |TXWIDTH   |Transfer Width Selection
 * |        |          |This field is used for transfer width.
 * |        |          |00 = One byte (8 bit) is transferred for every operation.
 * |        |          |01= One half-word (16 bit) is transferred for every operation.
 * |        |          |10 = One word (32-bit) is transferred for every operation.
 * |        |          |11 = Reserved.
 * |        |          |Note: The PDMA transfer source address (PDMA_DSCT_SA) and PDMA transfer destination address (PDMA_DSCT_DA) should be alignment under the TXWIDTH selection
 * |[14]    |TXACK     |Transfer Acknowledge Selection
 * |        |          |0 = transfer ack when transfer done.
 * |        |          |1 = transfer ack when PDMA get transfer data.
 * |[15]    |STRIDEEN  |Stride Mode Enable Bit
 * |        |          |0 = Stride transfer mode Disabled.
 * |        |          |1 = Stride transfer mode Enabled.
 * |[31:16] |TXCNT     |Transfer Count
 * |        |          |The TXCNT represents the required number of PDMA transfer, the real transfer count is (TXCNT + 1); The maximum transfer count is 16384 , every transfer may be byte, half-word or word that is dependent on TXWIDTH field.
 * |        |          |Note: When PDMA finish each transfer data, this field will be decrease immediately.
 * @var PDMA_T::DSCT12_SA
 * Offset: 0xC4  Source Address Register of PDMA Channel 12
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |SA        |PDMA Transfer Source Address Register
 * |        |          |This field indicates a 32-bit source address of PDMA controller.
 * @var PDMA_T::DSCT12_DA
 * Offset: 0xC8  Destination Address Register of PDMA Channel 12
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |DA        |PDMA Transfer Destination Address Register
 * |        |          |This field indicates a 32-bit destination address of PDMA controller.
 * @var PDMA_T::DSCT12_NEXT
 * Offset: 0xCC  First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 12
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:2]  |NEXT      |PDMA Next Descriptor Table Offset Address Register
 * |        |          |This field indicates the offset of next descriptor table address in system memory
 * |        |          |The system memory based address is 0x2000_0000 (PDMA_SCATBA), if the next descriptor table is 0x2000_0100, then this field must fill in 0x0100.
 * |        |          |Note1: The next descriptor table address must be word boundary.
 * |        |          |Note2: Before filled transfer task in the descriptor table, user must check if the descriptor table is complete.
 * @var PDMA_T::DSCT13_CTL
 * Offset: 0xD0  Descriptor Table Control Register of PDMA Channel 13
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |OPMODE    |PDMA Operation Mode Selection
 * |        |          |00 = Idle state: Channel is stopped or this table is complete, when PDMA finish channel table task, OPMODE will be cleared to idle state automatically.
 * |        |          |01 = Basic mode: The descriptor table only has one task
 * |        |          |When this task is finished, the PDMA_INTSTS[n] will be asserted.
 * |        |          |10 = Scatter-Gather mode: When operating in this mode, user must give the next descriptor table address in PDMA_DSCT_NEXT register; PDMA controller will ignore this task, then load the next task to execute.
 * |        |          |11 = Reserved.
 * |        |          |Note: Before filling transfer task in the Descriptor Table, user must check if the descriptor table is complete.
 * |[2]     |TXTYPE    |Transfer Type
 * |        |          |0 = Burst transfer type.
 * |        |          |1 = Single transfer type.
 * |[6:4]   |BURSIZE   |Burst Size
 * |        |          |This field is used for peripheral to determine the burst size or used for determine the re-arbitration size.
 * |        |          |000 = 128 Transfers.
 * |        |          |001 = 64 Transfers.
 * |        |          |010 = 32 Transfers.
 * |        |          |011 = 16 Transfers.
 * |        |          |100 = 8 Transfers.
 * |        |          |101 = 4 Transfers.
 * |        |          |110 = 2 Transfers.
 * |        |          |111 = 1 Transfers.
 * |        |          |Note: This field is only useful in burst transfer type.
 * |[9:8]   |SAINC     |Source Address Increment
 * |        |          |This field is used to set the source address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[11:10] |DAINC     |Destination Address Increment
 * |        |          |This field is used to set the destination address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[13:12] |TXWIDTH   |Transfer Width Selection
 * |        |          |This field is used for transfer width.
 * |        |          |00 = One byte (8 bit) is transferred for every operation.
 * |        |          |01= One half-word (16 bit) is transferred for every operation.
 * |        |          |10 = One word (32-bit) is transferred for every operation.
 * |        |          |11 = Reserved.
 * |        |          |Note: The PDMA transfer source address (PDMA_DSCT_SA) and PDMA transfer destination address (PDMA_DSCT_DA) should be alignment under the TXWIDTH selection
 * |[14]    |TXACK     |Transfer Acknowledge Selection
 * |        |          |0 = transfer ack when transfer done.
 * |        |          |1 = transfer ack when PDMA get transfer data.
 * |[15]    |STRIDEEN  |Stride Mode Enable Bit
 * |        |          |0 = Stride transfer mode Disabled.
 * |        |          |1 = Stride transfer mode Enabled.
 * |[31:16] |TXCNT     |Transfer Count
 * |        |          |The TXCNT represents the required number of PDMA transfer, the real transfer count is (TXCNT + 1); The maximum transfer count is 16384 , every transfer may be byte, half-word or word that is dependent on TXWIDTH field.
 * |        |          |Note: When PDMA finish each transfer data, this field will be decrease immediately.
 * @var PDMA_T::DSCT13_SA
 * Offset: 0xD4  Source Address Register of PDMA Channel 13
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |SA        |PDMA Transfer Source Address Register
 * |        |          |This field indicates a 32-bit source address of PDMA controller.
 * @var PDMA_T::DSCT13_DA
 * Offset: 0xD8  Destination Address Register of PDMA Channel 13
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |DA        |PDMA Transfer Destination Address Register
 * |        |          |This field indicates a 32-bit destination address of PDMA controller.
 * @var PDMA_T::DSCT13_NEXT
 * Offset: 0xDC  First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 13
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:2]  |NEXT      |PDMA Next Descriptor Table Offset Address Register
 * |        |          |This field indicates the offset of next descriptor table address in system memory
 * |        |          |The system memory based address is 0x2000_0000 (PDMA_SCATBA), if the next descriptor table is 0x2000_0100, then this field must fill in 0x0100.
 * |        |          |Note1: The next descriptor table address must be word boundary.
 * |        |          |Note2: Before filled transfer task in the descriptor table, user must check if the descriptor table is complete.
 * @var PDMA_T::DSCT14_CTL
 * Offset: 0xE0  Descriptor Table Control Register of PDMA Channel 14
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |OPMODE    |PDMA Operation Mode Selection
 * |        |          |00 = Idle state: Channel is stopped or this table is complete, when PDMA finish channel table task, OPMODE will be cleared to idle state automatically.
 * |        |          |01 = Basic mode: The descriptor table only has one task
 * |        |          |When this task is finished, the PDMA_INTSTS[n] will be asserted.
 * |        |          |10 = Scatter-Gather mode: When operating in this mode, user must give the next descriptor table address in PDMA_DSCT_NEXT register; PDMA controller will ignore this task, then load the next task to execute.
 * |        |          |11 = Reserved.
 * |        |          |Note: Before filling transfer task in the Descriptor Table, user must check if the descriptor table is complete.
 * |[2]     |TXTYPE    |Transfer Type
 * |        |          |0 = Burst transfer type.
 * |        |          |1 = Single transfer type.
 * |[6:4]   |BURSIZE   |Burst Size
 * |        |          |This field is used for peripheral to determine the burst size or used for determine the re-arbitration size.
 * |        |          |000 = 128 Transfers.
 * |        |          |001 = 64 Transfers.
 * |        |          |010 = 32 Transfers.
 * |        |          |011 = 16 Transfers.
 * |        |          |100 = 8 Transfers.
 * |        |          |101 = 4 Transfers.
 * |        |          |110 = 2 Transfers.
 * |        |          |111 = 1 Transfers.
 * |        |          |Note: This field is only useful in burst transfer type.
 * |[9:8]   |SAINC     |Source Address Increment
 * |        |          |This field is used to set the source address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[11:10] |DAINC     |Destination Address Increment
 * |        |          |This field is used to set the destination address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[13:12] |TXWIDTH   |Transfer Width Selection
 * |        |          |This field is used for transfer width.
 * |        |          |00 = One byte (8 bit) is transferred for every operation.
 * |        |          |01= One half-word (16 bit) is transferred for every operation.
 * |        |          |10 = One word (32-bit) is transferred for every operation.
 * |        |          |11 = Reserved.
 * |        |          |Note: The PDMA transfer source address (PDMA_DSCT_SA) and PDMA transfer destination address (PDMA_DSCT_DA) should be alignment under the TXWIDTH selection
 * |[14]    |TXACK     |Transfer Acknowledge Selection
 * |        |          |0 = transfer ack when transfer done.
 * |        |          |1 = transfer ack when PDMA get transfer data.
 * |[15]    |STRIDEEN  |Stride Mode Enable Bit
 * |        |          |0 = Stride transfer mode Disabled.
 * |        |          |1 = Stride transfer mode Enabled.
 * |[31:16] |TXCNT     |Transfer Count
 * |        |          |The TXCNT represents the required number of PDMA transfer, the real transfer count is (TXCNT + 1); The maximum transfer count is 16384 , every transfer may be byte, half-word or word that is dependent on TXWIDTH field.
 * |        |          |Note: When PDMA finish each transfer data, this field will be decrease immediately.
 * @var PDMA_T::DSCT14_SA
 * Offset: 0xE4  Source Address Register of PDMA Channel 14
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |SA        |PDMA Transfer Source Address Register
 * |        |          |This field indicates a 32-bit source address of PDMA controller.
 * @var PDMA_T::DSCT14_DA
 * Offset: 0xE8  Destination Address Register of PDMA Channel 14
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |DA        |PDMA Transfer Destination Address Register
 * |        |          |This field indicates a 32-bit destination address of PDMA controller.
 * @var PDMA_T::DSCT14_NEXT
 * Offset: 0xEC  First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 14
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:2]  |NEXT      |PDMA Next Descriptor Table Offset Address Register
 * |        |          |This field indicates the offset of next descriptor table address in system memory
 * |        |          |The system memory based address is 0x2000_0000 (PDMA_SCATBA), if the next descriptor table is 0x2000_0100, then this field must fill in 0x0100.
 * |        |          |Note1: The next descriptor table address must be word boundary.
 * |        |          |Note2: Before filled transfer task in the descriptor table, user must check if the descriptor table is complete.
 * @var PDMA_T::DSCT15_CTL
 * Offset: 0xF0  Descriptor Table Control Register of PDMA Channel 15
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |OPMODE    |PDMA Operation Mode Selection
 * |        |          |00 = Idle state: Channel is stopped or this table is complete, when PDMA finish channel table task, OPMODE will be cleared to idle state automatically.
 * |        |          |01 = Basic mode: The descriptor table only has one task
 * |        |          |When this task is finished, the PDMA_INTSTS[n] will be asserted.
 * |        |          |10 = Scatter-Gather mode: When operating in this mode, user must give the next descriptor table address in PDMA_DSCT_NEXT register; PDMA controller will ignore this task, then load the next task to execute.
 * |        |          |11 = Reserved.
 * |        |          |Note: Before filling transfer task in the Descriptor Table, user must check if the descriptor table is complete.
 * |[2]     |TXTYPE    |Transfer Type
 * |        |          |0 = Burst transfer type.
 * |        |          |1 = Single transfer type.
 * |[6:4]   |BURSIZE   |Burst Size
 * |        |          |This field is used for peripheral to determine the burst size or used for determine the re-arbitration size.
 * |        |          |000 = 128 Transfers.
 * |        |          |001 = 64 Transfers.
 * |        |          |010 = 32 Transfers.
 * |        |          |011 = 16 Transfers.
 * |        |          |100 = 8 Transfers.
 * |        |          |101 = 4 Transfers.
 * |        |          |110 = 2 Transfers.
 * |        |          |111 = 1 Transfers.
 * |        |          |Note: This field is only useful in burst transfer type.
 * |[9:8]   |SAINC     |Source Address Increment
 * |        |          |This field is used to set the source address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[11:10] |DAINC     |Destination Address Increment
 * |        |          |This field is used to set the destination address increment size.
 * |        |          |11 = No increment (fixed address).
 * |        |          |Others = Increment and size is depended on TXWIDTH selection.
 * |[13:12] |TXWIDTH   |Transfer Width Selection
 * |        |          |This field is used for transfer width.
 * |        |          |00 = One byte (8 bit) is transferred for every operation.
 * |        |          |01= One half-word (16 bit) is transferred for every operation.
 * |        |          |10 = One word (32-bit) is transferred for every operation.
 * |        |          |11 = Reserved.
 * |        |          |Note: The PDMA transfer source address (PDMA_DSCT_SA) and PDMA transfer destination address (PDMA_DSCT_DA) should be alignment under the TXWIDTH selection
 * |[14]    |TXACK     |Transfer Acknowledge Selection
 * |        |          |0 = transfer ack when transfer done.
 * |        |          |1 = transfer ack when PDMA get transfer data.
 * |[15]    |STRIDEEN  |Stride Mode Enable Bit
 * |        |          |0 = Stride transfer mode Disabled.
 * |        |          |1 = Stride transfer mode Enabled.
 * |[31:16] |TXCNT     |Transfer Count
 * |        |          |The TXCNT represents the required number of PDMA transfer, the real transfer count is (TXCNT + 1); The maximum transfer count is 16384 , every transfer may be byte, half-word or word that is dependent on TXWIDTH field.
 * |        |          |Note: When PDMA finish each transfer data, this field will be decrease immediately.
 * @var PDMA_T::DSCT15_SA
 * Offset: 0xF4  Source Address Register of PDMA Channel 15
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |SA        |PDMA Transfer Source Address Register
 * |        |          |This field indicates a 32-bit source address of PDMA controller.
 * @var PDMA_T::DSCT15_DA
 * Offset: 0xF8  Destination Address Register of PDMA Channel 15
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |DA        |PDMA Transfer Destination Address Register
 * |        |          |This field indicates a 32-bit destination address of PDMA controller.
 * @var PDMA_T::DSCT15_NEXT
 * Offset: 0xFC  First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 15
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:2]  |NEXT      |PDMA Next Descriptor Table Offset Address Register
 * |        |          |This field indicates the offset of next descriptor table address in system memory
 * |        |          |The system memory based address is 0x2000_0000 (PDMA_SCATBA), if the next descriptor table is 0x2000_0100, then this field must fill in 0x0100.
 * |        |          |Note1: The next descriptor table address must be word boundary.
 * |        |          |Note2: Before filled transfer task in the descriptor table, user must check if the descriptor table is complete.
 * @var PDMA_T::CURSCAT0
 * Offset: 0x100  Current Scatter-Gather Descriptor Table Address of PDMA Channel 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |CURADDR   |PDMA Current Description Address Register (Read Only)
 * |        |          |This field indicates a 32-bit current external description address of PDMA controller.
 * |        |          |Note: This field is read only and only used for Scatter-Gather mode to indicate the current external description address.
 * @var PDMA_T::CURSCAT1
 * Offset: 0x104  Current Scatter-Gather Descriptor Table Address of PDMA Channel 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |CURADDR   |PDMA Current Description Address Register (Read Only)
 * |        |          |This field indicates a 32-bit current external description address of PDMA controller.
 * |        |          |Note: This field is read only and only used for Scatter-Gather mode to indicate the current external description address.
 * @var PDMA_T::CURSCAT2
 * Offset: 0x108  Current Scatter-Gather Descriptor Table Address of PDMA Channel 2
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |CURADDR   |PDMA Current Description Address Register (Read Only)
 * |        |          |This field indicates a 32-bit current external description address of PDMA controller.
 * |        |          |Note: This field is read only and only used for Scatter-Gather mode to indicate the current external description address.
 * @var PDMA_T::CURSCAT3
 * Offset: 0x10C  Current Scatter-Gather Descriptor Table Address of PDMA Channel 3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |CURADDR   |PDMA Current Description Address Register (Read Only)
 * |        |          |This field indicates a 32-bit current external description address of PDMA controller.
 * |        |          |Note: This field is read only and only used for Scatter-Gather mode to indicate the current external description address.
 * @var PDMA_T::CURSCAT4
 * Offset: 0x110  Current Scatter-Gather Descriptor Table Address of PDMA Channel 4
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |CURADDR   |PDMA Current Description Address Register (Read Only)
 * |        |          |This field indicates a 32-bit current external description address of PDMA controller.
 * |        |          |Note: This field is read only and only used for Scatter-Gather mode to indicate the current external description address.
 * @var PDMA_T::CURSCAT5
 * Offset: 0x114  Current Scatter-Gather Descriptor Table Address of PDMA Channel 5
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |CURADDR   |PDMA Current Description Address Register (Read Only)
 * |        |          |This field indicates a 32-bit current external description address of PDMA controller.
 * |        |          |Note: This field is read only and only used for Scatter-Gather mode to indicate the current external description address.
 * @var PDMA_T::CURSCAT6
 * Offset: 0x118  Current Scatter-Gather Descriptor Table Address of PDMA Channel 6
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |CURADDR   |PDMA Current Description Address Register (Read Only)
 * |        |          |This field indicates a 32-bit current external description address of PDMA controller.
 * |        |          |Note: This field is read only and only used for Scatter-Gather mode to indicate the current external description address.
 * @var PDMA_T::CURSCAT7
 * Offset: 0x11C  Current Scatter-Gather Descriptor Table Address of PDMA Channel 7
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |CURADDR   |PDMA Current Description Address Register (Read Only)
 * |        |          |This field indicates a 32-bit current external description address of PDMA controller.
 * |        |          |Note: This field is read only and only used for Scatter-Gather mode to indicate the current external description address.
 * @var PDMA_T::CURSCAT8
 * Offset: 0x120  Current Scatter-Gather Descriptor Table Address of PDMA Channel 8
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |CURADDR   |PDMA Current Description Address Register (Read Only)
 * |        |          |This field indicates a 32-bit current external description address of PDMA controller.
 * |        |          |Note: This field is read only and only used for Scatter-Gather mode to indicate the current external description address.
 * @var PDMA_T::CURSCAT9
 * Offset: 0x124  Current Scatter-Gather Descriptor Table Address of PDMA Channel 9
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |CURADDR   |PDMA Current Description Address Register (Read Only)
 * |        |          |This field indicates a 32-bit current external description address of PDMA controller.
 * |        |          |Note: This field is read only and only used for Scatter-Gather mode to indicate the current external description address.
 * @var PDMA_T::CURSCAT10
 * Offset: 0x128  Current Scatter-Gather Descriptor Table Address of PDMA Channel 10
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |CURADDR   |PDMA Current Description Address Register (Read Only)
 * |        |          |This field indicates a 32-bit current external description address of PDMA controller.
 * |        |          |Note: This field is read only and only used for Scatter-Gather mode to indicate the current external description address.
 * @var PDMA_T::CURSCAT11
 * Offset: 0x12C  Current Scatter-Gather Descriptor Table Address of PDMA Channel 11
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |CURADDR   |PDMA Current Description Address Register (Read Only)
 * |        |          |This field indicates a 32-bit current external description address of PDMA controller.
 * |        |          |Note: This field is read only and only used for Scatter-Gather mode to indicate the current external description address.
 * @var PDMA_T::CURSCAT12
 * Offset: 0x130  Current Scatter-Gather Descriptor Table Address of PDMA Channel 12
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |CURADDR   |PDMA Current Description Address Register (Read Only)
 * |        |          |This field indicates a 32-bit current external description address of PDMA controller.
 * |        |          |Note: This field is read only and only used for Scatter-Gather mode to indicate the current external description address.
 * @var PDMA_T::CURSCAT13
 * Offset: 0x134  Current Scatter-Gather Descriptor Table Address of PDMA Channel 13
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |CURADDR   |PDMA Current Description Address Register (Read Only)
 * |        |          |This field indicates a 32-bit current external description address of PDMA controller.
 * |        |          |Note: This field is read only and only used for Scatter-Gather mode to indicate the current external description address.
 * @var PDMA_T::CURSCAT14
 * Offset: 0x138  Current Scatter-Gather Descriptor Table Address of PDMA Channel 14
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |CURADDR   |PDMA Current Description Address Register (Read Only)
 * |        |          |This field indicates a 32-bit current external description address of PDMA controller.
 * |        |          |Note: This field is read only and only used for Scatter-Gather mode to indicate the current external description address.
 * @var PDMA_T::CURSCAT15
 * Offset: 0x13C  Current Scatter-Gather Descriptor Table Address of PDMA Channel 15
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |CURADDR   |PDMA Current Description Address Register (Read Only)
 * |        |          |This field indicates a 32-bit current external description address of PDMA controller.
 * |        |          |Note: This field is read only and only used for Scatter-Gather mode to indicate the current external description address.
 * @var PDMA_T::CHCTL
 * Offset: 0x400  PDMA Channel Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CHEN0     |PDMA Channel 0 Enable Bit
 * |        |          |Set this bit to 1 to enable PDMA channel 0 operation
 * |        |          |Channel 0 cannot be active if it is not set as enabled.
 * |        |          |0 = PDMA Channel 0 Disabled.
 * |        |          |1 = PDMA Channel 0 Enabled.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[1]     |CHEN1     |PDMA Channel 1 Enable Bit
 * |        |          |Set this bit to 1 to enable PDMA channel 1 operation
 * |        |          |Channel 1 cannot be active if it is not set as enabled.
 * |        |          |0 = PDMA Channel 1 Disabled.
 * |        |          |1 = PDMA Channel 1 Enabled.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[2]     |CHEN2     |PDMA Channel 2 Enable Bit
 * |        |          |Set this bit to 1 to enable PDMA channel 2 operation
 * |        |          |Channel 2 cannot be active if it is not set as enabled.
 * |        |          |0 = PDMA Channel 2 Disabled.
 * |        |          |1 = PDMA Channel 2 Enabled.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[3]     |CHEN3     |PDMA Channel 3 Enable Bit
 * |        |          |Set this bit to 1 to enable PDMA channel 3 operation
 * |        |          |Channel 3 cannot be active if it is not set as enabled.
 * |        |          |0 = PDMA Channel 3 Disabled.
 * |        |          |1 = PDMA Channel 3 Enabled.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[4]     |CHEN4     |PDMA Channel 4 Enable Bit
 * |        |          |Set this bit to 1 to enable PDMA channel 4 operation
 * |        |          |Channel 4 cannot be active if it is not set as enabled.
 * |        |          |0 = PDMA Channel 4 Disabled.
 * |        |          |1 = PDMA Channel 4 Enabled.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[5]     |CHEN5     |PDMA Channel 5 Enable Bit
 * |        |          |Set this bit to 1 to enable PDMA channel 5 operation
 * |        |          |Channel 5 cannot be active if it is not set as enabled.
 * |        |          |0 = PDMA Channel 5 Disabled.
 * |        |          |1 = PDMA Channel 5 Enabled.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[6]     |CHEN6     |PDMA Channel 6 Enable Bit
 * |        |          |Set this bit to 1 to enable PDMA channel 6 operation
 * |        |          |Channel 6 cannot be active if it is not set as enabled.
 * |        |          |0 = PDMA Channel 6 Disabled.
 * |        |          |1 = PDMA Channel 6 Enabled.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[7]     |CHEN7     |PDMA Channel 7 Enable Bit
 * |        |          |Set this bit to 1 to enable PDMA channel 7 operation
 * |        |          |Channel 7 cannot be active if it is not set as enabled.
 * |        |          |0 = PDMA Channel 7 Disabled.
 * |        |          |1 = PDMA Channel 7 Enabled.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[8]     |CHEN8     |PDMA Channel 8 Enable Bit
 * |        |          |Set this bit to 1 to enable PDMA channel 8 operation
 * |        |          |Channel 8 cannot be active if it is not set as enabled.
 * |        |          |0 = PDMA Channel 8 Disabled.
 * |        |          |1 = PDMA Channel 8 Enabled.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[9]     |CHEN9     |PDMA Channel 9 Enable Bit
 * |        |          |Set this bit to 1 to enable PDMA channel 9 operation
 * |        |          |Channel 9 cannot be active if it is not set as enabled.
 * |        |          |0 = PDMA channel 9 Disabled.
 * |        |          |1 = PDMA channel 9 Enabled.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[10]    |CHEN10    |PDMA Channel 10 Enable Bit
 * |        |          |Set this bit to 1 to enable PDMA channel 10 operation
 * |        |          |Channel 10 cannot be active if it is not set as enabled.
 * |        |          |0 = PDMA Channel 10 Disabled.
 * |        |          |1 = PDMA Channel 10 Enabled.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[11]    |CHEN11    |PDMA Channel 11 Enable Bit
 * |        |          |Set this bit to 1 to enable PDMA channel 11 operation
 * |        |          |Channel 11 cannot be active if it is not set as enabled.
 * |        |          |0 = PDMA Channel 11 Disabled.
 * |        |          |1 = PDMA Channel 11 Enabled.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[12]    |CHEN12    |PDMA Channel 12 Enable Bit
 * |        |          |Set this bit to 1 to enable PDMA channel 12 operation
 * |        |          |Channel 12 cannot be active if it is not set as enabled.
 * |        |          |0 = PDMA Channel 12 Disabled.
 * |        |          |1 = PDMA Channel 12 Enabled.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[13]    |CHEN13    |PDMA Channel 13 Enable Bit
 * |        |          |Set this bit to 1 to enable PDMA channel 13 operation
 * |        |          |Channel 13 cannot be active if it is not set as enabled.
 * |        |          |0 = PDMA Channel 13 Disabled.
 * |        |          |1 = PDMA Channel 13 Enabled.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[14]    |CHEN14    |PDMA Channel 14 Enable Bit
 * |        |          |Set this bit to 1 to enable PDMA channel 14 operation
 * |        |          |Channel 14 cannot be active if it is not set as enabled.
 * |        |          |0 = PDMA Channel 14 Disabled.
 * |        |          |1 = PDMA Channel 14 Enabled.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[15]    |CHEN15    |PDMA Channel 15 Enable Bit
 * |        |          |Set this bit to 1 to enable PDMA channel 15 operation
 * |        |          |Channel 15 cannot be active if it is not set as enabled.
 * |        |          |0 = PDMA Channel 15 Disabled.
 * |        |          |1 = PDMA Channel 15 Enabled.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * @var PDMA_T::STOP
 * Offset: 0x404  PDMA Transfer Stop Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |STOP0     |PDMA Channel 0 Transfer Stop Control Register (Write Only)
 * |        |          |User can stop the PDMA Channel 0 transfer by this bit or by software reset (writing '0xFFFF_FFFF' to PDMA_STOP register).
 * |        |          |By bit field:
 * |        |          |0 = No effect.
 * |        |          |1 = Stop PDMA Channel 0 transfer
 * |        |          |When software set this bit, the operation will finish the on-going transfer channel and then clear the channel enable bit CHEN (PDMA_CHCTL [0]) and request active flag.
 * |        |          |By write 0xFFFF_FFFF to PDMA_STOP:
 * |        |          |Setting all PDMA_STOP bit to ...1u201D will generate software reset to reset internal state machine (the DSCT will not be reset)
 * |        |          |When software reset, the operation will be stopped imminently that include the on-going transfer and the channel enable bit (PDMA_CHCTL [CHEN]) and request active flag will be cleared to '0'.
 * |        |          |Note: User can read channel enable bit to know if the on-going transfer is finished.
 * |[1]     |STOP1     |PDMA Channel 1 Transfer Stop Control Register (Write Only)
 * |        |          |User can stop the PDMA Channel 1 transfer by this bit or by software reset (writing '0xFFFF_FFFF' to PDMA_STOP register).
 * |        |          |By bit field:
 * |        |          |0 = No effect.
 * |        |          |1 = Stop PDMA Channel 1 transfer
 * |        |          |When software set this bit, the operation will finish the on-going transfer channel and then clear the channel enable bit CHEN (PDMA_CHCTL [1]) and request active flag.
 * |        |          |By write 0xFFFF_FFFF to PDMA_STOP:
 * |        |          |Setting all PDMA_STOP bit to ...1u201D will generate software reset to reset internal state machine (the DSCT will not be reset)
 * |        |          |When software reset, the operation will be stopped imminently that include the on-going transfer and the channel enable bit (PDMA_CHCTL [CHEN]) and request active flag will be cleared to '0'.
 * |        |          |Note: User can read channel enable bit to know if the on-going transfer is finished.
 * |[2]     |STOP2     |PDMA Channel 2 Transfer Stop Control Register (Write Only)
 * |        |          |User can stop the PDMA Channel 2 transfer by this bit or by software reset (writing '0xFFFF_FFFF' to PDMA_STOP register).
 * |        |          |By bit field:
 * |        |          |0 = No effect.
 * |        |          |1 = Stop PDMA Channel 2 transfer
 * |        |          |When software set this bit, the operation will finish the on-going transfer channel and then clear the channel enable bit CHEN (PDMA_CHCTL [2]) and request active flag.
 * |        |          |By write 0xFFFF_FFFF to PDMA_STOP:
 * |        |          |Setting all PDMA_STOP bit to ...1u201D will generate software reset to reset internal state machine (the DSCT will not be reset)
 * |        |          |When software reset, the operation will be stopped imminently that include the on-going transfer and the channel enable bit (PDMA_CHCTL [CHEN]) and request active flag will be cleared to '0'.
 * |        |          |Note: User can read channel enable bit to know if the on-going transfer is finished.
 * |[3]     |STOP3     |PDMA Channel 3 Transfer Stop Control Register (Write Only)
 * |        |          |User can stop the PDMA Channel 3 transfer by this bit or by software reset (writing '0xFFFF_FFFF' to PDMA_STOP register).
 * |        |          |By bit field:
 * |        |          |0 = No effect.
 * |        |          |1 = Stop PDMA Channel 3 transfer
 * |        |          |When software set this bit, the operation will finish the on-going transfer channel and then clear the channel enable bit CHEN (PDMA_CHCTL [3]) and request active flag.
 * |        |          |By write 0xFFFF_FFFF to PDMA_STOP:
 * |        |          |Setting all PDMA_STOP bit to ...1u201D will generate software reset to reset internal state machine (the DSCT will not be reset)
 * |        |          |When software reset, the operation will be stopped imminently that include the on-going transfer and the channel enable bit (PDMA_CHCTL [CHEN]) and request active flag will be cleared to '0'.
 * |        |          |Note: User can read channel enable bit to know if the on-going transfer is finished.
 * |[4]     |STOP4     |PDMA Channel 4 Transfer Stop Control Register (Write Only)
 * |        |          |User can stop the PDMA Channel 4 transfer by this bit or by software reset (writing '0xFFFF_FFFF' to PDMA_STOP register).
 * |        |          |By bit field:
 * |        |          |0 = No effect.
 * |        |          |1 = Stop PDMA Channel 4 transfer
 * |        |          |When software set this bit, the operation will finish the on-going transfer channel and then clear the channel enable bit CHEN (PDMA_CHCTL [4]) and request active flag.
 * |        |          |By write 0xFFFF_FFFF to PDMA_STOP:
 * |        |          |Setting all PDMA_STOP bit to ...1u201D will generate software reset to reset internal state machine (the DSCT will not be reset)
 * |        |          |When software reset, the operation will be stopped imminently that include the on-going transfer and the channel enable bit (PDMA_CHCTL [CHEN]) and request active flag will be cleared to '0'.
 * |        |          |Note: User can read channel enable bit to know if the on-going transfer is finished.
 * |[5]     |STOP5     |PDMA Channel 5 Transfer Stop Control Register (Write Only)
 * |        |          |User can stop the PDMA Channel 5 transfer by this bit or by software reset (writing '0xFFFF_FFFF' to PDMA_STOP register).
 * |        |          |By bit field:
 * |        |          |0 = No effect.
 * |        |          |1 = Stop PDMA Channel 5 transfer
 * |        |          |When software set this bit, the operation will finish the on-going transfer channel and then clear the channel enable bit CHEN (PDMA_CHCTL [5]) and request active flag.
 * |        |          |By write 0xFFFF_FFFF to PDMA_STOP:
 * |        |          |Setting all PDMA_STOP bit to ...1u201D will generate software reset to reset internal state machine (the DSCT will not be reset)
 * |        |          |When software reset, the operation will be stopped imminently that include the on-going transfer and the channel enable bit (PDMA_CHCTL [CHEN]) and request active flag will be cleared to '0'.
 * |        |          |Note: User can read channel enable bit to know if the on-going transfer is finished.
 * |[6]     |STOP6     |PDMA Channel 6 Transfer Stop Control Register (Write Only)
 * |        |          |User can stop the PDMA Channel 6 transfer by this bit or by software reset (writing '0xFFFF_FFFF' to PDMA_STOP register).
 * |        |          |By bit field:
 * |        |          |0 = No effect.
 * |        |          |1 = Stop PDMA Channel 6 transfer
 * |        |          |When software set this bit, the operation will finish the on-going transfer channel and then clear the channel enable bit CHEN (PDMA_CHCTL [6]) and request active flag.
 * |        |          |By write 0xFFFF_FFFF to PDMA_STOP:
 * |        |          |Setting all PDMA_STOP bit to ...1u201D will generate software reset to reset internal state machine (the DSCT will not be reset)
 * |        |          |When software reset, the operation will be stopped imminently that include the on-going transfer and the channel enable bit (PDMA_CHCTL [CHEN]) and request active flag will be cleared to '0'.
 * |        |          |Note: User can read channel enable bit to know if the on-going transfer is finished.
 * |[7]     |STOP7     |PDMA Channel 7 Transfer Stop Control Register (Write Only)
 * |        |          |User can stop the PDMA Channel 7 transfer by this bit or by software reset (writing '0xFFFF_FFFF' to PDMA_STOP register).
 * |        |          |By bit field:
 * |        |          |0 = No effect.
 * |        |          |1 = Stop PDMA Channel 7 transfer
 * |        |          |When software set this bit, the operation will finish the on-going transfer channel and then clear the channel enable bit CHEN (PDMA_CHCTL [7]) and request active flag.
 * |        |          |By write 0xFFFF_FFFF to PDMA_STOP:
 * |        |          |Setting all PDMA_STOP bit to ...1u201D will generate software reset to reset internal state machine (the DSCT will not be reset)
 * |        |          |When software reset, the operation will be stopped imminently that include the on-going transfer and the channel enable bit (PDMA_CHCTL [CHEN]) and request active flag will be cleared to '0'.
 * |        |          |Note: User can read channel enable bit to know if the on-going transfer is finished.
 * |[8]     |STOP8     |PDMA Channel 8 Transfer Stop Control Register (Write Only)
 * |        |          |User can stop the PDMA Channel 8 transfer by this bit or by software reset (writing '0xFFFF_FFFF' to PDMA_STOP register).
 * |        |          |By bit field:
 * |        |          |0 = No effect.
 * |        |          |1 = Stop PDMA Channel 8 transfer
 * |        |          |When software set this bit, the operation will finish the on-going transfer channel and then clear the channel enable bit CHEN (PDMA_CHCTL [8]) and request active flag.
 * |        |          |By write 0xFFFF_FFFF to PDMA_STOP:
 * |        |          |Setting all PDMA_STOP bit to ...1u201D will generate software reset to reset internal state machine (the DSCT will not be reset)
 * |        |          |When software reset, the operation will be stopped imminently that include the on-going transfer and the channel enable bit (PDMA_CHCTL [CHEN]) and request active flag will be cleared to '0'.
 * |        |          |Note: User can read channel enable bit to know if the on-going transfer is finished.
 * |[9]     |STOP9     |PDMA Channel 9 Transfer Stop Control Register (Write Only)
 * |        |          |User can stop the PDMA Channel 9 transfer by this bit or by software reset (writing '0xFFFF_FFFF' to PDMA_STOP register).
 * |        |          |By bit field:
 * |        |          |0 = No effect.
 * |        |          |1 = Stop PDMA Channel 9 transfer
 * |        |          |When software set this bit, the operation will finish the on-going transfer channel and then clear the channel enable bit CHEN (PDMA_CHCTL [9]) and request active flag.
 * |        |          |By write 0xFFFF_FFFF to PDMA_STOP:
 * |        |          |Setting all PDMA_STOP bit to ...1u201D will generate software reset to reset internal state machine (the DSCT will not be reset)
 * |        |          |When software reset, the operation will be stopped imminently that include the on-going transfer and the channel enable bit (PDMA_CHCTL [CHEN]) and request active flag will be cleared to '0'.
 * |        |          |Note: User can read channel enable bit to know if the on-going transfer is finished.
 * |[10]    |STOP10    |PDMA Channel 10 Transfer Stop Control Register (Write Only)
 * |        |          |User can stop the PDMA Channel 10 transfer by this bit or by software reset (writing '0xFFFF_FFFF' to PDMA_STOP register).
 * |        |          |By bit field:
 * |        |          |0 = No effect.
 * |        |          |1 = Stop PDMA Channel 10 transfer
 * |        |          |When software set this bit, the operation will finish the on-going transfer channel and then clear the channel enable bit CHEN (PDMA_CHCTL [10]) and request active flag.
 * |        |          |By write 0xFFFF_FFFF to PDMA_STOP:
 * |        |          |Setting all PDMA_STOP bit to ...1u201D will generate software reset to reset internal state machine (the DSCT will not be reset)
 * |        |          |When software reset, the operation will be stopped imminently that include the on-going transfer and the channel enable bit (PDMA_CHCTL [CHEN]) and request active flag will be cleared to '0'.
 * |        |          |Note: User can read channel enable bit to know if the on-going transfer is finished.
 * |[11]    |STOP11    |PDMA Channel 11 Transfer Stop Control Register (Write Only)
 * |        |          |User can stop the PDMA Channel 11 transfer by this bit or by software reset (writing '0xFFFF_FFFF' to PDMA_STOP register).
 * |        |          |By bit field:
 * |        |          |0 = No effect.
 * |        |          |1 = Stop PDMA Channel 11 transfer
 * |        |          |When software set this bit, the operation will finish the on-going transfer channel and then clear the channel enable bit CHEN (PDMA_CHCTL [11]) and request active flag.
 * |        |          |By write 0xFFFF_FFFF to PDMA_STOP:
 * |        |          |Setting all PDMA_STOP bit to ...1u201D will generate software reset to reset internal state machine (the DSCT will not be reset)
 * |        |          |When software reset, the operation will be stopped imminently that include the on-going transfer and the channel enable bit (PDMA_CHCTL [CHEN]) and request active flag will be cleared to '0'.
 * |        |          |Note: User can read channel enable bit to know if the on-going transfer is finished.
 * |[12]    |STOP12    |PDMA Channel 12 Transfer Stop Control Register (Write Only)
 * |        |          |User can stop the PDMA Channel 12 transfer by this bit or by software reset (writing '0xFFFF_FFFF' to PDMA_STOP register).
 * |        |          |By bit field:
 * |        |          |0 = No effect.
 * |        |          |1 = Stop PDMA Channel 12 transfer
 * |        |          |When software set this bit, the operation will finish the on-going transfer channel and then clear the channel enable bit CHEN (PDMA_CHCTL [12]) and request active flag.
 * |        |          |By write 0xFFFF_FFFF to PDMA_STOP:
 * |        |          |Setting all PDMA_STOP bit to ...1u201D will generate software reset to reset internal state machine (the DSCT will not be reset)
 * |        |          |When software reset, the operation will be stopped imminently that include the on-going transfer and the channel enable bit (PDMA_CHCTL [CHEN]) and request active flag will be cleared to '0'.
 * |        |          |Note: User can read channel enable bit to know if the on-going transfer is finished.
 * |[13]    |STOP13    |PDMA Channel 13 Transfer Stop Control Register (Write Only)
 * |        |          |User can stop the PDMA Channel 13 transfer by this bit or by software reset (writing '0xFFFF_FFFF' to PDMA_STOP register).
 * |        |          |By bit field:
 * |        |          |0 = No effect.
 * |        |          |1 = Stop PDMA Channel 13 transfer
 * |        |          |When software set this bit, the operation will finish the on-going transfer channel and then clear the channel enable bit CHEN (PDMA_CHCTL [13]) and request active flag.
 * |        |          |By write 0xFFFF_FFFF to PDMA_STOP:
 * |        |          |Setting all PDMA_STOP bit to ...1u201D will generate software reset to reset internal state machine (the DSCT will not be reset)
 * |        |          |When software reset, the operation will be stopped imminently that include the on-going transfer and the channel enable bit (PDMA_CHCTL [CHEN]) and request active flag will be cleared to '0'.
 * |        |          |Note: User can read channel enable bit to know if the on-going transfer is finished.
 * |[14]    |STOP14    |PDMA Channel 14 Transfer Stop Control Register (Write Only)
 * |        |          |User can stop the PDMA Channel 14 transfer by this bit or by software reset (writing '0xFFFF_FFFF' to PDMA_STOP register).
 * |        |          |By bit field:
 * |        |          |0 = No effect.
 * |        |          |1 = Stop PDMA Channel 14 transfer
 * |        |          |When software set this bit, the operation will finish the on-going transfer channel and then clear the channel enable bit CHEN (PDMA_CHCTL [14]) and request active flag.
 * |        |          |By write 0xFFFF_FFFF to PDMA_STOP:
 * |        |          |Setting all PDMA_STOP bit to ...1u201D will generate software reset to reset internal state machine (the DSCT will not be reset)
 * |        |          |When software reset, the operation will be stopped imminently that include the on-going transfer and the channel enable bit (PDMA_CHCTL [CHEN]) and request active flag will be cleared to '0'.
 * |        |          |Note: User can read channel enable bit to know if the on-going transfer is finished.
 * |[15]    |STOP15    |PDMA Channel 15 Transfer Stop Control Register (Write Only)
 * |        |          |User can stop the PDMA Channel 15 transfer by this bit or by software reset (writing '0xFFFF_FFFF' to PDMA_STOP register).
 * |        |          |By bit field:
 * |        |          |0 = No effect.
 * |        |          |1 = Stop PDMA Channel 15 transfer
 * |        |          |When software set this bit, the operation will finish the on-going transfer channel and then clear the channel enable bit CHEN (PDMA_CHCTL [15]) and request active flag.
 * |        |          |By write 0xFFFF_FFFF to PDMA_STOP:
 * |        |          |Setting all PDMA_STOP bit to ...1u201D will generate software reset to reset internal state machine (the DSCT will not be reset)
 * |        |          |When software reset, the operation will be stopped imminently that include the on-going transfer and the channel enable bit (PDMA_CHCTL [CHEN]) and request active flag will be cleared to '0'.
 * |        |          |Note: User can read channel enable bit to know if the on-going transfer is finished.
 * @var PDMA_T::SWREQ
 * Offset: 0x408  PDMA Software Request Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |SWREQ0    |PDMA Channel 0 Software Request Register (Write Only)
 * |        |          |Set this bit to 1 to generate a software request to PDMA Channel 0.
 * |        |          |0 = PDMA Channel 0 no effect.
 * |        |          |1 = PDMA Channel 0 generate a software request.
 * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
 * |        |          |Active flag may be triggered by software request or peripheral request.
 * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
 * |[1]     |SWREQ1    |PDMA Channel 1 Software Request Register (Write Only)
 * |        |          |Set this bit to 1 to generate a software request to PDMA Channel 1.
 * |        |          |0 = PDMA Channel 1 no effect.
 * |        |          |1 = PDMA Channel 1 generate a software request.
 * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
 * |        |          |Active flag may be triggered by software request or peripheral request.
 * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
 * |[2]     |SWREQ2    |PDMA Channel 2 Software Request Register (Write Only)
 * |        |          |Set this bit to 1 to generate a software request to PDMA Channel 2.
 * |        |          |0 = PDMA Channel 2 no effect.
 * |        |          |1 = PDMA Channel 2 generate a software request.
 * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
 * |        |          |Active flag may be triggered by software request or peripheral request.
 * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
 * |[3]     |SWREQ3    |PDMA Channel 3 Software Request Register (Write Only)
 * |        |          |Set this bit to 1 to generate a software request to PDMA Channel 3.
 * |        |          |0 = PDMA Channel 3 no effect.
 * |        |          |1 = PDMA Channel 3 generate a software request.
 * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
 * |        |          |Active flag may be triggered by software request or peripheral request.
 * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
 * |[4]     |SWREQ4    |PDMA Channel 4 Software Request Register (Write Only)
 * |        |          |Set this bit to 1 to generate a software request to PDMA Channel 4.
 * |        |          |0 = PDMA Channel 4 no effect.
 * |        |          |1 = PDMA Channel 4 generate a software request.
 * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
 * |        |          |Active flag may be triggered by software request or peripheral request.
 * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
 * |[5]     |SWREQ5    |PDMA Channel 5 Software Request Register (Write Only)
 * |        |          |Set this bit to 1 to generate a software request to PDMA Channel 5.
 * |        |          |0 = PDMA Channel 5 no effect.
 * |        |          |1 = PDMA Channel 5 generate a software request.
 * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
 * |        |          |Active flag may be triggered by software request or peripheral request.
 * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
 * |[6]     |SWREQ6    |PDMA Channel 6 Software Request Register (Write Only)
 * |        |          |Set this bit to 1 to generate a software request to PDMA Channel 6.
 * |        |          |0 = PDMA Channel 6 no effect.
 * |        |          |1 = PDMA Channel 6 generate a software request.
 * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
 * |        |          |Active flag may be triggered by software request or peripheral request.
 * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
 * |[7]     |SWREQ7    |PDMA Channel 7 Software Request Register (Write Only)
 * |        |          |Set this bit to 1 to generate a software request to PDMA Channel 7.
 * |        |          |0 = PDMA Channel 7 no effect.
 * |        |          |1 = PDMA Channel 7 generate a software request.
 * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
 * |        |          |Active flag may be triggered by software request or peripheral request.
 * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
 * |[8]     |SWREQ8    |PDMA Channel 8 Software Request Register (Write Only)
 * |        |          |Set this bit to 1 to generate a software request to PDMA Channel 8.
 * |        |          |0 = PDMA Channel 8 no effect.
 * |        |          |1 = PDMA Channel 8 generate a software request.
 * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
 * |        |          |Active flag may be triggered by software request or peripheral request.
 * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
 * |[9]     |SWREQ9    |PDMA Channel 9 Software Request Register (Write Only)
 * |        |          |Set this bit to 1 to generate a software request to PDMA Channel 9.
 * |        |          |0 = PDMA Channel 9 no effect.
 * |        |          |1 = PDMA Channel 9 generate a software request.
 * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
 * |        |          |Active flag may be triggered by software request or peripheral request.
 * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
 * |[10]    |SWREQ10   |PDMA Channel 10 Software Request Register (Write Only)
 * |        |          |Set this bit to 1 to generate a software request to PDMA Channel 10.
 * |        |          |0 = PDMA Channel 10 no effect.
 * |        |          |1 = PDMA Channel 10 generate a software request.
 * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
 * |        |          |Active flag may be triggered by software request or peripheral request.
 * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
 * |[11]    |SWREQ11   |PDMA Channel 11 Software Request Register (Write Only)
 * |        |          |Set this bit to 1 to generate a software request to PDMA Channel 11.
 * |        |          |0 = PDMA Channel 11 no effect.
 * |        |          |1 = PDMA Channel 11 generate a software request.
 * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
 * |        |          |Active flag may be triggered by software request or peripheral request.
 * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
 * |[12]    |SWREQ12   |PDMA Channel 12 Software Request Register (Write Only)
 * |        |          |Set this bit to 1 to generate a software request to PDMA Channel 12.
 * |        |          |0 = PDMA Channel 12 no effect.
 * |        |          |1 = PDMA Channel 12 generate a software request.
 * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
 * |        |          |Active flag may be triggered by software request or peripheral request.
 * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
 * |[13]    |SWREQ13   |PDMA Channel 13 Software Request Register (Write Only)
 * |        |          |Set this bit to 1 to generate a software request to PDMA Channel 13.
 * |        |          |0 = PDMA Channel 13 no effect.
 * |        |          |1 = PDMA Channel 13 generate a software request.
 * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
 * |        |          |Active flag may be triggered by software request or peripheral request.
 * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
 * |[14]    |SWREQ14   |PDMA Channel 14 Software Request Register (Write Only)
 * |        |          |Set this bit to 1 to generate a software request to PDMA Channel 14.
 * |        |          |0 = PDMA Channel 14 no effect.
 * |        |          |1 = PDMA Channel 14 generate a software request.
 * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
 * |        |          |Active flag may be triggered by software request or peripheral request.
 * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
 * |[15]    |SWREQ15   |PDMA Channel 15 Software Request Register (Write Only)
 * |        |          |Set this bit to 1 to generate a software request to PDMA Channel 15.
 * |        |          |0 = PDMA Channel 15 no effect.
 * |        |          |1 = PDMA Channel 15 generate a software request.
 * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
 * |        |          |Active flag may be triggered by software request or peripheral request.
 * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
 * @var PDMA_T::TRGSTS
 * Offset: 0x40C  PDMA Channel Request Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |REQSTS0   |PDMA Channel 0 Request Status (Read Only)
 * |        |          |This flag indicates whether channel 0 have a request or not, no matter request from software or peripheral
 * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
 * |        |          |0 = PDMA Channel 0 has no request.
 * |        |          |1 = PDMA Channel 0 has a request.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[1]     |REQSTS1   |PDMA Channel 1 Request Status (Read Only)
 * |        |          |This flag indicates whether channel 1 have a request or not, no matter request from software or peripheral
 * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
 * |        |          |0 = PDMA Channel 1 has no request.
 * |        |          |1 = PDMA Channel 1 has a request.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[2]     |REQSTS2   |PDMA Channel 2 Request Status (Read Only)
 * |        |          |This flag indicates whether channel 2 have a request or not, no matter request from software or peripheral
 * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
 * |        |          |0 = PDMA Channel 2 has no request.
 * |        |          |1 = PDMA Channel 2 has a request.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[3]     |REQSTS3   |PDMA Channel 3 Request Status (Read Only)
 * |        |          |This flag indicates whether channel 3 have a request or not, no matter request from software or peripheral
 * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
 * |        |          |0 = PDMA Channel 3 has no request.
 * |        |          |1 = PDMA Channel 3 has a request.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[4]     |REQSTS4   |PDMA Channel 4 Request Status (Read Only)
 * |        |          |This flag indicates whether channel 4 have a request or not, no matter request from software or peripheral
 * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
 * |        |          |0 = PDMA Channel 4 has no request.
 * |        |          |1 = PDMA Channel 4 has a request.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[5]     |REQSTS5   |PDMA Channel 5 Request Status (Read Only)
 * |        |          |This flag indicates whether channel 5 have a request or not, no matter request from software or peripheral
 * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
 * |        |          |0 = PDMA Channel 5 has no request.
 * |        |          |1 = PDMA Channel 5 has a request.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[6]     |REQSTS6   |PDMA Channel 6 Request Status (Read Only)
 * |        |          |This flag indicates whether channel 6 have a request or not, no matter request from software or peripheral
 * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
 * |        |          |0 = PDMA Channel 6 has no request.
 * |        |          |1 = PDMA Channel 6 has a request.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[7]     |REQSTS7   |PDMA Channel 7 Request Status (Read Only)
 * |        |          |This flag indicates whether channel 7 have a request or not, no matter request from software or peripheral
 * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
 * |        |          |0 = PDMA Channel 7 has no request.
 * |        |          |1 = PDMA Channel 7 has a request.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[8]     |REQSTS8   |PDMA Channel 8 Request Status (Read Only)
 * |        |          |This flag indicates whether channel 8 have a request or not, no matter request from software or peripheral
 * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
 * |        |          |0 = PDMA Channel 8 has no request.
 * |        |          |1 = PDMA Channel 8 has a request.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[9]     |REQSTS9   |PDMA Channel 9 Request Status (Read Only)
 * |        |          |This flag indicates whether channel 9 have a request or not, no matter request from software or peripheral
 * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
 * |        |          |0 = PDMA Channel 9 has no request.
 * |        |          |1 = PDMA Channel 9 has a request.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[10]    |REQSTS10  |PDMA Channel 10 Request Status (Read Only)
 * |        |          |This flag indicates whether channel 10 have a request or not, no matter request from software or peripheral
 * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
 * |        |          |0 = PDMA Channel 10 has no request.
 * |        |          |1 = PDMA Channel 10 has a request.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[11]    |REQSTS11  |PDMA Channel 11 Request Status (Read Only)
 * |        |          |This flag indicates whether channel 11 have a request or not, no matter request from software or peripheral
 * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
 * |        |          |0 = PDMA Channel 11 has no request.
 * |        |          |1 = PDMA Channel 11 has a request.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[12]    |REQSTS12  |PDMA Channel 12 Request Status (Read Only)
 * |        |          |This flag indicates whether channel 12 have a request or not, no matter request from software or peripheral
 * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
 * |        |          |0 = PDMA Channel 12 has no request.
 * |        |          |1 = PDMA Channel 12 has a request.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[13]    |REQSTS13  |PDMA Channel 13 Request Status (Read Only)
 * |        |          |This flag indicates whether channel 13 have a request or not, no matter request from software or peripheral
 * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
 * |        |          |0 = PDMA Channel 13 has no request.
 * |        |          |1 = PDMA Channel 13 has a request.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[14]    |REQSTS14  |PDMA Channel 14 Request Status (Read Only)
 * |        |          |This flag indicates whether channel 14 have a request or not, no matter request from software or peripheral
 * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
 * |        |          |0 = PDMA Channel 14 has no request.
 * |        |          |1 = PDMA Channel 14 has a request.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * |[15]    |REQSTS15  |PDMA Channel 15 Request Status (Read Only)
 * |        |          |This flag indicates whether channel 15 have a request or not, no matter request from software or peripheral
 * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
 * |        |          |0 = PDMA Channel 15 has no request.
 * |        |          |1 = PDMA Channel 15 has a request.
 * |        |          |Note1: If software stops corresponding PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
 * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
 * @var PDMA_T::PRISET
 * Offset: 0x410  PDMA Fixed Priority Setting Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |FPRISET0  |PDMA Channel 0 Fixed Priority Setting Register
 * |        |          |Set this bit to 1 to enable fixed priority level.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set PDMA channel 0 to fixed priority channel.
 * |        |          |Read Operation:
 * |        |          |0 = Corresponding PDMA channel 0 is round-robin priority.
 * |        |          |1 = Corresponding PDMA channel 0 is fixed priority.
 * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
 * |[1]     |FPRISET1  |PDMA Channel 1 Fixed Priority Setting Register
 * |        |          |Set this bit to 1 to enable fixed priority level.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set PDMA channel 1 to fixed priority channel.
 * |        |          |Read Operation:
 * |        |          |0 = Corresponding PDMA channel 1 is round-robin priority.
 * |        |          |1 = Corresponding PDMA channel 1 is fixed priority.
 * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
 * |[2]     |FPRISET2  |PDMA Channel 2 Fixed Priority Setting Register
 * |        |          |Set this bit to 1 to enable fixed priority level.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set PDMA channel 2 to fixed priority channel.
 * |        |          |Read Operation:
 * |        |          |0 = Corresponding PDMA channel 2 is round-robin priority.
 * |        |          |1 = Corresponding PDMA channel 2 is fixed priority.
 * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
 * |[3]     |FPRISET3  |PDMA Channel 3 Fixed Priority Setting Register
 * |        |          |Set this bit to 1 to enable fixed priority level.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set PDMA channel 3 to fixed priority channel.
 * |        |          |Read Operation:
 * |        |          |0 = Corresponding PDMA channel 3 is round-robin priority.
 * |        |          |1 = Corresponding PDMA channel 3 is fixed priority.
 * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
 * |[4]     |FPRISET4  |PDMA Channel 4 Fixed Priority Setting Register
 * |        |          |Set this bit to 1 to enable fixed priority level.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set PDMA channel 4 to fixed priority channel.
 * |        |          |Read Operation:
 * |        |          |0 = Corresponding PDMA channel 4 is round-robin priority.
 * |        |          |1 = Corresponding PDMA channel 4 is fixed priority.
 * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
 * |[5]     |FPRISET5  |PDMA Channel 5 Fixed Priority Setting Register
 * |        |          |Set this bit to 1 to enable fixed priority level.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set PDMA channel 5 to fixed priority channel.
 * |        |          |Read Operation:
 * |        |          |0 = Corresponding PDMA channel 5 is round-robin priority.
 * |        |          |1 = Corresponding PDMA channel 5 is fixed priority.
 * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
 * |[6]     |FPRISET6  |PDMA Channel 6 Fixed Priority Setting Register
 * |        |          |Set this bit to 1 to enable fixed priority level.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set PDMA channel 6 to fixed priority channel.
 * |        |          |Read Operation:
 * |        |          |0 = Corresponding PDMA channel 6 is round-robin priority.
 * |        |          |1 = Corresponding PDMA channel 6 is fixed priority.
 * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
 * |[7]     |FPRISET7  |PDMA Channel 7 Fixed Priority Setting Register
 * |        |          |Set this bit to 1 to enable fixed priority level.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set PDMA channel 7 to fixed priority channel.
 * |        |          |Read Operation:
 * |        |          |0 = Corresponding PDMA channel 7 is round-robin priority.
 * |        |          |1 = Corresponding PDMA channel 7 is fixed priority.
 * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
 * |[8]     |FPRISET8  |PDMA Channel 8 Fixed Priority Setting Register
 * |        |          |Set this bit to 1 to enable fixed priority level.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set PDMA channel 8 to fixed priority channel.
 * |        |          |Read Operation:
 * |        |          |0 = Corresponding PDMA channel 8 is round-robin priority.
 * |        |          |1 = Corresponding PDMA channel 8 is fixed priority.
 * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
 * |[9]     |FPRISET9  |PDMA Channel 9 Fixed Priority Setting Register
 * |        |          |Set this bit to 1 to enable fixed priority level.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set PDMA channel 9 to fixed priority channel.
 * |        |          |Read Operation:
 * |        |          |0 = Corresponding PDMA channel 9 is round-robin priority.
 * |        |          |1 = Corresponding PDMA channel 9 is fixed priority.
 * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
 * |[10]    |FPRISET10 |PDMA Channel 10 Fixed Priority Setting Register
 * |        |          |Set this bit to 1 to enable fixed priority level.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set PDMA channel 10 to fixed priority channel.
 * |        |          |Read Operation:
 * |        |          |0 = Corresponding PDMA channel 10 is round-robin priority.
 * |        |          |1 = Corresponding PDMA channel 10 is fixed priority.
 * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
 * |[11]    |FPRISET11 |PDMA Channel 10 Fixed Priority Setting Register
 * |        |          |Set this bit to 1 to enable fixed priority level.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set PDMA channel 11 to fixed priority channel.
 * |        |          |Read Operation:
 * |        |          |0 = Corresponding PDMA channel 11 is round-robin priority.
 * |        |          |1 = Corresponding PDMA channel 11 is fixed priority.
 * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
 * |[12]    |FPRISET12 |PDMA Channel 12 Fixed Priority Setting Register
 * |        |          |Set this bit to 1 to enable fixed priority level.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set PDMA channel 12 to fixed priority channel.
 * |        |          |Read Operation:
 * |        |          |0 = Corresponding PDMA channel 12 is round-robin priority.
 * |        |          |1 = Corresponding PDMA channel 12 is fixed priority.
 * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
 * |[13]    |FPRISET13 |PDMA Channel 13 Fixed Priority Setting Register
 * |        |          |Set this bit to 1 to enable fixed priority level.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set PDMA channel 13 to fixed priority channel.
 * |        |          |Read Operation:
 * |        |          |0 = Corresponding PDMA channel 13 is round-robin priority.
 * |        |          |1 = Corresponding PDMA channel 13 is fixed priority.
 * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
 * |[14]    |FPRISET14 |PDMA Channel 14 Fixed Priority Setting Register
 * |        |          |Set this bit to 1 to enable fixed priority level.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set PDMA channel 14 to fixed priority channel.
 * |        |          |Read Operation:
 * |        |          |0 = Corresponding PDMA channel 14 is round-robin priority.
 * |        |          |1 = Corresponding PDMA channel 14 is fixed priority.
 * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
 * |[15]    |FPRISET15 |PDMA Channel 15 Fixed Priority Setting Register
 * |        |          |Set this bit to 1 to enable fixed priority level.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set PDMA channel 15 to fixed priority channel.
 * |        |          |Read Operation:
 * |        |          |0 = Corresponding PDMA channel 15 is round-robin priority.
 * |        |          |1 = Corresponding PDMA channel 15 is fixed priority.
 * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
 * @var PDMA_T::PRICLR
 * Offset: 0x414  PDMA Fixed Priority Clear Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |FPRICLR0  |PDMA Channel 0 Fixed Priority Clear Register (Write Only)
 * |        |          |Set this bit to 1 to clear fixed priority level.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear PDMA channel 0 fixed priority setting.
 * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
 * |[1]     |FPRICLR1  |PDMA Channel 1 Fixed Priority Clear Register (Write Only)
 * |        |          |Set this bit to 1 to clear fixed priority level.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear PDMA channel 1 fixed priority setting.
 * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
 * |[2]     |FPRICLR2  |PDMA Channel 2 Fixed Priority Clear Register (Write Only)
 * |        |          |Set this bit to 1 to clear fixed priority level.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear PDMA channel 2 fixed priority setting.
 * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
 * |[3]     |FPRICLR3  |PDMA Channel 3 Fixed Priority Clear Register (Write Only)
 * |        |          |Set this bit to 1 to clear fixed priority level.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear PDMA channel 3 fixed priority setting.
 * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
 * |[4]     |FPRICLR4  |PDMA Channel 4 Fixed Priority Clear Register (Write Only)
 * |        |          |Set this bit to 1 to clear fixed priority level.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear PDMA channel 4 fixed priority setting.
 * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
 * |[5]     |FPRICLR5  |PDMA Channel 5 Fixed Priority Clear Register (Write Only)
 * |        |          |Set this bit to 1 to clear fixed priority level.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear PDMA channel 5 fixed priority setting.
 * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
 * |[6]     |FPRICLR6  |PDMA Channel 6 Fixed Priority Clear Register (Write Only)
 * |        |          |Set this bit to 1 to clear fixed priority level.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear PDMA channel 6 fixed priority setting.
 * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
 * |[7]     |FPRICLR7  |PDMA Channel 7 Fixed Priority Clear Register (Write Only)
 * |        |          |Set this bit to 1 to clear fixed priority level.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear PDMA channel 7 fixed priority setting.
 * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
 * |[8]     |FPRICLR8  |PDMA Channel 8 Fixed Priority Clear Register (Write Only)
 * |        |          |Set this bit to 1 to clear fixed priority level.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear PDMA channel 8 fixed priority setting.
 * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
 * |[9]     |FPRICLR9  |PDMA Channel 9 Fixed Priority Clear Register (Write Only)
 * |        |          |Set this bit to 1 to clear fixed priority level.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear PDMA channel 9 fixed priority setting.
 * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
 * |[10]    |FPRICLR10 |PDMA Channel 10 Fixed Priority Clear Register (Write Only)
 * |        |          |Set this bit to 1 to clear fixed priority level.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear PDMA channel 10 fixed priority setting.
 * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
 * |[11]    |FPRICLR11 |PDMA Channel 11 Fixed Priority Clear Register (Write Only)
 * |        |          |Set this bit to 1 to clear fixed priority level.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear PDMA channel 11 fixed priority setting.
 * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
 * |[12]    |FPRICLR12 |PDMA Channel 12 Fixed Priority Clear Register (Write Only)
 * |        |          |Set this bit to 1 to clear fixed priority level.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear PDMA channel 12 fixed priority setting.
 * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
 * |[13]    |FPRICLR13 |PDMA Channel 13 Fixed Priority Clear Register (Write Only)
 * |        |          |Set this bit to 1 to clear fixed priority level.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear PDMA channel 13 fixed priority setting.
 * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
 * |[14]    |FPRICLR14 |PDMA Channel 14 Fixed Priority Clear Register (Write Only)
 * |        |          |Set this bit to 1 to clear fixed priority level.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear PDMA channel 14 fixed priority setting.
 * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
 * |[15]    |FPRICLR15 |PDMA Channel 15 Fixed Priority Clear Register (Write Only)
 * |        |          |Set this bit to 1 to clear fixed priority level.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear PDMA channel 15 fixed priority setting.
 * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
 * @var PDMA_T::INTEN
 * Offset: 0x418  PDMA Interrupt Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |INTEN0    |PDMA Channel 0 Interrupt Enable Register
 * |        |          |This field is used for enabling PDMA channel 0 interrupt.
 * |        |          |0 = PDMA channel 0 interrupt Disabled.
 * |        |          |1 = PDMA channel 0 interrupt Enabled.
 * |[1]     |INTEN1    |PDMA Channel 1 Interrupt Enable Register
 * |        |          |This field is used for enabling PDMA channel 1 interrupt.
 * |        |          |0 = PDMA channel 1 interrupt Disabled.
 * |        |          |1 = PDMA channel 1 interrupt Enabled.
 * |[2]     |INTEN2    |PDMA Channel 2 Interrupt Enable Register
 * |        |          |This field is used for enabling PDMA channel 2 interrupt.
 * |        |          |0 = PDMA channel 2 interrupt Disabled.
 * |        |          |1 = PDMA channel 2 interrupt Enabled.
 * |[3]     |INTEN3    |PDMA Channel 3 Interrupt Enable Register
 * |        |          |This field is used for enabling PDMA channel 3 interrupt.
 * |        |          |0 = PDMA channel 3 interrupt Disabled.
 * |        |          |1 = PDMA channel 3 interrupt Enabled.
 * |[4]     |INTEN4    |PDMA Channel 4 Interrupt Enable Register
 * |        |          |This field is used for enabling PDMA channel 4 interrupt.
 * |        |          |0 = PDMA channel 4 interrupt Disabled.
 * |        |          |1 = PDMA channel 4 interrupt Enabled.
 * |[5]     |INTEN5    |PDMA Channel 5 Interrupt Enable Register
 * |        |          |This field is used for enabling PDMA channel 5 interrupt.
 * |        |          |0 = PDMA channel 5 interrupt Disabled.
 * |        |          |1 = PDMA channel 5 interrupt Enabled.
 * |[6]     |INTEN6    |PDMA Channel 6 Interrupt Enable Register
 * |        |          |This field is used for enabling PDMA channel 6 interrupt.
 * |        |          |0 = PDMA channel 6 interrupt Disabled.
 * |        |          |1 = PDMA channel 6 interrupt Enabled.
 * |[7]     |INTEN7    |PDMA Channel 7 Interrupt Enable Register
 * |        |          |This field is used for enabling PDMA channel 7 interrupt.
 * |        |          |0 = PDMA channel 7 interrupt Disabled.
 * |        |          |1 = PDMA channel 7 interrupt Enabled.
 * |[8]     |INTEN8    |PDMA Channel 8 Interrupt Enable Register
 * |        |          |This field is used for enabling PDMA channel 8 interrupt.
 * |        |          |0 = PDMA channel 8 interrupt Disabled.
 * |        |          |1 = PDMA channel 8 interrupt Enabled.
 * |[9]     |INTEN9    |PDMA Channel 9 Interrupt Enable Register
 * |        |          |This field is used for enabling PDMA channel 9 interrupt.
 * |        |          |0 = PDMA channel 9 interrupt Disabled.
 * |        |          |1 = PDMA channel 9 interrupt Enabled.
 * |[10]    |INTEN10   |PDMA Channel 10 Interrupt Enable Register
 * |        |          |This field is used for enabling PDMA channel 10 interrupt.
 * |        |          |0 = PDMA channel 10 interrupt Disabled.
 * |        |          |1 = PDMA channel 10 interrupt Enabled.
 * |[11]    |INTEN11   |PDMA Channel 11 Interrupt Enable Register
 * |        |          |This field is used for enabling PDMA channel 11 interrupt.
 * |        |          |0 = PDMA channel 11 interrupt Disabled.
 * |        |          |1 = PDMA channel 11 interrupt Enabled.
 * |[12]    |INTEN12   |PDMA Channel 0 Interrupt Enable Register
 * |        |          |This field is used for enabling PDMA channel 12 interrupt.
 * |        |          |0 = PDMA channel 12 interrupt Disabled.
 * |        |          |1 = PDMA channel 12 interrupt Enabled.
 * |[13]    |INTEN13   |PDMA Channel 13 Interrupt Enable Register
 * |        |          |This field is used for enabling PDMA channel 13 interrupt.
 * |        |          |0 = PDMA channel 13 interrupt Disabled.
 * |        |          |1 = PDMA channel 13 interrupt Enabled.
 * |[14]    |INTEN14   |PDMA Channel 14 Interrupt Enable Register
 * |        |          |This field is used for enabling PDMA channel 14 interrupt.
 * |        |          |0 = PDMA channel 14 interrupt Disabled.
 * |        |          |1 = PDMA channel 14 interrupt Enabled.
 * |[15]    |INTEN15   |PDMA Channel 15 Interrupt Enable Register
 * |        |          |This field is used for enabling PDMA channel 15 interrupt.
 * |        |          |0 = PDMA channel 15 interrupt Disabled.
 * |        |          |1 = PDMA channel 15 interrupt Enabled.
 * |[31]    |BISTEN    |BIST Enable (Internal Use)[PM1]---u91CDu8981!!!TRMu8ACBu6A190
 * |        |          |This bit is used to enable the BIST (Built-in self-test) operation of embedded SRAM
 * |        |          |Set this bit high to enable the BIST test
 * |        |          |This bit should be enabled and cleared by software.
 * |        |          |0 = Software BIST operation Disabled.
 * |        |          |1 = Software BIST operation Enabled.
 * |        |          |[PM1]Do not release.
 * |        |          |should be keep 0 in TRM.
 * @var PDMA_T::INTSTS
 * Offset: 0x41C  PDMA Interrupt Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ABTIF     |PDMA Read/Write Target Abort Interrupt Flag (Read-only)
 * |        |          |This bit indicates that PDMA has target abort error; Software can read PDMA_ABTSTS register to find which channel has target abort error.
 * |        |          |0 = No AHB bus ERROR response received.
 * |        |          |1 = AHB bus ERROR response received.
 * |[1]     |TDIF      |Transfer Done Interrupt Flag (Read Only)
 * |        |          |This bit indicates that PDMA controller has finished transmission; User can read PDMA_TDSTS register to indicate which channel finished transfer.
 * |        |          |0 = Not finished yet.
 * |        |          |1 = PDMA channel has finished transmission.
 * |[2]     |ALIGNF    |Transfer Alignment Interrupt Flag (Read Only)
 * |        |          |0 = PDMA channel source address and destination address both follow transfer width setting.
 * |        |          |1 = PDMA channel source address or destination address is not follow transfer width setting.
 * |[8]     |REQTOF0   |Request Time-out Flag for Channel 0
 * |        |          |This flag indicates that PDMA controller has waited peripheral request for a period defined by PDMA_TOC0, user can write 1 to clear these bits.
 * |        |          |0 = No request time-out.
 * |        |          |1 = Peripheral request time-out.
 * |[9]     |REQTOF1   |Request Time-out Flag for Channel 1
 * |        |          |This flag indicates that PDMA controller has waited peripheral request for a period defined by PDMA_TOC1, user can write 1 to clear these bits.
 * |        |          |0 = No request time-out.
 * |        |          |1 = Peripheral request time-out.
 * |[30]    |BISTFAIL  |BIST Failed (Internal Use)
 * |        |          |This bit indicates if the BIST test of the embedded buffer was failed or not
 * |        |          |If it is 0 at the end of BIST, that means the shared buffer has passed the test; otherwise, it is failed
 * |        |          |The BISTFAIL field will be set to 1 once the BIST controller detects an error and remains high during BIST operation.
 * |[31]    |BISTDONE  |BIST Operation Finish (Internal Use)
 * |        |          |This bit indicates the end of BIST operation of the embedded buffers
 * |        |          |When BIST controller finishes all operations, this bit will be set high.
 * |        |          |0 = No BIST operation or BIST operation is in progress.
 * |        |          |1 = BIST operation finished.
 * @var PDMA_T::ABTSTS
 * Offset: 0x420  PDMA Channel Read/Write Target Abort Flag Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ABTIF0    |PDMA Channel 0 Read/Write Target Abort Interrupt Status Flag
 * |        |          |This bit indicates PDMA channel 0 has target abort error; User can write 1 to clear these bits.
 * |        |          |0 = No AHB bus ERROR response received when channel 0 transfer.
 * |        |          |1 = AHB bus ERROR response received when channel 0 transfer.
 * |[1]     |ABTIF1    |PDMA Channel 1 Read/Write Target Abort Interrupt Status Flag
 * |        |          |This bit indicates PDMA channel 1 has target abort error; User can write 1 to clear these bits.
 * |        |          |0 = No AHB bus ERROR response received when channel 1 transfer.
 * |        |          |1 = AHB bus ERROR response received when channel 1 transfer.
 * |[2]     |ABTIF2    |PDMA Channel 2 Read/Write Target Abort Interrupt Status Flag
 * |        |          |This bit indicates PDMA channel 2 has target abort error; User can write 1 to clear these bits.
 * |        |          |0 = No AHB bus ERROR response received when channel 2 transfer.
 * |        |          |1 = AHB bus ERROR response received when channel 2 transfer.
 * |[3]     |ABTIF3    |PDMA Channel 3 Read/Write Target Abort Interrupt Status Flag
 * |        |          |This bit indicates PDMA channel 3 has target abort error; User can write 1 to clear these bits.
 * |        |          |0 = No AHB bus ERROR response received when channel 3 transfer.
 * |        |          |1 = AHB bus ERROR response received when channel 3 transfer.
 * |[4]     |ABTIF4    |PDMA Channel 4 Read/Write Target Abort Interrupt Status Flag
 * |        |          |This bit indicates PDMA channel 4 has target abort error; User can write 1 to clear these bits.
 * |        |          |0 = No AHB bus ERROR response received when channel 4 transfer.
 * |        |          |1 = AHB bus ERROR response received when channel 4 transfer.
 * |[5]     |ABTIF5    |PDMA Channel 5 Read/Write Target Abort Interrupt Status Flag
 * |        |          |This bit indicates PDMA channel 5 has target abort error; User can write 1 to clear these bits.
 * |        |          |0 = No AHB bus ERROR response received when channel 5 transfer.
 * |        |          |1 = AHB bus ERROR response received when channel 5 transfer.
 * |[6]     |ABTIF6    |PDMA Channel 6 Read/Write Target Abort Interrupt Status Flag
 * |        |          |This bit indicates PDMA channel 6 has target abort error; User can write 1 to clear these bits.
 * |        |          |0 = No AHB bus ERROR response received when channel 6 transfer.
 * |        |          |1 = AHB bus ERROR response received when channel 6 transfer.
 * |[7]     |ABTIF7    |PDMA Channel 7 Read/Write Target Abort Interrupt Status Flag
 * |        |          |This bit indicates PDMA channel 7 has target abort error; User can write 1 to clear these bits.
 * |        |          |0 = No AHB bus ERROR response received when channel 7 transfer.
 * |        |          |1 = AHB bus ERROR response received when channel 7 transfer.
 * |[8]     |ABTIF8    |PDMA Channel 8 Read/Write Target Abort Interrupt Status Flag
 * |        |          |This bit indicates PDMA channel 8 has target abort error; User can write 1 to clear these bits.
 * |        |          |0 = No AHB bus ERROR response received when channel 8 transfer.
 * |        |          |1 = AHB bus ERROR response received when channel 8 transfer.
 * |[9]     |ABTIF9    |PDMA Channel 9 Read/Write Target Abort Interrupt Status Flag
 * |        |          |This bit indicates PDMA channel 9 has target abort error; User can write 1 to clear these bits.
 * |        |          |0 = No AHB bus ERROR response received when channel 9 transfer.
 * |        |          |1 = AHB bus ERROR response received when channel 9 transfer.
 * |[10]    |ABTIF10   |PDMA Channel 10 Read/Write Target Abort Interrupt Status Flag
 * |        |          |This bit indicates PDMA channel 10 has target abort error; User can write 1 to clear these bits.
 * |        |          |0 = No AHB bus ERROR response received when channel 10 transfer.
 * |        |          |1 = AHB bus ERROR response received when channel 10 transfer.
 * |[11]    |ABTIF11   |PDMA Channel 11 Read/Write Target Abort Interrupt Status Flag
 * |        |          |This bit indicates PDMA channel 11 has target abort error; User can write 1 to clear these bits.
 * |        |          |0 = No AHB bus ERROR response received when channel 11 transfer.
 * |        |          |1 = AHB bus ERROR response received when channel 11 transfer.
 * |[12]    |ABTIF12   |PDMA Channel 12 Read/Write Target Abort Interrupt Status Flag
 * |        |          |This bit indicates PDMA channel 12 has target abort error; User can write 1 to clear these bits.
 * |        |          |0 = No AHB bus ERROR response received when channel 12 transfer.
 * |        |          |1 = AHB bus ERROR response received when channel 12 transfer.
 * |[13]    |ABTIF13   |PDMA Channel 13 Read/Write Target Abort Interrupt Status Flag
 * |        |          |This bit indicates PDMA channel 13 has target abort error; User can write 1 to clear these bits.
 * |        |          |0 = No AHB bus ERROR response received when channel 13 transfer.
 * |        |          |1 = AHB bus ERROR response received when channel 13 transfer.
 * |[14]    |ABTIF14   |PDMA Channel 14 Read/Write Target Abort Interrupt Status Flag
 * |        |          |This bit indicates PDMA channel 14 has target abort error; User can write 1 to clear these bits.
 * |        |          |0 = No AHB bus ERROR response received when channel 14 transfer.
 * |        |          |1 = AHB bus ERROR response received when channel 14 transfer.
 * |[15]    |ABTIF15   |PDMA Channel 15 Read/Write Target Abort Interrupt Status Flag
 * |        |          |This bit indicates PDMA channel 15 has target abort error; User can write 1 to clear these bits.
 * |        |          |0 = No AHB bus ERROR response received when channel 15 transfer.
 * |        |          |1 = AHB bus ERROR response received when channel 15 transfer.
 * @var PDMA_T::TDSTS
 * Offset: 0x424  PDMA Channel Transfer Done Flag Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |TDIF0     |PDMA Channel 0 Transfer Done Flag Register
 * |        |          |This bit indicates PDMA channel 0 transfer has been finished or not, user can write 1 to clear this bits.
 * |        |          |0 = PDMA channel 0 transfer has not finished.
 * |        |          |1 = PDMA channel 0 has finished transmission.
 * |[1]     |TDIF1     |PDMA Channel 1 Transfer Done Flag Register
 * |        |          |This bit indicates PDMA channel 1 transfer has been finished or not, user can write 1 to clear this bits.
 * |        |          |0 = PDMA channel 1 transfer has not finished.
 * |        |          |1 = PDMA channel 1 has finished transmission.
 * |[2]     |TDIF2     |PDMA Channel 2 Transfer Done Flag Register
 * |        |          |This bit indicates PDMA channel 2 transfer has been finished or not, user can write 1 to clear this bits.
 * |        |          |0 = PDMA channel 2 transfer has not finished.
 * |        |          |1 = PDMA channel 2 has finished transmission.
 * |[3]     |TDIF3     |PDMA Channel 3 Transfer Done Flag Register
 * |        |          |This bit indicates PDMA channel 3 transfer has been finished or not, user can write 1 to clear this bits.
 * |        |          |0 = PDMA channel 3 transfer has not finished.
 * |        |          |1 = PDMA channel 3 has finished transmission.
 * |[4]     |TDIF4     |PDMA Channel 4 Transfer Done Flag Register
 * |        |          |This bit indicates PDMA channel 4 transfer has been finished or not, user can write 1 to clear this bits.
 * |        |          |0 = PDMA channel 4 transfer has not finished.
 * |        |          |1 = PDMA channel 4 has finished transmission.
 * |[5]     |TDIF5     |PDMA Channel 5 Transfer Done Flag Register
 * |        |          |This bit indicates PDMA channel 5 transfer has been finished or not, user can write 1 to clear this bits.
 * |        |          |0 = PDMA channel 5 transfer has not finished.
 * |        |          |1 = PDMA channel 5 has finished transmission.
 * |[6]     |TDIF6     |PDMA Channel 6 Transfer Done Flag Register
 * |        |          |This bit indicates PDMA channel 6 transfer has been finished or not, user can write 1 to clear this bits.
 * |        |          |0 = PDMA channel 6 transfer has not finished.
 * |        |          |1 = PDMA channel 6 has finished transmission.
 * |[7]     |TDIF7     |PDMA Channel 7 Transfer Done Flag Register
 * |        |          |This bit indicates PDMA channel 7 transfer has been finished or not, user can write 1 to clear this bits.
 * |        |          |0 = PDMA channel 7 transfer has not finished.
 * |        |          |1 = PDMA channel 7 has finished transmission.
 * |[8]     |TDIF8     |PDMA Channel 8 Transfer Done Flag Register
 * |        |          |This bit indicates PDMA channel 8 transfer has been finished or not, user can write 1 to clear this bits.
 * |        |          |0 = PDMA channel 8 transfer has not finished.
 * |        |          |1 = PDMA channel 8 has finished transmission.
 * |[9]     |TDIF9     |PDMA Channel 9 Transfer Done Flag Register
 * |        |          |This bit indicates PDMA channel 9 transfer has been finished or not, user can write 1 to clear this bits.
 * |        |          |0 = PDMA channel 9 transfer has not finished.
 * |        |          |1 = PDMA channel 9 has finished transmission.
 * |[10]    |TDIF10    |PDMA Channel 10 Transfer Done Flag Register
 * |        |          |This bit indicates PDMA channel 10 transfer has been finished or not, user can write 1 to clear this bits.
 * |        |          |0 = PDMA channel 10 transfer has not finished.
 * |        |          |1 = PDMA channel 10 has finished transmission.
 * |[11]    |TDIF11    |PDMA Channel 11 Transfer Done Flag Register
 * |        |          |This bit indicates PDMA channel 11 transfer has been finished or not, user can write 1 to clear this bits.
 * |        |          |0 = PDMA channel 11 transfer has not finished.
 * |        |          |1 = PDMA channel 11 has finished transmission.
 * |[12]    |TDIF12    |PDMA Channel 12 Transfer Done Flag Register
 * |        |          |This bit indicates PDMA channel 12 transfer has been finished or not, user can write 1 to clear this bits.
 * |        |          |0 = PDMA channel 12 transfer has not finished.
 * |        |          |1 = PDMA channel 12 has finished transmission.
 * |[13]    |TDIF13    |PDMA Channel 13 Transfer Done Flag Register
 * |        |          |This bit indicates PDMA channel 13 transfer has been finished or not, user can write 1 to clear this bits.
 * |        |          |0 = PDMA channel 13 transfer has not finished.
 * |        |          |1 = PDMA channel 13 has finished transmission.
 * |[14]    |TDIF14    |PDMA Channel 14 Transfer Done Flag Register
 * |        |          |This bit indicates PDMA channel 14 transfer has been finished or not, user can write 1 to clear this bits.
 * |        |          |0 = PDMA channel 14 transfer has not finished.
 * |        |          |1 = PDMA channel 14 has finished transmission.
 * |[15]    |TDIF15    |PDMA Channel 15 Transfer Done Flag Register
 * |        |          |This bit indicates PDMA channel 15 transfer has been finished or not, user can write 1 to clear this bits.
 * |        |          |0 = PDMA channel 15 transfer has not finished.
 * |        |          |1 = PDMA channel 15 has finished transmission.
 * @var PDMA_T::ALIGN
 * Offset: 0x428  PDMA Transfer Alignment Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ALIGN0    |PDMA Channel 0 Transfer Alignment Flag Register
 * |        |          |0 = PDMA channel 0 source address and destination address both follow transfer width setting.
 * |        |          |1 = PDMA channel 0 source address or destination address is not follow transfer width setting.
 * |[1]     |ALIGN1    |PDMA Channel 1 Transfer Alignment Flag Register
 * |        |          |0 = PDMA channel 1 source address and destination address both follow transfer width setting.
 * |        |          |1 = PDMA channel 1 source address or destination address is not follow transfer width setting.
 * |[2]     |ALIGN2    |PDMA Channel 2 Transfer Alignment Flag Register
 * |        |          |0 = PDMA channel 2 source address and destination address both follow transfer width setting.
 * |        |          |1 = PDMA channel 2 source address or destination address is not follow transfer width setting.
 * |[3]     |ALIGN3    |PDMA Channel 3 Transfer Alignment Flag Register
 * |        |          |0 = PDMA channel 3 source address and destination address both follow transfer width setting.
 * |        |          |1 = PDMA channel 3 source address or destination address is not follow transfer width setting.
 * |[4]     |ALIGN4    |PDMA Channel 4 Transfer Alignment Flag Register
 * |        |          |0 = PDMA channel 4 source address and destination address both follow transfer width setting.
 * |        |          |1 = PDMA channel 4 source address or destination address is not follow transfer width setting.
 * |[5]     |ALIGN5    |PDMA Channel 5 Transfer Alignment Flag Register
 * |        |          |0 = PDMA channel 5 source address and destination address both follow transfer width setting.
 * |        |          |1 = PDMA channel 5 source address or destination address is not follow transfer width setting.
 * |[6]     |ALIGN6    |PDMA Channel 6 Transfer Alignment Flag Register
 * |        |          |0 = PDMA channel 6 source address and destination address both follow transfer width setting.
 * |        |          |1 = PDMA channel 6 source address or destination address is not follow transfer width setting.
 * |[7]     |ALIGN7    |PDMA Channel 7 Transfer Alignment Flag Register
 * |        |          |0 = PDMA channel 7 source address and destination address both follow transfer width setting.
 * |        |          |1 = PDMA channel 7 source address or destination address is not follow transfer width setting.
 * |[8]     |ALIGN8    |PDMA Channel 8 Transfer Alignment Flag Register
 * |        |          |0 = PDMA channel 8 source address and destination address both follow transfer width setting.
 * |        |          |1 = PDMA channel 8 source address or destination address is not follow transfer width setting.
 * |[9]     |ALIGN9    |PDMA Channel 9 Transfer Alignment Flag Register
 * |        |          |0 = PDMA channel 9 source address and destination address both follow transfer width setting.
 * |        |          |1 = PDMA channel 9 source address or destination address is not follow transfer width setting.
 * |[10]    |ALIGN10   |PDMA Channel 10 Transfer Alignment Flag Register
 * |        |          |0 = PDMA channel 10 source address and destination address both follow transfer width setting.
 * |        |          |1 = PDMA channel 10 source address or destination address is not follow transfer width setting.
 * |[11]    |ALIGN11   |PDMA Channel 11 Transfer Alignment Flag Register
 * |        |          |0 = PDMA channel 11 source address and destination address both follow transfer width setting.
 * |        |          |1 = PDMA channel 11 source address or destination address is not follow transfer width setting.
 * |[12]    |ALIGN12   |PDMA Channel 12 Transfer Alignment Flag Register
 * |        |          |0 = PDMA channel 12 source address and destination address both follow transfer width setting.
 * |        |          |1 = PDMA channel 12 source address or destination address is not follow transfer width setting.
 * |[13]    |ALIGN13   |PDMA Channel 13 Transfer Alignment Flag Register
 * |        |          |0 = PDMA channel 13 source address and destination address both follow transfer width setting.
 * |        |          |1 = PDMA channel 13 source address or destination address is not follow transfer width setting.
 * |[14]    |ALIGN14   |PDMA Channel 14 Transfer Alignment Flag Register
 * |        |          |0 = PDMA channel 14 source address and destination address both follow transfer width setting.
 * |        |          |1 = PDMA channel 14 source address or destination address is not follow transfer width setting.
 * |[15]    |ALIGN15   |PDMA Channel 15 Transfer Alignment Flag Register
 * |        |          |0 = PDMA channel 15 source address and destination address both follow transfer width setting.
 * |        |          |1 = PDMA channel 15 source address or destination address is not follow transfer width setting.
 * @var PDMA_T::TACTSTS
 * Offset: 0x42C  PDMA Transfer Active Flag Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |TXACTF0   |PDMA Channel 0 Transfer on Active Flag Register (Read Only)
 * |        |          |0 = PDMA channel 0 is not finished.
 * |        |          |1 = PDMA channel 0 is in active.
 * |[1]     |TXACTF1   |PDMA Channel 1 Transfer on Active Flag Register (Read Only)
 * |        |          |0 = PDMA channel 1 is not finished.
 * |        |          |1 = PDMA channel 1 is in active.
 * |[2]     |TXACTF2   |PDMA Channel 2 Transfer on Active Flag Register (Read Only)
 * |        |          |0 = PDMA channel 2 is not finished.
 * |        |          |1 = PDMA channel 2 is in active.
 * |[3]     |TXACTF3   |PDMA Channel 3 Transfer on Active Flag Register (Read Only)
 * |        |          |0 = PDMA channel 3 is not finished.
 * |        |          |1 = PDMA channel 3 is in active.
 * |[4]     |TXACTF4   |PDMA Channel 4 Transfer on Active Flag Register (Read Only)
 * |        |          |0 = PDMA channel 4 is not finished.
 * |        |          |1 = PDMA channel 4 is in active.
 * |[5]     |TXACTF5   |PDMA Channel 5 Transfer on Active Flag Register (Read Only)
 * |        |          |0 = PDMA channel 5 is not finished.
 * |        |          |1 = PDMA channel 5 is in active.
 * |[6]     |TXACTF6   |PDMA Channel 6 Transfer on Active Flag Register (Read Only)
 * |        |          |0 = PDMA channel 6 is not finished.
 * |        |          |1 = PDMA channel 6 is in active.
 * |[7]     |TXACTF7   |PDMA Channel 7 Transfer on Active Flag Register (Read Only)
 * |        |          |0 = PDMA channel 7 is not finished.
 * |        |          |1 = PDMA channel 7 is in active.
 * |[8]     |TXACTF8   |PDMA Channel 8 Transfer on Active Flag Register (Read Only)
 * |        |          |0 = PDMA channel 8 is not finished.
 * |        |          |1 = PDMA channel 8 is in active.
 * |[9]     |TXACTF9   |PDMA Channel 9 Transfer on Active Flag Register (Read Only)
 * |        |          |0 = PDMA channel 9 is not finished.
 * |        |          |1 = PDMA channel 9 is in active.
 * |[10]    |TXACTF10  |PDMA Channel 10 Transfer on Active Flag Register (Read Only)
 * |        |          |0 = PDMA channel 10 is not finished.
 * |        |          |1 = PDMA channel 10 is in active.
 * |[11]    |TXACTF11  |PDMA Channel 11 Transfer on Active Flag Register (Read Only)
 * |        |          |0 = PDMA channel 11 is not finished.
 * |        |          |1 = PDMA channel 11 is in active.
 * |[12]    |TXACTF12  |PDMA Channel 12 Transfer on Active Flag Register (Read Only)
 * |        |          |0 = PDMA channel 12 is not finished.
 * |        |          |1 = PDMA channel 12 is in active.
 * |[13]    |TXACTF13  |PDMA Channel 13 Transfer on Active Flag Register (Read Only)
 * |        |          |0 = PDMA channel 13 is not finished.
 * |        |          |1 = PDMA channel 13 is in active.
 * |[14]    |TXACTF14  |PDMA Channel 14 Transfer on Active Flag Register (Read Only)
 * |        |          |0 = PDMA channel 14 is not finished.
 * |        |          |1 = PDMA channel 14 is in active.
 * |[15]    |TXACTF15  |PDMA Channel 15 Transfer on Active Flag Register (Read Only)
 * |        |          |0 = PDMA channel 15 is not finished.
 * |        |          |1 = PDMA channel 15 is in active.
 * @var PDMA_T::TOUTPSC
 * Offset: 0x430  PDMA Time-out Prescaler Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[2:0]   |TOUTPSC0  |PDMA Channel 0 Time-out Clock Source Prescaler Bits
 * |        |          |000 = PDMA channel 0 time-out clock source is HCLK/28.
 * |        |          |001 = PDMA channel 0 time-out clock source is HCLK/29.
 * |        |          |010 = PDMA channel 0 time-out clock source is HCLK/210.
 * |        |          |011 = PDMA channel 0 time-out clock source is HCLK/211.
 * |        |          |100 = PDMA channel 0 time-out clock source is HCLK/212.
 * |        |          |101 = PDMA channel 0 time-out clock source is HCLK/213.
 * |        |          |110 = PDMA channel 0 time-out clock source is HCLK/214.
 * |        |          |111 = PDMA channel 0 time-out clock source is HCLK/215.
 * |[6:4]   |TOUTPSC1  |PDMA Channel 1 Time-out Clock Source Prescaler Bits
 * |        |          |000 = PDMA channel 1 time-out clock source is HCLK/28.
 * |        |          |001 = PDMA channel 1 time-out clock source is HCLK/29.
 * |        |          |010 = PDMA channel 1 time-out clock source is HCLK/210.
 * |        |          |011 = PDMA channel 1 time-out clock source is HCLK/211.
 * |        |          |100 = PDMA channel 1 time-out clock source is HCLK/212.
 * |        |          |101 = PDMA channel 1 time-out clock source is HCLK/213.
 * |        |          |110 = PDMA channel 1 time-out clock source is HCLK/214.
 * |        |          |111 = PDMA channel 1 time-out clock source is HCLK/215.
 * @var PDMA_T::TOUTEN
 * Offset: 0x434  PDMA Time-out Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |TOUTEN0   |PDMA Channel 0 Time-out Enable Bit
 * |        |          |0 = PDMA Channel 0 time-out function Disable.
 * |        |          |1 = PDMA Channel 0 time-out function Enable.
 * |[1]     |TOUTEN1   |PDMA Channel 1 Time-out Enable Bit
 * |        |          |0 = PDMA Channel 1 time-out function Disable.
 * |        |          |1 = PDMA Channel 1 time-out function Enable.
 * @var PDMA_T::TOUTIEN
 * Offset: 0x438  PDMA Time-out Interrupt Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |TOUTIEN0  |PDMA Channel 0 Time-out Interrupt Enable Bit
 * |        |          |0 = PDMA Channel 0 time-out interrupt Disable.
 * |        |          |1 = PDMA Channel 0 time-out interrupt Enable.
 * |[1]     |TOUTIEN1  |PDMA Channel 1 Time-out Interrupt Enable Bit
 * |        |          |0 = PDMA Channel 1 time-out interrupt Disable.
 * |        |          |1 = PDMA Channel 1 time-out interrupt Enable.
 * @var PDMA_T::SCATBA
 * Offset: 0x43C  PDMA Scatter-Gather Descriptor Table Base Address Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:16] |SCATBA    |PDMA Scatter-gather Descriptor Table Address Register
 * |        |          |In Scatter-Gather mode, this is the base address for calculating the next link - list address
 * |        |          |The next link address equation is
 * |        |          |Next Link Address = PDMA_SCATBA + PDMA_DSCT_NEXT.
 * |        |          |Note: Only useful in Scatter-Gather mode.
 * @var PDMA_T::TOC0_1
 * Offset: 0x440  PDMA Time-out Counter Ch1 and Ch0 Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |TOC0      |Time-out Counter for Channel 0
 * |        |          |This controls the period of time-out function for channel 0
 * |        |          |The calculation unit is based on 10 kHz clock.
 * |[31:16] |TOC1      |Time-out Counter for Channel 1
 * |        |          |This controls the period of time-out function for channel 1
 * |        |          |The calculation unit is based on 10 kHz clock.
 * @var PDMA_T::CHRST
 * Offset: 0x460  PDMA Channel Reset Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CH0RST    |Channel 0 Reset
 * |        |          |0 = corresponding channel 0 not reset.
 * |        |          |1 = corresponding channel 0 is reset.
 * |[1]     |CH1RST    |Channel 1 Reset
 * |        |          |0 = corresponding channel 1 not reset.
 * |        |          |1 = corresponding channel 1 is reset.
 * |[2]     |CH2RST    |Channel 2 Reset
 * |        |          |0 = corresponding channel 2 not reset.
 * |        |          |1 = corresponding channel 2 is reset.
 * |[3]     |CH3RST    |Channel 3 Reset
 * |        |          |0 = corresponding channel 3 not reset.
 * |        |          |1 = corresponding channel 3 is reset.
 * |[4]     |CH4RST    |Channel 4 Reset
 * |        |          |0 = corresponding channel 4 not reset.
 * |        |          |1 = corresponding channel 4 is reset.
 * |[5]     |CH5RST    |Channel 5 Reset
 * |        |          |0 = corresponding channel 5 not reset.
 * |        |          |1 = corresponding channel 5 is reset.
 * |[6]     |CH6RST    |Channel 6 Reset
 * |        |          |0 = corresponding channel 6 not reset.
 * |        |          |1 = corresponding channel 6 is reset.
 * |[7]     |CH7RST    |Channel 7 Reset
 * |        |          |0 = corresponding channel 7 not reset.
 * |        |          |1 = corresponding channel 7 is reset.
 * |[8]     |CH8RST    |Channel 8 Reset
 * |        |          |0 = corresponding channel 8 not reset.
 * |        |          |1 = corresponding channel 8 is reset.
 * |[9]     |CH9RST    |Channel 9 Reset
 * |        |          |0 = corresponding channel 9 not reset.
 * |        |          |1 = corresponding channel 9 is reset.
 * |[10]    |CH10RST   |Channel 10 Reset
 * |        |          |0 = corresponding channel 10 not reset.
 * |        |          |1 = corresponding channel 10 is reset.
 * |[11]    |CH11RST   |Channel 11 Reset
 * |        |          |0 = corresponding channel 11 not reset.
 * |        |          |1 = corresponding channel 11 is reset.
 * |[12]    |CH12RST   |Channel 12 Reset
 * |        |          |0 = corresponding channel 12 not reset.
 * |        |          |1 = corresponding channel 12 is reset.
 * |[13]    |CH13RST   |Channel 13 Reset
 * |        |          |0 = corresponding channel 13 not reset.
 * |        |          |1 = corresponding channel 13 is reset.
 * |[14]    |CH14RST   |Channel 14 Reset
 * |        |          |0 = corresponding channel 14 not reset.
 * |        |          |1 = corresponding channel 14 is reset.
 * |[15]    |CH15RST   |Channel 15 Reset
 * |        |          |0 = corresponding channel 15 not reset.
 * |        |          |1 = corresponding channel 15 is reset.
 * @var PDMA_T::REQSEL0_3
 * Offset: 0x480  PDMA Request Source Select Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[5:0]   |REQSRC0   |Channel 0 Request Source Selection
 * |        |          |This filed defines which peripheral is connected to PDMA channel 0
 * |        |          |User can configure the peripheral by setting REQSRC0.
 * |        |          |0 = Disable PDMA peripheral request.
 * |        |          |1 = Reserved.
 * |        |          |2 = Channel connects to USB_TX.
 * |        |          |3 = Channel connects to USB_RX.
 * |        |          |4 = Channel connects to UART0_TX.
 * |        |          |5 = Channel connects to UART0_RX.
 * |        |          |20 = Channel connects to SPI0_TX.
 * |        |          |21 = Channel connects to SPI0_RX.
 * |        |          |22 = Channel connects to SPI1_TX.
 * |        |          |23 = Channel connects to SPI1_RX.
 * |        |          |24 = Channel connects to SPI2_TX.
 * |        |          |25 = Channel connects to SPI2_RX.
 * |        |          |32 = Channel connects to PWM0_P1_RX.
 * |        |          |33 = Channel connects to PWM0_P2_RX.
 * |        |          |34 = Channel connects to PWM0_P3_RX.
 * |        |          |38 = Channel connects to I2C0_TX.
 * |        |          |39 = Channel connects to I2C0_RX.
 * |        |          |40 = Channel connects to I2C1_TX.
 * |        |          |41 = Channel connects to I2C1_RX.
 * |        |          |44 = Channel connects to I2S0_TX.
 * |        |          |45 = Channel connects to I2S0_RX.
 * |        |          |46 = Channel connects to TMR0.
 * |        |          |47 = Channel connects to TMR1.
 * |        |          |48 = Channel connects to TMR2.
 * |        |          |49 = Channel connects to TMR3.
 * |        |          |50 = Channel connects to ADC_RX.
 * |        |          |53 = Channel connects to PWM0_CH0_TX.
 * |        |          |54 = Channel connects to PWM0_CH1_TX.
 * |        |          |55 = Channel connects to PWM0_CH2_TX.
 * |        |          |56 = Channel connects to PWM0_CH3_TX.
 * |        |          |57 = Channel connects to PWM0_CH4_TX.
 * |        |          |58 = Channel connects to PWM0_CH5_TX.
 * |        |          |Others = Reserved.
 * |        |          |Note 1: A peripheral can't assign to two channels at the same time.
 * |        |          |Note 2: This field is useless when transfer between memory and memory. 
 * |[13:8]  |REQSRC1   |Channel 1 Request Source Selection
 * |        |          |This filed defines which peripheral is connected to PDMA channel 1
 * |        |          |User can configure the peripheral setting by REQSRC1.
 * |        |          |Note: The channel configuration is the same as REQSRC0 field
 * |        |          |Please refer to the explanation of REQSRC0.
 * |[21:16] |REQSRC2   |Channel 2 Request Source Selection
 * |        |          |This filed defines which peripheral is connected to PDMA channel 2
 * |        |          |User can configure the peripheral setting by REQSRC2.
 * |        |          |Note: The channel configuration is the same as REQSRC0 field
 * |        |          |Please refer to the explanation of REQSRC0.
 * |[29:24] |REQSRC3   |Channel 3 Request Source Selection
 * |        |          |This filed defines which peripheral is connected to PDMA channel 3
 * |        |          |User can configure the peripheral setting by REQSRC3.
 * |        |          |Note: The channel configuration is the same as REQSRC0 field
 * |        |          |Please refer to the explanation of REQSRC0.
 * @var PDMA_T::REQSEL4_7
 * Offset: 0x484  PDMA Request Source Select Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[4:0]   |REQSRC4   |Channel 4 Request Source Selection
 * |        |          |This filed defines which peripheral is connected to PDMA channel 4
 * |        |          |User can configure the peripheral setting by REQSRC4.
 * |        |          |Note: The channel configuration is the same as REQSRC0 field
 * |        |          |Please refer to the explanation of REQSRC0.
 * |[12:8]  |REQSRC5   |Channel 5 Request Source Selection
 * |        |          |This filed defines which peripheral is connected to PDMA channel 5
 * |        |          |User can configure the peripheral setting by REQSRC5.
 * |        |          |Note: The channel configuration is the same as REQSRC0 field
 * |        |          |Please refer to the explanation of REQSRC0.
 * |[20:16] |REQSRC6   |Channel 6 Request Source Selection
 * |        |          |This filed defines which peripheral is connected to PDMA channel 6
 * |        |          |User can configure the peripheral setting by REQSRC6.
 * |        |          |Note: The channel configuration is the same as REQSRC0 field
 * |        |          |Please refer to the explanation of REQSRC0.
 * |[28:24] |REQSRC7   |Channel 7 Request Source Selection
 * |        |          |This filed defines which peripheral is connected to PDMA channel 7
 * |        |          |User can configure the peripheral setting by REQSRC7.
 * |        |          |Note: The channel configuration is the same as REQSRC0 field
 * |        |          |Please refer to the explanation of REQSRC0.
 * @var PDMA_T::REQSEL8_11
 * Offset: 0x488  PDMA Request Source Select Register 2
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[4:0]   |REQSRC8   |Channel 8 Request Source Selection
 * |        |          |This filed defines which peripheral is connected to PDMA channel 8
 * |        |          |User can configure the peripheral setting by REQSRC8.
 * |        |          |Note: The channel configuration is the same as REQSRC.0 field
 * |        |          |Please refer to the explanation of REQSRC0.
 * |[12:8]  |REQSRC9   |Channel 9 Request Source Selection
 * |        |          |This filed defines which peripheral is connected to PDMA channel 9
 * |        |          |User can configure the peripheral setting by REQSRC9.
 * |        |          |Note: The channel configuration is the same as REQSRC0 field
 * |        |          |Please refer to the explanation of REQSRC0.
 * |[20:16] |REQSRC10  |Channel 10 Request Source Selection
 * |        |          |This filed defines which peripheral is connected to PDMA channel 10
 * |        |          |User can configure the peripheral setting by REQSRC10.
 * |        |          |Note: The channel configuration is the same as REQSRC0 field
 * |        |          |Please refer to the explanation of REQSRC0.
 * |[28:24] |REQSRC11  |Channel 11 Request Source Selection
 * |        |          |This filed defines which peripheral is connected to PDMA channel 11
 * |        |          |User can configure 1the peripheral setting by REQSRC11.
 * |        |          |Note: The channel configuration is the same as REQSRC0 field
 * |        |          |Please refer to the explanation of REQSRC0.
 * @var PDMA_T::REQSEL12_15
 * Offset: 0x48C  PDMA Request Source Select Register 3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[4:0]   |REQSRC12  |Channel 4 Request Source Selection
 * |        |          |This filed defines which peripheral is connected to PDMA channel 12
 * |        |          |User can configure the peripheral setting by REQSRC12.
 * |        |          |Note: The channel configuration is the same as REQSRC0 field
 * |        |          |Please refer to the explanation of REQSRC0.
 * |[12:8]  |REQSRC13  |Channel 5 Request Source Selection
 * |        |          |This filed defines which peripheral is connected to PDMA channel 13
 * |        |          |User can configure the peripheral setting by REQSRC13.
 * |        |          |Note: The channel configuration is the same as REQSRC0 field
 * |        |          |Please refer to the explanation of REQSRC0.
 * |[20:16] |REQSRC14  |Channel 6 Request Source Selection
 * |        |          |This filed defines which peripheral is connected to PDMA channel 14
 * |        |          |User can configure the peripheral setting by REQSRC14.
 * |        |          |Note: The channel configuration is the same as REQSRC0 field
 * |        |          |Please refer to the explanation of REQSRC0.
 * |[28:24] |REQSRC15  |Channel 7 Request Source Selection
 * |        |          |This filed defines which peripheral is connected to PDMA channel 15
 * |        |          |User can configure the peripheral setting by REQSRC15.
 * |        |          |Note: The channel configuration is the same as REQSRC0 field
 * |        |          |Please refer to the explanation of REQSRC0.
 * @var PDMA_T::STCR0
 * Offset: 0x500  Stride Transfer Count Register of PDMA Channel 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |STC       |PDMA Stride Transfer Count
 * |        |          |The 16-bit register defines the stride transfer count of each row.
 * @var PDMA_T::ASOCR0
 * Offset: 0x504  Address Stride Offset Register of PDMA Channel 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |SASOL     |PDMA Source Address Stride Offset Length
 * |        |          |The 16-bit register defines the source address stride transfer offset count of each row.
 * |[31:16] |DASOL     |PDMA Destination Address Stride Offset Length
 * |        |          |The 16-bit register defines the destination address stride transfer offset count of each row.
 * @var PDMA_T::STCR1
 * Offset: 0x508  Stride Transfer Count Register of PDMA Channel 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |STC       |PDMA Stride Transfer Count
 * |        |          |The 16-bit register defines the stride transfer count of each row.
 * @var PDMA_T::ASOCR1
 * Offset: 0x50C  Address Stride Offset Register of PDMA Channel 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |SASOL     |PDMA Source Address Stride Offset Length
 * |        |          |The 16-bit register defines the source address stride transfer offset count of each row.
 * |[31:16] |DASOL     |PDMA Destination Address Stride Offset Length
 * |        |          |The 16-bit register defines the destination address stride transfer offset count of each row.
 * @var PDMA_T::STCR2
 * Offset: 0x510  Stride Transfer Count Register of PDMA Channel 2
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |STC       |PDMA Stride Transfer Count
 * |        |          |The 16-bit register defines the stride transfer count of each row.
 * @var PDMA_T::ASOCR2
 * Offset: 0x514  Address Stride Offset Register of PDMA Channel 2
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |SASOL     |PDMA Source Address Stride Offset Length
 * |        |          |The 16-bit register defines the source address stride transfer offset count of each row.
 * |[31:16] |DASOL     |PDMA Destination Address Stride Offset Length
 * |        |          |The 16-bit register defines the destination address stride transfer offset count of each row.
 * @var PDMA_T::STCR3
 * Offset: 0x518  Stride Transfer Count Register of PDMA Channel 3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |STC       |PDMA Stride Transfer Count
 * |        |          |The 16-bit register defines the stride transfer count of each row.
 * @var PDMA_T::ASOCR3
 * Offset: 0x51C  Address Stride Offset Register of PDMA Channel 3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |SASOL     |PDMA Source Address Stride Offset Length
 * |        |          |The 16-bit register defines the source address stride transfer offset count of each row.
 * |[31:16] |DASOL     |PDMA Destination Address Stride Offset Length
 * |        |          |The 16-bit register defines the destination address stride transfer offset count of each row.
 * @var PDMA_T::STCR4
 * Offset: 0x520  Stride Transfer Count Register of PDMA Channel 4
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |STC       |PDMA Stride Transfer Count
 * |        |          |The 16-bit register defines the stride transfer count of each row.
 * @var PDMA_T::ASOCR4
 * Offset: 0x524  Address Stride Offset Register of PDMA Channel 4
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |SASOL     |PDMA Source Address Stride Offset Length
 * |        |          |The 16-bit register defines the source address stride transfer offset count of each row.
 * |[31:16] |DASOL     |PDMA Destination Address Stride Offset Length
 * |        |          |The 16-bit register defines the destination address stride transfer offset count of each row.
 * @var PDMA_T::STCR5
 * Offset: 0x528  Stride Transfer Count Register of PDMA Channel 5
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |STC       |PDMA Stride Transfer Count
 * |        |          |The 16-bit register defines the stride transfer count of each row.
 * @var PDMA_T::ASOCR5
 * Offset: 0x52C  Address Stride Offset Register of PDMA Channel 5
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |SASOL     |PDMA Source Address Stride Offset Length
 * |        |          |The 16-bit register defines the source address stride transfer offset count of each row.
 * |[31:16] |DASOL     |PDMA Destination Address Stride Offset Length
 * |        |          |The 16-bit register defines the destination address stride transfer offset count of each row.
 * @var PDMA_T::VERSION
 * Offset: 0xFFC  PDMA RTL Design Version Number
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |MINOR     |PDMA RTL Design MINOR Version Number (Read Only)
 * |        |          |Minor version number is dependent on ECO version control
 * |        |          |0x0000: (current Minor Version Number)
 * |[23:16] |SUB       |PDMA RTL Design MINOR Version Number (Read Only)
 * |        |          |Sub version number is relative to key feature
 * |        |          |0x02: (current Sub Version Number)
 * |[31:24] |MAJOR     |PDMA RTL Design MAJOR Version Number (Read Only)
 * |        |          |Major version number is correlated to Product Line
 * |        |          |0x02: (current Major Version Number)
 */
    __IO uint32_t DSCT0_CTL;             /*!< [0x0000] Descriptor Table Control Register of PDMA Channel 0              */
    __IO uint32_t DSCT0_SA;              /*!< [0x0004] Source Address Register of PDMA Channel 0                        */
    __IO uint32_t DSCT0_DA;              /*!< [0x0008] Destination Address Register of PDMA Channel 0                   */
    __IO uint32_t DSCT0_NEXT;            /*!< [0x000c] First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 0 */
    __IO uint32_t DSCT1_CTL;             /*!< [0x0010] Descriptor Table Control Register of PDMA Channel 1              */
    __IO uint32_t DSCT1_SA;              /*!< [0x0014] Source Address Register of PDMA Channel 1                        */
    __IO uint32_t DSCT1_DA;              /*!< [0x0018] Destination Address Register of PDMA Channel 1                   */
    __IO uint32_t DSCT1_NEXT;            /*!< [0x001c] First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 1 */
    __IO uint32_t DSCT2_CTL;             /*!< [0x0020] Descriptor Table Control Register of PDMA Channel 2              */
    __IO uint32_t DSCT2_SA;              /*!< [0x0024] Source Address Register of PDMA Channel 2                        */
    __IO uint32_t DSCT2_DA;              /*!< [0x0028] Destination Address Register of PDMA Channel 2                   */
    __IO uint32_t DSCT2_NEXT;            /*!< [0x002c] First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 2 */
    __IO uint32_t DSCT3_CTL;             /*!< [0x0030] Descriptor Table Control Register of PDMA Channel 3              */
    __IO uint32_t DSCT3_SA;              /*!< [0x0034] Source Address Register of PDMA Channel 3                        */
    __IO uint32_t DSCT3_DA;              /*!< [0x0038] Destination Address Register of PDMA Channel 3                   */
    __IO uint32_t DSCT3_NEXT;            /*!< [0x003c] First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 3 */
    __IO uint32_t DSCT4_CTL;             /*!< [0x0040] Descriptor Table Control Register of PDMA Channel 4              */
    __IO uint32_t DSCT4_SA;              /*!< [0x0044] Source Address Register of PDMA Channel 4                        */
    __IO uint32_t DSCT4_DA;              /*!< [0x0048] Destination Address Register of PDMA Channel 4                   */
    __IO uint32_t DSCT4_NEXT;            /*!< [0x004c] First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 4 */
    __IO uint32_t DSCT5_CTL;             /*!< [0x0050] Descriptor Table Control Register of PDMA Channel 5              */
    __IO uint32_t DSCT5_SA;              /*!< [0x0054] Source Address Register of PDMA Channel 5                        */
    __IO uint32_t DSCT5_DA;              /*!< [0x0058] Destination Address Register of PDMA Channel 5                   */
    __IO uint32_t DSCT5_NEXT;            /*!< [0x005c] First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 5 */
    __IO uint32_t DSCT6_CTL;             /*!< [0x0060] Descriptor Table Control Register of PDMA Channel 6              */
    __IO uint32_t DSCT6_SA;              /*!< [0x0064] Source Address Register of PDMA Channel 6                        */
    __IO uint32_t DSCT6_DA;              /*!< [0x0068] Destination Address Register of PDMA Channel 6                   */
    __IO uint32_t DSCT6_NEXT;            /*!< [0x006c] First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 6 */
    __IO uint32_t DSCT7_CTL;             /*!< [0x0070] Descriptor Table Control Register of PDMA Channel 7              */
    __IO uint32_t DSCT7_SA;              /*!< [0x0074] Source Address Register of PDMA Channel 7                        */
    __IO uint32_t DSCT7_DA;              /*!< [0x0078] Destination Address Register of PDMA Channel 7                   */
    __IO uint32_t DSCT7_NEXT;            /*!< [0x007c] First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 7 */
    __IO uint32_t DSCT8_CTL;             /*!< [0x0080] Descriptor Table Control Register of PDMA Channel 8              */
    __IO uint32_t DSCT8_SA;              /*!< [0x0084] Source Address Register of PDMA Channel 8                        */
    __IO uint32_t DSCT8_DA;              /*!< [0x0088] Destination Address Register of PDMA Channel 8                   */
    __IO uint32_t DSCT8_NEXT;            /*!< [0x008c] First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 8 */
    __IO uint32_t DSCT9_CTL;             /*!< [0x0090] Descriptor Table Control Register of PDMA Channel 9              */
    __IO uint32_t DSCT9_SA;              /*!< [0x0094] Source Address Register of PDMA Channel 9                        */
    __IO uint32_t DSCT9_DA;              /*!< [0x0098] Destination Address Register of PDMA Channel 9                   */
    __IO uint32_t DSCT9_NEXT;            /*!< [0x009c] First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 9 */
    __IO uint32_t DSCT10_CTL;            /*!< [0x00a0] Descriptor Table Control Register of PDMA Channel 10             */
    __IO uint32_t DSCT10_SA;             /*!< [0x00a4] Source Address Register of PDMA Channel 10                       */
    __IO uint32_t DSCT10_DA;             /*!< [0x00a8] Destination Address Register of PDMA Channel 10                  */
    __IO uint32_t DSCT10_NEXT;           /*!< [0x00ac] First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 10 */
    __IO uint32_t DSCT11_CTL;            /*!< [0x00b0] Descriptor Table Control Register of PDMA Channel 11             */
    __IO uint32_t DSCT11_SA;             /*!< [0x00b4] Source Address Register of PDMA Channel 11                       */
    __IO uint32_t DSCT11_DA;             /*!< [0x00b8] Destination Address Register of PDMA Channel 11                  */
    __IO uint32_t DSCT11_NEXT;           /*!< [0x00bc] First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 11 */
    __IO uint32_t DSCT12_CTL;            /*!< [0x00c0] Descriptor Table Control Register of PDMA Channel 12             */
    __IO uint32_t DSCT12_SA;             /*!< [0x00c4] Source Address Register of PDMA Channel 12                       */
    __IO uint32_t DSCT12_DA;             /*!< [0x00c8] Destination Address Register of PDMA Channel 12                  */
    __IO uint32_t DSCT12_NEXT;           /*!< [0x00cc] First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 12 */
    __IO uint32_t DSCT13_CTL;            /*!< [0x00d0] Descriptor Table Control Register of PDMA Channel 13             */
    __IO uint32_t DSCT13_SA;             /*!< [0x00d4] Source Address Register of PDMA Channel 13                       */
    __IO uint32_t DSCT13_DA;             /*!< [0x00d8] Destination Address Register of PDMA Channel 13                  */
    __IO uint32_t DSCT13_NEXT;           /*!< [0x00dc] First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 13 */
    __IO uint32_t DSCT14_CTL;            /*!< [0x00e0] Descriptor Table Control Register of PDMA Channel 14             */
    __IO uint32_t DSCT14_SA;             /*!< [0x00e4] Source Address Register of PDMA Channel 14                       */
    __IO uint32_t DSCT14_DA;             /*!< [0x00e8] Destination Address Register of PDMA Channel 14                  */
    __IO uint32_t DSCT14_NEXT;           /*!< [0x00ec] First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 14 */
    __IO uint32_t DSCT15_CTL;            /*!< [0x00f0] Descriptor Table Control Register of PDMA Channel 15             */
    __IO uint32_t DSCT15_SA;             /*!< [0x00f4] Source Address Register of PDMA Channel 15                       */
    __IO uint32_t DSCT15_DA;             /*!< [0x00f8] Destination Address Register of PDMA Channel 15                  */
    __IO uint32_t DSCT15_NEXT;           /*!< [0x00fc] First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 15 */
    __I  uint32_t CURSCAT0;              /*!< [0x0100] Current Scatter-Gather Descriptor Table Address of PDMA Channel 0 */
    __I  uint32_t CURSCAT1;              /*!< [0x0104] Current Scatter-Gather Descriptor Table Address of PDMA Channel 1 */
    __I  uint32_t CURSCAT2;              /*!< [0x0108] Current Scatter-Gather Descriptor Table Address of PDMA Channel 2 */
    __I  uint32_t CURSCAT3;              /*!< [0x010c] Current Scatter-Gather Descriptor Table Address of PDMA Channel 3 */
    __I  uint32_t CURSCAT4;              /*!< [0x0110] Current Scatter-Gather Descriptor Table Address of PDMA Channel 4 */
    __I  uint32_t CURSCAT5;              /*!< [0x0114] Current Scatter-Gather Descriptor Table Address of PDMA Channel 5 */
    __I  uint32_t CURSCAT6;              /*!< [0x0118] Current Scatter-Gather Descriptor Table Address of PDMA Channel 6 */
    __I  uint32_t CURSCAT7;              /*!< [0x011c] Current Scatter-Gather Descriptor Table Address of PDMA Channel 7 */
    __I  uint32_t CURSCAT8;              /*!< [0x0120] Current Scatter-Gather Descriptor Table Address of PDMA Channel 8 */
    __I  uint32_t CURSCAT9;              /*!< [0x0124] Current Scatter-Gather Descriptor Table Address of PDMA Channel 9 */
    __I  uint32_t CURSCAT10;             /*!< [0x0128] Current Scatter-Gather Descriptor Table Address of PDMA Channel 10 */
    __I  uint32_t CURSCAT11;             /*!< [0x012c] Current Scatter-Gather Descriptor Table Address of PDMA Channel 11 */
    __I  uint32_t CURSCAT12;             /*!< [0x0130] Current Scatter-Gather Descriptor Table Address of PDMA Channel 12 */
    __I  uint32_t CURSCAT13;             /*!< [0x0134] Current Scatter-Gather Descriptor Table Address of PDMA Channel 13 */
    __I  uint32_t CURSCAT14;             /*!< [0x0138] Current Scatter-Gather Descriptor Table Address of PDMA Channel 14 */
    __I  uint32_t CURSCAT15;             /*!< [0x013c] Current Scatter-Gather Descriptor Table Address of PDMA Channel 15 */
    __I  uint32_t RESERVE0[176];
    __IO uint32_t CHCTL;                 /*!< [0x0400] PDMA Channel Control Register                                    */
    __O  uint32_t STOP;                  /*!< [0x0404] PDMA Transfer Stop Control Register                              */
    __O  uint32_t SWREQ;                 /*!< [0x0408] PDMA Software Request Register                                   */
    __I  uint32_t TRGSTS;                /*!< [0x040c] PDMA Channel Request Status Register                             */
    __IO uint32_t PRISET;                /*!< [0x0410] PDMA Fixed Priority Setting Register                             */
    __O  uint32_t PRICLR;                /*!< [0x0414] PDMA Fixed Priority Clear Register                               */
    __IO uint32_t INTEN;                 /*!< [0x0418] PDMA Interrupt Enable Register                                   */
    __IO uint32_t INTSTS;                /*!< [0x041c] PDMA Interrupt Status Register                                   */
    __IO uint32_t ABTSTS;                /*!< [0x0420] PDMA Channel Read/Write Target Abort Flag Register               */
    __IO uint32_t TDSTS;                 /*!< [0x0424] PDMA Channel Transfer Done Flag Register                         */
    __IO uint32_t ALIGN;                 /*!< [0x0428] PDMA Transfer Alignment Status Register                          */
    __I  uint32_t TACTSTS;               /*!< [0x042c] PDMA Transfer Active Flag Register                               */
    __IO uint32_t TOUTPSC;               /*!< [0x0430] PDMA Time-out Prescaler Register                                 */
    __IO uint32_t TOUTEN;                /*!< [0x0434] PDMA Time-out Enable Register                                    */
    __IO uint32_t TOUTIEN;               /*!< [0x0438] PDMA Time-out Interrupt Enable Register                          */
    __IO uint32_t SCATBA;                /*!< [0x043c] PDMA Scatter-Gather Descriptor Table Base Address Register       */
    __IO uint32_t TOC0_1;                /*!< [0x0440] PDMA Time-out Counter Ch1 and Ch0 Register                       */
    __I  uint32_t RESERVE1[7];
    __IO uint32_t CHRST;                 /*!< [0x0460] PDMA Channel Reset Register                                      */
    __I  uint32_t RESERVE2[7];
    __IO uint32_t REQSEL0_3;             /*!< [0x0480] PDMA Request Source Select Register 0                            */
    __IO uint32_t REQSEL4_7;             /*!< [0x0484] PDMA Request Source Select Register 1                            */
    __IO uint32_t REQSEL8_11;            /*!< [0x0488] PDMA Request Source Select Register 2                            */
    __IO uint32_t REQSEL12_15;           /*!< [0x048c] PDMA Request Source Select Register 3                            */
    __I  uint32_t RESERVE3[28];
    __IO uint32_t STCR0;                 /*!< [0x0500] Stride Transfer Count Register of PDMA Channel 0                 */
    __IO uint32_t ASOCR0;                /*!< [0x0504] Address Stride Offset Register of PDMA Channel 0                 */
    __IO uint32_t STCR1;                 /*!< [0x0508] Stride Transfer Count Register of PDMA Channel 1                 */
    __IO uint32_t ASOCR1;                /*!< [0x050c] Address Stride Offset Register of PDMA Channel 1                 */
    __IO uint32_t STCR2;                 /*!< [0x0510] Stride Transfer Count Register of PDMA Channel 2                 */
    __IO uint32_t ASOCR2;                /*!< [0x0514] Address Stride Offset Register of PDMA Channel 2                 */
    __IO uint32_t STCR3;                 /*!< [0x0518] Stride Transfer Count Register of PDMA Channel 3                 */
    __IO uint32_t ASOCR3;                /*!< [0x051c] Address Stride Offset Register of PDMA Channel 3                 */
    __IO uint32_t STCR4;                 /*!< [0x0520] Stride Transfer Count Register of PDMA Channel 4                 */
    __IO uint32_t ASOCR4;                /*!< [0x0524] Address Stride Offset Register of PDMA Channel 4                 */
    __IO uint32_t STCR5;                 /*!< [0x0528] Stride Transfer Count Register of PDMA Channel 5                 */
    __IO uint32_t ASOCR5;                /*!< [0x052c] Address Stride Offset Register of PDMA Channel 5                 */
    __I  uint32_t RESERVE4[691];
    __I  uint32_t VERSION;               /*!< [0x0ffc] PDMA RTL Design Version Number                                   */

} PDMA_T;

/**
    @addtogroup PDMA_CONST PDMA Bit Field Definition
    Constant Definitions for PDMA Controller
@{ */

#define PDMA_DSCT0_CTL_OPMODE_Pos        (0)                                               /*!< PDMA_T::DSCT0_CTL: OPMODE Position     */
#define PDMA_DSCT0_CTL_OPMODE_Msk        (0x3ul << PDMA_DSCT0_CTL_OPMODE_Pos)              /*!< PDMA_T::DSCT0_CTL: OPMODE Mask         */

#define PDMA_DSCT0_CTL_TXTYPE_Pos        (2)                                               /*!< PDMA_T::DSCT0_CTL: TXTYPE Position     */
#define PDMA_DSCT0_CTL_TXTYPE_Msk        (0x1ul << PDMA_DSCT0_CTL_TXTYPE_Pos)              /*!< PDMA_T::DSCT0_CTL: TXTYPE Mask         */

#define PDMA_DSCT0_CTL_BURSIZE_Pos       (4)                                               /*!< PDMA_T::DSCT0_CTL: BURSIZE Position    */
#define PDMA_DSCT0_CTL_BURSIZE_Msk       (0x7ul << PDMA_DSCT0_CTL_BURSIZE_Pos)             /*!< PDMA_T::DSCT0_CTL: BURSIZE Mask        */

#define PDMA_DSCT0_CTL_SAINC_Pos         (8)                                               /*!< PDMA_T::DSCT0_CTL: SAINC Position      */
#define PDMA_DSCT0_CTL_SAINC_Msk         (0x3ul << PDMA_DSCT0_CTL_SAINC_Pos)               /*!< PDMA_T::DSCT0_CTL: SAINC Mask          */

#define PDMA_DSCT0_CTL_DAINC_Pos         (10)                                              /*!< PDMA_T::DSCT0_CTL: DAINC Position      */
#define PDMA_DSCT0_CTL_DAINC_Msk         (0x3ul << PDMA_DSCT0_CTL_DAINC_Pos)               /*!< PDMA_T::DSCT0_CTL: DAINC Mask          */

#define PDMA_DSCT0_CTL_TXWIDTH_Pos       (12)                                              /*!< PDMA_T::DSCT0_CTL: TXWIDTH Position    */
#define PDMA_DSCT0_CTL_TXWIDTH_Msk       (0x3ul << PDMA_DSCT0_CTL_TXWIDTH_Pos)             /*!< PDMA_T::DSCT0_CTL: TXWIDTH Mask        */

#define PDMA_DSCT0_CTL_TXACK_Pos         (14)                                              /*!< PDMA_T::DSCT0_CTL: TXACK Position      */
#define PDMA_DSCT0_CTL_TXACK_Msk         (0x1ul << PDMA_DSCT0_CTL_TXACK_Pos)               /*!< PDMA_T::DSCT0_CTL: TXACK Mask          */

#define PDMA_DSCT0_CTL_STRIDEEN_Pos      (15)                                              /*!< PDMA_T::DSCT0_CTL: STRIDEEN Position   */
#define PDMA_DSCT0_CTL_STRIDEEN_Msk      (0x1ul << PDMA_DSCT0_CTL_STRIDEEN_Pos)            /*!< PDMA_T::DSCT0_CTL: STRIDEEN Mask       */

#define PDMA_DSCT0_CTL_TXCNT_Pos         (16)                                              /*!< PDMA_T::DSCT0_CTL: TXCNT Position      */
#define PDMA_DSCT0_CTL_TXCNT_Msk         (0xfffful << PDMA_DSCT0_CTL_TXCNT_Pos)            /*!< PDMA_T::DSCT0_CTL: TXCNT Mask          */

#define PDMA_DSCT0_SA_SA_Pos             (0)                                               /*!< PDMA_T::DSCT0_SA: SA Position          */
#define PDMA_DSCT0_SA_SA_Msk             (0xfffffffful << PDMA_DSCT0_SA_SA_Pos)            /*!< PDMA_T::DSCT0_SA: SA Mask              */

#define PDMA_DSCT0_DA_DA_Pos             (0)                                               /*!< PDMA_T::DSCT0_DA: DA Position          */
#define PDMA_DSCT0_DA_DA_Msk             (0xfffffffful << PDMA_DSCT0_DA_DA_Pos)            /*!< PDMA_T::DSCT0_DA: DA Mask              */

#define PDMA_DSCT0_NEXT_NEXT_Pos         (2)                                               /*!< PDMA_T::DSCT0_NEXT: NEXT Position      */
#define PDMA_DSCT0_NEXT_NEXT_Msk         (0x3ffful << PDMA_DSCT0_NEXT_NEXT_Pos)            /*!< PDMA_T::DSCT0_NEXT: NEXT Mask          */

#define PDMA_DSCT1_CTL_OPMODE_Pos        (0)                                               /*!< PDMA_T::DSCT1_CTL: OPMODE Position     */
#define PDMA_DSCT1_CTL_OPMODE_Msk        (0x3ul << PDMA_DSCT1_CTL_OPMODE_Pos)              /*!< PDMA_T::DSCT1_CTL: OPMODE Mask         */

#define PDMA_DSCT1_CTL_TXTYPE_Pos        (2)                                               /*!< PDMA_T::DSCT1_CTL: TXTYPE Position     */
#define PDMA_DSCT1_CTL_TXTYPE_Msk        (0x1ul << PDMA_DSCT1_CTL_TXTYPE_Pos)              /*!< PDMA_T::DSCT1_CTL: TXTYPE Mask         */

#define PDMA_DSCT1_CTL_BURSIZE_Pos       (4)                                               /*!< PDMA_T::DSCT1_CTL: BURSIZE Position    */
#define PDMA_DSCT1_CTL_BURSIZE_Msk       (0x7ul << PDMA_DSCT1_CTL_BURSIZE_Pos)             /*!< PDMA_T::DSCT1_CTL: BURSIZE Mask        */

#define PDMA_DSCT1_CTL_SAINC_Pos         (8)                                               /*!< PDMA_T::DSCT1_CTL: SAINC Position      */
#define PDMA_DSCT1_CTL_SAINC_Msk         (0x3ul << PDMA_DSCT1_CTL_SAINC_Pos)               /*!< PDMA_T::DSCT1_CTL: SAINC Mask          */

#define PDMA_DSCT1_CTL_DAINC_Pos         (10)                                              /*!< PDMA_T::DSCT1_CTL: DAINC Position      */
#define PDMA_DSCT1_CTL_DAINC_Msk         (0x3ul << PDMA_DSCT1_CTL_DAINC_Pos)               /*!< PDMA_T::DSCT1_CTL: DAINC Mask          */

#define PDMA_DSCT1_CTL_TXWIDTH_Pos       (12)                                              /*!< PDMA_T::DSCT1_CTL: TXWIDTH Position    */
#define PDMA_DSCT1_CTL_TXWIDTH_Msk       (0x3ul << PDMA_DSCT1_CTL_TXWIDTH_Pos)             /*!< PDMA_T::DSCT1_CTL: TXWIDTH Mask        */

#define PDMA_DSCT1_CTL_TXACK_Pos         (14)                                              /*!< PDMA_T::DSCT1_CTL: TXACK Position      */
#define PDMA_DSCT1_CTL_TXACK_Msk         (0x1ul << PDMA_DSCT1_CTL_TXACK_Pos)               /*!< PDMA_T::DSCT1_CTL: TXACK Mask          */

#define PDMA_DSCT1_CTL_STRIDEEN_Pos      (15)                                              /*!< PDMA_T::DSCT1_CTL: STRIDEEN Position   */
#define PDMA_DSCT1_CTL_STRIDEEN_Msk      (0x1ul << PDMA_DSCT1_CTL_STRIDEEN_Pos)            /*!< PDMA_T::DSCT1_CTL: STRIDEEN Mask       */

#define PDMA_DSCT1_CTL_TXCNT_Pos         (16)                                              /*!< PDMA_T::DSCT1_CTL: TXCNT Position      */
#define PDMA_DSCT1_CTL_TXCNT_Msk         (0xfffful << PDMA_DSCT1_CTL_TXCNT_Pos)            /*!< PDMA_T::DSCT1_CTL: TXCNT Mask          */

#define PDMA_DSCT1_SA_SA_Pos             (0)                                               /*!< PDMA_T::DSCT1_SA: SA Position          */
#define PDMA_DSCT1_SA_SA_Msk             (0xfffffffful << PDMA_DSCT1_SA_SA_Pos)            /*!< PDMA_T::DSCT1_SA: SA Mask              */

#define PDMA_DSCT1_DA_DA_Pos             (0)                                               /*!< PDMA_T::DSCT1_DA: DA Position          */
#define PDMA_DSCT1_DA_DA_Msk             (0xfffffffful << PDMA_DSCT1_DA_DA_Pos)            /*!< PDMA_T::DSCT1_DA: DA Mask              */

#define PDMA_DSCT1_NEXT_NEXT_Pos         (2)                                               /*!< PDMA_T::DSCT1_NEXT: NEXT Position      */
#define PDMA_DSCT1_NEXT_NEXT_Msk         (0x3ffful << PDMA_DSCT1_NEXT_NEXT_Pos)            /*!< PDMA_T::DSCT1_NEXT: NEXT Mask          */

#define PDMA_DSCT2_CTL_OPMODE_Pos        (0)                                               /*!< PDMA_T::DSCT2_CTL: OPMODE Position     */
#define PDMA_DSCT2_CTL_OPMODE_Msk        (0x3ul << PDMA_DSCT2_CTL_OPMODE_Pos)              /*!< PDMA_T::DSCT2_CTL: OPMODE Mask         */

#define PDMA_DSCT2_CTL_TXTYPE_Pos        (2)                                               /*!< PDMA_T::DSCT2_CTL: TXTYPE Position     */
#define PDMA_DSCT2_CTL_TXTYPE_Msk        (0x1ul << PDMA_DSCT2_CTL_TXTYPE_Pos)              /*!< PDMA_T::DSCT2_CTL: TXTYPE Mask         */

#define PDMA_DSCT2_CTL_BURSIZE_Pos       (4)                                               /*!< PDMA_T::DSCT2_CTL: BURSIZE Position    */
#define PDMA_DSCT2_CTL_BURSIZE_Msk       (0x7ul << PDMA_DSCT2_CTL_BURSIZE_Pos)             /*!< PDMA_T::DSCT2_CTL: BURSIZE Mask        */

#define PDMA_DSCT2_CTL_SAINC_Pos         (8)                                               /*!< PDMA_T::DSCT2_CTL: SAINC Position      */
#define PDMA_DSCT2_CTL_SAINC_Msk         (0x3ul << PDMA_DSCT2_CTL_SAINC_Pos)               /*!< PDMA_T::DSCT2_CTL: SAINC Mask          */

#define PDMA_DSCT2_CTL_DAINC_Pos         (10)                                              /*!< PDMA_T::DSCT2_CTL: DAINC Position      */
#define PDMA_DSCT2_CTL_DAINC_Msk         (0x3ul << PDMA_DSCT2_CTL_DAINC_Pos)               /*!< PDMA_T::DSCT2_CTL: DAINC Mask          */

#define PDMA_DSCT2_CTL_TXWIDTH_Pos       (12)                                              /*!< PDMA_T::DSCT2_CTL: TXWIDTH Position    */
#define PDMA_DSCT2_CTL_TXWIDTH_Msk       (0x3ul << PDMA_DSCT2_CTL_TXWIDTH_Pos)             /*!< PDMA_T::DSCT2_CTL: TXWIDTH Mask        */

#define PDMA_DSCT2_CTL_TXACK_Pos         (14)                                              /*!< PDMA_T::DSCT2_CTL: TXACK Position      */
#define PDMA_DSCT2_CTL_TXACK_Msk         (0x1ul << PDMA_DSCT2_CTL_TXACK_Pos)               /*!< PDMA_T::DSCT2_CTL: TXACK Mask          */

#define PDMA_DSCT2_CTL_STRIDEEN_Pos      (15)                                              /*!< PDMA_T::DSCT2_CTL: STRIDEEN Position   */
#define PDMA_DSCT2_CTL_STRIDEEN_Msk      (0x1ul << PDMA_DSCT2_CTL_STRIDEEN_Pos)            /*!< PDMA_T::DSCT2_CTL: STRIDEEN Mask       */

#define PDMA_DSCT2_CTL_TXCNT_Pos         (16)                                              /*!< PDMA_T::DSCT2_CTL: TXCNT Position      */
#define PDMA_DSCT2_CTL_TXCNT_Msk         (0xfffful << PDMA_DSCT2_CTL_TXCNT_Pos)            /*!< PDMA_T::DSCT2_CTL: TXCNT Mask          */

#define PDMA_DSCT2_SA_SA_Pos             (0)                                               /*!< PDMA_T::DSCT2_SA: SA Position          */
#define PDMA_DSCT2_SA_SA_Msk             (0xfffffffful << PDMA_DSCT2_SA_SA_Pos)            /*!< PDMA_T::DSCT2_SA: SA Mask              */

#define PDMA_DSCT2_DA_DA_Pos             (0)                                               /*!< PDMA_T::DSCT2_DA: DA Position          */
#define PDMA_DSCT2_DA_DA_Msk             (0xfffffffful << PDMA_DSCT2_DA_DA_Pos)            /*!< PDMA_T::DSCT2_DA: DA Mask              */

#define PDMA_DSCT2_NEXT_NEXT_Pos         (2)                                               /*!< PDMA_T::DSCT2_NEXT: NEXT Position      */
#define PDMA_DSCT2_NEXT_NEXT_Msk         (0x3ffful << PDMA_DSCT2_NEXT_NEXT_Pos)            /*!< PDMA_T::DSCT2_NEXT: NEXT Mask          */

#define PDMA_DSCT3_CTL_OPMODE_Pos        (0)                                               /*!< PDMA_T::DSCT3_CTL: OPMODE Position     */
#define PDMA_DSCT3_CTL_OPMODE_Msk        (0x3ul << PDMA_DSCT3_CTL_OPMODE_Pos)              /*!< PDMA_T::DSCT3_CTL: OPMODE Mask         */

#define PDMA_DSCT3_CTL_TXTYPE_Pos        (2)                                               /*!< PDMA_T::DSCT3_CTL: TXTYPE Position     */
#define PDMA_DSCT3_CTL_TXTYPE_Msk        (0x1ul << PDMA_DSCT3_CTL_TXTYPE_Pos)              /*!< PDMA_T::DSCT3_CTL: TXTYPE Mask         */

#define PDMA_DSCT3_CTL_BURSIZE_Pos       (4)                                               /*!< PDMA_T::DSCT3_CTL: BURSIZE Position    */
#define PDMA_DSCT3_CTL_BURSIZE_Msk       (0x7ul << PDMA_DSCT3_CTL_BURSIZE_Pos)             /*!< PDMA_T::DSCT3_CTL: BURSIZE Mask        */

#define PDMA_DSCT3_CTL_SAINC_Pos         (8)                                               /*!< PDMA_T::DSCT3_CTL: SAINC Position      */
#define PDMA_DSCT3_CTL_SAINC_Msk         (0x3ul << PDMA_DSCT3_CTL_SAINC_Pos)               /*!< PDMA_T::DSCT3_CTL: SAINC Mask          */

#define PDMA_DSCT3_CTL_DAINC_Pos         (10)                                              /*!< PDMA_T::DSCT3_CTL: DAINC Position      */
#define PDMA_DSCT3_CTL_DAINC_Msk         (0x3ul << PDMA_DSCT3_CTL_DAINC_Pos)               /*!< PDMA_T::DSCT3_CTL: DAINC Mask          */

#define PDMA_DSCT3_CTL_TXWIDTH_Pos       (12)                                              /*!< PDMA_T::DSCT3_CTL: TXWIDTH Position    */
#define PDMA_DSCT3_CTL_TXWIDTH_Msk       (0x3ul << PDMA_DSCT3_CTL_TXWIDTH_Pos)             /*!< PDMA_T::DSCT3_CTL: TXWIDTH Mask        */

#define PDMA_DSCT3_CTL_TXACK_Pos         (14)                                              /*!< PDMA_T::DSCT3_CTL: TXACK Position      */
#define PDMA_DSCT3_CTL_TXACK_Msk         (0x1ul << PDMA_DSCT3_CTL_TXACK_Pos)               /*!< PDMA_T::DSCT3_CTL: TXACK Mask          */

#define PDMA_DSCT3_CTL_STRIDEEN_Pos      (15)                                              /*!< PDMA_T::DSCT3_CTL: STRIDEEN Position   */
#define PDMA_DSCT3_CTL_STRIDEEN_Msk      (0x1ul << PDMA_DSCT3_CTL_STRIDEEN_Pos)            /*!< PDMA_T::DSCT3_CTL: STRIDEEN Mask       */

#define PDMA_DSCT3_CTL_TXCNT_Pos         (16)                                              /*!< PDMA_T::DSCT3_CTL: TXCNT Position      */
#define PDMA_DSCT3_CTL_TXCNT_Msk         (0xfffful << PDMA_DSCT3_CTL_TXCNT_Pos)            /*!< PDMA_T::DSCT3_CTL: TXCNT Mask          */

#define PDMA_DSCT3_SA_SA_Pos             (0)                                               /*!< PDMA_T::DSCT3_SA: SA Position          */
#define PDMA_DSCT3_SA_SA_Msk             (0xfffffffful << PDMA_DSCT3_SA_SA_Pos)            /*!< PDMA_T::DSCT3_SA: SA Mask              */

#define PDMA_DSCT3_DA_DA_Pos             (0)                                               /*!< PDMA_T::DSCT3_DA: DA Position          */
#define PDMA_DSCT3_DA_DA_Msk             (0xfffffffful << PDMA_DSCT3_DA_DA_Pos)            /*!< PDMA_T::DSCT3_DA: DA Mask              */

#define PDMA_DSCT3_NEXT_NEXT_Pos         (2)                                               /*!< PDMA_T::DSCT3_NEXT: NEXT Position      */
#define PDMA_DSCT3_NEXT_NEXT_Msk         (0x3ffful << PDMA_DSCT3_NEXT_NEXT_Pos)            /*!< PDMA_T::DSCT3_NEXT: NEXT Mask          */

#define PDMA_DSCT4_CTL_OPMODE_Pos        (0)                                               /*!< PDMA_T::DSCT4_CTL: OPMODE Position     */
#define PDMA_DSCT4_CTL_OPMODE_Msk        (0x3ul << PDMA_DSCT4_CTL_OPMODE_Pos)              /*!< PDMA_T::DSCT4_CTL: OPMODE Mask         */

#define PDMA_DSCT4_CTL_TXTYPE_Pos        (2)                                               /*!< PDMA_T::DSCT4_CTL: TXTYPE Position     */
#define PDMA_DSCT4_CTL_TXTYPE_Msk        (0x1ul << PDMA_DSCT4_CTL_TXTYPE_Pos)              /*!< PDMA_T::DSCT4_CTL: TXTYPE Mask         */

#define PDMA_DSCT4_CTL_BURSIZE_Pos       (4)                                               /*!< PDMA_T::DSCT4_CTL: BURSIZE Position    */
#define PDMA_DSCT4_CTL_BURSIZE_Msk       (0x7ul << PDMA_DSCT4_CTL_BURSIZE_Pos)             /*!< PDMA_T::DSCT4_CTL: BURSIZE Mask        */

#define PDMA_DSCT4_CTL_SAINC_Pos         (8)                                               /*!< PDMA_T::DSCT4_CTL: SAINC Position      */
#define PDMA_DSCT4_CTL_SAINC_Msk         (0x3ul << PDMA_DSCT4_CTL_SAINC_Pos)               /*!< PDMA_T::DSCT4_CTL: SAINC Mask          */

#define PDMA_DSCT4_CTL_DAINC_Pos         (10)                                              /*!< PDMA_T::DSCT4_CTL: DAINC Position      */
#define PDMA_DSCT4_CTL_DAINC_Msk         (0x3ul << PDMA_DSCT4_CTL_DAINC_Pos)               /*!< PDMA_T::DSCT4_CTL: DAINC Mask          */

#define PDMA_DSCT4_CTL_TXWIDTH_Pos       (12)                                              /*!< PDMA_T::DSCT4_CTL: TXWIDTH Position    */
#define PDMA_DSCT4_CTL_TXWIDTH_Msk       (0x3ul << PDMA_DSCT4_CTL_TXWIDTH_Pos)             /*!< PDMA_T::DSCT4_CTL: TXWIDTH Mask        */

#define PDMA_DSCT4_CTL_TXACK_Pos         (14)                                              /*!< PDMA_T::DSCT4_CTL: TXACK Position      */
#define PDMA_DSCT4_CTL_TXACK_Msk         (0x1ul << PDMA_DSCT4_CTL_TXACK_Pos)               /*!< PDMA_T::DSCT4_CTL: TXACK Mask          */

#define PDMA_DSCT4_CTL_STRIDEEN_Pos      (15)                                              /*!< PDMA_T::DSCT4_CTL: STRIDEEN Position   */
#define PDMA_DSCT4_CTL_STRIDEEN_Msk      (0x1ul << PDMA_DSCT4_CTL_STRIDEEN_Pos)            /*!< PDMA_T::DSCT4_CTL: STRIDEEN Mask       */

#define PDMA_DSCT4_CTL_TXCNT_Pos         (16)                                              /*!< PDMA_T::DSCT4_CTL: TXCNT Position      */
#define PDMA_DSCT4_CTL_TXCNT_Msk         (0xfffful << PDMA_DSCT4_CTL_TXCNT_Pos)            /*!< PDMA_T::DSCT4_CTL: TXCNT Mask          */

#define PDMA_DSCT4_SA_SA_Pos             (0)                                               /*!< PDMA_T::DSCT4_SA: SA Position          */
#define PDMA_DSCT4_SA_SA_Msk             (0xfffffffful << PDMA_DSCT4_SA_SA_Pos)            /*!< PDMA_T::DSCT4_SA: SA Mask              */

#define PDMA_DSCT4_DA_DA_Pos             (0)                                               /*!< PDMA_T::DSCT4_DA: DA Position          */
#define PDMA_DSCT4_DA_DA_Msk             (0xfffffffful << PDMA_DSCT4_DA_DA_Pos)            /*!< PDMA_T::DSCT4_DA: DA Mask              */

#define PDMA_DSCT4_NEXT_NEXT_Pos         (2)                                               /*!< PDMA_T::DSCT4_NEXT: NEXT Position      */
#define PDMA_DSCT4_NEXT_NEXT_Msk         (0x3ffful << PDMA_DSCT4_NEXT_NEXT_Pos)            /*!< PDMA_T::DSCT4_NEXT: NEXT Mask          */

#define PDMA_DSCT5_CTL_OPMODE_Pos        (0)                                               /*!< PDMA_T::DSCT5_CTL: OPMODE Position     */
#define PDMA_DSCT5_CTL_OPMODE_Msk        (0x3ul << PDMA_DSCT5_CTL_OPMODE_Pos)              /*!< PDMA_T::DSCT5_CTL: OPMODE Mask         */

#define PDMA_DSCT5_CTL_TXTYPE_Pos        (2)                                               /*!< PDMA_T::DSCT5_CTL: TXTYPE Position     */
#define PDMA_DSCT5_CTL_TXTYPE_Msk        (0x1ul << PDMA_DSCT5_CTL_TXTYPE_Pos)              /*!< PDMA_T::DSCT5_CTL: TXTYPE Mask         */

#define PDMA_DSCT5_CTL_BURSIZE_Pos       (4)                                               /*!< PDMA_T::DSCT5_CTL: BURSIZE Position    */
#define PDMA_DSCT5_CTL_BURSIZE_Msk       (0x7ul << PDMA_DSCT5_CTL_BURSIZE_Pos)             /*!< PDMA_T::DSCT5_CTL: BURSIZE Mask        */

#define PDMA_DSCT5_CTL_SAINC_Pos         (8)                                               /*!< PDMA_T::DSCT5_CTL: SAINC Position      */
#define PDMA_DSCT5_CTL_SAINC_Msk         (0x3ul << PDMA_DSCT5_CTL_SAINC_Pos)               /*!< PDMA_T::DSCT5_CTL: SAINC Mask          */

#define PDMA_DSCT5_CTL_DAINC_Pos         (10)                                              /*!< PDMA_T::DSCT5_CTL: DAINC Position      */
#define PDMA_DSCT5_CTL_DAINC_Msk         (0x3ul << PDMA_DSCT5_CTL_DAINC_Pos)               /*!< PDMA_T::DSCT5_CTL: DAINC Mask          */

#define PDMA_DSCT5_CTL_TXWIDTH_Pos       (12)                                              /*!< PDMA_T::DSCT5_CTL: TXWIDTH Position    */
#define PDMA_DSCT5_CTL_TXWIDTH_Msk       (0x3ul << PDMA_DSCT5_CTL_TXWIDTH_Pos)             /*!< PDMA_T::DSCT5_CTL: TXWIDTH Mask        */

#define PDMA_DSCT5_CTL_TXACK_Pos         (14)                                              /*!< PDMA_T::DSCT5_CTL: TXACK Position      */
#define PDMA_DSCT5_CTL_TXACK_Msk         (0x1ul << PDMA_DSCT5_CTL_TXACK_Pos)               /*!< PDMA_T::DSCT5_CTL: TXACK Mask          */

#define PDMA_DSCT5_CTL_STRIDEEN_Pos      (15)                                              /*!< PDMA_T::DSCT5_CTL: STRIDEEN Position   */
#define PDMA_DSCT5_CTL_STRIDEEN_Msk      (0x1ul << PDMA_DSCT5_CTL_STRIDEEN_Pos)            /*!< PDMA_T::DSCT5_CTL: STRIDEEN Mask       */

#define PDMA_DSCT5_CTL_TXCNT_Pos         (16)                                              /*!< PDMA_T::DSCT5_CTL: TXCNT Position      */
#define PDMA_DSCT5_CTL_TXCNT_Msk         (0xfffful << PDMA_DSCT5_CTL_TXCNT_Pos)            /*!< PDMA_T::DSCT5_CTL: TXCNT Mask          */

#define PDMA_DSCT5_SA_SA_Pos             (0)                                               /*!< PDMA_T::DSCT5_SA: SA Position          */
#define PDMA_DSCT5_SA_SA_Msk             (0xfffffffful << PDMA_DSCT5_SA_SA_Pos)            /*!< PDMA_T::DSCT5_SA: SA Mask              */

#define PDMA_DSCT5_DA_DA_Pos             (0)                                               /*!< PDMA_T::DSCT5_DA: DA Position          */
#define PDMA_DSCT5_DA_DA_Msk             (0xfffffffful << PDMA_DSCT5_DA_DA_Pos)            /*!< PDMA_T::DSCT5_DA: DA Mask              */

#define PDMA_DSCT5_NEXT_NEXT_Pos         (2)                                               /*!< PDMA_T::DSCT5_NEXT: NEXT Position      */
#define PDMA_DSCT5_NEXT_NEXT_Msk         (0x3ffful << PDMA_DSCT5_NEXT_NEXT_Pos)            /*!< PDMA_T::DSCT5_NEXT: NEXT Mask          */

#define PDMA_DSCT6_CTL_OPMODE_Pos        (0)                                               /*!< PDMA_T::DSCT6_CTL: OPMODE Position     */
#define PDMA_DSCT6_CTL_OPMODE_Msk        (0x3ul << PDMA_DSCT6_CTL_OPMODE_Pos)              /*!< PDMA_T::DSCT6_CTL: OPMODE Mask         */

#define PDMA_DSCT6_CTL_TXTYPE_Pos        (2)                                               /*!< PDMA_T::DSCT6_CTL: TXTYPE Position     */
#define PDMA_DSCT6_CTL_TXTYPE_Msk        (0x1ul << PDMA_DSCT6_CTL_TXTYPE_Pos)              /*!< PDMA_T::DSCT6_CTL: TXTYPE Mask         */

#define PDMA_DSCT6_CTL_BURSIZE_Pos       (4)                                               /*!< PDMA_T::DSCT6_CTL: BURSIZE Position    */
#define PDMA_DSCT6_CTL_BURSIZE_Msk       (0x7ul << PDMA_DSCT6_CTL_BURSIZE_Pos)             /*!< PDMA_T::DSCT6_CTL: BURSIZE Mask        */

#define PDMA_DSCT6_CTL_SAINC_Pos         (8)                                               /*!< PDMA_T::DSCT6_CTL: SAINC Position      */
#define PDMA_DSCT6_CTL_SAINC_Msk         (0x3ul << PDMA_DSCT6_CTL_SAINC_Pos)               /*!< PDMA_T::DSCT6_CTL: SAINC Mask          */

#define PDMA_DSCT6_CTL_DAINC_Pos         (10)                                              /*!< PDMA_T::DSCT6_CTL: DAINC Position      */
#define PDMA_DSCT6_CTL_DAINC_Msk         (0x3ul << PDMA_DSCT6_CTL_DAINC_Pos)               /*!< PDMA_T::DSCT6_CTL: DAINC Mask          */

#define PDMA_DSCT6_CTL_TXWIDTH_Pos       (12)                                              /*!< PDMA_T::DSCT6_CTL: TXWIDTH Position    */
#define PDMA_DSCT6_CTL_TXWIDTH_Msk       (0x3ul << PDMA_DSCT6_CTL_TXWIDTH_Pos)             /*!< PDMA_T::DSCT6_CTL: TXWIDTH Mask        */

#define PDMA_DSCT6_CTL_TXACK_Pos         (14)                                              /*!< PDMA_T::DSCT6_CTL: TXACK Position      */
#define PDMA_DSCT6_CTL_TXACK_Msk         (0x1ul << PDMA_DSCT6_CTL_TXACK_Pos)               /*!< PDMA_T::DSCT6_CTL: TXACK Mask          */

#define PDMA_DSCT6_CTL_STRIDEEN_Pos      (15)                                              /*!< PDMA_T::DSCT6_CTL: STRIDEEN Position   */
#define PDMA_DSCT6_CTL_STRIDEEN_Msk      (0x1ul << PDMA_DSCT6_CTL_STRIDEEN_Pos)            /*!< PDMA_T::DSCT6_CTL: STRIDEEN Mask       */

#define PDMA_DSCT6_CTL_TXCNT_Pos         (16)                                              /*!< PDMA_T::DSCT6_CTL: TXCNT Position      */
#define PDMA_DSCT6_CTL_TXCNT_Msk         (0xfffful << PDMA_DSCT6_CTL_TXCNT_Pos)            /*!< PDMA_T::DSCT6_CTL: TXCNT Mask          */

#define PDMA_DSCT6_SA_SA_Pos             (0)                                               /*!< PDMA_T::DSCT6_SA: SA Position          */
#define PDMA_DSCT6_SA_SA_Msk             (0xfffffffful << PDMA_DSCT6_SA_SA_Pos)            /*!< PDMA_T::DSCT6_SA: SA Mask              */

#define PDMA_DSCT6_DA_DA_Pos             (0)                                               /*!< PDMA_T::DSCT6_DA: DA Position          */
#define PDMA_DSCT6_DA_DA_Msk             (0xfffffffful << PDMA_DSCT6_DA_DA_Pos)            /*!< PDMA_T::DSCT6_DA: DA Mask              */

#define PDMA_DSCT6_NEXT_NEXT_Pos         (2)                                               /*!< PDMA_T::DSCT6_NEXT: NEXT Position      */
#define PDMA_DSCT6_NEXT_NEXT_Msk         (0x3ffful << PDMA_DSCT6_NEXT_NEXT_Pos)            /*!< PDMA_T::DSCT6_NEXT: NEXT Mask          */

#define PDMA_DSCT7_CTL_OPMODE_Pos        (0)                                               /*!< PDMA_T::DSCT7_CTL: OPMODE Position     */
#define PDMA_DSCT7_CTL_OPMODE_Msk        (0x3ul << PDMA_DSCT7_CTL_OPMODE_Pos)              /*!< PDMA_T::DSCT7_CTL: OPMODE Mask         */

#define PDMA_DSCT7_CTL_TXTYPE_Pos        (2)                                               /*!< PDMA_T::DSCT7_CTL: TXTYPE Position     */
#define PDMA_DSCT7_CTL_TXTYPE_Msk        (0x1ul << PDMA_DSCT7_CTL_TXTYPE_Pos)              /*!< PDMA_T::DSCT7_CTL: TXTYPE Mask         */

#define PDMA_DSCT7_CTL_BURSIZE_Pos       (4)                                               /*!< PDMA_T::DSCT7_CTL: BURSIZE Position    */
#define PDMA_DSCT7_CTL_BURSIZE_Msk       (0x7ul << PDMA_DSCT7_CTL_BURSIZE_Pos)             /*!< PDMA_T::DSCT7_CTL: BURSIZE Mask        */

#define PDMA_DSCT7_CTL_SAINC_Pos         (8)                                               /*!< PDMA_T::DSCT7_CTL: SAINC Position      */
#define PDMA_DSCT7_CTL_SAINC_Msk         (0x3ul << PDMA_DSCT7_CTL_SAINC_Pos)               /*!< PDMA_T::DSCT7_CTL: SAINC Mask          */

#define PDMA_DSCT7_CTL_DAINC_Pos         (10)                                              /*!< PDMA_T::DSCT7_CTL: DAINC Position      */
#define PDMA_DSCT7_CTL_DAINC_Msk         (0x3ul << PDMA_DSCT7_CTL_DAINC_Pos)               /*!< PDMA_T::DSCT7_CTL: DAINC Mask          */

#define PDMA_DSCT7_CTL_TXWIDTH_Pos       (12)                                              /*!< PDMA_T::DSCT7_CTL: TXWIDTH Position    */
#define PDMA_DSCT7_CTL_TXWIDTH_Msk       (0x3ul << PDMA_DSCT7_CTL_TXWIDTH_Pos)             /*!< PDMA_T::DSCT7_CTL: TXWIDTH Mask        */

#define PDMA_DSCT7_CTL_TXACK_Pos         (14)                                              /*!< PDMA_T::DSCT7_CTL: TXACK Position      */
#define PDMA_DSCT7_CTL_TXACK_Msk         (0x1ul << PDMA_DSCT7_CTL_TXACK_Pos)               /*!< PDMA_T::DSCT7_CTL: TXACK Mask          */

#define PDMA_DSCT7_CTL_STRIDEEN_Pos      (15)                                              /*!< PDMA_T::DSCT7_CTL: STRIDEEN Position   */
#define PDMA_DSCT7_CTL_STRIDEEN_Msk      (0x1ul << PDMA_DSCT7_CTL_STRIDEEN_Pos)            /*!< PDMA_T::DSCT7_CTL: STRIDEEN Mask       */

#define PDMA_DSCT7_CTL_TXCNT_Pos         (16)                                              /*!< PDMA_T::DSCT7_CTL: TXCNT Position      */
#define PDMA_DSCT7_CTL_TXCNT_Msk         (0xfffful << PDMA_DSCT7_CTL_TXCNT_Pos)            /*!< PDMA_T::DSCT7_CTL: TXCNT Mask          */

#define PDMA_DSCT7_SA_SA_Pos             (0)                                               /*!< PDMA_T::DSCT7_SA: SA Position          */
#define PDMA_DSCT7_SA_SA_Msk             (0xfffffffful << PDMA_DSCT7_SA_SA_Pos)            /*!< PDMA_T::DSCT7_SA: SA Mask              */

#define PDMA_DSCT7_DA_DA_Pos             (0)                                               /*!< PDMA_T::DSCT7_DA: DA Position          */
#define PDMA_DSCT7_DA_DA_Msk             (0xfffffffful << PDMA_DSCT7_DA_DA_Pos)            /*!< PDMA_T::DSCT7_DA: DA Mask              */

#define PDMA_DSCT7_NEXT_NEXT_Pos         (2)                                               /*!< PDMA_T::DSCT7_NEXT: NEXT Position      */
#define PDMA_DSCT7_NEXT_NEXT_Msk         (0x3ffful << PDMA_DSCT7_NEXT_NEXT_Pos)            /*!< PDMA_T::DSCT7_NEXT: NEXT Mask          */

#define PDMA_DSCT8_CTL_OPMODE_Pos        (0)                                               /*!< PDMA_T::DSCT8_CTL: OPMODE Position     */
#define PDMA_DSCT8_CTL_OPMODE_Msk        (0x3ul << PDMA_DSCT8_CTL_OPMODE_Pos)              /*!< PDMA_T::DSCT8_CTL: OPMODE Mask         */

#define PDMA_DSCT8_CTL_TXTYPE_Pos        (2)                                               /*!< PDMA_T::DSCT8_CTL: TXTYPE Position     */
#define PDMA_DSCT8_CTL_TXTYPE_Msk        (0x1ul << PDMA_DSCT8_CTL_TXTYPE_Pos)              /*!< PDMA_T::DSCT8_CTL: TXTYPE Mask         */

#define PDMA_DSCT8_CTL_BURSIZE_Pos       (4)                                               /*!< PDMA_T::DSCT8_CTL: BURSIZE Position    */
#define PDMA_DSCT8_CTL_BURSIZE_Msk       (0x7ul << PDMA_DSCT8_CTL_BURSIZE_Pos)             /*!< PDMA_T::DSCT8_CTL: BURSIZE Mask        */

#define PDMA_DSCT8_CTL_SAINC_Pos         (8)                                               /*!< PDMA_T::DSCT8_CTL: SAINC Position      */
#define PDMA_DSCT8_CTL_SAINC_Msk         (0x3ul << PDMA_DSCT8_CTL_SAINC_Pos)               /*!< PDMA_T::DSCT8_CTL: SAINC Mask          */

#define PDMA_DSCT8_CTL_DAINC_Pos         (10)                                              /*!< PDMA_T::DSCT8_CTL: DAINC Position      */
#define PDMA_DSCT8_CTL_DAINC_Msk         (0x3ul << PDMA_DSCT8_CTL_DAINC_Pos)               /*!< PDMA_T::DSCT8_CTL: DAINC Mask          */

#define PDMA_DSCT8_CTL_TXWIDTH_Pos       (12)                                              /*!< PDMA_T::DSCT8_CTL: TXWIDTH Position    */
#define PDMA_DSCT8_CTL_TXWIDTH_Msk       (0x3ul << PDMA_DSCT8_CTL_TXWIDTH_Pos)             /*!< PDMA_T::DSCT8_CTL: TXWIDTH Mask        */

#define PDMA_DSCT8_CTL_TXACK_Pos         (14)                                              /*!< PDMA_T::DSCT8_CTL: TXACK Position      */
#define PDMA_DSCT8_CTL_TXACK_Msk         (0x1ul << PDMA_DSCT8_CTL_TXACK_Pos)               /*!< PDMA_T::DSCT8_CTL: TXACK Mask          */

#define PDMA_DSCT8_CTL_STRIDEEN_Pos      (15)                                              /*!< PDMA_T::DSCT8_CTL: STRIDEEN Position   */
#define PDMA_DSCT8_CTL_STRIDEEN_Msk      (0x1ul << PDMA_DSCT8_CTL_STRIDEEN_Pos)            /*!< PDMA_T::DSCT8_CTL: STRIDEEN Mask       */

#define PDMA_DSCT8_CTL_TXCNT_Pos         (16)                                              /*!< PDMA_T::DSCT8_CTL: TXCNT Position      */
#define PDMA_DSCT8_CTL_TXCNT_Msk         (0xfffful << PDMA_DSCT8_CTL_TXCNT_Pos)            /*!< PDMA_T::DSCT8_CTL: TXCNT Mask          */

#define PDMA_DSCT8_SA_SA_Pos             (0)                                               /*!< PDMA_T::DSCT8_SA: SA Position          */
#define PDMA_DSCT8_SA_SA_Msk             (0xfffffffful << PDMA_DSCT8_SA_SA_Pos)            /*!< PDMA_T::DSCT8_SA: SA Mask              */

#define PDMA_DSCT8_DA_DA_Pos             (0)                                               /*!< PDMA_T::DSCT8_DA: DA Position          */
#define PDMA_DSCT8_DA_DA_Msk             (0xfffffffful << PDMA_DSCT8_DA_DA_Pos)            /*!< PDMA_T::DSCT8_DA: DA Mask              */

#define PDMA_DSCT8_NEXT_NEXT_Pos         (2)                                               /*!< PDMA_T::DSCT8_NEXT: NEXT Position      */
#define PDMA_DSCT8_NEXT_NEXT_Msk         (0x3ffful << PDMA_DSCT8_NEXT_NEXT_Pos)            /*!< PDMA_T::DSCT8_NEXT: NEXT Mask          */

#define PDMA_DSCT9_CTL_OPMODE_Pos        (0)                                               /*!< PDMA_T::DSCT9_CTL: OPMODE Position     */
#define PDMA_DSCT9_CTL_OPMODE_Msk        (0x3ul << PDMA_DSCT9_CTL_OPMODE_Pos)              /*!< PDMA_T::DSCT9_CTL: OPMODE Mask         */

#define PDMA_DSCT9_CTL_TXTYPE_Pos        (2)                                               /*!< PDMA_T::DSCT9_CTL: TXTYPE Position     */
#define PDMA_DSCT9_CTL_TXTYPE_Msk        (0x1ul << PDMA_DSCT9_CTL_TXTYPE_Pos)              /*!< PDMA_T::DSCT9_CTL: TXTYPE Mask         */

#define PDMA_DSCT9_CTL_BURSIZE_Pos       (4)                                               /*!< PDMA_T::DSCT9_CTL: BURSIZE Position    */
#define PDMA_DSCT9_CTL_BURSIZE_Msk       (0x7ul << PDMA_DSCT9_CTL_BURSIZE_Pos)             /*!< PDMA_T::DSCT9_CTL: BURSIZE Mask        */

#define PDMA_DSCT9_CTL_SAINC_Pos         (8)                                               /*!< PDMA_T::DSCT9_CTL: SAINC Position      */
#define PDMA_DSCT9_CTL_SAINC_Msk         (0x3ul << PDMA_DSCT9_CTL_SAINC_Pos)               /*!< PDMA_T::DSCT9_CTL: SAINC Mask          */

#define PDMA_DSCT9_CTL_DAINC_Pos         (10)                                              /*!< PDMA_T::DSCT9_CTL: DAINC Position      */
#define PDMA_DSCT9_CTL_DAINC_Msk         (0x3ul << PDMA_DSCT9_CTL_DAINC_Pos)               /*!< PDMA_T::DSCT9_CTL: DAINC Mask          */

#define PDMA_DSCT9_CTL_TXWIDTH_Pos       (12)                                              /*!< PDMA_T::DSCT9_CTL: TXWIDTH Position    */
#define PDMA_DSCT9_CTL_TXWIDTH_Msk       (0x3ul << PDMA_DSCT9_CTL_TXWIDTH_Pos)             /*!< PDMA_T::DSCT9_CTL: TXWIDTH Mask        */

#define PDMA_DSCT9_CTL_TXACK_Pos         (14)                                              /*!< PDMA_T::DSCT9_CTL: TXACK Position      */
#define PDMA_DSCT9_CTL_TXACK_Msk         (0x1ul << PDMA_DSCT9_CTL_TXACK_Pos)               /*!< PDMA_T::DSCT9_CTL: TXACK Mask          */

#define PDMA_DSCT9_CTL_STRIDEEN_Pos      (15)                                              /*!< PDMA_T::DSCT9_CTL: STRIDEEN Position   */
#define PDMA_DSCT9_CTL_STRIDEEN_Msk      (0x1ul << PDMA_DSCT9_CTL_STRIDEEN_Pos)            /*!< PDMA_T::DSCT9_CTL: STRIDEEN Mask       */

#define PDMA_DSCT9_CTL_TXCNT_Pos         (16)                                              /*!< PDMA_T::DSCT9_CTL: TXCNT Position      */
#define PDMA_DSCT9_CTL_TXCNT_Msk         (0xfffful << PDMA_DSCT9_CTL_TXCNT_Pos)            /*!< PDMA_T::DSCT9_CTL: TXCNT Mask          */

#define PDMA_DSCT9_SA_SA_Pos             (0)                                               /*!< PDMA_T::DSCT9_SA: SA Position          */
#define PDMA_DSCT9_SA_SA_Msk             (0xfffffffful << PDMA_DSCT9_SA_SA_Pos)            /*!< PDMA_T::DSCT9_SA: SA Mask              */

#define PDMA_DSCT9_DA_DA_Pos             (0)                                               /*!< PDMA_T::DSCT9_DA: DA Position          */
#define PDMA_DSCT9_DA_DA_Msk             (0xfffffffful << PDMA_DSCT9_DA_DA_Pos)            /*!< PDMA_T::DSCT9_DA: DA Mask              */

#define PDMA_DSCT9_NEXT_NEXT_Pos         (2)                                               /*!< PDMA_T::DSCT9_NEXT: NEXT Position      */
#define PDMA_DSCT9_NEXT_NEXT_Msk         (0x3ffful << PDMA_DSCT9_NEXT_NEXT_Pos)            /*!< PDMA_T::DSCT9_NEXT: NEXT Mask          */

#define PDMA_DSCT10_CTL_OPMODE_Pos       (0)                                               /*!< PDMA_T::DSCT10_CTL: OPMODE Position    */
#define PDMA_DSCT10_CTL_OPMODE_Msk       (0x3ul << PDMA_DSCT10_CTL_OPMODE_Pos)             /*!< PDMA_T::DSCT10_CTL: OPMODE Mask        */

#define PDMA_DSCT10_CTL_TXTYPE_Pos       (2)                                               /*!< PDMA_T::DSCT10_CTL: TXTYPE Position    */
#define PDMA_DSCT10_CTL_TXTYPE_Msk       (0x1ul << PDMA_DSCT10_CTL_TXTYPE_Pos)             /*!< PDMA_T::DSCT10_CTL: TXTYPE Mask        */

#define PDMA_DSCT10_CTL_BURSIZE_Pos      (4)                                               /*!< PDMA_T::DSCT10_CTL: BURSIZE Position   */
#define PDMA_DSCT10_CTL_BURSIZE_Msk      (0x7ul << PDMA_DSCT10_CTL_BURSIZE_Pos)            /*!< PDMA_T::DSCT10_CTL: BURSIZE Mask       */

#define PDMA_DSCT10_CTL_SAINC_Pos        (8)                                               /*!< PDMA_T::DSCT10_CTL: SAINC Position     */
#define PDMA_DSCT10_CTL_SAINC_Msk        (0x3ul << PDMA_DSCT10_CTL_SAINC_Pos)              /*!< PDMA_T::DSCT10_CTL: SAINC Mask         */

#define PDMA_DSCT10_CTL_DAINC_Pos        (10)                                              /*!< PDMA_T::DSCT10_CTL: DAINC Position     */
#define PDMA_DSCT10_CTL_DAINC_Msk        (0x3ul << PDMA_DSCT10_CTL_DAINC_Pos)              /*!< PDMA_T::DSCT10_CTL: DAINC Mask         */

#define PDMA_DSCT10_CTL_TXWIDTH_Pos      (12)                                              /*!< PDMA_T::DSCT10_CTL: TXWIDTH Position   */
#define PDMA_DSCT10_CTL_TXWIDTH_Msk      (0x3ul << PDMA_DSCT10_CTL_TXWIDTH_Pos)            /*!< PDMA_T::DSCT10_CTL: TXWIDTH Mask       */

#define PDMA_DSCT10_CTL_TXACK_Pos        (14)                                              /*!< PDMA_T::DSCT10_CTL: TXACK Position     */
#define PDMA_DSCT10_CTL_TXACK_Msk        (0x1ul << PDMA_DSCT10_CTL_TXACK_Pos)              /*!< PDMA_T::DSCT10_CTL: TXACK Mask         */

#define PDMA_DSCT10_CTL_STRIDEEN_Pos     (15)                                              /*!< PDMA_T::DSCT10_CTL: STRIDEEN Position  */
#define PDMA_DSCT10_CTL_STRIDEEN_Msk     (0x1ul << PDMA_DSCT10_CTL_STRIDEEN_Pos)           /*!< PDMA_T::DSCT10_CTL: STRIDEEN Mask      */

#define PDMA_DSCT10_CTL_TXCNT_Pos        (16)                                              /*!< PDMA_T::DSCT10_CTL: TXCNT Position     */
#define PDMA_DSCT10_CTL_TXCNT_Msk        (0xfffful << PDMA_DSCT10_CTL_TXCNT_Pos)           /*!< PDMA_T::DSCT10_CTL: TXCNT Mask         */

#define PDMA_DSCT10_SA_SA_Pos            (0)                                               /*!< PDMA_T::DSCT10_SA: SA Position         */
#define PDMA_DSCT10_SA_SA_Msk            (0xfffffffful << PDMA_DSCT10_SA_SA_Pos)           /*!< PDMA_T::DSCT10_SA: SA Mask             */

#define PDMA_DSCT10_DA_DA_Pos            (0)                                               /*!< PDMA_T::DSCT10_DA: DA Position         */
#define PDMA_DSCT10_DA_DA_Msk            (0xfffffffful << PDMA_DSCT10_DA_DA_Pos)           /*!< PDMA_T::DSCT10_DA: DA Mask             */

#define PDMA_DSCT10_NEXT_NEXT_Pos        (2)                                               /*!< PDMA_T::DSCT10_NEXT: NEXT Position     */
#define PDMA_DSCT10_NEXT_NEXT_Msk        (0x3ffful << PDMA_DSCT10_NEXT_NEXT_Pos)           /*!< PDMA_T::DSCT10_NEXT: NEXT Mask         */

#define PDMA_DSCT11_CTL_OPMODE_Pos       (0)                                               /*!< PDMA_T::DSCT11_CTL: OPMODE Position    */
#define PDMA_DSCT11_CTL_OPMODE_Msk       (0x3ul << PDMA_DSCT11_CTL_OPMODE_Pos)             /*!< PDMA_T::DSCT11_CTL: OPMODE Mask        */

#define PDMA_DSCT11_CTL_TXTYPE_Pos       (2)                                               /*!< PDMA_T::DSCT11_CTL: TXTYPE Position    */
#define PDMA_DSCT11_CTL_TXTYPE_Msk       (0x1ul << PDMA_DSCT11_CTL_TXTYPE_Pos)             /*!< PDMA_T::DSCT11_CTL: TXTYPE Mask        */

#define PDMA_DSCT11_CTL_BURSIZE_Pos      (4)                                               /*!< PDMA_T::DSCT11_CTL: BURSIZE Position   */
#define PDMA_DSCT11_CTL_BURSIZE_Msk      (0x7ul << PDMA_DSCT11_CTL_BURSIZE_Pos)            /*!< PDMA_T::DSCT11_CTL: BURSIZE Mask       */

#define PDMA_DSCT11_CTL_SAINC_Pos        (8)                                               /*!< PDMA_T::DSCT11_CTL: SAINC Position     */
#define PDMA_DSCT11_CTL_SAINC_Msk        (0x3ul << PDMA_DSCT11_CTL_SAINC_Pos)              /*!< PDMA_T::DSCT11_CTL: SAINC Mask         */

#define PDMA_DSCT11_CTL_DAINC_Pos        (10)                                              /*!< PDMA_T::DSCT11_CTL: DAINC Position     */
#define PDMA_DSCT11_CTL_DAINC_Msk        (0x3ul << PDMA_DSCT11_CTL_DAINC_Pos)              /*!< PDMA_T::DSCT11_CTL: DAINC Mask         */

#define PDMA_DSCT11_CTL_TXWIDTH_Pos      (12)                                              /*!< PDMA_T::DSCT11_CTL: TXWIDTH Position   */
#define PDMA_DSCT11_CTL_TXWIDTH_Msk      (0x3ul << PDMA_DSCT11_CTL_TXWIDTH_Pos)            /*!< PDMA_T::DSCT11_CTL: TXWIDTH Mask       */

#define PDMA_DSCT11_CTL_TXACK_Pos        (14)                                              /*!< PDMA_T::DSCT11_CTL: TXACK Position     */
#define PDMA_DSCT11_CTL_TXACK_Msk        (0x1ul << PDMA_DSCT11_CTL_TXACK_Pos)              /*!< PDMA_T::DSCT11_CTL: TXACK Mask         */

#define PDMA_DSCT11_CTL_STRIDEEN_Pos     (15)                                              /*!< PDMA_T::DSCT11_CTL: STRIDEEN Position  */
#define PDMA_DSCT11_CTL_STRIDEEN_Msk     (0x1ul << PDMA_DSCT11_CTL_STRIDEEN_Pos)           /*!< PDMA_T::DSCT11_CTL: STRIDEEN Mask      */

#define PDMA_DSCT11_CTL_TXCNT_Pos        (16)                                              /*!< PDMA_T::DSCT11_CTL: TXCNT Position     */
#define PDMA_DSCT11_CTL_TXCNT_Msk        (0xfffful << PDMA_DSCT11_CTL_TXCNT_Pos)           /*!< PDMA_T::DSCT11_CTL: TXCNT Mask         */

#define PDMA_DSCT11_SA_SA_Pos            (0)                                               /*!< PDMA_T::DSCT11_SA: SA Position         */
#define PDMA_DSCT11_SA_SA_Msk            (0xfffffffful << PDMA_DSCT11_SA_SA_Pos)           /*!< PDMA_T::DSCT11_SA: SA Mask             */

#define PDMA_DSCT11_DA_DA_Pos            (0)                                               /*!< PDMA_T::DSCT11_DA: DA Position         */
#define PDMA_DSCT11_DA_DA_Msk            (0xfffffffful << PDMA_DSCT11_DA_DA_Pos)           /*!< PDMA_T::DSCT11_DA: DA Mask             */

#define PDMA_DSCT11_NEXT_NEXT_Pos        (2)                                               /*!< PDMA_T::DSCT11_NEXT: NEXT Position     */
#define PDMA_DSCT11_NEXT_NEXT_Msk        (0x3ffful << PDMA_DSCT11_NEXT_NEXT_Pos)           /*!< PDMA_T::DSCT11_NEXT: NEXT Mask         */

#define PDMA_DSCT12_CTL_OPMODE_Pos       (0)                                               /*!< PDMA_T::DSCT12_CTL: OPMODE Position    */
#define PDMA_DSCT12_CTL_OPMODE_Msk       (0x3ul << PDMA_DSCT12_CTL_OPMODE_Pos)             /*!< PDMA_T::DSCT12_CTL: OPMODE Mask        */

#define PDMA_DSCT12_CTL_TXTYPE_Pos       (2)                                               /*!< PDMA_T::DSCT12_CTL: TXTYPE Position    */
#define PDMA_DSCT12_CTL_TXTYPE_Msk       (0x1ul << PDMA_DSCT12_CTL_TXTYPE_Pos)             /*!< PDMA_T::DSCT12_CTL: TXTYPE Mask        */

#define PDMA_DSCT12_CTL_BURSIZE_Pos      (4)                                               /*!< PDMA_T::DSCT12_CTL: BURSIZE Position   */
#define PDMA_DSCT12_CTL_BURSIZE_Msk      (0x7ul << PDMA_DSCT12_CTL_BURSIZE_Pos)            /*!< PDMA_T::DSCT12_CTL: BURSIZE Mask       */

#define PDMA_DSCT12_CTL_SAINC_Pos        (8)                                               /*!< PDMA_T::DSCT12_CTL: SAINC Position     */
#define PDMA_DSCT12_CTL_SAINC_Msk        (0x3ul << PDMA_DSCT12_CTL_SAINC_Pos)              /*!< PDMA_T::DSCT12_CTL: SAINC Mask         */

#define PDMA_DSCT12_CTL_DAINC_Pos        (10)                                              /*!< PDMA_T::DSCT12_CTL: DAINC Position     */
#define PDMA_DSCT12_CTL_DAINC_Msk        (0x3ul << PDMA_DSCT12_CTL_DAINC_Pos)              /*!< PDMA_T::DSCT12_CTL: DAINC Mask         */

#define PDMA_DSCT12_CTL_TXWIDTH_Pos      (12)                                              /*!< PDMA_T::DSCT12_CTL: TXWIDTH Position   */
#define PDMA_DSCT12_CTL_TXWIDTH_Msk      (0x3ul << PDMA_DSCT12_CTL_TXWIDTH_Pos)            /*!< PDMA_T::DSCT12_CTL: TXWIDTH Mask       */

#define PDMA_DSCT12_CTL_TXACK_Pos        (14)                                              /*!< PDMA_T::DSCT12_CTL: TXACK Position     */
#define PDMA_DSCT12_CTL_TXACK_Msk        (0x1ul << PDMA_DSCT12_CTL_TXACK_Pos)              /*!< PDMA_T::DSCT12_CTL: TXACK Mask         */

#define PDMA_DSCT12_CTL_STRIDEEN_Pos     (15)                                              /*!< PDMA_T::DSCT12_CTL: STRIDEEN Position  */
#define PDMA_DSCT12_CTL_STRIDEEN_Msk     (0x1ul << PDMA_DSCT12_CTL_STRIDEEN_Pos)           /*!< PDMA_T::DSCT12_CTL: STRIDEEN Mask      */

#define PDMA_DSCT12_CTL_TXCNT_Pos        (16)                                              /*!< PDMA_T::DSCT12_CTL: TXCNT Position     */
#define PDMA_DSCT12_CTL_TXCNT_Msk        (0xfffful << PDMA_DSCT12_CTL_TXCNT_Pos)           /*!< PDMA_T::DSCT12_CTL: TXCNT Mask         */

#define PDMA_DSCT12_SA_SA_Pos            (0)                                               /*!< PDMA_T::DSCT12_SA: SA Position         */
#define PDMA_DSCT12_SA_SA_Msk            (0xfffffffful << PDMA_DSCT12_SA_SA_Pos)           /*!< PDMA_T::DSCT12_SA: SA Mask             */

#define PDMA_DSCT12_DA_DA_Pos            (0)                                               /*!< PDMA_T::DSCT12_DA: DA Position         */
#define PDMA_DSCT12_DA_DA_Msk            (0xfffffffful << PDMA_DSCT12_DA_DA_Pos)           /*!< PDMA_T::DSCT12_DA: DA Mask             */

#define PDMA_DSCT12_NEXT_NEXT_Pos        (2)                                               /*!< PDMA_T::DSCT12_NEXT: NEXT Position     */
#define PDMA_DSCT12_NEXT_NEXT_Msk        (0x3ffful << PDMA_DSCT12_NEXT_NEXT_Pos)           /*!< PDMA_T::DSCT12_NEXT: NEXT Mask         */

#define PDMA_DSCT13_CTL_OPMODE_Pos       (0)                                               /*!< PDMA_T::DSCT13_CTL: OPMODE Position    */
#define PDMA_DSCT13_CTL_OPMODE_Msk       (0x3ul << PDMA_DSCT13_CTL_OPMODE_Pos)             /*!< PDMA_T::DSCT13_CTL: OPMODE Mask        */

#define PDMA_DSCT13_CTL_TXTYPE_Pos       (2)                                               /*!< PDMA_T::DSCT13_CTL: TXTYPE Position    */
#define PDMA_DSCT13_CTL_TXTYPE_Msk       (0x1ul << PDMA_DSCT13_CTL_TXTYPE_Pos)             /*!< PDMA_T::DSCT13_CTL: TXTYPE Mask        */

#define PDMA_DSCT13_CTL_BURSIZE_Pos      (4)                                               /*!< PDMA_T::DSCT13_CTL: BURSIZE Position   */
#define PDMA_DSCT13_CTL_BURSIZE_Msk      (0x7ul << PDMA_DSCT13_CTL_BURSIZE_Pos)            /*!< PDMA_T::DSCT13_CTL: BURSIZE Mask       */

#define PDMA_DSCT13_CTL_SAINC_Pos        (8)                                               /*!< PDMA_T::DSCT13_CTL: SAINC Position     */
#define PDMA_DSCT13_CTL_SAINC_Msk        (0x3ul << PDMA_DSCT13_CTL_SAINC_Pos)              /*!< PDMA_T::DSCT13_CTL: SAINC Mask         */

#define PDMA_DSCT13_CTL_DAINC_Pos        (10)                                              /*!< PDMA_T::DSCT13_CTL: DAINC Position     */
#define PDMA_DSCT13_CTL_DAINC_Msk        (0x3ul << PDMA_DSCT13_CTL_DAINC_Pos)              /*!< PDMA_T::DSCT13_CTL: DAINC Mask         */

#define PDMA_DSCT13_CTL_TXWIDTH_Pos      (12)                                              /*!< PDMA_T::DSCT13_CTL: TXWIDTH Position   */
#define PDMA_DSCT13_CTL_TXWIDTH_Msk      (0x3ul << PDMA_DSCT13_CTL_TXWIDTH_Pos)            /*!< PDMA_T::DSCT13_CTL: TXWIDTH Mask       */

#define PDMA_DSCT13_CTL_TXACK_Pos        (14)                                              /*!< PDMA_T::DSCT13_CTL: TXACK Position     */
#define PDMA_DSCT13_CTL_TXACK_Msk        (0x1ul << PDMA_DSCT13_CTL_TXACK_Pos)              /*!< PDMA_T::DSCT13_CTL: TXACK Mask         */

#define PDMA_DSCT13_CTL_STRIDEEN_Pos     (15)                                              /*!< PDMA_T::DSCT13_CTL: STRIDEEN Position  */
#define PDMA_DSCT13_CTL_STRIDEEN_Msk     (0x1ul << PDMA_DSCT13_CTL_STRIDEEN_Pos)           /*!< PDMA_T::DSCT13_CTL: STRIDEEN Mask      */

#define PDMA_DSCT13_CTL_TXCNT_Pos        (16)                                              /*!< PDMA_T::DSCT13_CTL: TXCNT Position     */
#define PDMA_DSCT13_CTL_TXCNT_Msk        (0xfffful << PDMA_DSCT13_CTL_TXCNT_Pos)           /*!< PDMA_T::DSCT13_CTL: TXCNT Mask         */

#define PDMA_DSCT13_SA_SA_Pos            (0)                                               /*!< PDMA_T::DSCT13_SA: SA Position         */
#define PDMA_DSCT13_SA_SA_Msk            (0xfffffffful << PDMA_DSCT13_SA_SA_Pos)           /*!< PDMA_T::DSCT13_SA: SA Mask             */

#define PDMA_DSCT13_DA_DA_Pos            (0)                                               /*!< PDMA_T::DSCT13_DA: DA Position         */
#define PDMA_DSCT13_DA_DA_Msk            (0xfffffffful << PDMA_DSCT13_DA_DA_Pos)           /*!< PDMA_T::DSCT13_DA: DA Mask             */

#define PDMA_DSCT13_NEXT_NEXT_Pos        (2)                                               /*!< PDMA_T::DSCT13_NEXT: NEXT Position     */
#define PDMA_DSCT13_NEXT_NEXT_Msk        (0x3ffful << PDMA_DSCT13_NEXT_NEXT_Pos)           /*!< PDMA_T::DSCT13_NEXT: NEXT Mask         */

#define PDMA_DSCT14_CTL_OPMODE_Pos       (0)                                               /*!< PDMA_T::DSCT14_CTL: OPMODE Position    */
#define PDMA_DSCT14_CTL_OPMODE_Msk       (0x3ul << PDMA_DSCT14_CTL_OPMODE_Pos)             /*!< PDMA_T::DSCT14_CTL: OPMODE Mask        */

#define PDMA_DSCT14_CTL_TXTYPE_Pos       (2)                                               /*!< PDMA_T::DSCT14_CTL: TXTYPE Position    */
#define PDMA_DSCT14_CTL_TXTYPE_Msk       (0x1ul << PDMA_DSCT14_CTL_TXTYPE_Pos)             /*!< PDMA_T::DSCT14_CTL: TXTYPE Mask        */

#define PDMA_DSCT14_CTL_BURSIZE_Pos      (4)                                               /*!< PDMA_T::DSCT14_CTL: BURSIZE Position   */
#define PDMA_DSCT14_CTL_BURSIZE_Msk      (0x7ul << PDMA_DSCT14_CTL_BURSIZE_Pos)            /*!< PDMA_T::DSCT14_CTL: BURSIZE Mask       */

#define PDMA_DSCT14_CTL_SAINC_Pos        (8)                                               /*!< PDMA_T::DSCT14_CTL: SAINC Position     */
#define PDMA_DSCT14_CTL_SAINC_Msk        (0x3ul << PDMA_DSCT14_CTL_SAINC_Pos)              /*!< PDMA_T::DSCT14_CTL: SAINC Mask         */

#define PDMA_DSCT14_CTL_DAINC_Pos        (10)                                              /*!< PDMA_T::DSCT14_CTL: DAINC Position     */
#define PDMA_DSCT14_CTL_DAINC_Msk        (0x3ul << PDMA_DSCT14_CTL_DAINC_Pos)              /*!< PDMA_T::DSCT14_CTL: DAINC Mask         */

#define PDMA_DSCT14_CTL_TXWIDTH_Pos      (12)                                              /*!< PDMA_T::DSCT14_CTL: TXWIDTH Position   */
#define PDMA_DSCT14_CTL_TXWIDTH_Msk      (0x3ul << PDMA_DSCT14_CTL_TXWIDTH_Pos)            /*!< PDMA_T::DSCT14_CTL: TXWIDTH Mask       */

#define PDMA_DSCT14_CTL_TXACK_Pos        (14)                                              /*!< PDMA_T::DSCT14_CTL: TXACK Position     */
#define PDMA_DSCT14_CTL_TXACK_Msk        (0x1ul << PDMA_DSCT14_CTL_TXACK_Pos)              /*!< PDMA_T::DSCT14_CTL: TXACK Mask         */

#define PDMA_DSCT14_CTL_STRIDEEN_Pos     (15)                                              /*!< PDMA_T::DSCT14_CTL: STRIDEEN Position  */
#define PDMA_DSCT14_CTL_STRIDEEN_Msk     (0x1ul << PDMA_DSCT14_CTL_STRIDEEN_Pos)           /*!< PDMA_T::DSCT14_CTL: STRIDEEN Mask      */

#define PDMA_DSCT14_CTL_TXCNT_Pos        (16)                                              /*!< PDMA_T::DSCT14_CTL: TXCNT Position     */
#define PDMA_DSCT14_CTL_TXCNT_Msk        (0xfffful << PDMA_DSCT14_CTL_TXCNT_Pos)           /*!< PDMA_T::DSCT14_CTL: TXCNT Mask         */

#define PDMA_DSCT14_SA_SA_Pos            (0)                                               /*!< PDMA_T::DSCT14_SA: SA Position         */
#define PDMA_DSCT14_SA_SA_Msk            (0xfffffffful << PDMA_DSCT14_SA_SA_Pos)           /*!< PDMA_T::DSCT14_SA: SA Mask             */

#define PDMA_DSCT14_DA_DA_Pos            (0)                                               /*!< PDMA_T::DSCT14_DA: DA Position         */
#define PDMA_DSCT14_DA_DA_Msk            (0xfffffffful << PDMA_DSCT14_DA_DA_Pos)           /*!< PDMA_T::DSCT14_DA: DA Mask             */

#define PDMA_DSCT14_NEXT_NEXT_Pos        (2)                                               /*!< PDMA_T::DSCT14_NEXT: NEXT Position     */
#define PDMA_DSCT14_NEXT_NEXT_Msk        (0x3ffful << PDMA_DSCT14_NEXT_NEXT_Pos)           /*!< PDMA_T::DSCT14_NEXT: NEXT Mask         */

#define PDMA_DSCT15_CTL_OPMODE_Pos       (0)                                               /*!< PDMA_T::DSCT15_CTL: OPMODE Position    */
#define PDMA_DSCT15_CTL_OPMODE_Msk       (0x3ul << PDMA_DSCT15_CTL_OPMODE_Pos)             /*!< PDMA_T::DSCT15_CTL: OPMODE Mask        */

#define PDMA_DSCT15_CTL_TXTYPE_Pos       (2)                                               /*!< PDMA_T::DSCT15_CTL: TXTYPE Position    */
#define PDMA_DSCT15_CTL_TXTYPE_Msk       (0x1ul << PDMA_DSCT15_CTL_TXTYPE_Pos)             /*!< PDMA_T::DSCT15_CTL: TXTYPE Mask        */

#define PDMA_DSCT15_CTL_BURSIZE_Pos      (4)                                               /*!< PDMA_T::DSCT15_CTL: BURSIZE Position   */
#define PDMA_DSCT15_CTL_BURSIZE_Msk      (0x7ul << PDMA_DSCT15_CTL_BURSIZE_Pos)            /*!< PDMA_T::DSCT15_CTL: BURSIZE Mask       */

#define PDMA_DSCT15_CTL_SAINC_Pos        (8)                                               /*!< PDMA_T::DSCT15_CTL: SAINC Position     */
#define PDMA_DSCT15_CTL_SAINC_Msk        (0x3ul << PDMA_DSCT15_CTL_SAINC_Pos)              /*!< PDMA_T::DSCT15_CTL: SAINC Mask         */

#define PDMA_DSCT15_CTL_DAINC_Pos        (10)                                              /*!< PDMA_T::DSCT15_CTL: DAINC Position     */
#define PDMA_DSCT15_CTL_DAINC_Msk        (0x3ul << PDMA_DSCT15_CTL_DAINC_Pos)              /*!< PDMA_T::DSCT15_CTL: DAINC Mask         */

#define PDMA_DSCT15_CTL_TXWIDTH_Pos      (12)                                              /*!< PDMA_T::DSCT15_CTL: TXWIDTH Position   */
#define PDMA_DSCT15_CTL_TXWIDTH_Msk      (0x3ul << PDMA_DSCT15_CTL_TXWIDTH_Pos)            /*!< PDMA_T::DSCT15_CTL: TXWIDTH Mask       */

#define PDMA_DSCT15_CTL_TXACK_Pos        (14)                                              /*!< PDMA_T::DSCT15_CTL: TXACK Position     */
#define PDMA_DSCT15_CTL_TXACK_Msk        (0x1ul << PDMA_DSCT15_CTL_TXACK_Pos)              /*!< PDMA_T::DSCT15_CTL: TXACK Mask         */

#define PDMA_DSCT15_CTL_STRIDEEN_Pos     (15)                                              /*!< PDMA_T::DSCT15_CTL: STRIDEEN Position  */
#define PDMA_DSCT15_CTL_STRIDEEN_Msk     (0x1ul << PDMA_DSCT15_CTL_STRIDEEN_Pos)           /*!< PDMA_T::DSCT15_CTL: STRIDEEN Mask      */

#define PDMA_DSCT15_CTL_TXCNT_Pos        (16)                                              /*!< PDMA_T::DSCT15_CTL: TXCNT Position     */
#define PDMA_DSCT15_CTL_TXCNT_Msk        (0xfffful << PDMA_DSCT15_CTL_TXCNT_Pos)           /*!< PDMA_T::DSCT15_CTL: TXCNT Mask         */

#define PDMA_DSCT15_SA_SA_Pos            (0)                                               /*!< PDMA_T::DSCT15_SA: SA Position         */
#define PDMA_DSCT15_SA_SA_Msk            (0xfffffffful << PDMA_DSCT15_SA_SA_Pos)           /*!< PDMA_T::DSCT15_SA: SA Mask             */

#define PDMA_DSCT15_DA_DA_Pos            (0)                                               /*!< PDMA_T::DSCT15_DA: DA Position         */
#define PDMA_DSCT15_DA_DA_Msk            (0xfffffffful << PDMA_DSCT15_DA_DA_Pos)           /*!< PDMA_T::DSCT15_DA: DA Mask             */

#define PDMA_DSCT15_NEXT_NEXT_Pos        (2)                                               /*!< PDMA_T::DSCT15_NEXT: NEXT Position     */
#define PDMA_DSCT15_NEXT_NEXT_Msk        (0x3ffful << PDMA_DSCT15_NEXT_NEXT_Pos)           /*!< PDMA_T::DSCT15_NEXT: NEXT Mask         */

#define PDMA_CURSCAT0_CURADDR_Pos        (0)                                               /*!< PDMA_T::CURSCAT0: CURADDR Position     */
#define PDMA_CURSCAT0_CURADDR_Msk        (0xfffffffful << PDMA_CURSCAT0_CURADDR_Pos)       /*!< PDMA_T::CURSCAT0: CURADDR Mask         */

#define PDMA_CURSCAT1_CURADDR_Pos        (0)                                               /*!< PDMA_T::CURSCAT1: CURADDR Position     */
#define PDMA_CURSCAT1_CURADDR_Msk        (0xfffffffful << PDMA_CURSCAT1_CURADDR_Pos)       /*!< PDMA_T::CURSCAT1: CURADDR Mask         */

#define PDMA_CURSCAT2_CURADDR_Pos        (0)                                               /*!< PDMA_T::CURSCAT2: CURADDR Position     */
#define PDMA_CURSCAT2_CURADDR_Msk        (0xfffffffful << PDMA_CURSCAT2_CURADDR_Pos)       /*!< PDMA_T::CURSCAT2: CURADDR Mask         */

#define PDMA_CURSCAT3_CURADDR_Pos        (0)                                               /*!< PDMA_T::CURSCAT3: CURADDR Position     */
#define PDMA_CURSCAT3_CURADDR_Msk        (0xfffffffful << PDMA_CURSCAT3_CURADDR_Pos)       /*!< PDMA_T::CURSCAT3: CURADDR Mask         */

#define PDMA_CURSCAT4_CURADDR_Pos        (0)                                               /*!< PDMA_T::CURSCAT4: CURADDR Position     */
#define PDMA_CURSCAT4_CURADDR_Msk        (0xfffffffful << PDMA_CURSCAT4_CURADDR_Pos)       /*!< PDMA_T::CURSCAT4: CURADDR Mask         */

#define PDMA_CURSCAT5_CURADDR_Pos        (0)                                               /*!< PDMA_T::CURSCAT5: CURADDR Position     */
#define PDMA_CURSCAT5_CURADDR_Msk        (0xfffffffful << PDMA_CURSCAT5_CURADDR_Pos)       /*!< PDMA_T::CURSCAT5: CURADDR Mask         */

#define PDMA_CURSCAT6_CURADDR_Pos        (0)                                               /*!< PDMA_T::CURSCAT6: CURADDR Position     */
#define PDMA_CURSCAT6_CURADDR_Msk        (0xfffffffful << PDMA_CURSCAT6_CURADDR_Pos)       /*!< PDMA_T::CURSCAT6: CURADDR Mask         */

#define PDMA_CURSCAT7_CURADDR_Pos        (0)                                               /*!< PDMA_T::CURSCAT7: CURADDR Position     */
#define PDMA_CURSCAT7_CURADDR_Msk        (0xfffffffful << PDMA_CURSCAT7_CURADDR_Pos)       /*!< PDMA_T::CURSCAT7: CURADDR Mask         */

#define PDMA_CURSCAT8_CURADDR_Pos        (0)                                               /*!< PDMA_T::CURSCAT8: CURADDR Position     */
#define PDMA_CURSCAT8_CURADDR_Msk        (0xfffffffful << PDMA_CURSCAT8_CURADDR_Pos)       /*!< PDMA_T::CURSCAT8: CURADDR Mask         */

#define PDMA_CURSCAT9_CURADDR_Pos        (0)                                               /*!< PDMA_T::CURSCAT9: CURADDR Position     */
#define PDMA_CURSCAT9_CURADDR_Msk        (0xfffffffful << PDMA_CURSCAT9_CURADDR_Pos)       /*!< PDMA_T::CURSCAT9: CURADDR Mask         */

#define PDMA_CURSCAT10_CURADDR_Pos       (0)                                               /*!< PDMA_T::CURSCAT10: CURADDR Position    */
#define PDMA_CURSCAT10_CURADDR_Msk       (0xfffffffful << PDMA_CURSCAT10_CURADDR_Pos)      /*!< PDMA_T::CURSCAT10: CURADDR Mask        */

#define PDMA_CURSCAT11_CURADDR_Pos       (0)                                               /*!< PDMA_T::CURSCAT11: CURADDR Position    */
#define PDMA_CURSCAT11_CURADDR_Msk       (0xfffffffful << PDMA_CURSCAT11_CURADDR_Pos)      /*!< PDMA_T::CURSCAT11: CURADDR Mask        */

#define PDMA_CURSCAT12_CURADDR_Pos       (0)                                               /*!< PDMA_T::CURSCAT12: CURADDR Position    */
#define PDMA_CURSCAT12_CURADDR_Msk       (0xfffffffful << PDMA_CURSCAT12_CURADDR_Pos)      /*!< PDMA_T::CURSCAT12: CURADDR Mask        */

#define PDMA_CURSCAT13_CURADDR_Pos       (0)                                               /*!< PDMA_T::CURSCAT13: CURADDR Position    */
#define PDMA_CURSCAT13_CURADDR_Msk       (0xfffffffful << PDMA_CURSCAT13_CURADDR_Pos)      /*!< PDMA_T::CURSCAT13: CURADDR Mask        */

#define PDMA_CURSCAT14_CURADDR_Pos       (0)                                               /*!< PDMA_T::CURSCAT14: CURADDR Position    */
#define PDMA_CURSCAT14_CURADDR_Msk       (0xfffffffful << PDMA_CURSCAT14_CURADDR_Pos)      /*!< PDMA_T::CURSCAT14: CURADDR Mask        */

#define PDMA_CURSCAT15_CURADDR_Pos       (0)                                               /*!< PDMA_T::CURSCAT15: CURADDR Position    */
#define PDMA_CURSCAT15_CURADDR_Msk       (0xfffffffful << PDMA_CURSCAT15_CURADDR_Pos)      /*!< PDMA_T::CURSCAT15: CURADDR Mask        */

#define PDMA_CHCTL_CHEN0_Pos             (0)                                               /*!< PDMA_T::CHCTL: CHEN0 Position          */
#define PDMA_CHCTL_CHEN0_Msk             (0x1ul << PDMA_CHCTL_CHEN0_Pos)                   /*!< PDMA_T::CHCTL: CHEN0 Mask              */

#define PDMA_CHCTL_CHEN1_Pos             (1)                                               /*!< PDMA_T::CHCTL: CHEN1 Position          */
#define PDMA_CHCTL_CHEN1_Msk             (0x1ul << PDMA_CHCTL_CHEN1_Pos)                   /*!< PDMA_T::CHCTL: CHEN1 Mask              */

#define PDMA_CHCTL_CHEN2_Pos             (2)                                               /*!< PDMA_T::CHCTL: CHEN2 Position          */
#define PDMA_CHCTL_CHEN2_Msk             (0x1ul << PDMA_CHCTL_CHEN2_Pos)                   /*!< PDMA_T::CHCTL: CHEN2 Mask              */

#define PDMA_CHCTL_CHEN3_Pos             (3)                                               /*!< PDMA_T::CHCTL: CHEN3 Position          */
#define PDMA_CHCTL_CHEN3_Msk             (0x1ul << PDMA_CHCTL_CHEN3_Pos)                   /*!< PDMA_T::CHCTL: CHEN3 Mask              */

#define PDMA_CHCTL_CHEN4_Pos             (4)                                               /*!< PDMA_T::CHCTL: CHEN4 Position          */
#define PDMA_CHCTL_CHEN4_Msk             (0x1ul << PDMA_CHCTL_CHEN4_Pos)                   /*!< PDMA_T::CHCTL: CHEN4 Mask              */

#define PDMA_CHCTL_CHEN5_Pos             (5)                                               /*!< PDMA_T::CHCTL: CHEN5 Position          */
#define PDMA_CHCTL_CHEN5_Msk             (0x1ul << PDMA_CHCTL_CHEN5_Pos)                   /*!< PDMA_T::CHCTL: CHEN5 Mask              */

#define PDMA_CHCTL_CHEN6_Pos             (6)                                               /*!< PDMA_T::CHCTL: CHEN6 Position          */
#define PDMA_CHCTL_CHEN6_Msk             (0x1ul << PDMA_CHCTL_CHEN6_Pos)                   /*!< PDMA_T::CHCTL: CHEN6 Mask              */

#define PDMA_CHCTL_CHEN7_Pos             (7)                                               /*!< PDMA_T::CHCTL: CHEN7 Position          */
#define PDMA_CHCTL_CHEN7_Msk             (0x1ul << PDMA_CHCTL_CHEN7_Pos)                   /*!< PDMA_T::CHCTL: CHEN7 Mask              */

#define PDMA_CHCTL_CHEN8_Pos             (8)                                               /*!< PDMA_T::CHCTL: CHEN8 Position          */
#define PDMA_CHCTL_CHEN8_Msk             (0x1ul << PDMA_CHCTL_CHEN8_Pos)                   /*!< PDMA_T::CHCTL: CHEN8 Mask              */

#define PDMA_CHCTL_CHEN9_Pos             (9)                                               /*!< PDMA_T::CHCTL: CHEN9 Position          */
#define PDMA_CHCTL_CHEN9_Msk             (0x1ul << PDMA_CHCTL_CHEN9_Pos)                   /*!< PDMA_T::CHCTL: CHEN9 Mask              */

#define PDMA_CHCTL_CHEN10_Pos            (10)                                              /*!< PDMA_T::CHCTL: CHEN10 Position         */
#define PDMA_CHCTL_CHEN10_Msk            (0x1ul << PDMA_CHCTL_CHEN10_Pos)                  /*!< PDMA_T::CHCTL: CHEN10 Mask             */

#define PDMA_CHCTL_CHEN11_Pos            (11)                                              /*!< PDMA_T::CHCTL: CHEN11 Position         */
#define PDMA_CHCTL_CHEN11_Msk            (0x1ul << PDMA_CHCTL_CHEN11_Pos)                  /*!< PDMA_T::CHCTL: CHEN11 Mask             */

#define PDMA_CHCTL_CHEN12_Pos            (12)                                              /*!< PDMA_T::CHCTL: CHEN12 Position         */
#define PDMA_CHCTL_CHEN12_Msk            (0x1ul << PDMA_CHCTL_CHEN12_Pos)                  /*!< PDMA_T::CHCTL: CHEN12 Mask             */

#define PDMA_CHCTL_CHEN13_Pos            (13)                                              /*!< PDMA_T::CHCTL: CHEN13 Position         */
#define PDMA_CHCTL_CHEN13_Msk            (0x1ul << PDMA_CHCTL_CHEN13_Pos)                  /*!< PDMA_T::CHCTL: CHEN13 Mask             */

#define PDMA_CHCTL_CHEN14_Pos            (14)                                              /*!< PDMA_T::CHCTL: CHEN14 Position         */
#define PDMA_CHCTL_CHEN14_Msk            (0x1ul << PDMA_CHCTL_CHEN14_Pos)                  /*!< PDMA_T::CHCTL: CHEN14 Mask             */

#define PDMA_CHCTL_CHEN15_Pos            (15)                                              /*!< PDMA_T::CHCTL: CHEN15 Position         */
#define PDMA_CHCTL_CHEN15_Msk            (0x1ul << PDMA_CHCTL_CHEN15_Pos)                  /*!< PDMA_T::CHCTL: CHEN15 Mask             */

#define PDMA_STOP_STOP0_Pos              (0)                                               /*!< PDMA_T::STOP: STOP0 Position           */
#define PDMA_STOP_STOP0_Msk              (0x1ul << PDMA_STOP_STOP0_Pos)                    /*!< PDMA_T::STOP: STOP0 Mask               */

#define PDMA_STOP_STOP1_Pos              (1)                                               /*!< PDMA_T::STOP: STOP1 Position           */
#define PDMA_STOP_STOP1_Msk              (0x1ul << PDMA_STOP_STOP1_Pos)                    /*!< PDMA_T::STOP: STOP1 Mask               */

#define PDMA_STOP_STOP2_Pos              (2)                                               /*!< PDMA_T::STOP: STOP2 Position           */
#define PDMA_STOP_STOP2_Msk              (0x1ul << PDMA_STOP_STOP2_Pos)                    /*!< PDMA_T::STOP: STOP2 Mask               */

#define PDMA_STOP_STOP3_Pos              (3)                                               /*!< PDMA_T::STOP: STOP3 Position           */
#define PDMA_STOP_STOP3_Msk              (0x1ul << PDMA_STOP_STOP3_Pos)                    /*!< PDMA_T::STOP: STOP3 Mask               */

#define PDMA_STOP_STOP4_Pos              (4)                                               /*!< PDMA_T::STOP: STOP4 Position           */
#define PDMA_STOP_STOP4_Msk              (0x1ul << PDMA_STOP_STOP4_Pos)                    /*!< PDMA_T::STOP: STOP4 Mask               */

#define PDMA_STOP_STOP5_Pos              (5)                                               /*!< PDMA_T::STOP: STOP5 Position           */
#define PDMA_STOP_STOP5_Msk              (0x1ul << PDMA_STOP_STOP5_Pos)                    /*!< PDMA_T::STOP: STOP5 Mask               */

#define PDMA_STOP_STOP6_Pos              (6)                                               /*!< PDMA_T::STOP: STOP6 Position           */
#define PDMA_STOP_STOP6_Msk              (0x1ul << PDMA_STOP_STOP6_Pos)                    /*!< PDMA_T::STOP: STOP6 Mask               */

#define PDMA_STOP_STOP7_Pos              (7)                                               /*!< PDMA_T::STOP: STOP7 Position           */
#define PDMA_STOP_STOP7_Msk              (0x1ul << PDMA_STOP_STOP7_Pos)                    /*!< PDMA_T::STOP: STOP7 Mask               */

#define PDMA_STOP_STOP8_Pos              (8)                                               /*!< PDMA_T::STOP: STOP8 Position           */
#define PDMA_STOP_STOP8_Msk              (0x1ul << PDMA_STOP_STOP8_Pos)                    /*!< PDMA_T::STOP: STOP8 Mask               */

#define PDMA_STOP_STOP9_Pos              (9)                                               /*!< PDMA_T::STOP: STOP9 Position           */
#define PDMA_STOP_STOP9_Msk              (0x1ul << PDMA_STOP_STOP9_Pos)                    /*!< PDMA_T::STOP: STOP9 Mask               */

#define PDMA_STOP_STOP10_Pos             (10)                                              /*!< PDMA_T::STOP: STOP10 Position          */
#define PDMA_STOP_STOP10_Msk             (0x1ul << PDMA_STOP_STOP10_Pos)                   /*!< PDMA_T::STOP: STOP10 Mask              */

#define PDMA_STOP_STOP11_Pos             (11)                                              /*!< PDMA_T::STOP: STOP11 Position          */
#define PDMA_STOP_STOP11_Msk             (0x1ul << PDMA_STOP_STOP11_Pos)                   /*!< PDMA_T::STOP: STOP11 Mask              */

#define PDMA_STOP_STOP12_Pos             (12)                                              /*!< PDMA_T::STOP: STOP12 Position          */
#define PDMA_STOP_STOP12_Msk             (0x1ul << PDMA_STOP_STOP12_Pos)                   /*!< PDMA_T::STOP: STOP12 Mask              */

#define PDMA_STOP_STOP13_Pos             (13)                                              /*!< PDMA_T::STOP: STOP13 Position          */
#define PDMA_STOP_STOP13_Msk             (0x1ul << PDMA_STOP_STOP13_Pos)                   /*!< PDMA_T::STOP: STOP13 Mask              */

#define PDMA_STOP_STOP14_Pos             (14)                                              /*!< PDMA_T::STOP: STOP14 Position          */
#define PDMA_STOP_STOP14_Msk             (0x1ul << PDMA_STOP_STOP14_Pos)                   /*!< PDMA_T::STOP: STOP14 Mask              */

#define PDMA_STOP_STOP15_Pos             (15)                                              /*!< PDMA_T::STOP: STOP15 Position          */
#define PDMA_STOP_STOP15_Msk             (0x1ul << PDMA_STOP_STOP15_Pos)                   /*!< PDMA_T::STOP: STOP15 Mask              */

#define PDMA_SWREQ_SWREQ0_Pos            (0)                                               /*!< PDMA_T::SWREQ: SWREQ0 Position         */
#define PDMA_SWREQ_SWREQ0_Msk            (0x1ul << PDMA_SWREQ_SWREQ0_Pos)                  /*!< PDMA_T::SWREQ: SWREQ0 Mask             */

#define PDMA_SWREQ_SWREQ1_Pos            (1)                                               /*!< PDMA_T::SWREQ: SWREQ1 Position         */
#define PDMA_SWREQ_SWREQ1_Msk            (0x1ul << PDMA_SWREQ_SWREQ1_Pos)                  /*!< PDMA_T::SWREQ: SWREQ1 Mask             */

#define PDMA_SWREQ_SWREQ2_Pos            (2)                                               /*!< PDMA_T::SWREQ: SWREQ2 Position         */
#define PDMA_SWREQ_SWREQ2_Msk            (0x1ul << PDMA_SWREQ_SWREQ2_Pos)                  /*!< PDMA_T::SWREQ: SWREQ2 Mask             */

#define PDMA_SWREQ_SWREQ3_Pos            (3)                                               /*!< PDMA_T::SWREQ: SWREQ3 Position         */
#define PDMA_SWREQ_SWREQ3_Msk            (0x1ul << PDMA_SWREQ_SWREQ3_Pos)                  /*!< PDMA_T::SWREQ: SWREQ3 Mask             */

#define PDMA_SWREQ_SWREQ4_Pos            (4)                                               /*!< PDMA_T::SWREQ: SWREQ4 Position         */
#define PDMA_SWREQ_SWREQ4_Msk            (0x1ul << PDMA_SWREQ_SWREQ4_Pos)                  /*!< PDMA_T::SWREQ: SWREQ4 Mask             */

#define PDMA_SWREQ_SWREQ5_Pos            (5)                                               /*!< PDMA_T::SWREQ: SWREQ5 Position         */
#define PDMA_SWREQ_SWREQ5_Msk            (0x1ul << PDMA_SWREQ_SWREQ5_Pos)                  /*!< PDMA_T::SWREQ: SWREQ5 Mask             */

#define PDMA_SWREQ_SWREQ6_Pos            (6)                                               /*!< PDMA_T::SWREQ: SWREQ6 Position         */
#define PDMA_SWREQ_SWREQ6_Msk            (0x1ul << PDMA_SWREQ_SWREQ6_Pos)                  /*!< PDMA_T::SWREQ: SWREQ6 Mask             */

#define PDMA_SWREQ_SWREQ7_Pos            (7)                                               /*!< PDMA_T::SWREQ: SWREQ7 Position         */
#define PDMA_SWREQ_SWREQ7_Msk            (0x1ul << PDMA_SWREQ_SWREQ7_Pos)                  /*!< PDMA_T::SWREQ: SWREQ7 Mask             */

#define PDMA_SWREQ_SWREQ8_Pos            (8)                                               /*!< PDMA_T::SWREQ: SWREQ8 Position         */
#define PDMA_SWREQ_SWREQ8_Msk            (0x1ul << PDMA_SWREQ_SWREQ8_Pos)                  /*!< PDMA_T::SWREQ: SWREQ8 Mask             */

#define PDMA_SWREQ_SWREQ9_Pos            (9)                                               /*!< PDMA_T::SWREQ: SWREQ9 Position         */
#define PDMA_SWREQ_SWREQ9_Msk            (0x1ul << PDMA_SWREQ_SWREQ9_Pos)                  /*!< PDMA_T::SWREQ: SWREQ9 Mask             */

#define PDMA_SWREQ_SWREQ10_Pos           (10)                                              /*!< PDMA_T::SWREQ: SWREQ10 Position        */
#define PDMA_SWREQ_SWREQ10_Msk           (0x1ul << PDMA_SWREQ_SWREQ10_Pos)                 /*!< PDMA_T::SWREQ: SWREQ10 Mask            */

#define PDMA_SWREQ_SWREQ11_Pos           (11)                                              /*!< PDMA_T::SWREQ: SWREQ11 Position        */
#define PDMA_SWREQ_SWREQ11_Msk           (0x1ul << PDMA_SWREQ_SWREQ11_Pos)                 /*!< PDMA_T::SWREQ: SWREQ11 Mask            */

#define PDMA_SWREQ_SWREQ12_Pos           (12)                                              /*!< PDMA_T::SWREQ: SWREQ12 Position        */
#define PDMA_SWREQ_SWREQ12_Msk           (0x1ul << PDMA_SWREQ_SWREQ12_Pos)                 /*!< PDMA_T::SWREQ: SWREQ12 Mask            */

#define PDMA_SWREQ_SWREQ13_Pos           (13)                                              /*!< PDMA_T::SWREQ: SWREQ13 Position        */
#define PDMA_SWREQ_SWREQ13_Msk           (0x1ul << PDMA_SWREQ_SWREQ13_Pos)                 /*!< PDMA_T::SWREQ: SWREQ13 Mask            */

#define PDMA_SWREQ_SWREQ14_Pos           (14)                                              /*!< PDMA_T::SWREQ: SWREQ14 Position        */
#define PDMA_SWREQ_SWREQ14_Msk           (0x1ul << PDMA_SWREQ_SWREQ14_Pos)                 /*!< PDMA_T::SWREQ: SWREQ14 Mask            */

#define PDMA_SWREQ_SWREQ15_Pos           (15)                                              /*!< PDMA_T::SWREQ: SWREQ15 Position        */
#define PDMA_SWREQ_SWREQ15_Msk           (0x1ul << PDMA_SWREQ_SWREQ15_Pos)                 /*!< PDMA_T::SWREQ: SWREQ15 Mask            */

#define PDMA_TRGSTS_REQSTS0_Pos          (0)                                               /*!< PDMA_T::TRGSTS: REQSTS0 Position       */
#define PDMA_TRGSTS_REQSTS0_Msk          (0x1ul << PDMA_TRGSTS_REQSTS0_Pos)                /*!< PDMA_T::TRGSTS: REQSTS0 Mask           */

#define PDMA_TRGSTS_REQSTS1_Pos          (1)                                               /*!< PDMA_T::TRGSTS: REQSTS1 Position       */
#define PDMA_TRGSTS_REQSTS1_Msk          (0x1ul << PDMA_TRGSTS_REQSTS1_Pos)                /*!< PDMA_T::TRGSTS: REQSTS1 Mask           */

#define PDMA_TRGSTS_REQSTS2_Pos          (2)                                               /*!< PDMA_T::TRGSTS: REQSTS2 Position       */
#define PDMA_TRGSTS_REQSTS2_Msk          (0x1ul << PDMA_TRGSTS_REQSTS2_Pos)                /*!< PDMA_T::TRGSTS: REQSTS2 Mask           */

#define PDMA_TRGSTS_REQSTS3_Pos          (3)                                               /*!< PDMA_T::TRGSTS: REQSTS3 Position       */
#define PDMA_TRGSTS_REQSTS3_Msk          (0x1ul << PDMA_TRGSTS_REQSTS3_Pos)                /*!< PDMA_T::TRGSTS: REQSTS3 Mask           */

#define PDMA_TRGSTS_REQSTS4_Pos          (4)                                               /*!< PDMA_T::TRGSTS: REQSTS4 Position       */
#define PDMA_TRGSTS_REQSTS4_Msk          (0x1ul << PDMA_TRGSTS_REQSTS4_Pos)                /*!< PDMA_T::TRGSTS: REQSTS4 Mask           */

#define PDMA_TRGSTS_REQSTS5_Pos          (5)                                               /*!< PDMA_T::TRGSTS: REQSTS5 Position       */
#define PDMA_TRGSTS_REQSTS5_Msk          (0x1ul << PDMA_TRGSTS_REQSTS5_Pos)                /*!< PDMA_T::TRGSTS: REQSTS5 Mask           */

#define PDMA_TRGSTS_REQSTS6_Pos          (6)                                               /*!< PDMA_T::TRGSTS: REQSTS6 Position       */
#define PDMA_TRGSTS_REQSTS6_Msk          (0x1ul << PDMA_TRGSTS_REQSTS6_Pos)                /*!< PDMA_T::TRGSTS: REQSTS6 Mask           */

#define PDMA_TRGSTS_REQSTS7_Pos          (7)                                               /*!< PDMA_T::TRGSTS: REQSTS7 Position       */
#define PDMA_TRGSTS_REQSTS7_Msk          (0x1ul << PDMA_TRGSTS_REQSTS7_Pos)                /*!< PDMA_T::TRGSTS: REQSTS7 Mask           */

#define PDMA_TRGSTS_REQSTS8_Pos          (8)                                               /*!< PDMA_T::TRGSTS: REQSTS8 Position       */
#define PDMA_TRGSTS_REQSTS8_Msk          (0x1ul << PDMA_TRGSTS_REQSTS8_Pos)                /*!< PDMA_T::TRGSTS: REQSTS8 Mask           */

#define PDMA_TRGSTS_REQSTS9_Pos          (9)                                               /*!< PDMA_T::TRGSTS: REQSTS9 Position       */
#define PDMA_TRGSTS_REQSTS9_Msk          (0x1ul << PDMA_TRGSTS_REQSTS9_Pos)                /*!< PDMA_T::TRGSTS: REQSTS9 Mask           */

#define PDMA_TRGSTS_REQSTS10_Pos         (10)                                              /*!< PDMA_T::TRGSTS: REQSTS10 Position      */
#define PDMA_TRGSTS_REQSTS10_Msk         (0x1ul << PDMA_TRGSTS_REQSTS10_Pos)               /*!< PDMA_T::TRGSTS: REQSTS10 Mask          */

#define PDMA_TRGSTS_REQSTS11_Pos         (11)                                              /*!< PDMA_T::TRGSTS: REQSTS11 Position      */
#define PDMA_TRGSTS_REQSTS11_Msk         (0x1ul << PDMA_TRGSTS_REQSTS11_Pos)               /*!< PDMA_T::TRGSTS: REQSTS11 Mask          */

#define PDMA_TRGSTS_REQSTS12_Pos         (12)                                              /*!< PDMA_T::TRGSTS: REQSTS12 Position      */
#define PDMA_TRGSTS_REQSTS12_Msk         (0x1ul << PDMA_TRGSTS_REQSTS12_Pos)               /*!< PDMA_T::TRGSTS: REQSTS12 Mask          */

#define PDMA_TRGSTS_REQSTS13_Pos         (13)                                              /*!< PDMA_T::TRGSTS: REQSTS13 Position      */
#define PDMA_TRGSTS_REQSTS13_Msk         (0x1ul << PDMA_TRGSTS_REQSTS13_Pos)               /*!< PDMA_T::TRGSTS: REQSTS13 Mask          */

#define PDMA_TRGSTS_REQSTS14_Pos         (14)                                              /*!< PDMA_T::TRGSTS: REQSTS14 Position      */
#define PDMA_TRGSTS_REQSTS14_Msk         (0x1ul << PDMA_TRGSTS_REQSTS14_Pos)               /*!< PDMA_T::TRGSTS: REQSTS14 Mask          */

#define PDMA_TRGSTS_REQSTS15_Pos         (15)                                              /*!< PDMA_T::TRGSTS: REQSTS15 Position      */
#define PDMA_TRGSTS_REQSTS15_Msk         (0x1ul << PDMA_TRGSTS_REQSTS15_Pos)               /*!< PDMA_T::TRGSTS: REQSTS15 Mask          */

#define PDMA_PRISET_FPRISET0_Pos         (0)                                               /*!< PDMA_T::PRISET: FPRISET0 Position      */
#define PDMA_PRISET_FPRISET0_Msk         (0x1ul << PDMA_PRISET_FPRISET0_Pos)               /*!< PDMA_T::PRISET: FPRISET0 Mask          */

#define PDMA_PRISET_FPRISET1_Pos         (1)                                               /*!< PDMA_T::PRISET: FPRISET1 Position      */
#define PDMA_PRISET_FPRISET1_Msk         (0x1ul << PDMA_PRISET_FPRISET1_Pos)               /*!< PDMA_T::PRISET: FPRISET1 Mask          */

#define PDMA_PRISET_FPRISET2_Pos         (2)                                               /*!< PDMA_T::PRISET: FPRISET2 Position      */
#define PDMA_PRISET_FPRISET2_Msk         (0x1ul << PDMA_PRISET_FPRISET2_Pos)               /*!< PDMA_T::PRISET: FPRISET2 Mask          */

#define PDMA_PRISET_FPRISET3_Pos         (3)                                               /*!< PDMA_T::PRISET: FPRISET3 Position      */
#define PDMA_PRISET_FPRISET3_Msk         (0x1ul << PDMA_PRISET_FPRISET3_Pos)               /*!< PDMA_T::PRISET: FPRISET3 Mask          */

#define PDMA_PRISET_FPRISET4_Pos         (4)                                               /*!< PDMA_T::PRISET: FPRISET4 Position      */
#define PDMA_PRISET_FPRISET4_Msk         (0x1ul << PDMA_PRISET_FPRISET4_Pos)               /*!< PDMA_T::PRISET: FPRISET4 Mask          */

#define PDMA_PRISET_FPRISET5_Pos         (5)                                               /*!< PDMA_T::PRISET: FPRISET5 Position      */
#define PDMA_PRISET_FPRISET5_Msk         (0x1ul << PDMA_PRISET_FPRISET5_Pos)               /*!< PDMA_T::PRISET: FPRISET5 Mask          */

#define PDMA_PRISET_FPRISET6_Pos         (6)                                               /*!< PDMA_T::PRISET: FPRISET6 Position      */
#define PDMA_PRISET_FPRISET6_Msk         (0x1ul << PDMA_PRISET_FPRISET6_Pos)               /*!< PDMA_T::PRISET: FPRISET6 Mask          */

#define PDMA_PRISET_FPRISET7_Pos         (7)                                               /*!< PDMA_T::PRISET: FPRISET7 Position      */
#define PDMA_PRISET_FPRISET7_Msk         (0x1ul << PDMA_PRISET_FPRISET7_Pos)               /*!< PDMA_T::PRISET: FPRISET7 Mask          */

#define PDMA_PRISET_FPRISET8_Pos         (8)                                               /*!< PDMA_T::PRISET: FPRISET8 Position      */
#define PDMA_PRISET_FPRISET8_Msk         (0x1ul << PDMA_PRISET_FPRISET8_Pos)               /*!< PDMA_T::PRISET: FPRISET8 Mask          */

#define PDMA_PRISET_FPRISET9_Pos         (9)                                               /*!< PDMA_T::PRISET: FPRISET9 Position      */
#define PDMA_PRISET_FPRISET9_Msk         (0x1ul << PDMA_PRISET_FPRISET9_Pos)               /*!< PDMA_T::PRISET: FPRISET9 Mask          */

#define PDMA_PRISET_FPRISET10_Pos        (10)                                              /*!< PDMA_T::PRISET: FPRISET10 Position     */
#define PDMA_PRISET_FPRISET10_Msk        (0x1ul << PDMA_PRISET_FPRISET10_Pos)              /*!< PDMA_T::PRISET: FPRISET10 Mask         */

#define PDMA_PRISET_FPRISET11_Pos        (11)                                              /*!< PDMA_T::PRISET: FPRISET11 Position     */
#define PDMA_PRISET_FPRISET11_Msk        (0x1ul << PDMA_PRISET_FPRISET11_Pos)              /*!< PDMA_T::PRISET: FPRISET11 Mask         */

#define PDMA_PRISET_FPRISET12_Pos        (12)                                              /*!< PDMA_T::PRISET: FPRISET12 Position     */
#define PDMA_PRISET_FPRISET12_Msk        (0x1ul << PDMA_PRISET_FPRISET12_Pos)              /*!< PDMA_T::PRISET: FPRISET12 Mask         */

#define PDMA_PRISET_FPRISET13_Pos        (13)                                              /*!< PDMA_T::PRISET: FPRISET13 Position     */
#define PDMA_PRISET_FPRISET13_Msk        (0x1ul << PDMA_PRISET_FPRISET13_Pos)              /*!< PDMA_T::PRISET: FPRISET13 Mask         */

#define PDMA_PRISET_FPRISET14_Pos        (14)                                              /*!< PDMA_T::PRISET: FPRISET14 Position     */
#define PDMA_PRISET_FPRISET14_Msk        (0x1ul << PDMA_PRISET_FPRISET14_Pos)              /*!< PDMA_T::PRISET: FPRISET14 Mask         */

#define PDMA_PRISET_FPRISET15_Pos        (15)                                              /*!< PDMA_T::PRISET: FPRISET15 Position     */
#define PDMA_PRISET_FPRISET15_Msk        (0x1ul << PDMA_PRISET_FPRISET15_Pos)              /*!< PDMA_T::PRISET: FPRISET15 Mask         */

#define PDMA_PRICLR_FPRICLR0_Pos         (0)                                               /*!< PDMA_T::PRICLR: FPRICLR0 Position      */
#define PDMA_PRICLR_FPRICLR0_Msk         (0x1ul << PDMA_PRICLR_FPRICLR0_Pos)               /*!< PDMA_T::PRICLR: FPRICLR0 Mask          */

#define PDMA_PRICLR_FPRICLR1_Pos         (1)                                               /*!< PDMA_T::PRICLR: FPRICLR1 Position      */
#define PDMA_PRICLR_FPRICLR1_Msk         (0x1ul << PDMA_PRICLR_FPRICLR1_Pos)               /*!< PDMA_T::PRICLR: FPRICLR1 Mask          */

#define PDMA_PRICLR_FPRICLR2_Pos         (2)                                               /*!< PDMA_T::PRICLR: FPRICLR2 Position      */
#define PDMA_PRICLR_FPRICLR2_Msk         (0x1ul << PDMA_PRICLR_FPRICLR2_Pos)               /*!< PDMA_T::PRICLR: FPRICLR2 Mask          */

#define PDMA_PRICLR_FPRICLR3_Pos         (3)                                               /*!< PDMA_T::PRICLR: FPRICLR3 Position      */
#define PDMA_PRICLR_FPRICLR3_Msk         (0x1ul << PDMA_PRICLR_FPRICLR3_Pos)               /*!< PDMA_T::PRICLR: FPRICLR3 Mask          */

#define PDMA_PRICLR_FPRICLR4_Pos         (4)                                               /*!< PDMA_T::PRICLR: FPRICLR4 Position      */
#define PDMA_PRICLR_FPRICLR4_Msk         (0x1ul << PDMA_PRICLR_FPRICLR4_Pos)               /*!< PDMA_T::PRICLR: FPRICLR4 Mask          */

#define PDMA_PRICLR_FPRICLR5_Pos         (5)                                               /*!< PDMA_T::PRICLR: FPRICLR5 Position      */
#define PDMA_PRICLR_FPRICLR5_Msk         (0x1ul << PDMA_PRICLR_FPRICLR5_Pos)               /*!< PDMA_T::PRICLR: FPRICLR5 Mask          */

#define PDMA_PRICLR_FPRICLR6_Pos         (6)                                               /*!< PDMA_T::PRICLR: FPRICLR6 Position      */
#define PDMA_PRICLR_FPRICLR6_Msk         (0x1ul << PDMA_PRICLR_FPRICLR6_Pos)               /*!< PDMA_T::PRICLR: FPRICLR6 Mask          */

#define PDMA_PRICLR_FPRICLR7_Pos         (7)                                               /*!< PDMA_T::PRICLR: FPRICLR7 Position      */
#define PDMA_PRICLR_FPRICLR7_Msk         (0x1ul << PDMA_PRICLR_FPRICLR7_Pos)               /*!< PDMA_T::PRICLR: FPRICLR7 Mask          */

#define PDMA_PRICLR_FPRICLR8_Pos         (8)                                               /*!< PDMA_T::PRICLR: FPRICLR8 Position      */
#define PDMA_PRICLR_FPRICLR8_Msk         (0x1ul << PDMA_PRICLR_FPRICLR8_Pos)               /*!< PDMA_T::PRICLR: FPRICLR8 Mask          */

#define PDMA_PRICLR_FPRICLR9_Pos         (9)                                               /*!< PDMA_T::PRICLR: FPRICLR9 Position      */
#define PDMA_PRICLR_FPRICLR9_Msk         (0x1ul << PDMA_PRICLR_FPRICLR9_Pos)               /*!< PDMA_T::PRICLR: FPRICLR9 Mask          */

#define PDMA_PRICLR_FPRICLR10_Pos        (10)                                              /*!< PDMA_T::PRICLR: FPRICLR10 Position     */
#define PDMA_PRICLR_FPRICLR10_Msk        (0x1ul << PDMA_PRICLR_FPRICLR10_Pos)              /*!< PDMA_T::PRICLR: FPRICLR10 Mask         */

#define PDMA_PRICLR_FPRICLR11_Pos        (11)                                              /*!< PDMA_T::PRICLR: FPRICLR11 Position     */
#define PDMA_PRICLR_FPRICLR11_Msk        (0x1ul << PDMA_PRICLR_FPRICLR11_Pos)              /*!< PDMA_T::PRICLR: FPRICLR11 Mask         */

#define PDMA_PRICLR_FPRICLR12_Pos        (12)                                              /*!< PDMA_T::PRICLR: FPRICLR12 Position     */
#define PDMA_PRICLR_FPRICLR12_Msk        (0x1ul << PDMA_PRICLR_FPRICLR12_Pos)              /*!< PDMA_T::PRICLR: FPRICLR12 Mask         */

#define PDMA_PRICLR_FPRICLR13_Pos        (13)                                              /*!< PDMA_T::PRICLR: FPRICLR13 Position     */
#define PDMA_PRICLR_FPRICLR13_Msk        (0x1ul << PDMA_PRICLR_FPRICLR13_Pos)              /*!< PDMA_T::PRICLR: FPRICLR13 Mask         */

#define PDMA_PRICLR_FPRICLR14_Pos        (14)                                              /*!< PDMA_T::PRICLR: FPRICLR14 Position     */
#define PDMA_PRICLR_FPRICLR14_Msk        (0x1ul << PDMA_PRICLR_FPRICLR14_Pos)              /*!< PDMA_T::PRICLR: FPRICLR14 Mask         */

#define PDMA_PRICLR_FPRICLR15_Pos        (15)                                              /*!< PDMA_T::PRICLR: FPRICLR15 Position     */
#define PDMA_PRICLR_FPRICLR15_Msk        (0x1ul << PDMA_PRICLR_FPRICLR15_Pos)              /*!< PDMA_T::PRICLR: FPRICLR15 Mask         */

#define PDMA_INTEN_INTEN0_Pos            (0)                                               /*!< PDMA_T::INTEN: INTEN0 Position         */
#define PDMA_INTEN_INTEN0_Msk            (0x1ul << PDMA_INTEN_INTEN0_Pos)                  /*!< PDMA_T::INTEN: INTEN0 Mask             */

#define PDMA_INTEN_INTEN1_Pos            (1)                                               /*!< PDMA_T::INTEN: INTEN1 Position         */
#define PDMA_INTEN_INTEN1_Msk            (0x1ul << PDMA_INTEN_INTEN1_Pos)                  /*!< PDMA_T::INTEN: INTEN1 Mask             */

#define PDMA_INTEN_INTEN2_Pos            (2)                                               /*!< PDMA_T::INTEN: INTEN2 Position         */
#define PDMA_INTEN_INTEN2_Msk            (0x1ul << PDMA_INTEN_INTEN2_Pos)                  /*!< PDMA_T::INTEN: INTEN2 Mask             */

#define PDMA_INTEN_INTEN3_Pos            (3)                                               /*!< PDMA_T::INTEN: INTEN3 Position         */
#define PDMA_INTEN_INTEN3_Msk            (0x1ul << PDMA_INTEN_INTEN3_Pos)                  /*!< PDMA_T::INTEN: INTEN3 Mask             */

#define PDMA_INTEN_INTEN4_Pos            (4)                                               /*!< PDMA_T::INTEN: INTEN4 Position         */
#define PDMA_INTEN_INTEN4_Msk            (0x1ul << PDMA_INTEN_INTEN4_Pos)                  /*!< PDMA_T::INTEN: INTEN4 Mask             */

#define PDMA_INTEN_INTEN5_Pos            (5)                                               /*!< PDMA_T::INTEN: INTEN5 Position         */
#define PDMA_INTEN_INTEN5_Msk            (0x1ul << PDMA_INTEN_INTEN5_Pos)                  /*!< PDMA_T::INTEN: INTEN5 Mask             */

#define PDMA_INTEN_INTEN6_Pos            (6)                                               /*!< PDMA_T::INTEN: INTEN6 Position         */
#define PDMA_INTEN_INTEN6_Msk            (0x1ul << PDMA_INTEN_INTEN6_Pos)                  /*!< PDMA_T::INTEN: INTEN6 Mask             */

#define PDMA_INTEN_INTEN7_Pos            (7)                                               /*!< PDMA_T::INTEN: INTEN7 Position         */
#define PDMA_INTEN_INTEN7_Msk            (0x1ul << PDMA_INTEN_INTEN7_Pos)                  /*!< PDMA_T::INTEN: INTEN7 Mask             */

#define PDMA_INTEN_INTEN8_Pos            (8)                                               /*!< PDMA_T::INTEN: INTEN8 Position         */
#define PDMA_INTEN_INTEN8_Msk            (0x1ul << PDMA_INTEN_INTEN8_Pos)                  /*!< PDMA_T::INTEN: INTEN8 Mask             */

#define PDMA_INTEN_INTEN9_Pos            (9)                                               /*!< PDMA_T::INTEN: INTEN9 Position         */
#define PDMA_INTEN_INTEN9_Msk            (0x1ul << PDMA_INTEN_INTEN9_Pos)                  /*!< PDMA_T::INTEN: INTEN9 Mask             */

#define PDMA_INTEN_INTEN10_Pos           (10)                                              /*!< PDMA_T::INTEN: INTEN10 Position        */
#define PDMA_INTEN_INTEN10_Msk           (0x1ul << PDMA_INTEN_INTEN10_Pos)                 /*!< PDMA_T::INTEN: INTEN10 Mask            */

#define PDMA_INTEN_INTEN11_Pos           (11)                                              /*!< PDMA_T::INTEN: INTEN11 Position        */
#define PDMA_INTEN_INTEN11_Msk           (0x1ul << PDMA_INTEN_INTEN11_Pos)                 /*!< PDMA_T::INTEN: INTEN11 Mask            */

#define PDMA_INTEN_INTEN12_Pos           (12)                                              /*!< PDMA_T::INTEN: INTEN12 Position        */
#define PDMA_INTEN_INTEN12_Msk           (0x1ul << PDMA_INTEN_INTEN12_Pos)                 /*!< PDMA_T::INTEN: INTEN12 Mask            */

#define PDMA_INTEN_INTEN13_Pos           (13)                                              /*!< PDMA_T::INTEN: INTEN13 Position        */
#define PDMA_INTEN_INTEN13_Msk           (0x1ul << PDMA_INTEN_INTEN13_Pos)                 /*!< PDMA_T::INTEN: INTEN13 Mask            */

#define PDMA_INTEN_INTEN14_Pos           (14)                                              /*!< PDMA_T::INTEN: INTEN14 Position        */
#define PDMA_INTEN_INTEN14_Msk           (0x1ul << PDMA_INTEN_INTEN14_Pos)                 /*!< PDMA_T::INTEN: INTEN14 Mask            */

#define PDMA_INTEN_INTEN15_Pos           (15)                                              /*!< PDMA_T::INTEN: INTEN15 Position        */
#define PDMA_INTEN_INTEN15_Msk           (0x1ul << PDMA_INTEN_INTEN15_Pos)                 /*!< PDMA_T::INTEN: INTEN15 Mask            */

#define PDMA_INTEN_BISTEN_Pos            (31)                                              /*!< PDMA_T::INTEN: BISTEN Position         */
#define PDMA_INTEN_BISTEN_Msk            (0x1ul << PDMA_INTEN_BISTEN_Pos)                  /*!< PDMA_T::INTEN: BISTEN Mask             */

#define PDMA_INTSTS_ABTIF_Pos            (0)                                               /*!< PDMA_T::INTSTS: ABTIF Position         */
#define PDMA_INTSTS_ABTIF_Msk            (0x1ul << PDMA_INTSTS_ABTIF_Pos)                  /*!< PDMA_T::INTSTS: ABTIF Mask             */

#define PDMA_INTSTS_TDIF_Pos             (1)                                               /*!< PDMA_T::INTSTS: TDIF Position          */
#define PDMA_INTSTS_TDIF_Msk             (0x1ul << PDMA_INTSTS_TDIF_Pos)                   /*!< PDMA_T::INTSTS: TDIF Mask              */

#define PDMA_INTSTS_ALIGNF_Pos           (2)                                               /*!< PDMA_T::INTSTS: ALIGNF Position        */
#define PDMA_INTSTS_ALIGNF_Msk           (0x1ul << PDMA_INTSTS_ALIGNF_Pos)                 /*!< PDMA_T::INTSTS: ALIGNF Mask            */

#define PDMA_INTSTS_REQTOF0_Pos          (8)                                               /*!< PDMA_T::INTSTS: REQTOF0 Position       */
#define PDMA_INTSTS_REQTOF0_Msk          (0x1ul << PDMA_INTSTS_REQTOF0_Pos)                /*!< PDMA_T::INTSTS: REQTOF0 Mask           */

#define PDMA_INTSTS_REQTOF1_Pos          (9)                                               /*!< PDMA_T::INTSTS: REQTOF1 Position       */
#define PDMA_INTSTS_REQTOF1_Msk          (0x1ul << PDMA_INTSTS_REQTOF1_Pos)                /*!< PDMA_T::INTSTS: REQTOF1 Mask           */

#define PDMA_INTSTS_BISTFAIL_Pos         (30)                                              /*!< PDMA_T::INTSTS: BISTFAIL Position      */
#define PDMA_INTSTS_BISTFAIL_Msk         (0x1ul << PDMA_INTSTS_BISTFAIL_Pos)               /*!< PDMA_T::INTSTS: BISTFAIL Mask          */

#define PDMA_INTSTS_BISTDONE_Pos         (31)                                              /*!< PDMA_T::INTSTS: BISTDONE Position      */
#define PDMA_INTSTS_BISTDONE_Msk         (0x1ul << PDMA_INTSTS_BISTDONE_Pos)               /*!< PDMA_T::INTSTS: BISTDONE Mask          */

#define PDMA_ABTSTS_ABTIF0_Pos           (0)                                               /*!< PDMA_T::ABTSTS: ABTIF0 Position        */
#define PDMA_ABTSTS_ABTIF0_Msk           (0x1ul << PDMA_ABTSTS_ABTIF0_Pos)                 /*!< PDMA_T::ABTSTS: ABTIF0 Mask            */

#define PDMA_ABTSTS_ABTIF1_Pos           (1)                                               /*!< PDMA_T::ABTSTS: ABTIF1 Position        */
#define PDMA_ABTSTS_ABTIF1_Msk           (0x1ul << PDMA_ABTSTS_ABTIF1_Pos)                 /*!< PDMA_T::ABTSTS: ABTIF1 Mask            */

#define PDMA_ABTSTS_ABTIF2_Pos           (2)                                               /*!< PDMA_T::ABTSTS: ABTIF2 Position        */
#define PDMA_ABTSTS_ABTIF2_Msk           (0x1ul << PDMA_ABTSTS_ABTIF2_Pos)                 /*!< PDMA_T::ABTSTS: ABTIF2 Mask            */

#define PDMA_ABTSTS_ABTIF3_Pos           (3)                                               /*!< PDMA_T::ABTSTS: ABTIF3 Position        */
#define PDMA_ABTSTS_ABTIF3_Msk           (0x1ul << PDMA_ABTSTS_ABTIF3_Pos)                 /*!< PDMA_T::ABTSTS: ABTIF3 Mask            */

#define PDMA_ABTSTS_ABTIF4_Pos           (4)                                               /*!< PDMA_T::ABTSTS: ABTIF4 Position        */
#define PDMA_ABTSTS_ABTIF4_Msk           (0x1ul << PDMA_ABTSTS_ABTIF4_Pos)                 /*!< PDMA_T::ABTSTS: ABTIF4 Mask            */

#define PDMA_ABTSTS_ABTIF5_Pos           (5)                                               /*!< PDMA_T::ABTSTS: ABTIF5 Position        */
#define PDMA_ABTSTS_ABTIF5_Msk           (0x1ul << PDMA_ABTSTS_ABTIF5_Pos)                 /*!< PDMA_T::ABTSTS: ABTIF5 Mask            */

#define PDMA_ABTSTS_ABTIF6_Pos           (6)                                               /*!< PDMA_T::ABTSTS: ABTIF6 Position        */
#define PDMA_ABTSTS_ABTIF6_Msk           (0x1ul << PDMA_ABTSTS_ABTIF6_Pos)                 /*!< PDMA_T::ABTSTS: ABTIF6 Mask            */

#define PDMA_ABTSTS_ABTIF7_Pos           (7)                                               /*!< PDMA_T::ABTSTS: ABTIF7 Position        */
#define PDMA_ABTSTS_ABTIF7_Msk           (0x1ul << PDMA_ABTSTS_ABTIF7_Pos)                 /*!< PDMA_T::ABTSTS: ABTIF7 Mask            */

#define PDMA_ABTSTS_ABTIF8_Pos           (8)                                               /*!< PDMA_T::ABTSTS: ABTIF8 Position        */
#define PDMA_ABTSTS_ABTIF8_Msk           (0x1ul << PDMA_ABTSTS_ABTIF8_Pos)                 /*!< PDMA_T::ABTSTS: ABTIF8 Mask            */

#define PDMA_ABTSTS_ABTIF9_Pos           (9)                                               /*!< PDMA_T::ABTSTS: ABTIF9 Position        */
#define PDMA_ABTSTS_ABTIF9_Msk           (0x1ul << PDMA_ABTSTS_ABTIF9_Pos)                 /*!< PDMA_T::ABTSTS: ABTIF9 Mask            */

#define PDMA_ABTSTS_ABTIF10_Pos          (10)                                              /*!< PDMA_T::ABTSTS: ABTIF10 Position       */
#define PDMA_ABTSTS_ABTIF10_Msk          (0x1ul << PDMA_ABTSTS_ABTIF10_Pos)                /*!< PDMA_T::ABTSTS: ABTIF10 Mask           */

#define PDMA_ABTSTS_ABTIF11_Pos          (11)                                              /*!< PDMA_T::ABTSTS: ABTIF11 Position       */
#define PDMA_ABTSTS_ABTIF11_Msk          (0x1ul << PDMA_ABTSTS_ABTIF11_Pos)                /*!< PDMA_T::ABTSTS: ABTIF11 Mask           */

#define PDMA_ABTSTS_ABTIF12_Pos          (12)                                              /*!< PDMA_T::ABTSTS: ABTIF12 Position       */
#define PDMA_ABTSTS_ABTIF12_Msk          (0x1ul << PDMA_ABTSTS_ABTIF12_Pos)                /*!< PDMA_T::ABTSTS: ABTIF12 Mask           */

#define PDMA_ABTSTS_ABTIF13_Pos          (13)                                              /*!< PDMA_T::ABTSTS: ABTIF13 Position       */
#define PDMA_ABTSTS_ABTIF13_Msk          (0x1ul << PDMA_ABTSTS_ABTIF13_Pos)                /*!< PDMA_T::ABTSTS: ABTIF13 Mask           */

#define PDMA_ABTSTS_ABTIF14_Pos          (14)                                              /*!< PDMA_T::ABTSTS: ABTIF14 Position       */
#define PDMA_ABTSTS_ABTIF14_Msk          (0x1ul << PDMA_ABTSTS_ABTIF14_Pos)                /*!< PDMA_T::ABTSTS: ABTIF14 Mask           */

#define PDMA_ABTSTS_ABTIF15_Pos          (15)                                              /*!< PDMA_T::ABTSTS: ABTIF15 Position       */
#define PDMA_ABTSTS_ABTIF15_Msk          (0x1ul << PDMA_ABTSTS_ABTIF15_Pos)                /*!< PDMA_T::ABTSTS: ABTIF15 Mask           */

#define PDMA_TDSTS_TDIF0_Pos             (0)                                               /*!< PDMA_T::TDSTS: TDIF0 Position          */
#define PDMA_TDSTS_TDIF0_Msk             (0x1ul << PDMA_TDSTS_TDIF0_Pos)                   /*!< PDMA_T::TDSTS: TDIF0 Mask              */

#define PDMA_TDSTS_TDIF1_Pos             (1)                                               /*!< PDMA_T::TDSTS: TDIF1 Position          */
#define PDMA_TDSTS_TDIF1_Msk             (0x1ul << PDMA_TDSTS_TDIF1_Pos)                   /*!< PDMA_T::TDSTS: TDIF1 Mask              */

#define PDMA_TDSTS_TDIF2_Pos             (2)                                               /*!< PDMA_T::TDSTS: TDIF2 Position          */
#define PDMA_TDSTS_TDIF2_Msk             (0x1ul << PDMA_TDSTS_TDIF2_Pos)                   /*!< PDMA_T::TDSTS: TDIF2 Mask              */

#define PDMA_TDSTS_TDIF3_Pos             (3)                                               /*!< PDMA_T::TDSTS: TDIF3 Position          */
#define PDMA_TDSTS_TDIF3_Msk             (0x1ul << PDMA_TDSTS_TDIF3_Pos)                   /*!< PDMA_T::TDSTS: TDIF3 Mask              */

#define PDMA_TDSTS_TDIF4_Pos             (4)                                               /*!< PDMA_T::TDSTS: TDIF4 Position          */
#define PDMA_TDSTS_TDIF4_Msk             (0x1ul << PDMA_TDSTS_TDIF4_Pos)                   /*!< PDMA_T::TDSTS: TDIF4 Mask              */

#define PDMA_TDSTS_TDIF5_Pos             (5)                                               /*!< PDMA_T::TDSTS: TDIF5 Position          */
#define PDMA_TDSTS_TDIF5_Msk             (0x1ul << PDMA_TDSTS_TDIF5_Pos)                   /*!< PDMA_T::TDSTS: TDIF5 Mask              */

#define PDMA_TDSTS_TDIF6_Pos             (6)                                               /*!< PDMA_T::TDSTS: TDIF6 Position          */
#define PDMA_TDSTS_TDIF6_Msk             (0x1ul << PDMA_TDSTS_TDIF6_Pos)                   /*!< PDMA_T::TDSTS: TDIF6 Mask              */

#define PDMA_TDSTS_TDIF7_Pos             (7)                                               /*!< PDMA_T::TDSTS: TDIF7 Position          */
#define PDMA_TDSTS_TDIF7_Msk             (0x1ul << PDMA_TDSTS_TDIF7_Pos)                   /*!< PDMA_T::TDSTS: TDIF7 Mask              */

#define PDMA_TDSTS_TDIF8_Pos             (8)                                               /*!< PDMA_T::TDSTS: TDIF8 Position          */
#define PDMA_TDSTS_TDIF8_Msk             (0x1ul << PDMA_TDSTS_TDIF8_Pos)                   /*!< PDMA_T::TDSTS: TDIF8 Mask              */

#define PDMA_TDSTS_TDIF9_Pos             (9)                                               /*!< PDMA_T::TDSTS: TDIF9 Position          */
#define PDMA_TDSTS_TDIF9_Msk             (0x1ul << PDMA_TDSTS_TDIF9_Pos)                   /*!< PDMA_T::TDSTS: TDIF9 Mask              */

#define PDMA_TDSTS_TDIF10_Pos            (10)                                              /*!< PDMA_T::TDSTS: TDIF10 Position         */
#define PDMA_TDSTS_TDIF10_Msk            (0x1ul << PDMA_TDSTS_TDIF10_Pos)                  /*!< PDMA_T::TDSTS: TDIF10 Mask             */

#define PDMA_TDSTS_TDIF11_Pos            (11)                                              /*!< PDMA_T::TDSTS: TDIF11 Position         */
#define PDMA_TDSTS_TDIF11_Msk            (0x1ul << PDMA_TDSTS_TDIF11_Pos)                  /*!< PDMA_T::TDSTS: TDIF11 Mask             */

#define PDMA_TDSTS_TDIF12_Pos            (12)                                              /*!< PDMA_T::TDSTS: TDIF12 Position         */
#define PDMA_TDSTS_TDIF12_Msk            (0x1ul << PDMA_TDSTS_TDIF12_Pos)                  /*!< PDMA_T::TDSTS: TDIF12 Mask             */

#define PDMA_TDSTS_TDIF13_Pos            (13)                                              /*!< PDMA_T::TDSTS: TDIF13 Position         */
#define PDMA_TDSTS_TDIF13_Msk            (0x1ul << PDMA_TDSTS_TDIF13_Pos)                  /*!< PDMA_T::TDSTS: TDIF13 Mask             */

#define PDMA_TDSTS_TDIF14_Pos            (14)                                              /*!< PDMA_T::TDSTS: TDIF14 Position         */
#define PDMA_TDSTS_TDIF14_Msk            (0x1ul << PDMA_TDSTS_TDIF14_Pos)                  /*!< PDMA_T::TDSTS: TDIF14 Mask             */

#define PDMA_TDSTS_TDIF15_Pos            (15)                                              /*!< PDMA_T::TDSTS: TDIF15 Position         */
#define PDMA_TDSTS_TDIF15_Msk            (0x1ul << PDMA_TDSTS_TDIF15_Pos)                  /*!< PDMA_T::TDSTS: TDIF15 Mask             */

#define PDMA_ALIGN_ALIGN0_Pos            (0)                                               /*!< PDMA_T::ALIGN: ALIGN0 Position         */
#define PDMA_ALIGN_ALIGN0_Msk            (0x1ul << PDMA_ALIGN_ALIGN0_Pos)                  /*!< PDMA_T::ALIGN: ALIGN0 Mask             */

#define PDMA_ALIGN_ALIGN1_Pos            (1)                                               /*!< PDMA_T::ALIGN: ALIGN1 Position         */
#define PDMA_ALIGN_ALIGN1_Msk            (0x1ul << PDMA_ALIGN_ALIGN1_Pos)                  /*!< PDMA_T::ALIGN: ALIGN1 Mask             */

#define PDMA_ALIGN_ALIGN2_Pos            (2)                                               /*!< PDMA_T::ALIGN: ALIGN2 Position         */
#define PDMA_ALIGN_ALIGN2_Msk            (0x1ul << PDMA_ALIGN_ALIGN2_Pos)                  /*!< PDMA_T::ALIGN: ALIGN2 Mask             */

#define PDMA_ALIGN_ALIGN3_Pos            (3)                                               /*!< PDMA_T::ALIGN: ALIGN3 Position         */
#define PDMA_ALIGN_ALIGN3_Msk            (0x1ul << PDMA_ALIGN_ALIGN3_Pos)                  /*!< PDMA_T::ALIGN: ALIGN3 Mask             */

#define PDMA_ALIGN_ALIGN4_Pos            (4)                                               /*!< PDMA_T::ALIGN: ALIGN4 Position         */
#define PDMA_ALIGN_ALIGN4_Msk            (0x1ul << PDMA_ALIGN_ALIGN4_Pos)                  /*!< PDMA_T::ALIGN: ALIGN4 Mask             */

#define PDMA_ALIGN_ALIGN5_Pos            (5)                                               /*!< PDMA_T::ALIGN: ALIGN5 Position         */
#define PDMA_ALIGN_ALIGN5_Msk            (0x1ul << PDMA_ALIGN_ALIGN5_Pos)                  /*!< PDMA_T::ALIGN: ALIGN5 Mask             */

#define PDMA_ALIGN_ALIGN6_Pos            (6)                                               /*!< PDMA_T::ALIGN: ALIGN6 Position         */
#define PDMA_ALIGN_ALIGN6_Msk            (0x1ul << PDMA_ALIGN_ALIGN6_Pos)                  /*!< PDMA_T::ALIGN: ALIGN6 Mask             */

#define PDMA_ALIGN_ALIGN7_Pos            (7)                                               /*!< PDMA_T::ALIGN: ALIGN7 Position         */
#define PDMA_ALIGN_ALIGN7_Msk            (0x1ul << PDMA_ALIGN_ALIGN7_Pos)                  /*!< PDMA_T::ALIGN: ALIGN7 Mask             */

#define PDMA_ALIGN_ALIGN8_Pos            (8)                                               /*!< PDMA_T::ALIGN: ALIGN8 Position         */
#define PDMA_ALIGN_ALIGN8_Msk            (0x1ul << PDMA_ALIGN_ALIGN8_Pos)                  /*!< PDMA_T::ALIGN: ALIGN8 Mask             */

#define PDMA_ALIGN_ALIGN9_Pos            (9)                                               /*!< PDMA_T::ALIGN: ALIGN9 Position         */
#define PDMA_ALIGN_ALIGN9_Msk            (0x1ul << PDMA_ALIGN_ALIGN9_Pos)                  /*!< PDMA_T::ALIGN: ALIGN9 Mask             */

#define PDMA_ALIGN_ALIGN10_Pos           (10)                                              /*!< PDMA_T::ALIGN: ALIGN10 Position        */
#define PDMA_ALIGN_ALIGN10_Msk           (0x1ul << PDMA_ALIGN_ALIGN10_Pos)                 /*!< PDMA_T::ALIGN: ALIGN10 Mask            */

#define PDMA_ALIGN_ALIGN11_Pos           (11)                                              /*!< PDMA_T::ALIGN: ALIGN11 Position        */
#define PDMA_ALIGN_ALIGN11_Msk           (0x1ul << PDMA_ALIGN_ALIGN11_Pos)                 /*!< PDMA_T::ALIGN: ALIGN11 Mask            */

#define PDMA_ALIGN_ALIGN12_Pos           (12)                                              /*!< PDMA_T::ALIGN: ALIGN12 Position        */
#define PDMA_ALIGN_ALIGN12_Msk           (0x1ul << PDMA_ALIGN_ALIGN12_Pos)                 /*!< PDMA_T::ALIGN: ALIGN12 Mask            */

#define PDMA_ALIGN_ALIGN13_Pos           (13)                                              /*!< PDMA_T::ALIGN: ALIGN13 Position        */
#define PDMA_ALIGN_ALIGN13_Msk           (0x1ul << PDMA_ALIGN_ALIGN13_Pos)                 /*!< PDMA_T::ALIGN: ALIGN13 Mask            */

#define PDMA_ALIGN_ALIGN14_Pos           (14)                                              /*!< PDMA_T::ALIGN: ALIGN14 Position        */
#define PDMA_ALIGN_ALIGN14_Msk           (0x1ul << PDMA_ALIGN_ALIGN14_Pos)                 /*!< PDMA_T::ALIGN: ALIGN14 Mask            */

#define PDMA_ALIGN_ALIGN15_Pos           (15)                                              /*!< PDMA_T::ALIGN: ALIGN15 Position        */
#define PDMA_ALIGN_ALIGN15_Msk           (0x1ul << PDMA_ALIGN_ALIGN15_Pos)                 /*!< PDMA_T::ALIGN: ALIGN15 Mask            */

#define PDMA_TACTSTS_TXACTF0_Pos         (0)                                               /*!< PDMA_T::TACTSTS: TXACTF0 Position      */
#define PDMA_TACTSTS_TXACTF0_Msk         (0x1ul << PDMA_TACTSTS_TXACTF0_Pos)               /*!< PDMA_T::TACTSTS: TXACTF0 Mask          */

#define PDMA_TACTSTS_TXACTF1_Pos         (1)                                               /*!< PDMA_T::TACTSTS: TXACTF1 Position      */
#define PDMA_TACTSTS_TXACTF1_Msk         (0x1ul << PDMA_TACTSTS_TXACTF1_Pos)               /*!< PDMA_T::TACTSTS: TXACTF1 Mask          */

#define PDMA_TACTSTS_TXACTF2_Pos         (2)                                               /*!< PDMA_T::TACTSTS: TXACTF2 Position      */
#define PDMA_TACTSTS_TXACTF2_Msk         (0x1ul << PDMA_TACTSTS_TXACTF2_Pos)               /*!< PDMA_T::TACTSTS: TXACTF2 Mask          */

#define PDMA_TACTSTS_TXACTF3_Pos         (3)                                               /*!< PDMA_T::TACTSTS: TXACTF3 Position      */
#define PDMA_TACTSTS_TXACTF3_Msk         (0x1ul << PDMA_TACTSTS_TXACTF3_Pos)               /*!< PDMA_T::TACTSTS: TXACTF3 Mask          */

#define PDMA_TACTSTS_TXACTF4_Pos         (4)                                               /*!< PDMA_T::TACTSTS: TXACTF4 Position      */
#define PDMA_TACTSTS_TXACTF4_Msk         (0x1ul << PDMA_TACTSTS_TXACTF4_Pos)               /*!< PDMA_T::TACTSTS: TXACTF4 Mask          */

#define PDMA_TACTSTS_TXACTF5_Pos         (5)                                               /*!< PDMA_T::TACTSTS: TXACTF5 Position      */
#define PDMA_TACTSTS_TXACTF5_Msk         (0x1ul << PDMA_TACTSTS_TXACTF5_Pos)               /*!< PDMA_T::TACTSTS: TXACTF5 Mask          */

#define PDMA_TACTSTS_TXACTF6_Pos         (6)                                               /*!< PDMA_T::TACTSTS: TXACTF6 Position      */
#define PDMA_TACTSTS_TXACTF6_Msk         (0x1ul << PDMA_TACTSTS_TXACTF6_Pos)               /*!< PDMA_T::TACTSTS: TXACTF6 Mask          */

#define PDMA_TACTSTS_TXACTF7_Pos         (7)                                               /*!< PDMA_T::TACTSTS: TXACTF7 Position      */
#define PDMA_TACTSTS_TXACTF7_Msk         (0x1ul << PDMA_TACTSTS_TXACTF7_Pos)               /*!< PDMA_T::TACTSTS: TXACTF7 Mask          */

#define PDMA_TACTSTS_TXACTF8_Pos         (8)                                               /*!< PDMA_T::TACTSTS: TXACTF8 Position      */
#define PDMA_TACTSTS_TXACTF8_Msk         (0x1ul << PDMA_TACTSTS_TXACTF8_Pos)               /*!< PDMA_T::TACTSTS: TXACTF8 Mask          */

#define PDMA_TACTSTS_TXACTF9_Pos         (9)                                               /*!< PDMA_T::TACTSTS: TXACTF9 Position      */
#define PDMA_TACTSTS_TXACTF9_Msk         (0x1ul << PDMA_TACTSTS_TXACTF9_Pos)               /*!< PDMA_T::TACTSTS: TXACTF9 Mask          */

#define PDMA_TACTSTS_TXACTF10_Pos        (10)                                              /*!< PDMA_T::TACTSTS: TXACTF10 Position     */
#define PDMA_TACTSTS_TXACTF10_Msk        (0x1ul << PDMA_TACTSTS_TXACTF10_Pos)              /*!< PDMA_T::TACTSTS: TXACTF10 Mask         */

#define PDMA_TACTSTS_TXACTF11_Pos        (11)                                              /*!< PDMA_T::TACTSTS: TXACTF11 Position     */
#define PDMA_TACTSTS_TXACTF11_Msk        (0x1ul << PDMA_TACTSTS_TXACTF11_Pos)              /*!< PDMA_T::TACTSTS: TXACTF11 Mask         */

#define PDMA_TACTSTS_TXACTF12_Pos        (12)                                              /*!< PDMA_T::TACTSTS: TXACTF12 Position     */
#define PDMA_TACTSTS_TXACTF12_Msk        (0x1ul << PDMA_TACTSTS_TXACTF12_Pos)              /*!< PDMA_T::TACTSTS: TXACTF12 Mask         */

#define PDMA_TACTSTS_TXACTF13_Pos        (13)                                              /*!< PDMA_T::TACTSTS: TXACTF13 Position     */
#define PDMA_TACTSTS_TXACTF13_Msk        (0x1ul << PDMA_TACTSTS_TXACTF13_Pos)              /*!< PDMA_T::TACTSTS: TXACTF13 Mask         */

#define PDMA_TACTSTS_TXACTF14_Pos        (14)                                              /*!< PDMA_T::TACTSTS: TXACTF14 Position     */
#define PDMA_TACTSTS_TXACTF14_Msk        (0x1ul << PDMA_TACTSTS_TXACTF14_Pos)              /*!< PDMA_T::TACTSTS: TXACTF14 Mask         */

#define PDMA_TACTSTS_TXACTF15_Pos        (15)                                              /*!< PDMA_T::TACTSTS: TXACTF15 Position     */
#define PDMA_TACTSTS_TXACTF15_Msk        (0x1ul << PDMA_TACTSTS_TXACTF15_Pos)              /*!< PDMA_T::TACTSTS: TXACTF15 Mask         */

#define PDMA_TOUTPSC_TOUTPSC0_Pos        (0)                                               /*!< PDMA_T::TOUTPSC: TOUTPSC0 Position     */
#define PDMA_TOUTPSC_TOUTPSC0_Msk        (0x7ul << PDMA_TOUTPSC_TOUTPSC0_Pos)              /*!< PDMA_T::TOUTPSC: TOUTPSC0 Mask         */

#define PDMA_TOUTPSC_TOUTPSC1_Pos        (4)                                               /*!< PDMA_T::TOUTPSC: TOUTPSC1 Position     */
#define PDMA_TOUTPSC_TOUTPSC1_Msk        (0x7ul << PDMA_TOUTPSC_TOUTPSC1_Pos)              /*!< PDMA_T::TOUTPSC: TOUTPSC1 Mask         */

#define PDMA_TOUTEN_TOUTEN0_Pos          (0)                                               /*!< PDMA_T::TOUTEN: TOUTEN0 Position       */
#define PDMA_TOUTEN_TOUTEN0_Msk          (0x1ul << PDMA_TOUTEN_TOUTEN0_Pos)                /*!< PDMA_T::TOUTEN: TOUTEN0 Mask           */

#define PDMA_TOUTEN_TOUTEN1_Pos          (1)                                               /*!< PDMA_T::TOUTEN: TOUTEN1 Position       */
#define PDMA_TOUTEN_TOUTEN1_Msk          (0x1ul << PDMA_TOUTEN_TOUTEN1_Pos)                /*!< PDMA_T::TOUTEN: TOUTEN1 Mask           */

#define PDMA_TOUTIEN_TOUTIEN0_Pos        (0)                                               /*!< PDMA_T::TOUTIEN: TOUTIEN0 Position     */
#define PDMA_TOUTIEN_TOUTIEN0_Msk        (0x1ul << PDMA_TOUTIEN_TOUTIEN0_Pos)              /*!< PDMA_T::TOUTIEN: TOUTIEN0 Mask         */

#define PDMA_TOUTIEN_TOUTIEN1_Pos        (1)                                               /*!< PDMA_T::TOUTIEN: TOUTIEN1 Position     */
#define PDMA_TOUTIEN_TOUTIEN1_Msk        (0x1ul << PDMA_TOUTIEN_TOUTIEN1_Pos)              /*!< PDMA_T::TOUTIEN: TOUTIEN1 Mask         */

#define PDMA_SCATBA_SCATBA_Pos           (16)                                              /*!< PDMA_T::SCATBA: SCATBA Position        */
#define PDMA_SCATBA_SCATBA_Msk           (0xfffful << PDMA_SCATBA_SCATBA_Pos)              /*!< PDMA_T::SCATBA: SCATBA Mask            */

#define PDMA_TOC0_1_TOC0_Pos             (0)                                               /*!< PDMA_T::TOC0_1: TOC0 Position          */
#define PDMA_TOC0_1_TOC0_Msk             (0xfffful << PDMA_TOC0_1_TOC0_Pos)                /*!< PDMA_T::TOC0_1: TOC0 Mask              */

#define PDMA_TOC0_1_TOC1_Pos             (16)                                              /*!< PDMA_T::TOC0_1: TOC1 Position          */
#define PDMA_TOC0_1_TOC1_Msk             (0xfffful << PDMA_TOC0_1_TOC1_Pos)                /*!< PDMA_T::TOC0_1: TOC1 Mask              */

#define PDMA_CHRST_CH0RST_Pos            (0)                                               /*!< PDMA_T::CHRST: CH0RST Position         */
#define PDMA_CHRST_CH0RST_Msk            (0x1ul << PDMA_CHRST_CH0RST_Pos)                  /*!< PDMA_T::CHRST: CH0RST Mask             */

#define PDMA_CHRST_CH1RST_Pos            (1)                                               /*!< PDMA_T::CHRST: CH1RST Position         */
#define PDMA_CHRST_CH1RST_Msk            (0x1ul << PDMA_CHRST_CH1RST_Pos)                  /*!< PDMA_T::CHRST: CH1RST Mask             */

#define PDMA_CHRST_CH2RST_Pos            (2)                                               /*!< PDMA_T::CHRST: CH2RST Position         */
#define PDMA_CHRST_CH2RST_Msk            (0x1ul << PDMA_CHRST_CH2RST_Pos)                  /*!< PDMA_T::CHRST: CH2RST Mask             */

#define PDMA_CHRST_CH3RST_Pos            (3)                                               /*!< PDMA_T::CHRST: CH3RST Position         */
#define PDMA_CHRST_CH3RST_Msk            (0x1ul << PDMA_CHRST_CH3RST_Pos)                  /*!< PDMA_T::CHRST: CH3RST Mask             */

#define PDMA_CHRST_CH4RST_Pos            (4)                                               /*!< PDMA_T::CHRST: CH4RST Position         */
#define PDMA_CHRST_CH4RST_Msk            (0x1ul << PDMA_CHRST_CH4RST_Pos)                  /*!< PDMA_T::CHRST: CH4RST Mask             */

#define PDMA_CHRST_CH5RST_Pos            (5)                                               /*!< PDMA_T::CHRST: CH5RST Position         */
#define PDMA_CHRST_CH5RST_Msk            (0x1ul << PDMA_CHRST_CH5RST_Pos)                  /*!< PDMA_T::CHRST: CH5RST Mask             */

#define PDMA_CHRST_CH6RST_Pos            (6)                                               /*!< PDMA_T::CHRST: CH6RST Position         */
#define PDMA_CHRST_CH6RST_Msk            (0x1ul << PDMA_CHRST_CH6RST_Pos)                  /*!< PDMA_T::CHRST: CH6RST Mask             */

#define PDMA_CHRST_CH7RST_Pos            (7)                                               /*!< PDMA_T::CHRST: CH7RST Position         */
#define PDMA_CHRST_CH7RST_Msk            (0x1ul << PDMA_CHRST_CH7RST_Pos)                  /*!< PDMA_T::CHRST: CH7RST Mask             */

#define PDMA_CHRST_CH8RST_Pos            (8)                                               /*!< PDMA_T::CHRST: CH8RST Position         */
#define PDMA_CHRST_CH8RST_Msk            (0x1ul << PDMA_CHRST_CH8RST_Pos)                  /*!< PDMA_T::CHRST: CH8RST Mask             */

#define PDMA_CHRST_CH9RST_Pos            (9)                                               /*!< PDMA_T::CHRST: CH9RST Position         */
#define PDMA_CHRST_CH9RST_Msk            (0x1ul << PDMA_CHRST_CH9RST_Pos)                  /*!< PDMA_T::CHRST: CH9RST Mask             */

#define PDMA_CHRST_CH10RST_Pos           (10)                                              /*!< PDMA_T::CHRST: CH10RST Position        */
#define PDMA_CHRST_CH10RST_Msk           (0x1ul << PDMA_CHRST_CH10RST_Pos)                 /*!< PDMA_T::CHRST: CH10RST Mask            */

#define PDMA_CHRST_CH11RST_Pos           (11)                                              /*!< PDMA_T::CHRST: CH11RST Position        */
#define PDMA_CHRST_CH11RST_Msk           (0x1ul << PDMA_CHRST_CH11RST_Pos)                 /*!< PDMA_T::CHRST: CH11RST Mask            */

#define PDMA_CHRST_CH12RST_Pos           (12)                                              /*!< PDMA_T::CHRST: CH12RST Position        */
#define PDMA_CHRST_CH12RST_Msk           (0x1ul << PDMA_CHRST_CH12RST_Pos)                 /*!< PDMA_T::CHRST: CH12RST Mask            */

#define PDMA_CHRST_CH13RST_Pos           (13)                                              /*!< PDMA_T::CHRST: CH13RST Position        */
#define PDMA_CHRST_CH13RST_Msk           (0x1ul << PDMA_CHRST_CH13RST_Pos)                 /*!< PDMA_T::CHRST: CH13RST Mask            */

#define PDMA_CHRST_CH14RST_Pos           (14)                                              /*!< PDMA_T::CHRST: CH14RST Position        */
#define PDMA_CHRST_CH14RST_Msk           (0x1ul << PDMA_CHRST_CH14RST_Pos)                 /*!< PDMA_T::CHRST: CH14RST Mask            */

#define PDMA_CHRST_CH15RST_Pos           (15)                                              /*!< PDMA_T::CHRST: CH15RST Position        */
#define PDMA_CHRST_CH15RST_Msk           (0x1ul << PDMA_CHRST_CH15RST_Pos)                 /*!< PDMA_T::CHRST: CH15RST Mask            */

#define PDMA_REQSEL0_3_REQSRC0_Pos       (0)                                               /*!< PDMA_T::REQSEL0_3: REQSRC0 Position    */
#define PDMA_REQSEL0_3_REQSRC0_Msk       (0x3ful << PDMA_REQSEL0_3_REQSRC0_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC0 Mask        */

#define PDMA_REQSEL0_3_REQSRC1_Pos       (8)                                               /*!< PDMA_T::REQSEL0_3: REQSRC1 Position    */
#define PDMA_REQSEL0_3_REQSRC1_Msk       (0x3ful << PDMA_REQSEL0_3_REQSRC1_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC1 Mask        */

#define PDMA_REQSEL0_3_REQSRC2_Pos       (16)                                              /*!< PDMA_T::REQSEL0_3: REQSRC2 Position    */
#define PDMA_REQSEL0_3_REQSRC2_Msk       (0x3ful << PDMA_REQSEL0_3_REQSRC2_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC2 Mask        */

#define PDMA_REQSEL0_3_REQSRC3_Pos       (24)                                              /*!< PDMA_T::REQSEL0_3: REQSRC3 Position    */
#define PDMA_REQSEL0_3_REQSRC3_Msk       (0x3ful << PDMA_REQSEL0_3_REQSRC3_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC3 Mask        */

#define PDMA_REQSEL4_7_REQSRC4_Pos       (0)                                               /*!< PDMA_T::REQSEL4_7: REQSRC4 Position    */
#define PDMA_REQSEL4_7_REQSRC4_Msk       (0x1ful << PDMA_REQSEL4_7_REQSRC4_Pos)            /*!< PDMA_T::REQSEL4_7: REQSRC4 Mask        */

#define PDMA_REQSEL4_7_REQSRC5_Pos       (8)                                               /*!< PDMA_T::REQSEL4_7: REQSRC5 Position    */
#define PDMA_REQSEL4_7_REQSRC5_Msk       (0x1ful << PDMA_REQSEL4_7_REQSRC5_Pos)            /*!< PDMA_T::REQSEL4_7: REQSRC5 Mask        */

#define PDMA_REQSEL4_7_REQSRC6_Pos       (16)                                              /*!< PDMA_T::REQSEL4_7: REQSRC6 Position    */
#define PDMA_REQSEL4_7_REQSRC6_Msk       (0x1ful << PDMA_REQSEL4_7_REQSRC6_Pos)            /*!< PDMA_T::REQSEL4_7: REQSRC6 Mask        */

#define PDMA_REQSEL4_7_REQSRC7_Pos       (24)                                              /*!< PDMA_T::REQSEL4_7: REQSRC7 Position    */
#define PDMA_REQSEL4_7_REQSRC7_Msk       (0x1ful << PDMA_REQSEL4_7_REQSRC7_Pos)            /*!< PDMA_T::REQSEL4_7: REQSRC7 Mask        */

#define PDMA_REQSEL8_11_REQSRC8_Pos      (0)                                               /*!< PDMA_T::REQSEL8_11: REQSRC8 Position   */
#define PDMA_REQSEL8_11_REQSRC8_Msk      (0x1ful << PDMA_REQSEL8_11_REQSRC8_Pos)           /*!< PDMA_T::REQSEL8_11: REQSRC8 Mask       */

#define PDMA_REQSEL8_11_REQSRC9_Pos      (8)                                               /*!< PDMA_T::REQSEL8_11: REQSRC9 Position   */
#define PDMA_REQSEL8_11_REQSRC9_Msk      (0x1ful << PDMA_REQSEL8_11_REQSRC9_Pos)           /*!< PDMA_T::REQSEL8_11: REQSRC9 Mask       */

#define PDMA_REQSEL8_11_REQSRC10_Pos     (16)                                              /*!< PDMA_T::REQSEL8_11: REQSRC10 Position  */
#define PDMA_REQSEL8_11_REQSRC10_Msk     (0x1ful << PDMA_REQSEL8_11_REQSRC10_Pos)          /*!< PDMA_T::REQSEL8_11: REQSRC10 Mask      */

#define PDMA_REQSEL8_11_REQSRC11_Pos     (24)                                              /*!< PDMA_T::REQSEL8_11: REQSRC11 Position  */
#define PDMA_REQSEL8_11_REQSRC11_Msk     (0x1ful << PDMA_REQSEL8_11_REQSRC11_Pos)          /*!< PDMA_T::REQSEL8_11: REQSRC11 Mask      */

#define PDMA_REQSEL12_15_REQSRC12_Pos    (0)                                               /*!< PDMA_T::REQSEL12_15: REQSRC12 Position */
#define PDMA_REQSEL12_15_REQSRC12_Msk    (0x1ful << PDMA_REQSEL12_15_REQSRC12_Pos)         /*!< PDMA_T::REQSEL12_15: REQSRC12 Mask     */

#define PDMA_REQSEL12_15_REQSRC13_Pos    (8)                                               /*!< PDMA_T::REQSEL12_15: REQSRC13 Position */
#define PDMA_REQSEL12_15_REQSRC13_Msk    (0x1ful << PDMA_REQSEL12_15_REQSRC13_Pos)         /*!< PDMA_T::REQSEL12_15: REQSRC13 Mask     */

#define PDMA_REQSEL12_15_REQSRC14_Pos    (16)                                              /*!< PDMA_T::REQSEL12_15: REQSRC14 Position */
#define PDMA_REQSEL12_15_REQSRC14_Msk    (0x1ful << PDMA_REQSEL12_15_REQSRC14_Pos)         /*!< PDMA_T::REQSEL12_15: REQSRC14 Mask     */

#define PDMA_REQSEL12_15_REQSRC15_Pos    (24)                                              /*!< PDMA_T::REQSEL12_15: REQSRC15 Position */
#define PDMA_REQSEL12_15_REQSRC15_Msk    (0x1ful << PDMA_REQSEL12_15_REQSRC15_Pos)         /*!< PDMA_T::REQSEL12_15: REQSRC15 Mask     */

#define PDMA_STCR0_STC_Pos               (0)                                               /*!< PDMA_T::STCR0: STC Position            */
#define PDMA_STCR0_STC_Msk               (0xfffful << PDMA_STCR0_STC_Pos)                  /*!< PDMA_T::STCR0: STC Mask                */

#define PDMA_ASOCR0_SASOL_Pos            (0)                                               /*!< PDMA_T::ASOCR0: SASOL Position         */
#define PDMA_ASOCR0_SASOL_Msk            (0xfffful << PDMA_ASOCR0_SASOL_Pos)               /*!< PDMA_T::ASOCR0: SASOL Mask             */

#define PDMA_ASOCR0_DASOL_Pos            (16)                                              /*!< PDMA_T::ASOCR0: DASOL Position         */
#define PDMA_ASOCR0_DASOL_Msk            (0xfffful << PDMA_ASOCR0_DASOL_Pos)               /*!< PDMA_T::ASOCR0: DASOL Mask             */

#define PDMA_STCR1_STC_Pos               (0)                                               /*!< PDMA_T::STCR1: STC Position            */
#define PDMA_STCR1_STC_Msk               (0xfffful << PDMA_STCR1_STC_Pos)                  /*!< PDMA_T::STCR1: STC Mask                */

#define PDMA_ASOCR1_SASOL_Pos            (0)                                               /*!< PDMA_T::ASOCR1: SASOL Position         */
#define PDMA_ASOCR1_SASOL_Msk            (0xfffful << PDMA_ASOCR1_SASOL_Pos)               /*!< PDMA_T::ASOCR1: SASOL Mask             */

#define PDMA_ASOCR1_DASOL_Pos            (16)                                              /*!< PDMA_T::ASOCR1: DASOL Position         */
#define PDMA_ASOCR1_DASOL_Msk            (0xfffful << PDMA_ASOCR1_DASOL_Pos)               /*!< PDMA_T::ASOCR1: DASOL Mask             */

#define PDMA_STCR2_STC_Pos               (0)                                               /*!< PDMA_T::STCR2: STC Position            */
#define PDMA_STCR2_STC_Msk               (0xfffful << PDMA_STCR2_STC_Pos)                  /*!< PDMA_T::STCR2: STC Mask                */

#define PDMA_ASOCR2_SASOL_Pos            (0)                                               /*!< PDMA_T::ASOCR2: SASOL Position         */
#define PDMA_ASOCR2_SASOL_Msk            (0xfffful << PDMA_ASOCR2_SASOL_Pos)               /*!< PDMA_T::ASOCR2: SASOL Mask             */

#define PDMA_ASOCR2_DASOL_Pos            (16)                                              /*!< PDMA_T::ASOCR2: DASOL Position         */
#define PDMA_ASOCR2_DASOL_Msk            (0xfffful << PDMA_ASOCR2_DASOL_Pos)               /*!< PDMA_T::ASOCR2: DASOL Mask             */

#define PDMA_STCR3_STC_Pos               (0)                                               /*!< PDMA_T::STCR3: STC Position            */
#define PDMA_STCR3_STC_Msk               (0xfffful << PDMA_STCR3_STC_Pos)                  /*!< PDMA_T::STCR3: STC Mask                */

#define PDMA_ASOCR3_SASOL_Pos            (0)                                               /*!< PDMA_T::ASOCR3: SASOL Position         */
#define PDMA_ASOCR3_SASOL_Msk            (0xfffful << PDMA_ASOCR3_SASOL_Pos)               /*!< PDMA_T::ASOCR3: SASOL Mask             */

#define PDMA_ASOCR3_DASOL_Pos            (16)                                              /*!< PDMA_T::ASOCR3: DASOL Position         */
#define PDMA_ASOCR3_DASOL_Msk            (0xfffful << PDMA_ASOCR3_DASOL_Pos)               /*!< PDMA_T::ASOCR3: DASOL Mask             */

#define PDMA_STCR4_STC_Pos               (0)                                               /*!< PDMA_T::STCR4: STC Position            */
#define PDMA_STCR4_STC_Msk               (0xfffful << PDMA_STCR4_STC_Pos)                  /*!< PDMA_T::STCR4: STC Mask                */

#define PDMA_ASOCR4_SASOL_Pos            (0)                                               /*!< PDMA_T::ASOCR4: SASOL Position         */
#define PDMA_ASOCR4_SASOL_Msk            (0xfffful << PDMA_ASOCR4_SASOL_Pos)               /*!< PDMA_T::ASOCR4: SASOL Mask             */

#define PDMA_ASOCR4_DASOL_Pos            (16)                                              /*!< PDMA_T::ASOCR4: DASOL Position         */
#define PDMA_ASOCR4_DASOL_Msk            (0xfffful << PDMA_ASOCR4_DASOL_Pos)               /*!< PDMA_T::ASOCR4: DASOL Mask             */

#define PDMA_STCR5_STC_Pos               (0)                                               /*!< PDMA_T::STCR5: STC Position            */
#define PDMA_STCR5_STC_Msk               (0xfffful << PDMA_STCR5_STC_Pos)                  /*!< PDMA_T::STCR5: STC Mask                */

#define PDMA_ASOCR5_SASOL_Pos            (0)                                               /*!< PDMA_T::ASOCR5: SASOL Position         */
#define PDMA_ASOCR5_SASOL_Msk            (0xfffful << PDMA_ASOCR5_SASOL_Pos)               /*!< PDMA_T::ASOCR5: SASOL Mask             */

#define PDMA_ASOCR5_DASOL_Pos            (16)                                              /*!< PDMA_T::ASOCR5: DASOL Position         */
#define PDMA_ASOCR5_DASOL_Msk            (0xfffful << PDMA_ASOCR5_DASOL_Pos)               /*!< PDMA_T::ASOCR5: DASOL Mask             */

#define PDMA_VERSION_MINOR_Pos           (0)                                               /*!< PDMA_T::VERSION: MINOR Position        */
#define PDMA_VERSION_MINOR_Msk           (0xfffful << PDMA_VERSION_MINOR_Pos)              /*!< PDMA_T::VERSION: MINOR Mask            */

#define PDMA_VERSION_SUB_Pos             (16)                                              /*!< PDMA_T::VERSION: SUB Position          */
#define PDMA_VERSION_SUB_Msk             (0xfful << PDMA_VERSION_SUB_Pos)                  /*!< PDMA_T::VERSION: SUB Mask              */

#define PDMA_VERSION_MAJOR_Pos           (24)                                              /*!< PDMA_T::VERSION: MAJOR Position        */
#define PDMA_VERSION_MAJOR_Msk           (0xfful << PDMA_VERSION_MAJOR_Pos)                /*!< PDMA_T::VERSION: MAJOR Mask            */

/**@}*/ /* PDMA_CONST */
/**@}*/ /* end of PDMA register group */


/*---------------------- Pulse Width Modulation Controller -------------------------*/
/**
    @addtogroup PWM Pulse Width Modulation Controller(PWM)
    Memory Mapped Structure for PWM Controller
@{ */
 
typedef struct
{


/**
 * @var PWM_T::CTL0
 * Offset: 0x00  PWM Control Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CTRLD0    |PWM Channel 0 Center Re-load
 * |        |          |In up-down counter type, PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the center point of a period
 * |[1]     |CTRLD1    |PWM Channel 1 Center Re-load
 * |        |          |In up-down counter type, PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the center point of a period
 * |[2]     |CTRLD2    |PWM Channel 2 Center Re-load
 * |        |          |In up-down counter type, PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the center point of a period
 * |[3]     |CTRLD3    |PWM Channel 3 Center Re-load
 * |        |          |In up-down counter type, PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the center point of a period
 * |[4]     |CTRLD4    |PWM Channel 4 Center Re-load
 * |        |          |In up-down counter type, PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the center point of a period
 * |[5]     |CTRLD5    |PWM Channel 5 Center Re-load
 * |        |          |In up-down counter type, PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the center point of a period
 * |[8]     |WINLDEN0  |PWM Channel 0 Window Load Enable Bits
 * |        |          |0 = PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
 * |        |          |1 = PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the end point of each period when valid reload window is set
 * |        |          |The valid reload window is set by software write 1 to PWM_LOAD register and cleared by hardware after load success.
 * |[9]     |WINLDEN1  |PWM Channel 1 Window Load Enable Bits
 * |        |          |0 = PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
 * |        |          |1 = PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the end point of each period when valid reload window is set
 * |        |          |The valid reload window is set by software write 1 to PWM_LOAD register and cleared by hardware after load success.
 * |[10]    |WINLDEN2  |PWM Channel 2 Window Load Enable Bits
 * |        |          |0 = PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
 * |        |          |1 = PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the end point of each period when valid reload window is set
 * |        |          |The valid reload window is set by software write 1 to PWM_LOAD register and cleared by hardware after load success.
 * |[11]    |WINLDEN3  |PWM Channel 3 Window Load Enable Bits
 * |        |          |0 = PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
 * |        |          |1 = PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the end point of each period when valid reload window is set
 * |        |          |The valid reload window is set by software write 1 to PWM_LOAD register and cleared by hardware after load success.
 * |[12]    |WINLDEN4  |PWM Channel 4 Window Load Enable Bits
 * |        |          |0 = PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
 * |        |          |1 = PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the end point of each period when valid reload window is set
 * |        |          |The valid reload window is set by software write 1 to PWM_LOAD register and cleared by hardware after load success.
 * |[13]    |WINLDEN5  |PWM Channel 5 Window Load Enable Bits
 * |        |          |0 = PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
 * |        |          |1 = PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the end point of each period when valid reload window is set
 * |        |          |The valid reload window is set by software write 1 to PWM_LOAD register and cleared by hardware after load success.
 * |[16]    |IMMLDEN0  |PWM Channel 0 Immediately Load Enable Bits
 * |        |          |0 = PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
 * |        |          |1 = PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT.
 * |        |          |Note: If IMMLDEN0 is enabled, WINLDEN0 and CTRLD0 will be invalid.
 * |[17]    |IMMLDEN1  |PWM Channel 1 Immediately Load Enable Bits
 * |        |          |0 = PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
 * |        |          |1 = PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT.
 * |        |          |Note: If IMMLDEN1 is enabled, WINLDEN1 and CTRLD1 will be invalid.
 * |[18]    |IMMLDEN2  |PWM Channel 2 Immediately Load Enable Bits
 * |        |          |0 = PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
 * |        |          |1 = PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT.
 * |        |          |Note: If IMMLDEN2 is enabled, WINLDEN2 and CTRLD2 will be invalid.
 * |[19]    |IMMLDEN3  |PWM Channel 3 Immediately Load Enable Bits
 * |        |          |0 = PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
 * |        |          |1 = PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT.
 * |        |          |Note: If IMMLDEN3 is enabled, WINLDEN3 and CTRLD3 will be invalid.
 * |[20]    |IMMLDEN4  |PWM Channel 4 Immediately Load Enable Bits
 * |        |          |0 = PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
 * |        |          |1 = PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT.
 * |        |          |Note: If IMMLDEN4 is enabled, WINLDEN4 and CTRLD4 will be invalid.
 * |[21]    |IMMLDEN5  |PWM Channel 5 Immediately Load Enable Bits
 * |        |          |0 = PERIOD will load to PBUF at the end point of each period
 * |        |          |CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
 * |        |          |1 = PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT.
 * |        |          |Note: If IMMLDEN5 is enabled, WINLDEN5 and CTRLD5 will be invalid.
 * |[24]    |GROUPEN   |Group Function Enable Bit(S)
 * |        |          |0 = The output waveform of each PWM channel are independent.
 * |        |          |1 = Unify the PWM_CH2 and PWM_CH4 to output the same waveform as PWM_CH0 and unify the PWM_CH3 and PWM_CH5 to output the same waveform as PWM_CH1.
 * |[30]    |DBGHALT   |ICE Debug Mode Counter Halt (Write Protect)
 * |        |          |If counter halt is enabled, PWM all counters will keep current value until exit ICE debug mode.
 * |        |          |0 = ICE debug mode counter halt disable.
 * |        |          |1 = ICE debug mode counter halt enable.
 * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
 * |[31]    |DBGTRIOFF |ICE Debug Mode Acknowledge Disable (Write Protect)
 * |        |          |0 = ICE debug mode acknowledgement effects PWM output.
 * |        |          |PWM pin will be forced as tri-state while ICE debug mode acknowledged.
 * |        |          |1 = ICE debug mode acknowledgement disabled.
 * |        |          |PWM pin will keep output no matter ICE debug mode acknowledged or not.
 * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register. 
 * @var PWM_T::CTL1
 * Offset: 0x04  PWM Control Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |CNTTYPE0  |PWM Channel 0 Counter Behavior Type
 * |        |          |00 = Up counter type (supports in capture mode).
 * |        |          |01 = Down count type (supports in capture mode).
 * |        |          |10 = Up-down counter type.
 * |        |          |11 = Reserved.
 * |[3:2]   |CNTTYPE1  |PWM Channel 1 Counter Behavior Type
 * |        |          |00 = Up counter type (supports in capture mode).
 * |        |          |01 = Down count type (supports in capture mode).
 * |        |          |10 = Up-down counter type.
 * |        |          |11 = Reserved.
 * |[5:4]   |CNTTYPE2  |PWM Channel 2 Counter Behavior Type
 * |        |          |00 = Up counter type (supports in capture mode).
 * |        |          |01 = Down count type (supports in capture mode).
 * |        |          |10 = Up-down counter type.
 * |        |          |11 = Reserved.
 * |[7:6]   |CNTTYPE3  |PWM Channel 3 Counter Behavior Type
 * |        |          |00 = Up counter type (supports in capture mode).
 * |        |          |01 = Down count type (supports in capture mode).
 * |        |          |10 = Up-down counter type.
 * |        |          |11 = Reserved.
 * |[9:8]   |CNTTYPE4  |PWM Channel 4 Counter Behavior Type
 * |        |          |00 = Up counter type (supports in capture mode).
 * |        |          |01 = Down count type (supports in capture mode).
 * |        |          |10 = Up-down counter type.
 * |        |          |11 = Reserved.
 * |[11:10] |CNTTYPE5  |PWM Channel 5 Counter Behavior Type
 * |        |          |00 = Up counter type (supports in capture mode).
 * |        |          |01 = Down count type (supports in capture mode).
 * |        |          |10 = Up-down counter type.
 * |        |          |11 = Reserved.
 * |[16]    |CNTMODE0  |PWM Channel 0 Counter Mode
 * |        |          |0 = Auto-reload mode.
 * |        |          |1 = One-shot mode.
 * |[17]    |CNTMODE1  |PWM Channel 1 Counter Mode
 * |        |          |0 = Auto-reload mode.
 * |        |          |1 = One-shot mode.
 * |[18]    |CNTMODE2  |PWM Channel 2 Counter Mode
 * |        |          |0 = Auto-reload mode.
 * |        |          |1 = One-shot mode.
 * |[19]    |CNTMODE3  |PWM Channel 3 Counter Mode
 * |        |          |0 = Auto-reload mode.
 * |        |          |1 = One-shot mode.
 * |[20]    |CNTMODE4  |PWM Channel 4 Counter Mode
 * |        |          |0 = Auto-reload mode.
 * |        |          |1 = One-shot mode.
 * |[21]    |CNTMODE5  |PWM Channel 5 Counter Mode
 * |        |          |0 = Auto-reload mode.
 * |        |          |1 = One-shot mode.
 * |[24]    |OUTMODE0  |PWM Channel 0 Output Mode
 * |        |          |0 = PWM independent mode.
 * |        |          |1 = PWM complementary mode.
 * |        |          |Note: When operating in group function, these bits must all set to the same mode.
 * |[25]    |OUTMODE2  |PWM Channel 2 Output Mode
 * |        |          |0 = PWM independent mode.
 * |        |          |1 = PWM complementary mode.
 * |        |          |Note: When operating in group function, these bits must all set to the same mode.
 * |[26]    |OUTMODE4  |PWM Channel 4 Output Mode
 * |        |          |0 = PWM independent mode.
 * |        |          |1 = PWM complementary mode.
 * |        |          |Note: When operating in group function, these bits must all set to the same mode.
 * @var PWM_T::SYNC
 * Offset: 0x08  PWM Synchronization Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PHSEN0    |PWM Channel 0 SYNC Phase Enable Bits
 * |        |          |0 = PWM counter disable to load PHS value.
 * |        |          |1 = PWM counter enable to load PHS value.
 * |[1]     |PHSEN2    |PWM Channel 2 SYNC Phase Enable Bits
 * |        |          |0 = PWM counter disable to load PHS value.
 * |        |          |1 = PWM counter enable to load PHS value.
 * |[2]     |PHSEN4    |PWM Channel 4 SYNC Phase Enable Bits
 * |        |          |0 = PWM counter disable to load PHS value.
 * |        |          |1 = PWM counter enable to load PHS value.
 * |[9:8]   |SINSRC0   |PWM Channel 0 PWM0_SYNC_IN Source Selection
 * |        |          |00 = Synchronize source from SYNC_IN or SWSYNC.
 * |        |          |01 = Counter equal to 0.
 * |        |          |10 = Counter equal to PWM_CMPDATm, m denotes 1, 3, 5.
 * |        |          |11 = SYNC_OUT will not be generated. 
 * |[11:10] |SINSRC2   |PWM Channel 2 PWM0_SYNC_IN Source Selection
 * |        |          |00 = Synchronize source from SYNC_IN or SWSYNC.
 * |        |          |01 = Counter equal to 0.
 * |        |          |10 = Counter equal to PWM_CMPDATm, m denotes 1, 3, 5.
 * |        |          |11 = SYNC_OUT will not be generated. 
 * |[13:12] |SINSRC4   |PWM Channel 4 PWM0_SYNC_IN Source Selection
 * |        |          |00 = Synchronize source from SYNC_IN or SWSYNC.
 * |        |          |01 = Counter equal to 0.
 * |        |          |10 = Counter equal to PWM_CMPDATm, m denotes 1, 3, 5.
 * |        |          |11 = SYNC_OUT will not be generated. 
 * |[16]    |SNFLTEN   |PWM0_SYNC_IN Noise Filter Enable Bits
 * |        |          |0 = Noise filter of input pin PWM0_SYNC_IN is Disabled.
 * |        |          |1 = Noise filter of input pin PWM0_SYNC_IN is Enabled.
 * |[19:17] |SFLTCSEL  |SYNC Edge Detector Filter Clock Selection
 * |        |          |000 = Filter clock = HCLK.
 * |        |          |001 = Filter clock = HCLK/2.
 * |        |          |010 = Filter clock = HCLK/4.
 * |        |          |011 = Filter clock = HCLK/8.
 * |        |          |100 = Filter clock = HCLK/16.
 * |        |          |101 = Filter clock = HCLK/32.
 * |        |          |110 = Filter clock = HCLK/64.
 * |        |          |111 = Filter clock = HCLK/128.
 * |[22:20] |SFLTCNT   |SYNC Edge Detector Filter Count
 * |        |          |The register bits control the counter number of edge detector.
 * |[23]    |SINPINV   |SYNC Input Pin Inverse
 * |        |          |0 = The state of pin SYNC is passed to the negative edge detector.
 * |        |          |1 = The inversed state of pin SYNC is passed to the negative edge detector.
 * |[24]    |PHSDIR0   |PWM Channel 0 Phase Direction Control
 * |        |          |0 = Control PWM counter count decrement after synchronizing.
 * |        |          |1 = Control PWM counter count increment after synchronizing.
 * |[25]    |PHSDIR2   |PWM Channel 2 Phase Direction Control
 * |        |          |0 = Control PWM counter count decrement after synchronizing.
 * |        |          |1 = Control PWM counter count increment after synchronizing.
 * |[26]    |PHSDIR4   |PWM Channel 4 Phase Direction Control
 * |        |          |0 = Control PWM counter count decrement after synchronizing.
 * |        |          |1 = Control PWM counter count increment after synchronizing.
 * @var PWM_T::SWSYNC
 * Offset: 0x0C  PWM Software Control Synchronization Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |SWSYNC0   |PWM Channel 0 Software SYNC Function
 * |        |          |When SINSRC0 (PWM_SYNC[9:8]) is selected to 0, SYNC_OUT source is come from SYNC_IN or this bit.
 * |[1]     |SWSYNC2   |PWM Channel 2 Software SYNC Function
 * |        |          |When SINSRC2 (PWM_SYNC[11:10]) is selected to 0, SYNC_OUT source is come from SYNC_IN or this bit.
 * |[2]     |SWSYNC4   |PWM Channel 4 Software SYNC Function
 * |        |          |When SINSRC4 (PWM_SYNC[13:12]) is selected to 0, SYNC_OUT source is come from SYNC_IN or this bit.
 * @var PWM_T::CLKSRC
 * Offset: 0x10  PWM Clock Source Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[2:0]   |ECLKSRC0  |PWM_CH01 External Clock Source Select
 * |        |          |000 = PWM0_CLK.
 * |        |          |001 = TIMER0 overflow.
 * |        |          |010 = TIMER1 overflow.
 * |        |          |011 = TIMER2 overflow.
 * |        |          |100 = TIMER3 overflow.
 * |        |          |Others = Reserved.
 * |[10:8]  |ECLKSRC2  |PWM_CH23 External Clock Source Select
 * |        |          |000 = PWM0_CLK.
 * |        |          |001 = TIMER0 overflow.
 * |        |          |010 = TIMER1 overflow.
 * |        |          |011 = TIMER2 overflow.
 * |        |          |100 = TIMER3 overflow.
 * |        |          |Others = Reserved.
 * |[18:16] |ECLKSRC4  |PWM_CH45 External Clock Source Select
 * |        |          |000 = PWM0_CLK.
 * |        |          |001 = TIMER0 overflow.
 * |        |          |010 = TIMER1 overflow.
 * |        |          |011 = TIMER2 overflow.
 * |        |          |100 = TIMER3 overflow.
 * |        |          |Others = Reserved.
 * @var PWM_T::CLKPSC0_1
 * Offset: 0x14  PWM Clock Pre-scale Register 0/1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-scale
 * |        |          |The clock of PWM counter is decided by clock prescaler
 * |        |          |Each PWM pair share one PWM counter clock prescaler
 * |        |          |The clock of PWM counter is divided by (CLKPSC+ 1)
 * @var PWM_T::CLKPSC2_3
 * Offset: 0x18  PWM Clock Pre-scale Register 2/3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-scale
 * |        |          |The clock of PWM counter is decided by clock prescaler
 * |        |          |Each PWM pair share one PWM counter clock prescaler
 * |        |          |The clock of PWM counter is divided by (CLKPSC+ 1)
 * @var PWM_T::CLKPSC4_5
 * Offset: 0x1C  PWM Clock Pre-scale Register 4/5
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-scale
 * |        |          |The clock of PWM counter is decided by clock prescaler
 * |        |          |Each PWM pair share one PWM counter clock prescaler
 * |        |          |The clock of PWM counter is divided by (CLKPSC+ 1)
 * @var PWM_T::CNTEN
 * Offset: 0x20  PWM Counter Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CNTEN0    |PWM Channel 0 Counter Enable Bits
 * |        |          |0 = PWM Counter and clock prescaler Stop Running.
 * |        |          |1 = PWM Counter and clock prescaler Start Running.
 * |[1]     |CNTEN1    |PWM Channel 1 Counter Enable Bits
 * |        |          |0 = PWM Counter and clock prescaler Stop Running.
 * |        |          |1 = PWM Counter and clock prescaler Start Running.
 * |[2]     |CNTEN2    |PWM Channel 2 Counter Enable Bits
 * |        |          |0 = PWM Counter and clock prescaler Stop Running.
 * |        |          |1 = PWM Counter and clock prescaler Start Running.
 * |[3]     |CNTEN3    |PWM Channel 3 Counter Enable Bits
 * |        |          |0 = PWM Counter and clock prescaler Stop Running.
 * |        |          |1 = PWM Counter and clock prescaler Start Running.
 * |[4]     |CNTEN4    |PWM Channel 4 Counter Enable Bits
 * |        |          |0 = PWM Counter and clock prescaler Stop Running.
 * |        |          |1 = PWM Counter and clock prescaler Start Running.
 * |[5]     |CNTEN5    |PWM Channel 5 Counter Enable Bits
 * |        |          |0 = PWM Counter and clock prescaler Stop Running.
 * |        |          |1 = PWM Counter and clock prescaler Start Running.
 * @var PWM_T::CNTCLR
 * Offset: 0x24  PWM Clear Counter Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CNTCLR0   |PWM Channel 0 Clear PWM Counter Control Bit
 * |        |          |It is automatically cleared by hardware.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear 16-bit PWM counter to 0000H. 
 * |[1]     |CNTCLR1   |PWM Channel 1 Clear PWM Counter Control Bit
 * |        |          |It is automatically cleared by hardware.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear 16-bit PWM counter to 0000H. 
 * |[2]     |CNTCLR2   |PWM Channel 2 Clear PWM Counter Control Bit
 * |        |          |It is automatically cleared by hardware.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear 16-bit PWM counter to 0000H. 
 * |[3]     |CNTCLR3   |PWM Channel 3 Clear PWM Counter Control Bit
 * |        |          |It is automatically cleared by hardware.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear 16-bit PWM counter to 0000H. 
 * |[4]     |CNTCLR4   |PWM Channel 4 Clear PWM Counter Control Bit
 * |        |          |It is automatically cleared by hardware.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear 16-bit PWM counter to 0000H. 
 * |[5]     |CNTCLR5   |PWM Channel 5 Clear PWM Counter Control Bit
 * |        |          |It is automatically cleared by hardware.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear 16-bit PWM counter to 0000H. 
 * @var PWM_T::LOAD
 * Offset: 0x28  PWM Load Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |LOAD0     |PWM Channel 0 Re-load PWM Comparator Register (CMPDAT) Control Bit
 * |        |          |This bit is software write, hardware clear when current PWM period end.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set load window of window loading mode.
 * |        |          |Read Operation:
 * |        |          |0 = No load window is set.
 * |        |          |1 = Load window is set.
 * |        |          |Note: This bit only use in window loading mode, WINLDEN0(PWM_CTL0[8]) = 1.
 * |[1]     |LOAD1     |PWM Channel 1 Re-load PWM Comparator Register (CMPDAT) Control Bit
 * |        |          |This bit is software write, hardware clear when current PWM period end.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set load window of window loading mode.
 * |        |          |Read Operation:
 * |        |          |0 = No load window is set.
 * |        |          |1 = Load window is set.
 * |        |          |Note: This bit only use in window loading mode, WINLDEN1(PWM_CTL0[9]) = 1.
 * |[2]     |LOAD2     |PWM Channel 2 Re-load PWM Comparator Register (CMPDAT) Control Bit
 * |        |          |This bit is software write, hardware clear when current PWM period end.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set load window of window loading mode.
 * |        |          |Read Operation:
 * |        |          |0 = No load window is set.
 * |        |          |1 = Load window is set.
 * |        |          |Note: This bit only use in window loading mode, WINLDEN2(PWM_CTL0[10]) = 1.
 * |[3]     |LOAD3     |PWM Channel 3 Re-load PWM Comparator Register (CMPDAT) Control Bit
 * |        |          |This bit is software write, hardware clear when current PWM period end.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set load window of window loading mode.
 * |        |          |Read Operation:
 * |        |          |0 = No load window is set.
 * |        |          |1 = Load window is set.
 * |        |          |Note: This bit only use in window loading mode, WINLDEN3(PWM_CTL0[11]) = 1.
 * |[4]     |LOAD4     |PWM Channel 4 Re-load PWM Comparator Register (CMPDAT) Control Bit
 * |        |          |This bit is software write, hardware clear when current PWM period end.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set load window of window loading mode.
 * |        |          |Read Operation:
 * |        |          |0 = No load window is set.
 * |        |          |1 = Load window is set.
 * |        |          |Note: This bit only use in window loading mode, WINLDEN4(PWM_CTL0[12]) = 1.
 * |[5]     |LOAD5     |PWM Channel 5 Re-load PWM Comparator Register (CMPDAT) Control Bit
 * |        |          |This bit is software write, hardware clear when current PWM period end.
 * |        |          |Write Operation:
 * |        |          |0 = No effect.
 * |        |          |1 = Set load window of window loading mode.
 * |        |          |Read Operation:
 * |        |          |0 = No load window is set.
 * |        |          |1 = Load window is set.
 * |        |          |Note: This bit only use in window loading mode, WINLDEN5(PWM_CTL0[13]) = 1.
 * @var PWM_T::PERIOD0
 * Offset: 0x30  PWM Period Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PERIOD    |PWM Period Register
 * |        |          |Up-Count mode: In this mode, PWM counter counts from 0 to PERIOD, and restarts from 0.
 * |        |          |Down-Count mode: In this mode, PWM counter counts from PERIOD to 0, and restarts from PERIOD.
 * |        |          |PWM period time = (PERIOD+1) * PWM_CLK period.
 * |        |          |Up-Down-Count mode: In this mode, PWM counter counts from 0 to PERIOD, then decrements to 0 and repeats again.
 * |        |          |PWM period time = 2 * PERIOD * PWM_CLK period.
 * @var PWM_T::PERIOD1
 * Offset: 0x34  PWM Period Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PERIOD    |PWM Period Register
 * |        |          |Up-Count mode: In this mode, PWM counter counts from 0 to PERIOD, and restarts from 0.
 * |        |          |Down-Count mode: In this mode, PWM counter counts from PERIOD to 0, and restarts from PERIOD.
 * |        |          |PWM period time = (PERIOD+1) * PWM_CLK period.
 * |        |          |Up-Down-Count mode: In this mode, PWM counter counts from 0 to PERIOD, then decrements to 0 and repeats again.
 * |        |          |PWM period time = 2 * PERIOD * PWM_CLK period.
 * @var PWM_T::PERIOD2
 * Offset: 0x38  PWM Period Register 2
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PERIOD    |PWM Period Register
 * |        |          |Up-Count mode: In this mode, PWM counter counts from 0 to PERIOD, and restarts from 0.
 * |        |          |Down-Count mode: In this mode, PWM counter counts from PERIOD to 0, and restarts from PERIOD.
 * |        |          |PWM period time = (PERIOD+1) * PWM_CLK period.
 * |        |          |Up-Down-Count mode: In this mode, PWM counter counts from 0 to PERIOD, then decrements to 0 and repeats again.
 * |        |          |PWM period time = 2 * PERIOD * PWM_CLK period.
 * @var PWM_T::PERIOD3
 * Offset: 0x3C  PWM Period Register 3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PERIOD    |PWM Period Register
 * |        |          |Up-Count mode: In this mode, PWM counter counts from 0 to PERIOD, and restarts from 0.
 * |        |          |Down-Count mode: In this mode, PWM counter counts from PERIOD to 0, and restarts from PERIOD.
 * |        |          |PWM period time = (PERIOD+1) * PWM_CLK period.
 * |        |          |Up-Down-Count mode: In this mode, PWM counter counts from 0 to PERIOD, then decrements to 0 and repeats again.
 * |        |          |PWM period time = 2 * PERIOD * PWM_CLK period.
 * @var PWM_T::PERIOD4
 * Offset: 0x40  PWM Period Register 4
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PERIOD    |PWM Period Register
 * |        |          |Up-Count mode: In this mode, PWM counter counts from 0 to PERIOD, and restarts from 0.
 * |        |          |Down-Count mode: In this mode, PWM counter counts from PERIOD to 0, and restarts from PERIOD.
 * |        |          |PWM period time = (PERIOD+1) * PWM_CLK period.
 * |        |          |Up-Down-Count mode: In this mode, PWM counter counts from 0 to PERIOD, then decrements to 0 and repeats again.
 * |        |          |PWM period time = 2 * PERIOD * PWM_CLK period.
 * @var PWM_T::PERIOD5
 * Offset: 0x44  PWM Period Register 5
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PERIOD    |PWM Period Register
 * |        |          |Up-Count mode: In this mode, PWM counter counts from 0 to PERIOD, and restarts from 0.
 * |        |          |Down-Count mode: In this mode, PWM counter counts from PERIOD to 0, and restarts from PERIOD.
 * |        |          |PWM period time = (PERIOD+1) * PWM_CLK period.
 * |        |          |Up-Down-Count mode: In this mode, PWM counter counts from 0 to PERIOD, then decrements to 0 and repeats again.
 * |        |          |PWM period time = 2 * PERIOD * PWM_CLK period.
 * @var PWM_T::CMPDAT0
 * Offset: 0x50  PWM Comparator Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CMP       |PWM Comparator Register
 * |        |          |CMP use to compare with CNTR to generate PWM waveform, interrupt and trigger EADC.
 * |        |          |In independent mode, CMPDAT0~5 denote as 6 independent PWM_CH0~5 compared point.
 * |        |          |In complementary mode, CMPDAT0, 2, 4 denote as first compared point, and CMPDAT1, 3, 5 denote as second compared point for the corresponding 3 complementary pairs PWM_CH0 and PWM_CH1, PWM_CH2 and PWM_CH3, PWM_CH4 and PWM_CH5.
 * @var PWM_T::CMPDAT1
 * Offset: 0x54  PWM Comparator Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CMP       |PWM Comparator Register
 * |        |          |CMP use to compare with CNTR to generate PWM waveform, interrupt and trigger EADC.
 * |        |          |In independent mode, CMPDAT0~5 denote as 6 independent PWM_CH0~5 compared point.
 * |        |          |In complementary mode, CMPDAT0, 2, 4 denote as first compared point, and CMPDAT1, 3, 5 denote as second compared point for the corresponding 3 complementary pairs PWM_CH0 and PWM_CH1, PWM_CH2 and PWM_CH3, PWM_CH4 and PWM_CH5.
 * @var PWM_T::CMPDAT2
 * Offset: 0x58  PWM Comparator Register 2
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CMP       |PWM Comparator Register
 * |        |          |CMP use to compare with CNTR to generate PWM waveform, interrupt and trigger EADC.
 * |        |          |In independent mode, CMPDAT0~5 denote as 6 independent PWM_CH0~5 compared point.
 * |        |          |In complementary mode, CMPDAT0, 2, 4 denote as first compared point, and CMPDAT1, 3, 5 denote as second compared point for the corresponding 3 complementary pairs PWM_CH0 and PWM_CH1, PWM_CH2 and PWM_CH3, PWM_CH4 and PWM_CH5.
 * @var PWM_T::CMPDAT3
 * Offset: 0x5C  PWM Comparator Register 3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CMP       |PWM Comparator Register
 * |        |          |CMP use to compare with CNTR to generate PWM waveform, interrupt and trigger EADC.
 * |        |          |In independent mode, CMPDAT0~5 denote as 6 independent PWM_CH0~5 compared point.
 * |        |          |In complementary mode, CMPDAT0, 2, 4 denote as first compared point, and CMPDAT1, 3, 5 denote as second compared point for the corresponding 3 complementary pairs PWM_CH0 and PWM_CH1, PWM_CH2 and PWM_CH3, PWM_CH4 and PWM_CH5.
 * @var PWM_T::CMPDAT4
 * Offset: 0x60  PWM Comparator Register 4
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CMP       |PWM Comparator Register
 * |        |          |CMP use to compare with CNTR to generate PWM waveform, interrupt and trigger EADC.
 * |        |          |In independent mode, CMPDAT0~5 denote as 6 independent PWM_CH0~5 compared point.
 * |        |          |In complementary mode, CMPDAT0, 2, 4 denote as first compared point, and CMPDAT1, 3, 5 denote as second compared point for the corresponding 3 complementary pairs PWM_CH0 and PWM_CH1, PWM_CH2 and PWM_CH3, PWM_CH4 and PWM_CH5.
 * @var PWM_T::CMPDAT5
 * Offset: 0x64  PWM Comparator Register 5
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CMP       |PWM Comparator Register
 * |        |          |CMP use to compare with CNTR to generate PWM waveform, interrupt and trigger EADC.
 * |        |          |In independent mode, CMPDAT0~5 denote as 6 independent PWM_CH0~5 compared point.
 * |        |          |In complementary mode, CMPDAT0, 2, 4 denote as first compared point, and CMPDAT1, 3, 5 denote as second compared point for the corresponding 3 complementary pairs PWM_CH0 and PWM_CH1, PWM_CH2 and PWM_CH3, PWM_CH4 and PWM_CH5.
 * @var PWM_T::DTCTL0_1
 * Offset: 0x70  PWM Dead-Time Control Register 0/1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[11:0]  |DTCNT     |Dead-time Counter (Write Protect)
 * |        |          |The dead-time can be calculated from the following formula:
 * |        |          |Dead-time = (DTCNT[11:0]+1) * PWM_CLK period.
 * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
 * |[16]    |DTEN      |Enable Dead-time Insertion for PWM Pair (PWM_CH0, PWM_CH1) (PWM_CH2, PWM_CH3) (PWM_CH4, PWM_CH5) (Write Protect)
 * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled
 * |        |          |If dead- time insertion is inactive, the outputs of pin pair are complementary without any delay.
 * |        |          |0 = Dead-time insertion Disabled on the pin pair.
 * |        |          |1 = Dead-time insertion Enabled on the pin pair.
 * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
 * |[24]    |DTCKSEL   |Dead-time Clock Select (Write Protect)
 * |        |          |0 = Dead-time clock source from PWM_CLK.
 * |        |          |1 = Dead-time clock source from prescaler output.
 * |        |          |Note: This register is write protected. Refer toREGWRPROT register.
 * @var PWM_T::DTCTL2_3
 * Offset: 0x74  PWM Dead-Time Control Register 2/3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[11:0]  |DTCNT     |Dead-time Counter (Write Protect)
 * |        |          |The dead-time can be calculated from the following formula:
 * |        |          |Dead-time = (DTCNT[11:0]+1) * PWM_CLK period.
 * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
 * |[16]    |DTEN      |Enable Dead-time Insertion for PWM Pair (PWM_CH0, PWM_CH1) (PWM_CH2, PWM_CH3) (PWM_CH4, PWM_CH5) (Write Protect)
 * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled
 * |        |          |If dead- time insertion is inactive, the outputs of pin pair are complementary without any delay.
 * |        |          |0 = Dead-time insertion Disabled on the pin pair.
 * |        |          |1 = Dead-time insertion Enabled on the pin pair.
 * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
 * |[24]    |DTCKSEL   |Dead-time Clock Select (Write Protect)
 * |        |          |0 = Dead-time clock source from PWM_CLK.
 * |        |          |1 = Dead-time clock source from prescaler output.
 * |        |          |Note: This register is write protected. Refer toREGWRPROT register.
 * @var PWM_T::DTCTL4_5
 * Offset: 0x78  PWM Dead-Time Control Register 4/5
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[11:0]  |DTCNT     |Dead-time Counter (Write Protect)
 * |        |          |The dead-time can be calculated from the following formula:
 * |        |          |Dead-time = (DTCNT[11:0]+1) * PWM_CLK period.
 * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
 * |[16]    |DTEN      |Enable Dead-time Insertion for PWM Pair (PWM_CH0, PWM_CH1) (PWM_CH2, PWM_CH3) (PWM_CH4, PWM_CH5) (Write Protect)
 * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled
 * |        |          |If dead- time insertion is inactive, the outputs of pin pair are complementary without any delay.
 * |        |          |0 = Dead-time insertion Disabled on the pin pair.
 * |        |          |1 = Dead-time insertion Enabled on the pin pair.
 * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
 * |[24]    |DTCKSEL   |Dead-time Clock Select (Write Protect)
 * |        |          |0 = Dead-time clock source from PWM_CLK.
 * |        |          |1 = Dead-time clock source from prescaler output.
 * |        |          |Note: This register is write protected. Refer toREGWRPROT register.
 * @var PWM_T::PHS0_1
 * Offset: 0x80  PWM Counter Phase Register 0/1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PHS       |PWM Synchronous Start Phase Bits
 * |        |          |PHS determines the PWM synchronous start phase value. These bits only use in synchronous function.
 * @var PWM_T::PHS2_3
 * Offset: 0x84  PWM Counter Phase Register 2/3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PHS       |PWM Synchronous Start Phase Bits
 * |        |          |PHS determines the PWM synchronous start phase value. These bits only use in synchronous function.
 * @var PWM_T::PHS4_5
 * Offset: 0x88  PWM Counter Phase Register 4/5
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PHS       |PWM Synchronous Start Phase Bits
 * |        |          |PHS determines the PWM synchronous start phase value. These bits only use in synchronous function.
 * @var PWM_T::CNT0
 * Offset: 0x90  PWM Counter Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CNT       |PWM Data Register (Read Only)
 * |        |          |User can monitor CNTR to know the current value in 16-bit period counter.
 * |[16]    |DIRF      |PWM Direction Indicator Flag (Read Only)
 * |        |          |0 = Counter is Down count.
 * |        |          |1 = Counter is UP count.
 * @var PWM_T::CNT1
 * Offset: 0x94  PWM Counter Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CNT       |PWM Data Register (Read Only)
 * |        |          |User can monitor CNTR to know the current value in 16-bit period counter.
 * |[16]    |DIRF      |PWM Direction Indicator Flag (Read Only)
 * |        |          |0 = Counter is Down count.
 * |        |          |1 = Counter is UP count.
 * @var PWM_T::CNT2
 * Offset: 0x98  PWM Counter Register 2
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CNT       |PWM Data Register (Read Only)
 * |        |          |User can monitor CNTR to know the current value in 16-bit period counter.
 * |[16]    |DIRF      |PWM Direction Indicator Flag (Read Only)
 * |        |          |0 = Counter is Down count.
 * |        |          |1 = Counter is UP count.
 * @var PWM_T::CNT3
 * Offset: 0x9C  PWM Counter Register 3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CNT       |PWM Data Register (Read Only)
 * |        |          |User can monitor CNTR to know the current value in 16-bit period counter.
 * |[16]    |DIRF      |PWM Direction Indicator Flag (Read Only)
 * |        |          |0 = Counter is Down count.
 * |        |          |1 = Counter is UP count.
 * @var PWM_T::CNT4
 * Offset: 0xA0  PWM Counter Register 4
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CNT       |PWM Data Register (Read Only)
 * |        |          |User can monitor CNTR to know the current value in 16-bit period counter.
 * |[16]    |DIRF      |PWM Direction Indicator Flag (Read Only)
 * |        |          |0 = Counter is Down count.
 * |        |          |1 = Counter is UP count.
 * @var PWM_T::CNT5
 * Offset: 0xA4  PWM Counter Register 5
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CNT       |PWM Data Register (Read Only)
 * |        |          |User can monitor CNTR to know the current value in 16-bit period counter.
 * |[16]    |DIRF      |PWM Direction Indicator Flag (Read Only)
 * |        |          |0 = Counter is Down count.
 * |        |          |1 = Counter is UP count.
 * @var PWM_T::WGCTL0
 * Offset: 0xB0  PWM Generation Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |ZPCTL0    |PWM Channel 0 Zero Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM zero point output Low.
 * |        |          |10 = PWM zero point output High.
 * |        |          |11 = PWM zero point output Toggle.
 * |        |          |PWM can control output level when PWM counter count to zero.
 * |[3:2]   |ZPCTL1    |PWM Channel 1 Zero Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM zero point output Low.
 * |        |          |10 = PWM zero point output High.
 * |        |          |11 = PWM zero point output Toggle.
 * |        |          |PWM can control output level when PWM counter count to zero.
 * |[5:4]   |ZPCTL2    |PWM Channel 2 Zero Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM zero point output Low.
 * |        |          |10 = PWM zero point output High.
 * |        |          |11 = PWM zero point output Toggle.
 * |        |          |PWM can control output level when PWM counter count to zero.
 * |[7:6]   |ZPCTL3    |PWM Channel 3 Zero Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM zero point output Low.
 * |        |          |10 = PWM zero point output High.
 * |        |          |11 = PWM zero point output Toggle.
 * |        |          |PWM can control output level when PWM counter count to zero.
 * |[9:8]   |ZPCTL4    |PWM Channel 4 Zero Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM zero point output Low.
 * |        |          |10 = PWM zero point output High.
 * |        |          |11 = PWM zero point output Toggle.
 * |        |          |PWM can control output level when PWM counter count to zero.
 * |[11:10] |ZPCTL5    |PWM Channel 5 Zero Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM zero point output Low.
 * |        |          |10 = PWM zero point output High.
 * |        |          |11 = PWM zero point output Toggle.
 * |        |          |PWM can control output level when PWM counter count to zero.
 * |[17:16] |PRDPCTL0  |PWM Channel 0 Period (Center) Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM period (center) point output Low.
 * |        |          |10 = PWM period (center) point output High.
 * |        |          |11 = PWM period (center) point output Toggle.
 * |        |          |PWM can control output level when PWM counter count to (PERIODn+1).
 * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
 * |[19:18] |PRDPCTL1  |PWM Channel 1 Period (Center) Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM period (center) point output Low.
 * |        |          |10 = PWM period (center) point output High.
 * |        |          |11 = PWM period (center) point output Toggle.
 * |        |          |PWM can control output level when PWM counter count to (PERIODn+1).
 * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
 * |[21:20] |PRDPCTL2  |PWM Channel 2 Period (Center) Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM period (center) point output Low.
 * |        |          |10 = PWM period (center) point output High.
 * |        |          |11 = PWM period (center) point output Toggle.
 * |        |          |PWM can control output level when PWM counter count to (PERIODn+1).
 * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
 * |[23:22] |PRDPCTL3  |PWM Channel 3 Period (Center) Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM period (center) point output Low.
 * |        |          |10 = PWM period (center) point output High.
 * |        |          |11 = PWM period (center) point output Toggle.
 * |        |          |PWM can control output level when PWM counter count to (PERIODn+1).
 * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
 * |[25:24] |PRDPCTL4  |PWM Channel 4 Period (Center) Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM period (center) point output Low.
 * |        |          |10 = PWM period (center) point output High.
 * |        |          |11 = PWM period (center) point output Toggle.
 * |        |          |PWM can control output level when PWM counter count to (PERIODn+1).
 * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
 * |[27:26] |PRDPCTL5  |PWM Channel 5 Period (Center) Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM period (center) point output Low.
 * |        |          |10 = PWM period (center) point output High.
 * |        |          |11 = PWM period (center) point output Toggle.
 * |        |          |PWM can control output level when PWM counter count to (PERIODn+1).
 * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
 * @var PWM_T::WGCTL1
 * Offset: 0xB4  PWM Generation Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |CMPUCTL0  |PWM Channel 0 Compare Up Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM compare up point output Low.
 * |        |          |10 = PWM compare up point output High.
 * |        |          |11 = PWM compare up point output Toggle.
 * |        |          |PWM can control output level when PWM counter up count to CMPDAT.
 * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
 * |[3:2]   |CMPUCTL1  |PWM Channel 1 Compare Up Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM compare up point output Low.
 * |        |          |10 = PWM compare up point output High.
 * |        |          |11 = PWM compare up point output Toggle.
 * |        |          |PWM can control output level when PWM counter up count to CMPDAT.
 * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
 * |[5:4]   |CMPUCTL2  |PWM Channel 2 Compare Up Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM compare up point output Low.
 * |        |          |10 = PWM compare up point output High.
 * |        |          |11 = PWM compare up point output Toggle.
 * |        |          |PWM can control output level when PWM counter up count to CMPDAT.
 * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
 * |[7:6]   |CMPUCTL3  |PWM Channel 3 Compare Up Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM compare up point output Low.
 * |        |          |10 = PWM compare up point output High.
 * |        |          |11 = PWM compare up point output Toggle.
 * |        |          |PWM can control output level when PWM counter up count to CMPDAT.
 * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
 * |[9:8]   |CMPUCTL4  |PWM Channel 4 Compare Up Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM compare up point output Low.
 * |        |          |10 = PWM compare up point output High.
 * |        |          |11 = PWM compare up point output Toggle.
 * |        |          |PWM can control output level when PWM counter up count to CMPDAT.
 * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
 * |[11:10] |CMPUCTL5  |PWM Channel 5 Compare Up Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM compare up point output Low.
 * |        |          |10 = PWM compare up point output High.
 * |        |          |11 = PWM compare up point output Toggle.
 * |        |          |PWM can control output level when PWM counter up count to CMPDAT.
 * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
 * |[17:16] |CMPDCTL0  |PWM Channel 0 Compare Down Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM compare down point output Low.
 * |        |          |10 = PWM compare down point output High.
 * |        |          |11 = PWM compare down point output Toggle.
 * |        |          |PWM can control output level when PWM counter down count to CMPDAT.
 * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
 * |[19:18] |CMPDCTL1  |PWM Channel 1 Compare Down Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM compare down point output Low.
 * |        |          |10 = PWM compare down point output High.
 * |        |          |11 = PWM compare down point output Toggle.
 * |        |          |PWM can control output level when PWM counter down count to CMPDAT.
 * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
 * |[21:20] |CMPDCTL2  |PWM Channel 2 Compare Down Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM compare down point output Low.
 * |        |          |10 = PWM compare down point output High.
 * |        |          |11 = PWM compare down point output Toggle.
 * |        |          |PWM can control output level when PWM counter down count to CMPDAT.
 * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
 * |[23:22] |CMPDCTL3  |PWM Channel 3 Compare Down Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM compare down point output Low.
 * |        |          |10 = PWM compare down point output High.
 * |        |          |11 = PWM compare down point output Toggle.
 * |        |          |PWM can control output level when PWM counter down count to CMPDAT.
 * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
 * |[25:24] |CMPDCTL4  |PWM Channel 4 Compare Down Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM compare down point output Low.
 * |        |          |10 = PWM compare down point output High.
 * |        |          |11 = PWM compare down point output Toggle.
 * |        |          |PWM can control output level when PWM counter down count to CMPDAT.
 * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
 * |[27:26] |CMPDCTL5  |PWM Channel 5 Compare Down Point Control
 * |        |          |00 = Do nothing.
 * |        |          |01 = PWM compare down point output Low.
 * |        |          |10 = PWM compare down point output High.
 * |        |          |11 = PWM compare down point output Toggle.
 * |        |          |PWM can control output level when PWM counter down count to CMPDAT.
 * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
 * @var PWM_T::MSKEN
 * Offset: 0xB8  PWM Mask Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |MSKEN0    |PWM Channel 0 Mask Enable Bits
 * |        |          |The PWM output signal will be masked when this bit is enabled.
 * |        |          |0 = PWM output signal is non-masked.
 * |        |          |1 = PWM output signal is masked and output MSKDAT0 (PWM_MSK[0]) data.
 * |[1]     |MSKEN1    |PWM Channel 1 Mask Enable Bits
 * |        |          |The PWM output signal will be masked when this bit is enabled and output MSKDAT1 (PWM_MSK[1]) data.
 * |        |          |0 = PWM output signal is non-masked.
 * |        |          |1 = PWM output signal is masked and output MSKDAT1 (PWM_MSK[1]) data.
 * |[2]     |MSKEN2    |PWM Channel 2 Mask Enable Bits
 * |        |          |The PWM output signal will be masked when this bit is enabled and output MSKDAT2 (PWM_MSK[2]) data.
 * |        |          |0 = PWM output signal is non-masked.
 * |        |          |1 = PWM output signal is masked and output MSKDAT2 (PWM_MSK[2]) data.
 * |[3]     |MSKEN3    |PWM Channel 3 Mask Enable Bits
 * |        |          |The PWM output signal will be masked when this bit is enabled and output MSKDAT3 (PWM_MSK[3]) data.
 * |        |          |0 = PWM output signal is non-masked.
 * |        |          |1 = PWM output signal is masked and output MSKDAT3 (PWM_MSK[3]) data.
 * |[4]     |MSKEN4    |PWM Channel 4 Mask Enable Bits
 * |        |          |The PWM output signal will be masked when this bit is enabled and output MSKDAT4 (PWM_MSK[4]) data.
 * |        |          |0 = PWM output signal is non-masked.
 * |        |          |1 = PWM output signal is masked and output MSKDAT4 (PWM_MSK[4]) data.
 * |[5]     |MSKEN5    |PWM Channel 5 Mask Enable Bits
 * |        |          |The PWM output signal will be masked when this bit is enabled and output MSKDAT5 (PWM_MSK[5]) data.
 * |        |          |0 = PWM output signal is non-masked.
 * |        |          |1 = PWM output signal is masked and output MSKDAT5 (PWM_MSK[5]) data.
 * @var PWM_T::MSK
 * Offset: 0xBC  PWM Mask Data Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |MSKDAT0   |PWM Channel 0 Mask Data Bit
 * |        |          |This bit control the state of output pin, if MSKEN0 (PWM_MSKEN[0]) is enabled.
 * |        |          |0 = Output logic low to PWM0.
 * |        |          |1 = Output logic high to PWM0.
 * |[1]     |MSKDAT1   |PWM Channel 1 Mask Data Bit
 * |        |          |This bit control the state of output pin, if MSKEN1 (PWM_MSKEN[1]) is enabled.
 * |        |          |0 = Output logic low to PWM1.
 * |        |          |1 = Output logic high to PWM1.
 * |[2]     |MSKDAT2   |PWM Channel 2 Mask Data Bit
 * |        |          |This bit control the state of output pin, if MSKEN2 (PWM_MSKEN[2]) is enabled.
 * |        |          |0 = Output logic low to PWM2.
 * |        |          |1 = Output logic high to PWM2.
 * |[3]     |MSKDAT3   |PWM Channel 3 Mask Data Bit
 * |        |          |This bit control the state of output pin, if MSKEN3 (PWM_MSKEN[3]) is enabled.
 * |        |          |0 = Output logic low to PWM3.
 * |        |          |1 = Output logic high to PWM3.
 * |[4]     |MSKDAT4   |PWM Channel 4 Mask Data Bit
 * |        |          |This bit control the state of output pin, if MSKEN4 (PWM_MSKEN[4]) is enabled.
 * |        |          |0 = Output logic low to PWM4.
 * |        |          |1 = Output logic high to PWM4.
 * |[5]     |MSKDAT5   |PWM Channel 5 Mask Data Bit
 * |        |          |This bit control the state of output pin, if MSKEN5 (PWM_MSKEN[5]) is enabled.
 * |        |          |0 = Output logic low to PWM5.
 * |        |          |1 = Output logic high to PWM5.
 * @var PWM_T::BNF
 * Offset: 0xC0  PWM Brake Noise Filter Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BRK0NFEN  |PWM Brake 0 Noise Filter Enable Bit
 * |        |          |0 = Noise filter of PWM Brake 0 Disabled.
 * |        |          |1 = Noise filter of PWM Brake 0 Enabled.
 * |[3:1]   |BRK0NFSEL |Brake 0 Edge Detector Filter Clock Selection
 * |        |          |000 = Filter clock = HCLK.
 * |        |          |001 = Filter clock = HCLK/2.
 * |        |          |010 = Filter clock = HCLK/4.
 * |        |          |011 = Filter clock = HCLK/8.
 * |        |          |100 = Filter clock = HCLK/16.
 * |        |          |101 = Filter clock = HCLK/32.
 * |        |          |110 = Filter clock = HCLK/64.
 * |        |          |111 = Filter clock = HCLK/128.
 * |[6:4]   |BRK0FCNT  |Brake 0 Edge Detector Filter Count
 * |        |          |The register bits control the Brake0 filter counter to count from 0 to BRK1FCNT.
 * |[7]     |BRK0PINV  |Brake 0 Pin Inverse
 * |        |          |0 = The state of pin PWM0_BRAKE0 is passed to the negative edge detector.
 * |        |          |1 = The inversed state of pin PWM0_BRAKE1 is passed to the negative edge detector.
 * |[8]     |BRK1NFEN  |PWM Brake 1 Noise Filter Enable Bit
 * |        |          |0 = Noise filter of PWM Brake 1 Disabled.
 * |        |          |1 = Noise filter of PWM Brake 1 Enabled.
 * |[11:9]  |BRK1NFSEL |Brake 1 Edge Detector Filter Clock Selection
 * |        |          |000 = Filter clock = HCLK.
 * |        |          |001 = Filter clock = HCLK/2.
 * |        |          |010 = Filter clock = HCLK/4.
 * |        |          |011 = Filter clock = HCLK/8.
 * |        |          |100 = Filter clock = HCLK/16.
 * |        |          |101 = Filter clock = HCLK/32.
 * |        |          |110 = Filter clock = HCLK/64.
 * |        |          |111 = Filter clock = HCLK/128.
 * |[14:12] |BRK1FCNT  |Brake 1 Edge Detector Filter Count
 * |        |          |The register bits control the Brake1 filter counter to count from 0 to BRK1FCNT. 
 * |[15]    |BRK1PINV  |Brake 1 Pin Inverse
 * |        |          |0 = The state of pin PWM0_BRAKE1 is passed to the negative edge detector.
 * |        |          |1 = The inversed state of pin PWM0_BRAKE1 is passed to the negative edge detector.
 * @var PWM_T::FAILBRK
 * Offset: 0xC4  PWM System Fail Brake Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CSSBRKEN  |Clock Security System Detection Trigger PWM Brake Function 0 Enable Bit
 * |        |          |0 = Brake Function triggered by CSS detection Disabled.
 * |        |          |1 = Brake Function triggered by CSS detection Enabled.
 * |[1]     |BODBRKEN  |Brown-out Detection Trigger PWM Brake Function 0 Enable Bit
 * |        |          |0 = Brake Function triggered by BOD Disabled.
 * |        |          |1 = Brake Function triggered by BOD Enabled.
 * |[2]     |RAMBRKEN  |SRAM Parity Error Detection Trigger PWM Brake Function 0 Enable Bit
 * |        |          |0 = Brake Function triggered by SRAM parity error detection Disabled.
 * |        |          |1 = Brake Function triggered by SRAM parity error detection Enabled.
 * |[3]     |CORBRKEN  |Core Lockup Detection Trigger PWM Brake Function 0 Enable Bit
 * |        |          |0 = Brake Function triggered by Core lockup detection Disabled.
 * |        |          |1 = Brake Function triggered by Core lockup detection Enabled.
 * @var PWM_T::BRKCTL0_1
 * Offset: 0xC8  PWM Brake Edge Detect Control Register 0/1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[4]     |BRKP0EEN  |Enable PWM0_BRAKE0 Pin As Edge-detect Brake Source (Write Protect)
 * |        |          |0 = PWM0_BRAKE0 pin as edge-detect brake source Disabled.
 * |        |          |1 = PWM0_BRAKE0 pin as edge-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[5]     |BRKP1EEN  |Enable PWM0_BRAKE1 Pin As Edge-detect Brake Source (Write Protect)
 * |        |          |0 = PWM0_BRAKE1 pin as edge-detect brake source Disabled.
 * |        |          |1 = PWM0_BRAKE1 pin as edge-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[7]     |SYSEBEN   |Enable System Fail As Edge-detect Brake Source (Write Protect)
 * |        |          |0 = System Fail condition as edge-detect brake source Disabled.
 * |        |          |1 = System Fail condition as edge-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[12]    |BRKP0LEN  |Enable BKP0 Pin As Level-detect Brake Source (Write Protect)
 * |        |          |0 = PWM0_BRAKE0 pin as level-detect brake source Disabled.
 * |        |          |1 = PWM0_BRAKE0 pin as level-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[13]    |BRKP1LEN  |Enable BKP1 Pin As Level-detect Brake Source (Write Protect)
 * |        |          |0 = PWM0_BRAKE1 pin as level-detect brake source Disabled.
 * |        |          |1 = PWM0_BRAKE1 pin as level-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[15]    |SYSLBEN   |Enable System Fail As Level-detect Brake Source (Write Protect)
 * |        |          |0 = System Fail condition as level-detect brake source Disabled.
 * |        |          |1 = System Fail condition as level-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[17:16] |BRKAEVEN  |PWM Brake Action Select for Even Channel (Write Protect)
 * |        |          |00 = PWM0 brake event will not affect even channels output.
 * |        |          |01 = PWM even channel output tri-state when PWM0 brake event happened.
 * |        |          |10 = PWM even channel output low level when PWM0 brake event happened.
 * |        |          |11 = PWM even channel output high level when PWM0 brake event happened.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[19:18] |BRKAODD   |PWM Brake Action Select for Odd Channel (Write Protect)
 * |        |          |00 = PWM0 brake event will not affect odd channels output.
 * |        |          |01 = PWM odd channel output tri-state when PWM0 brake event happened.
 * |        |          |10 = PWM odd channel output low level when PWM0 brake event happened.
 * |        |          |11 = PWM odd channel output high level when PWM0 brake event happened.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[20]    |ADCEBEN   |Enable ADC Result Monitor (ADCRM) As Edge-detect Brake Source (Write Protect)
 * |        |          |0 = ADCRM as edge-detect brake source Disabled.
 * |        |          |1 = ADCRM as edge-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[28]    |ADCLBEN   |Enable ADC Result Monitor (ADCRM) As Level-detect Brake Source (Write Protect)
 * |        |          |0 = ADCRM as level-detect brake source Disabled.
 * |        |          |1 = ADCRM as level-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * @var PWM_T::BRKCTL2_3
 * Offset: 0xCC  PWM Brake Edge Detect Control Register 2/3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[4]     |BRKP0EEN  |Enable PWM0_BRAKE0 Pin As Edge-detect Brake Source (Write Protect)
 * |        |          |0 = PWM0_BRAKE0 pin as edge-detect brake source Disabled.
 * |        |          |1 = PWM0_BRAKE0 pin as edge-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[5]     |BRKP1EEN  |Enable PWM0_BRAKE1 Pin As Edge-detect Brake Source (Write Protect)
 * |        |          |0 = PWM0_BRAKE1 pin as edge-detect brake source Disabled.
 * |        |          |1 = PWM0_BRAKE1 pin as edge-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[7]     |SYSEBEN   |Enable System Fail As Edge-detect Brake Source (Write Protect)
 * |        |          |0 = System Fail condition as edge-detect brake source Disabled.
 * |        |          |1 = System Fail condition as edge-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[12]    |BRKP0LEN  |Enable BKP0 Pin As Level-detect Brake Source (Write Protect)
 * |        |          |0 = PWM0_BRAKE0 pin as level-detect brake source Disabled.
 * |        |          |1 = PWM0_BRAKE0 pin as level-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[13]    |BRKP1LEN  |Enable BKP1 Pin As Level-detect Brake Source (Write Protect)
 * |        |          |0 = PWM0_BRAKE1 pin as level-detect brake source Disabled.
 * |        |          |1 = PWM0_BRAKE1 pin as level-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[15]    |SYSLBEN   |Enable System Fail As Level-detect Brake Source (Write Protect)
 * |        |          |0 = System Fail condition as level-detect brake source Disabled.
 * |        |          |1 = System Fail condition as level-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[17:16] |BRKAEVEN  |PWM Brake Action Select for Even Channel (Write Protect)
 * |        |          |00 = PWM0 brake event will not affect even channels output.
 * |        |          |01 = PWM even channel output tri-state when PWM0 brake event happened.
 * |        |          |10 = PWM even channel output low level when PWM0 brake event happened.
 * |        |          |11 = PWM even channel output high level when PWM0 brake event happened.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[19:18] |BRKAODD   |PWM Brake Action Select for Odd Channel (Write Protect)
 * |        |          |00 = PWM0 brake event will not affect odd channels output.
 * |        |          |01 = PWM odd channel output tri-state when PWM0 brake event happened.
 * |        |          |10 = PWM odd channel output low level when PWM0 brake event happened.
 * |        |          |11 = PWM odd channel output high level when PWM0 brake event happened.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[20]    |ADCEBEN   |Enable ADC Result Monitor (ADCRM) As Edge-detect Brake Source (Write Protect)
 * |        |          |0 = ADCRM as edge-detect brake source Disabled.
 * |        |          |1 = ADCRM as edge-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[28]    |ADCLBEN   |Enable ADC Result Monitor (ADCRM) As Level-detect Brake Source (Write Protect)
 * |        |          |0 = ADCRM as level-detect brake source Disabled.
 * |        |          |1 = ADCRM as level-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * @var PWM_T::BRKCTL4_5
 * Offset: 0xD0  PWM Brake Edge Detect Control Register 4/5
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[4]     |BRKP0EEN  |Enable PWM0_BRAKE0 Pin As Edge-detect Brake Source (Write Protect)
 * |        |          |0 = PWM0_BRAKE0 pin as edge-detect brake source Disabled.
 * |        |          |1 = PWM0_BRAKE0 pin as edge-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[5]     |BRKP1EEN  |Enable PWM0_BRAKE1 Pin As Edge-detect Brake Source (Write Protect)
 * |        |          |0 = PWM0_BRAKE1 pin as edge-detect brake source Disabled.
 * |        |          |1 = PWM0_BRAKE1 pin as edge-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[7]     |SYSEBEN   |Enable System Fail As Edge-detect Brake Source (Write Protect)
 * |        |          |0 = System Fail condition as edge-detect brake source Disabled.
 * |        |          |1 = System Fail condition as edge-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[12]    |BRKP0LEN  |Enable BKP0 Pin As Level-detect Brake Source (Write Protect)
 * |        |          |0 = PWM0_BRAKE0 pin as level-detect brake source Disabled.
 * |        |          |1 = PWM0_BRAKE0 pin as level-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[13]    |BRKP1LEN  |Enable BKP1 Pin As Level-detect Brake Source (Write Protect)
 * |        |          |0 = PWM0_BRAKE1 pin as level-detect brake source Disabled.
 * |        |          |1 = PWM0_BRAKE1 pin as level-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[15]    |SYSLBEN   |Enable System Fail As Level-detect Brake Source (Write Protect)
 * |        |          |0 = System Fail condition as level-detect brake source Disabled.
 * |        |          |1 = System Fail condition as level-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[17:16] |BRKAEVEN  |PWM Brake Action Select for Even Channel (Write Protect)
 * |        |          |00 = PWM0 brake event will not affect even channels output.
 * |        |          |01 = PWM even channel output tri-state when PWM0 brake event happened.
 * |        |          |10 = PWM even channel output low level when PWM0 brake event happened.
 * |        |          |11 = PWM even channel output high level when PWM0 brake event happened.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[19:18] |BRKAODD   |PWM Brake Action Select for Odd Channel (Write Protect)
 * |        |          |00 = PWM0 brake event will not affect odd channels output.
 * |        |          |01 = PWM odd channel output tri-state when PWM0 brake event happened.
 * |        |          |10 = PWM odd channel output low level when PWM0 brake event happened.
 * |        |          |11 = PWM odd channel output high level when PWM0 brake event happened.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[20]    |ADCEBEN   |Enable ADC Result Monitor (ADCRM) As Edge-detect Brake Source (Write Protect)
 * |        |          |0 = ADCRM as edge-detect brake source Disabled.
 * |        |          |1 = ADCRM as edge-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[28]    |ADCLBEN   |Enable ADC Result Monitor (ADCRM) As Level-detect Brake Source (Write Protect)
 * |        |          |0 = ADCRM as level-detect brake source Disabled.
 * |        |          |1 = ADCRM as level-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * @var PWM_T::POLCTL
 * Offset: 0xD4  PWM Pin Polar Inverse Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PINV0     |PWM Channel 0 PIN Polar Inverse Control
 * |        |          |The register controls polarity state of PWM output.
 * |        |          |0 = PWM output polar inverse Disabled.
 * |        |          |1 = PWM output polar inverse Enabled.
 * |[1]     |PINV1     |PWM Channel 1 PIN Polar Inverse Control
 * |        |          |The register controls polarity state of PWM output.
 * |        |          |0 = PWM output polar inverse Disabled.
 * |        |          |1 = PWM output polar inverse Enabled.
 * |[2]     |PINV2     |PWM Channel 2 PIN Polar Inverse Control
 * |        |          |The register controls polarity state of PWM output.
 * |        |          |0 = PWM output polar inverse Disabled.
 * |        |          |1 = PWM output polar inverse Enabled.
 * |[3]     |PINV3     |PWM Channel 3 PIN Polar Inverse Control
 * |        |          |The register controls polarity state of PWM output.
 * |        |          |0 = PWM output polar inverse Disabled.
 * |        |          |1 = PWM output polar inverse Enabled.
 * |[4]     |PINV4     |PWM Channel 4 PIN Polar Inverse Control
 * |        |          |The register controls polarity state of PWM output.
 * |        |          |0 = PWM output polar inverse Disabled.
 * |        |          |1 = PWM output polar inverse Enabled.
 * |[5]     |PINV5     |PWM Channel 5 PIN Polar Inverse Control
 * |        |          |The register controls polarity state of PWM output.
 * |        |          |0 = PWM output polar inverse Disabled.
 * |        |          |1 = PWM output polar inverse Enabled.
 * @var PWM_T::POEN
 * Offset: 0xD8  PWM Output Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |POEN0     |PWM Channel 0 Pin Output Enable Bits
 * |        |          |0 = PWM pin at tri-state.
 * |        |          |1 = PWM pin in output mode.
 * |[1]     |POEN1     |PWM Channel 1 Pin Output Enable Bits
 * |        |          |0 = PWM pin at tri-state.
 * |        |          |1 = PWM pin in output mode.
 * |[2]     |POEN2     |PWM Channel 2 Pin Output Enable Bits
 * |        |          |0 = PWM pin at tri-state.
 * |        |          |1 = PWM pin in output mode.
 * |[3]     |POEN3     |PWM Channel 3 Pin Output Enable Bits
 * |        |          |0 = PWM pin at tri-state.
 * |        |          |1 = PWM pin in output mode.
 * |[4]     |POEN4     |PWM Channel 4 Pin Output Enable Bits
 * |        |          |0 = PWM pin at tri-state.
 * |        |          |1 = PWM pin in output mode.
 * |[5]     |POEN5     |PWM Channel 5 Pin Output Enable Bits
 * |        |          |0 = PWM pin at tri-state.
 * |        |          |1 = PWM pin in output mode.
 * @var PWM_T::SWBRK
 * Offset: 0xDC  PWM Software Brake Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BRKETRG0  |PWM Pair 0 Edge Brake Software Trigger (Write Only) (Write Protect)
 * |        |          |Write 1 to this bit will trigger edge brake, and set BRKEIF0 to 1 in PWM_INTSTS1 register.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register. 
 * |[1]     |BRKETRG2  |PWM Pair 2 Edge Brake Software Trigger (Write Only) (Write Protect)
 * |        |          |Write 1 to this bit will trigger edge brake, and set BRKEIF2 to 1 in PWM_INTSTS1 register.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register. 
 * |[2]     |BRKETRG4  |PWM Pair 4 Edge Brake Software Trigger (Write Only) (Write Protect)
 * |        |          |Write 1 to this bit will trigger edge brake, and set BRKEIF4 to 1 in PWM_INTSTS1 register.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register. 
 * |[8]     |BRKLTRG0  |PWM Pair 0 Level Brake Software Trigger (Write Only) (Write Protect)
 * |        |          |Write 1 to this bit will trigger level brake, and set BRKLIF0 to 1 in PWM_INTSTS1 register.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[9]     |BRKLTRG2  |PWM Pair 2 Level Brake Software Trigger (Write Only) (Write Protect)
 * |        |          |Write 1 to this bit will trigger level brake, and set BRKLIF2 to 1 in PWM_INTSTS1 register.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[10]    |BRKLTRG4  |PWM Pair 4 Level Brake Software Trigger (Write Only) (Write Protect)
 * |        |          |Write 1 to this bit will trigger level brake, and set BRKLIF4 to 1 in PWM_INTSTS1 register.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * @var PWM_T::INTEN0
 * Offset: 0xE0  PWM Interrupt Enable Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ZIEN0     |PWM Channel 0 Zero Point Interrupt Enable Bits
 * |        |          |0 = Zero point interrupt Disabled.
 * |        |          |1 = Zero point interrupt Enabled.
 * |[1]     |ZIEN1     |PWM Channel 1 Zero Point Interrupt Enable Bits
 * |        |          |0 = Zero point interrupt Disabled.
 * |        |          |1 = Zero point interrupt Enabled.
 * |        |          |Note: This channel will read always 0 at complementary mode.
 * |[2]     |ZIEN2     |PWM Channel 2 Zero Point Interrupt Enable Bits
 * |        |          |0 = Zero point interrupt Disabled.
 * |        |          |1 = Zero point interrupt Enabled.
 * |[3]     |ZIEN3     |PWM Channel 3 Zero Point Interrupt Enable Bits
 * |        |          |0 = Zero point interrupt Disabled.
 * |        |          |1 = Zero point interrupt Enabled.
 * |        |          |Note: This channel will read always 0 at complementary mode.
 * |[4]     |ZIEN4     |PWM Channel 4 Zero Point Interrupt Enable Bits
 * |        |          |0 = Zero point interrupt Disabled.
 * |        |          |1 = Zero point interrupt Enabled.
 * |[5]     |ZIEN5     |PWM Channel 5 Zero Point Interrupt Enable Bits
 * |        |          |0 = Zero point interrupt Disabled.
 * |        |          |1 = Zero point interrupt Enabled.
 * |        |          |Note: This channel will read always 0 at complementary mode.
 * |[7]     |IFAIEN0_1 |PWM_CH0/1 Interrupt Flag Accumulator Interrupt Enable Bit
 * |        |          |0 = Interrupt Flag accumulator interrupt Disabled.
 * |        |          |1 = Interrupt Flag accumulator interrupt Enabled.
 * |[8]     |PIEN0     |PWM Channel 0 Period Point Interrupt Enable Bits
 * |        |          |0 = Period point interrupt Disabled.
 * |        |          |1 = Period point interrupt Enabled.
 * |        |          |Note: When up-down counter type period point means center point.
 * |[9]     |PIEN1     |PWM Channel 1 Period Point Interrupt Enable Bits
 * |        |          |0 = Period point interrupt Disabled.
 * |        |          |1 = Period point interrupt Enabled.
 * |        |          |Note1: When up-down counter type period point means center point.
 * |        |          |Note2: This channels will read always 0 at complementary mode.
 * |[10]    |PIEN2     |PWM Channel 2 Period Point Interrupt Enable Bits
 * |        |          |0 = Period point interrupt Disabled.
 * |        |          |1 = Period point interrupt Enabled.
 * |        |          |Note: When up-down counter type period point means center point.
 * |[11]    |PIEN3     |PWM Channel 3 Period Point Interrupt Enable Bits
 * |        |          |0 = Period point interrupt Disabled.
 * |        |          |1 = Period point interrupt Enabled.
 * |        |          |Note1: When up-down counter type period point means center point.
 * |        |          |Note2: This channels will read always 0 at complementary mode.
 * |[12]    |PIEN4     |PWM Channel 4 Period Point Interrupt Enable Bits
 * |        |          |0 = Period point interrupt Disabled.
 * |        |          |1 = Period point interrupt Enabled.
 * |        |          |Note: When up-down counter type period point means center point.
 * |[13]    |PIEN5     |PWM Channel 5 Period Point Interrupt Enable Bits
 * |        |          |0 = Period point interrupt Disabled.
 * |        |          |1 = Period point interrupt Enabled.
 * |        |          |Note1: When up-down counter type period point means center point.
 * |        |          |Note2: This channels will read always 0 at complementary mode.
 * |[15]    |IFAIEN2_3 |PWM_CH2/3 Interrupt Flag Accumulator Interrupt Enable Bit
 * |        |          |0 = Interrupt Flag accumulator interrupt Disabled.
 * |        |          |1 = Interrupt Flag accumulator interrupt Enabled.
 * |[16]    |CMPUIEN0  |PWM Channel 0 Compare Up Count Interrupt Enable Bits
 * |        |          |0 = Compare up count interrupt Disabled.
 * |        |          |1 = Compare up count interrupt Enabled.
 * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
 * |[17]    |CMPUIEN1  |PWM Channel 1 Compare Up Count Interrupt Enable Bits
 * |        |          |0 = Compare up count interrupt Disabled.
 * |        |          |1 = Compare up count interrupt Enabled.
 * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
 * |[18]    |CMPUIEN2  |PWM Channel 2 Compare Up Count Interrupt Enable Bits
 * |        |          |0 = Compare up count interrupt Disabled.
 * |        |          |1 = Compare up count interrupt Enabled.
 * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
 * |[19]    |CMPUIEN3  |PWM Channel 3 Compare Up Count Interrupt Enable Bits
 * |        |          |0 = Compare up count interrupt Disabled.
 * |        |          |1 = Compare up count interrupt Enabled.
 * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
 * |[20]    |CMPUIEN4  |PWM Channel 4 Compare Up Count Interrupt Enable Bits
 * |        |          |0 = Compare up count interrupt Disabled.
 * |        |          |1 = Compare up count interrupt Enabled.
 * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
 * |[21]    |CMPUIEN5  |PWM Channel 5 Compare Up Count Interrupt Enable Bits
 * |        |          |0 = Compare up count interrupt Disabled.
 * |        |          |1 = Compare up count interrupt Enabled.
 * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
 * |[23]    |IFAIEN4_5 |PWM_CH4/5 Interrupt Flag Accumulator Interrupt Enable Bit
 * |        |          |0 = Interrupt Flag accumulator interrupt Disabled.
 * |        |          |1 = Interrupt Flag accumulator interrupt Enabled.
 * |[24]    |CMPDIEN0  |PWM Channel 0 Compare Down Count Interrupt Enable Bits
 * |        |          |0 = Compare down count interrupt Disabled.
 * |        |          |1 = Compare down count interrupt Enabled.
 * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
 * |[25]    |CMPDIEN1  |PWM Channel 1 Compare Down Count Interrupt Enable Bits
 * |        |          |0 = Compare down count interrupt Disabled.
 * |        |          |1 = Compare down count interrupt Enabled.
 * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
 * |[26]    |CMPDIEN2  |PWM Channel 2 Compare Down Count Interrupt Enable Bits
 * |        |          |0 = Compare down count interrupt Disabled.
 * |        |          |1 = Compare down count interrupt Enabled.
 * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
 * |[27]    |CMPDIEN3  |PWM Channel 3 Compare Down Count Interrupt Enable Bits
 * |        |          |0 = Compare down count interrupt Disabled.
 * |        |          |1 = Compare down count interrupt Enabled.
 * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
 * |[28]    |CMPDIEN4  |PWM Channel 4 Compare Down Count Interrupt Enable Bits
 * |        |          |0 = Compare down count interrupt Disabled.
 * |        |          |1 = Compare down count interrupt Enabled.
 * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
 * |[29]    |CMPDIEN5  |PWM Channel 5 Compare Down Count Interrupt Enable Bits
 * |        |          |0 = Compare down count interrupt Disabled.
 * |        |          |1 = Compare down count interrupt Enabled.
 * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
 * @var PWM_T::INTEN1
 * Offset: 0xE4  PWM Interrupt Enable Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BRKEIEN0_1|PWM Edge-detect Brake Interrupt Enable for Channel0/1 (Write Protect)
 * |        |          |0 = Edge-detect Brake interrupt for channel0/1 Disabled.
 * |        |          |1 = Edge-detect Brake interrupt for channel0/1 Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[1]     |BRKEIEN2_3|PWM Edge-detect Brake Interrupt Enable for Channel2/3 (Write Protect)
 * |        |          |0 = Edge-detect Brake interrupt for channel2/3 Disabled.
 * |        |          |1 = Edge-detect Brake interrupt for channel2/3 Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[2]     |BRKEIEN4_5|PWM Edge-detect Brake Interrupt Enable for Channel4/5 (Write Protect)
 * |        |          |0 = Edge-detect Brake interrupt for channel4/5 Disabled.
 * |        |          |1 = Edge-detect Brake interrupt for channel4/5 Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[8]     |BRKLIEN0_1|PWM Level-detect Brake Interrupt Enable for Channel0/1 (Write Protect)
 * |        |          |0 = Level-detect Brake interrupt for channel0/1 Disabled.
 * |        |          |1 = Level-detect Brake interrupt for channel0/1 Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[9]     |BRKLIEN2_3|PWM Level-detect Brake Interrupt Enable for Channel2/3 (Write Protect)
 * |        |          |0 = Level-detect Brake interrupt for channel2/3 Disabled.
 * |        |          |1 = Level-detect Brake interrupt for channel2/3 Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[10]    |BRKLIEN4_5|PWM Level-detect Brake Interrupt Enable for Channel4/5 (Write Protect)
 * |        |          |0 = Level-detect Brake interrupt for channel4/5 Disabled.
 * |        |          |1 = Level-detect Brake interrupt for channel4/5 Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * @var PWM_T::INTSTS0
 * Offset: 0xE8  PWM Interrupt Flag Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ZIF0      |PWM Channel 0 Zero Point Interrupt Flag
 * |        |          |This bit is set by hardware when PWM counter reaches zero, software can write 1 to clear this bit to zero.
 * |[1]     |ZIF1      |PWM Channel 1 Zero Point Interrupt Flag
 * |        |          |This bit is set by hardware when PWM counter reaches zero, software can write 1 to clear this bit to zero.
 * |[2]     |ZIF2      |PWM Channel 2 Zero Point Interrupt Flag
 * |        |          |This bit is set by hardware when PWM counter reaches zero, software can write 1 to clear this bit to zero.
 * |[3]     |ZIF3      |PWM Channel 3 Zero Point Interrupt Flag
 * |        |          |This bit is set by hardware when PWM counter reaches zero, software can write 1 to clear this bit to zero.
 * |[4]     |ZIF4      |PWM Channel 4 Zero Point Interrupt Flag
 * |        |          |This bit is set by hardware when PWM counter reaches zero, software can write 1 to clear this bit to zero.
 * |[5]     |ZIF5      |PWM Channel 5 Zero Point Interrupt Flag
 * |        |          |This bit is set by hardware when PWM counter reaches zero, software can write 1 to clear this bit to zero.
 * |[7]     |IFAIF0_1  |PWM_CH0/1 Interrupt Flag Accumulator Interrupt Flag
 * |        |          |Flag is set by hardware when condition match IFSEL0_1 in PWM_IFA register, software can clear this bit by writing 1 to it.
 * |[8]     |PIF0      |PWM Channel 0 Period Point Interrupt Flag
 * |        |          |This bit is set by hardware when PWM counter reaches PWM_PERIOD0, software can write 1 to clear this bit to zero.
 * |[9]     |PIF1      |PWM Channel 1 Period Point Interrupt Flag
 * |        |          |This bit is set by hardware when PWM counter reaches PWM_PERIOD1, software can write 1 to clear this bit to zero.
 * |[10]    |PIF2      |PWM Channel 2 Period Point Interrupt Flag
 * |        |          |This bit is set by hardware when PWM counter reaches PWM_PERIOD2, software can write 1 to clear this bit to zero.
 * |[11]    |PIF3      |PWM Channel 3 Period Point Interrupt Flag
 * |        |          |This bit is set by hardware when PWM counter reaches PWM_PERIOD3, software can write 1 to clear this bit to zero.
 * |[12]    |PIF4      |PWM Channel 4 Period Point Interrupt Flag
 * |        |          |This bit is set by hardware when PWM counter reaches PWM_PERIOD4, software can write 1 to clear this bit to zero.
 * |[13]    |PIF5      |PWM Channel 5 Period Point Interrupt Flag
 * |        |          |This bit is set by hardware when PWM counter reaches PWM_PERIOD5, software can write 1 to clear this bit to zero.
 * |[15]    |IFAIF2_3  |PWM_CH2/3 Interrupt Flag Accumulator Interrupt Flag
 * |        |          |Flag is set by hardware when condition match IFSEL2_3 in PWM_IFA register, software can clear this bit by writing 1 to it.
 * |[16]    |CMPUIF0   |PWM Channel 0 Compare Up Count Interrupt Flag
 * |        |          |Flag is set by hardware when PWM counter up count and reaches PWM_CMPDAT0, software can clear this bit by writing 1 to it.
 * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
 * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
 * |[17]    |CMPUIF1   |PWM Channel 1 Compare Up Count Interrupt Flag
 * |        |          |Flag is set by hardware when PWM counter up count and reaches PWM_CMPDAT1, software can clear this bit by writing 1 to it.
 * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
 * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
 * |[18]    |CMPUIF2   |PWM Channel 2 Compare Up Count Interrupt Flag
 * |        |          |Flag is set by hardware when PWM counter up count and reaches PWM_CMPDAT2, software can clear this bit by writing 1 to it.
 * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
 * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
 * |[19]    |CMPUIF3   |PWM Channel 3 Compare Up Count Interrupt Flag
 * |        |          |Flag is set by hardware when PWM counter up count and reaches PWM_CMPDAT3, software can clear this bit by writing 1 to it.
 * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
 * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
 * |[20]    |CMPUIF4   |PWM Channel 4 Compare Up Count Interrupt Flag
 * |        |          |Flag is set by hardware when PWM counter up count and reaches PWM_CMPDAT4, software can clear this bit by writing 1 to it.
 * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
 * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
 * |[21]    |CMPUIF5   |PWM Channel 5 Compare Up Count Interrupt Flag
 * |        |          |Flag is set by hardware when PWM counter up count and reaches PWM_CMPDAT5, software can clear this bit by writing 1 to it.
 * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
 * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
 * |[23]    |IFAIF4_5  |PWM_CH4/5 Interrupt Flag Accumulator Interrupt Flag
 * |        |          |Flag is set by hardware when condition match IFSEL4_5 in PWM_IFA register, software can clear this bit by writing 1 to it.
 * |[24]    |CMPDIF0   |PWM Channel 0 Compare Down Count Interrupt Flag
 * |        |          |Flag is set by hardware when PWM counter down count and reaches PWM_CMPDAT0, software can clear this bit by writing 1 to it.
 * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.
 * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
 * |[25]    |CMPDIF1   |PWM Channel 1 Compare Down Count Interrupt Flag
 * |        |          |Flag is set by hardware when PWM counter down count and reaches PWM_CMPDAT1, software can clear this bit by writing 1 to it.
 * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.
 * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
 * |[26]    |CMPDIF2   |PWM Channel 2 Compare Down Count Interrupt Flag
 * |        |          |Flag is set by hardware when PWM counter down count and reaches PWM_CMPDAT2, software can clear this bit by writing 1 to it.
 * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.
 * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
 * |[27]    |CMPDIF3   |PWM Channel 3 Compare Down Count Interrupt Flag
 * |        |          |Flag is set by hardware when PWM counter down count and reaches PWM_CMPDAT3, software can clear this bit by writing 1 to it.
 * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.
 * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
 * |[28]    |CMPDIF4   |PWM Channel 4 Compare Down Count Interrupt Flag
 * |        |          |Flag is set by hardware when PWM counter down count and reaches PWM_CMPDAT4, software can clear this bit by writing 1 to it.
 * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.
 * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
 * |[29]    |CMPDIF5   |PWM Channel 4 Compare Down Count Interrupt Flag
 * |        |          |Flag is set by hardware when PWM counter down count and reaches PWM_CMPDAT5, software can clear this bit by writing 1 to it.
 * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.
 * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
 * @var PWM_T::INTSTS1
 * Offset: 0xEC  PWM Interrupt Flag Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BRKEIF0   |PWM Channel 0 Edge-detect Brake Interrupt Flag (Write Protect)
 * |        |          |0 = PWM channel 0 edge-detect brake event do not happened.
 * |        |          |1 = When PWM channel0 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[1]     |BRKEIF1   |PWM Channel 1 Edge-detect Brake Interrupt Flag (Write Protect)
 * |        |          |0 = PWM channel 1 edge-detect brake event do not happened.
 * |        |          |1 = When PWM channel1 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[2]     |BRKEIF2   |PWM Channel 2 Edge-detect Brake Interrupt Flag (Write Protect)
 * |        |          |0 = PWM channel 2 edge-detect brake event do not happened.
 * |        |          |1 = When PWM channel 2 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[3]     |BRKEIF3   |PWM Channel 3 Edge-detect Brake Interrupt Flag (Write Protect)
 * |        |          |0 = PWM channel 3 edge-detect brake event do not happened.
 * |        |          |1 = When PWM channel 3 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[4]     |BRKEIF4   |PWM Channel 4 Edge-detect Brake Interrupt Flag (Write Protect)
 * |        |          |0 = PWM channel 4 edge-detect brake event do not happened.
 * |        |          |1 = When PWM channel 4 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[5]     |BRKEIF5   |PWM Channel 5 Edge-detect Brake Interrupt Flag (Write Protect)
 * |        |          |0 = PWM channel 5 edge-detect brake event do not happened.
 * |        |          |1 = When PWM channel 5 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[8]     |BRKLIF0   |PWM Channel 0 Level-detect Brake Interrupt Flag (Write Protect)
 * |        |          |0 = PWM channel 0 level-detect brake event do not happened.
 * |        |          |1 = When PWM channel 0 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[9]     |BRKLIF1   |PWM Channel 1 Level-detect Brake Interrupt Flag (Write Protect)
 * |        |          |0 = PWM channel 1 level-detect brake event do not happened.
 * |        |          |1 = When PWM channel 1 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[10]    |BRKLIF2   |PWM Channel 2 Level-detect Brake Interrupt Flag (Write Protect)
 * |        |          |0 = PWM channel 2 level-detect brake event do not happened.
 * |        |          |1 = When PWM channel 2 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[11]    |BRKLIF3   |PWM Channel 3 Level-detect Brake Interrupt Flag (Write Protect)
 * |        |          |0 = PWM channel 3 level-detect brake event do not happened.
 * |        |          |1 = When PWM channel 3 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[12]    |BRKLIF4   |PWM Channel 4 Level-detect Brake Interrupt Flag (Write Protect)
 * |        |          |0 = PWM channel 4 level-detect brake event do not happened.
 * |        |          |1 = When PWM channel 4 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[13]    |BRKLIF5   |PWM Channel 5 Level-detect Brake Interrupt Flag (Write Protect)
 * |        |          |0 = PWM channel 5 level-detect brake event do not happened.
 * |        |          |1 = When PWM channel 5 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * |[16]    |BRKESTS0  |PWM Channel 0 Edge-detect Brake Status
 * |        |          |0 = PWM channel 0 edge-detect brake state is released.
 * |        |          |1 = When PWM channel 0 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 0 at brake state, writing 1 to clear.
 * |[17]    |BRKESTS1  |PWM Channel 1 Edge-detect Brake Status
 * |        |          |0 = PWM channel 1 edge-detect brake state is released.
 * |        |          |1 = When PWM channel 1 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 1 at brake state, writing 1 to clear.
 * |[18]    |BRKESTS2  |PWM Channel 2 Edge-detect Brake Status
 * |        |          |0 = PWM channel 2 edge-detect brake state is released.
 * |        |          |1 = When PWM channel 2 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 2 at brake state, writing 1 to clear.
 * |[19]    |BRKESTS3  |PWM Channel 3 Edge-detect Brake Status
 * |        |          |0 = PWM channel 3 edge-detect brake state is released.
 * |        |          |1 = When PWM channel 3 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 3 at brake state, writing 1 to clear.
 * |[20]    |BRKESTS4  |PWM Channel 4 Edge-detect Brake Status
 * |        |          |0 = PWM channel 4 edge-detect brake state is released.
 * |        |          |1 = When PWM channel 4 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 4 at brake state, writing 1 to clear.
 * |[21]    |BRKESTS5  |PWM Channel 5 Edge-detect Brake Status
 * |        |          |0 = PWM channel 5 edge-detect brake state is released.
 * |        |          |1 = When PWM channel 5 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 5 at brake state, writing 1 to clear.
 * |[24]    |BRKLSTS0  |PWM Channel 0 Level-detect Brake Status (Read Only)
 * |        |          |0 = PWM channel 0 level-detect brake state is released.
 * |        |          |1 = When PWM channel 0 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 0 at brake state.
 * |        |          |Note: This bit is read only and auto cleared by hardware
 * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished
 * |        |          |The PWM waveform will start output from next full PWM period.
 * |[25]    |BRKLSTS1  |PWM Channel 1 Level-detect Brake Status (Read Only)
 * |        |          |0 = PWM channel 1 level-detect brake state is released.
 * |        |          |1 = When PWM channel 1 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 1 at brake state.
 * |        |          |Note: This bit is read only and auto cleared by hardware
 * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished
 * |        |          |The PWM waveform will start output from next full PWM period.
 * |[26]    |BRKLSTS2  |PWM Channel 2 Level-detect Brake Status (Read Only)
 * |        |          |0 = PWM channel 2 level-detect brake state is released.
 * |        |          |1 = When PWM channel 2 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 2 at brake state.
 * |        |          |Note: This bit is read only and auto cleared by hardware
 * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished
 * |        |          |The PWM waveform will start output from next full PWM period.
 * |[27]    |BRKLSTS3  |PWM Channel 3 Level-detect Brake Status (Read Only)
 * |        |          |0 = PWM channel 3 level-detect brake state is released.
 * |        |          |1 = When PWM channel 3 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 3 at brake state.
 * |        |          |Note: This bit is read only and auto cleared by hardware
 * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished
 * |        |          |The PWM waveform will start output from next full PWM period.
 * |[28]    |BRKLSTS4  |PWM Channel 4 Level-detect Brake Status (Read Only)
 * |        |          |0 = PWM channel 4 level-detect brake state is released.
 * |        |          |1 = When PWM channel 4 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 4 at brake state.
 * |        |          |Note: This bit is read only and auto cleared by hardware
 * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished
 * |        |          |The PWM waveform will start output from next full PWM period.
 * |[29]    |BRKLSTS5  |PWM Channel 5 Level-detect Brake Status (Read Only)
 * |        |          |0 = PWM channel 5 level-detect brake state is released.
 * |        |          |1 = When PWM channel 5 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 5 at brake state.
 * |        |          |Note: This bit is read only and auto cleared by hardware
 * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished
 * |        |          |The PWM waveform will start output from next full PWM period.
 * @var PWM_T::IFA
 * Offset: 0xF0  PWM Interrupt Flag Accumulator Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |IFCNT0_1  |PWM_CH0 and PWM_CH1 Interrupt Flag Counter
 * |        |          |The register sets the count number which defines how many times of PWM_CH0 and PWM_CH1 period occurs to set bit IFAIF0_1 to request the PWM period interrupt.
 * |        |          |PWM flag will be set in every IFCNT0_1 [3:0] times of PWM period.
 * |[6:4]   |IFSEL0_1  |PWM_CH0 and PWM_CH1 Interrupt Flag Accumulator Source Select
 * |        |          |000 = CNT equal to Zero in channel 0.
 * |        |          |001 = CNT equal to PERIOD in channel 0.
 * |        |          |010 = CNT equal to CMPU in channel 0.
 * |        |          |011 = CNT equal to CMPD in channel 0.
 * |        |          |100 = CNT equal to Zero in channel 1.
 * |        |          |101 = CNT equal to PERIOD in channel 1.
 * |        |          |110 = CNT equal to CMPU in channel 1.
 * |        |          |111 = CNT equal to CMPD in channel 1.
 * |[7]     |IFAEN0_1  |PWM_CH0 and PWM_CH1 Interrupt Flag Accumulator Enable Bit
 * |        |          |0 = PWM_CH0 and PWM_CH1 interrupt flag accumulator disable.
 * |        |          |1 = PWM_CH0 and PWM_CH1 interrupt flag accumulator enable.
 * |[11:8]  |IFCNT2_3  |PWM_CH2 and PWM_CH3 Interrupt Flag Counter
 * |        |          |The register sets the count number which defines how many times of PWM_CH2 and PWM_CH3 period occurs to set bit IFAIF2_3 to request the PWM period interrupt.
 * |        |          |PWM flag will be set in every IFCNT2_3[3:0] times of PWM period.
 * |[14:12] |IFSEL2_3  |PWM_CH2 and PWM_CH3 Interrupt Flag Accumulator Source Select
 * |        |          |000 = CNT equal to Zero in channel 2.
 * |        |          |001 = CNT equal to PERIOD in channel 2.
 * |        |          |010 = CNT equal to CMPU in channel 2.
 * |        |          |011 = CNT equal to CMPD in channel 2.
 * |        |          |100 = CNT equal to Zero in channel 3.
 * |        |          |101 = CNT equal to PERIOD in channel 3.
 * |        |          |110 = CNT equal to CMPU in channel 3.
 * |        |          |111 = CNT equal to CMPD in channel 3.
 * |[15]    |IFAEN2_3  |PWM_CH2 and PWM_CH3 Interrupt Flag Accumulator Enable Bit
 * |        |          |0 = PWM_CH2 and PWM_CH3 interrupt flag accumulator disable.
 * |        |          |1 = PWM_CH2 and PWM_CH3 interrupt flag accumulator enable.
 * |[19:16] |IFCNT4_5  |PWM_CH4 and PWM_CH5 Interrupt Flag Counter
 * |        |          |The register sets the count number which defines how many times of PWM_CH4 and PWM_CH5 period occurs to set bit IFAIF4_5 to request the PWM period interrupt.
 * |        |          |PWM flag will be set in every IFCNT4_5[3:0] times of PWM period.
 * |[22:20] |IFSEL4_5  |PWM_CH4 and PWM_CH5 Interrupt Flag Accumulator Source Select
 * |        |          |000 = CNT equal to Zero in channel 4.
 * |        |          |001 = CNT equal to PERIOD in channel 4.
 * |        |          |010 = CNT equal to CMPU in channel 4.
 * |        |          |011 = CNT equal to CMPD in channel 4.
 * |        |          |100 = CNT equal to Zero in channel 5.
 * |        |          |101 = CNT equal to PERIOD in channel 5.
 * |        |          |110 = CNT equal to CMPU in channel 5.
 * |        |          |111 = CNT equal to CMPD in channel 5.
 * |[23]    |IFAEN4_5  |PWM_CH4 and PWM_CH5 Interrupt Flag Accumulator Enable Bit
 * |        |          |0 = PWM_CH4 and PWM_CH5 interrupt flag accumulator disable.
 * |        |          |1 = PWM_CH4 and PWM_CH5 interrupt flag accumulator enable.
 * @var PWM_T::EADCTS0
 * Offset: 0xF8  PWM Trigger EADC Source Select Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |TRGSEL0   |PWM_CH0 Trigger EADC Source Select
 * |        |          |0000 = PWM_CH0 zero point.
 * |        |          |0001 = PWM_CH0 period point.
 * |        |          |0010 = PWM_CH0 zero or period point.
 * |        |          |0011 = PWM_CH0 up-count CMPDAT point.
 * |        |          |0100 = PWM_CH0 down-count CMPDAT point.
 * |        |          |0101 = PWM_CH1 zero point.
 * |        |          |0110 = PWM_CH1 period point.
 * |        |          |0111 = PWM_CH1 zero or period point.
 * |        |          |1000 = PWM_CH1 up-count CMPDAT point.
 * |        |          |1001 = PWM_CH1 down-count CMPDAT point.
 * |        |          |1010 = PWM_CH0 up-count free CMPDAT point.
 * |        |          |1011 = PWM_CH0 down-count free CMPDAT point.
 * |        |          |1100 = PWM_CH2 up-count free CMPDAT point.
 * |        |          |1101 = PWM_CH2 down-count free CMPDAT point.
 * |        |          |1110 = PWM_CH4 up-count free CMPDAT point.
 * |        |          |1111 = PWM_CH4 down-count free CMPDAT point.
 * |[7]     |TRGEN0    |PWM_CH0 Trigger EADC enable bit
 * |[11:8]  |TRGSEL1   |PWM_CH1 Trigger EADC Source Select
 * |        |          |0000 = PWM_CH0 zero point.
 * |        |          |0001 = PWM_CH0 period point.
 * |        |          |0010 = PWM_CH0 zero or period point.
 * |        |          |0011 = PWM_CH0 up-count CMPDAT point.
 * |        |          |0100 = PWM_CH0 down-count CMPDAT point.
 * |        |          |0101 = PWM_CH1 zero point.
 * |        |          |0110 = PWM_CH1 period point.
 * |        |          |0111 = PWM_CH1 zero or period point.
 * |        |          |1000 = PWM_CH1 up-count CMPDAT point.
 * |        |          |1001 = PWM_CH1 down-count CMPDAT point.
 * |        |          |1010 = PWM_CH0 up-count free CMPDAT point.
 * |        |          |1011 = PWM_CH0 down-count free CMPDAT point.
 * |        |          |1100 = PWM_CH2 up-count free CMPDAT point.
 * |        |          |1101 = PWM_CH2 down-count free CMPDAT point.
 * |        |          |1110 = PWM_CH4 up-count free CMPDAT point.
 * |        |          |1111 = PWM_CH4 down-count free CMPDAT point.
 * |[15]    |TRGEN1    |PWM_CH1 Trigger EADC enable bit
 * |[19:16] |TRGSEL2   |PWM_CH2 Trigger EADC Source Select
 * |        |          |0000 = PWM_CH2 zero point.
 * |        |          |0001 = PWM_CH2 period point.
 * |        |          |0010 = PWM_CH2 zero or period point.
 * |        |          |0011 = PWM_CH2 up-count CMPDAT point.
 * |        |          |0100 = PWM_CH2 down-count CMPDAT point.
 * |        |          |0101 = PWM_CH3 zero point.
 * |        |          |0110 = PWM_CH3 period point.
 * |        |          |0111 = PWM_CH3 zero or period point.
 * |        |          |1000 = PWM_CH3 up-count CMPDAT point.
 * |        |          |1001 = PWM_CH3 down-count CMPDAT point.
 * |        |          |1010 = PWM_CH0 up-count free CMPDAT point.
 * |        |          |1011 = PWM_CH0 down-count free CMPDAT point.
 * |        |          |1100 = PWM_CH2 up-count free CMPDAT point.
 * |        |          |1101 = PWM_CH2 down-count free CMPDAT point.
 * |        |          |1110 = PWM_CH4 up-count free CMPDAT point.
 * |        |          |1111 = PWM_CH4 down-count free CMPDAT point.
 * |[23]    |TRGEN2    |PWM_CH2 Trigger EADC enable bit
 * |[27:24] |TRGSEL3   |PWM_CH3 Trigger EADC Source Select
 * |        |          |0000 = PWM_CH2 zero point.
 * |        |          |0001 = PWM_CH2 period point.
 * |        |          |0010 = PWM_CH2 zero or period point.
 * |        |          |0011 = PWM_CH2 up-count CMPDAT point.
 * |        |          |0100 = PWM_CH2 down-count CMPDAT point.
 * |        |          |0101 = PWM_CH3 zero point.
 * |        |          |0110 = PWM_CH3 period point.
 * |        |          |0111 = PWM_CH3 zero or period point.
 * |        |          |1000 = PWM_CH3 up-count CMPDAT point.
 * |        |          |1001 = PWM_CH3 down-count CMPDAT point.
 * |        |          |1010 = PWM_CH0 up-count free CMPDAT point.
 * |        |          |1011 = PWM_CH0 down-count free CMPDAT point.
 * |        |          |1100 = PWM_CH2 up-count free CMPDAT point.
 * |        |          |1101 = PWM_CH2 down-count free CMPDAT point.
 * |        |          |1110 = PWM_CH4 up-count free CMPDAT point.
 * |        |          |1111 = PWM_CH4 down-count free CMPDAT point.
 * |[31]    |TRGEN3    |PWM_CH3 Trigger EADC enable bit
 * @var PWM_T::EADCTS1
 * Offset: 0xFC  PWM Trigger EADC Source Select Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |TRGSEL4   |PWM_CH4 Trigger EADC Source Select
 * |        |          |0000 = PWM_CH4 zero point.
 * |        |          |0001 = PWM_CH4 period point.
 * |        |          |0010 = PWM_CH4 zero or period point.
 * |        |          |0011 = PWM_CH4 up-count CMPDAT point.
 * |        |          |0100 = PWM_CH4 down-count CMPDAT point.
 * |        |          |0101 = PWM_CH5 zero point.
 * |        |          |0110 = PWM_CH5 period point.
 * |        |          |0111 = PWM_CH5 zero or period point.
 * |        |          |1000 = PWM_CH5 up-count CMPDAT point.
 * |        |          |1001 = PWM_CH5 down-count CMPDAT point.
 * |        |          |1010 = PWM_CH0 up-count free CMPDAT point.
 * |        |          |1011 = PWM_CH0 down-count free CMPDAT point.
 * |        |          |1100 = PWM_CH2 up-count free CMPDAT point.
 * |        |          |1101 = PWM_CH2 down-count free CMPDAT point.
 * |        |          |1110 = PWM_CH4 up-count free CMPDAT point.
 * |        |          |1111 = PWM_CH4 down-count free CMPDAT point.
 * |[7]     |TRGEN4    |PWM_CH4 Trigger EADC enable bit
 * |[11:8]  |TRGSEL5   |PWM_CH5 Trigger EADC Source Select
 * |        |          |0000 = PWM_CH4 zero point.
 * |        |          |0001 = PWM_CH4 period point.
 * |        |          |0010 = PWM_CH4 zero or period point.
 * |        |          |0011 = PWM_CH4 up-count CMPDAT point.
 * |        |          |0100 = PWM_CH4 down-count CMPDAT point.
 * |        |          |0101 = PWM_CH5 zero point.
 * |        |          |0110 = PWM_CH5 period point.
 * |        |          |0111 = PWM_CH5 zero or period point.
 * |        |          |1000 = PWM_CH5 up-count CMPDAT point.
 * |        |          |1001 = PWM_CH5 down-count CMPDAT point.
 * |        |          |1010 = PWM_CH0 up-count free CMPDAT point.
 * |        |          |1011 = PWM_CH0 down-count free CMPDAT point.
 * |        |          |1100 = PWM_CH2 up-count free CMPDAT point.
 * |        |          |1101 = PWM_CH2 down-count free CMPDAT point.
 * |        |          |1110 = PWM_CH4 up-count free CMPDAT point.
 * |        |          |1111 = PWM_CH4 down-count free CMPDAT point.
 * |[15]    |TRGEN5    |PWM_CH5 Trigger EADC enable bit
 * @var PWM_T::FTCMPDAT0_1
 * Offset: 0x100  PWM Free Trigger Compare Register 0/1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |FTCMP     |PWM Free Trigger Compare Register
 * |        |          |FTCMP use to compare with even CNTR to trigger EADC
 * |        |          |FTCMPDAT0_1, 2_3, 4_5 corresponding complementary pairs PWM_CH0 and PWM_CH1, PWM_CH2 and PWM_CH3, PWM_CH4 and PWM_CH5.
 * @var PWM_T::FTCMPDAT2_3
 * Offset: 0x104  PWM Free Trigger Compare Register 2/3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |FTCMP     |PWM Free Trigger Compare Register
 * |        |          |FTCMP use to compare with even CNTR to trigger EADC
 * |        |          |FTCMPDAT0_1, 2_3, 4_5 corresponding complementary pairs PWM_CH0 and PWM_CH1, PWM_CH2 and PWM_CH3, PWM_CH4 and PWM_CH5.
 * @var PWM_T::FTCMPDAT4_5
 * Offset: 0x108  PWM Free Trigger Compare Register 4/5
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |FTCMP     |PWM Free Trigger Compare Register
 * |        |          |FTCMP use to compare with even CNTR to trigger EADC
 * |        |          |FTCMPDAT0_1, 2_3, 4_5 corresponding complementary pairs PWM_CH0 and PWM_CH1, PWM_CH2 and PWM_CH3, PWM_CH4 and PWM_CH5.
 * @var PWM_T::SSCTL
 * Offset: 0x110  PWM Synchronous Start Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |SSEN0     |PWM Channel 0 Synchronous Start Function Enable Bits
 * |        |          |When synchronous start function is enabled, the PWM counter enable register (PWM_CNTEN) can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
 * |        |          |0 = PWM synchronous start function Disabled.
 * |        |          |1 = PWM synchronous start function Enabled.
 * |[1]     |SSEN1     |PWM Channel 1 Synchronous Start Function Enable Bits
 * |        |          |When synchronous start function is enabled, the PWM counter enable register (PWM_CNTEN) can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
 * |        |          |0 = PWM synchronous start function Disabled.
 * |        |          |1 = PWM synchronous start function Enabled.
 * |[2]     |SSEN2     |PWM Channel 2 Synchronous Start Function Enable Bits
 * |        |          |When synchronous start function is enabled, the PWM counter enable register (PWM_CNTEN) can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
 * |        |          |0 = PWM synchronous start function Disabled.
 * |        |          |1 = PWM synchronous start function Enabled.
 * |[3]     |SSEN3     |PWM Channel 3 Synchronous Start Function Enable Bits
 * |        |          |When synchronous start function is enabled, the PWM counter enable register (PWM_CNTEN) can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
 * |        |          |0 = PWM synchronous start function Disabled.
 * |        |          |1 = PWM synchronous start function Enabled.
 * |[4]     |SSEN4     |PWM Channel 4 Synchronous Start Function Enable Bits
 * |        |          |When synchronous start function is enabled, the PWM counter enable register (PWM_CNTEN) can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
 * |        |          |0 = PWM synchronous start function Disabled.
 * |        |          |1 = PWM synchronous start function Enabled.
 * |[5]     |SSEN5     |PWM Channel 5 Synchronous Start Function Enable Bits
 * |        |          |When synchronous start function is enabled, the PWM counter enable register (PWM_CNTEN) can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
 * |        |          |0 = PWM synchronous start function Disabled.
 * |        |          |1 = PWM synchronous start function Enabled.
 * |[9:8]   |SSRC      |PWM Synchronous Start Source Select Bits
 * |        |          |00 = Synchronous start source come from PWM0.
 * |        |          |Other = No synchronous function.
 * @var PWM_T::SSTRG
 * Offset: 0x114  PWM Synchronous Start Trigger Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CNTSEN    |PWM Counter Synchronous Start Enable (Write Only)
 * |        |          |PMW counter synchronous enable function is used to make selected PWM channels (include PWM0_CHx) start counting at the same time.
 * |        |          |Writing this bit to 1 will also set the counter enable bit (CNTENn, n denotes channel 0 to 5) if correlated PWM channel counter synchronous start function is enabled.
 * @var PWM_T::STATUS
 * Offset: 0x120  PWM Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CNTMAXF0  |PWM Channel 0 Time-base Counter Equal to 0xFFFF Latched Flag
 * |        |          |0 = indicates the time-base counter never reached its maximum value 0xFFFF.
 * |        |          |1 = indicates the time-base counter reached its maximum value, software can write 1 to clear this bit.
 * |[1]     |CNTMAXF1  |PWM Channel 1 Time-base Counter Equal to 0xFFFF Latched Flag
 * |        |          |0 = indicates the time-base counter never reached its maximum value 0xFFFF.
 * |        |          |1 = indicates the time-base counter reached its maximum value, software can write 1 to clear this bit.
 * |[2]     |CNTMAXF2  |PWM Channel 2 Time-base Counter Equal to 0xFFFF Latched Flag
 * |        |          |0 = indicates the time-base counter never reached its maximum value 0xFFFF.
 * |        |          |1 = indicates the time-base counter reached its maximum value, software can write 1 to clear this bit.
 * |[3]     |CNTMAXF3  |PWM Channel 3 Time-base Counter Equal to 0xFFFF Latched Flag
 * |        |          |0 = indicates the time-base counter never reached its maximum value 0xFFFF.
 * |        |          |1 = indicates the time-base counter reached its maximum value, software can write 1 to clear this bit.
 * |[4]     |CNTMAXF4  |PWM Channel 4 Time-base Counter Equal to 0xFFFF Latched Flag
 * |        |          |0 = indicates the time-base counter never reached its maximum value 0xFFFF.
 * |        |          |1 = indicates the time-base counter reached its maximum value, software can write 1 to clear this bit.
 * |[5]     |CNTMAXF5  |PWM Channel 5 Time-base Counter Equal to 0xFFFF Latched Flag
 * |        |          |0 = indicates the time-base counter never reached its maximum value 0xFFFF.
 * |        |          |1 = indicates the time-base counter reached its maximum value, software can write 1 to clear this bit.
 * |[8]     |SYNCINF0  |PWM Channel 0 Input Synchronization Latched Flag
 * |        |          |0 = Indicates no SYNC_IN event has occurred.
 * |        |          |1 = Indicates an SYNC_IN event has occurred, software can write 1 to clear this bit.
 * |[9]     |SYNCINF2  |PWM Channel 2 Input Synchronization Latched Flag
 * |        |          |0 = Indicates no SYNC_IN event has occurred.
 * |        |          |1 = Indicates an SYNC_IN event has occurred, software can write 1 to clear this bit.
 * |[10]    |SYNCINF4  |PWM Channel 4 Input Synchronization Latched Flag
 * |        |          |0 = Indicates no SYNC_IN event has occurred.
 * |        |          |1 = Indicates an SYNC_IN event has occurred, software can write 1 to clear this bit.
 * |[16]    |ADCTRGF0  |PWM Channel 0 EADC Start of Conversion Flag
 * |        |          |0 = Indicates no EADC start of conversion trigger event has occurred.
 * |        |          |1 = Indicates an EADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
 * |[17]    |ADCTRGF1  |PWM Channel 1 EADC Start of Conversion Flag
 * |        |          |0 = Indicates no EADC start of conversion trigger event has occurred.
 * |        |          |1 = Indicates an EADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
 * |[18]    |ADCTRGF2  |PWM Channel 2 EADC Start of Conversion Flag
 * |        |          |0 = Indicates no EADC start of conversion trigger event has occurred.
 * |        |          |1 = Indicates an EADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
 * |[19]    |ADCTRGF3  |PWM Channel 3 EADC Start of Conversion Flag
 * |        |          |0 = Indicates no EADC start of conversion trigger event has occurred.
 * |        |          |1 = Indicates an EADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
 * |[20]    |ADCTRGF4  |PWM Channel 4 EADC Start of Conversion Flag
 * |        |          |0 = Indicates no EADC start of conversion trigger event has occurred.
 * |        |          |1 = Indicates an EADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
 * |[21]    |ADCTRGF5  |PWM Channel 5 EADC Start of Conversion Flag
 * |        |          |0 = Indicates no EADC start of conversion trigger event has occurred.
 * |        |          |1 = Indicates an EADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
 * @var PWM_T::CAPINEN
 * Offset: 0x200  PWM Capture Input Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CAPINEN0  |PWM Channel 0 Capture Input Enable Bits
 * |        |          |0 = PWM Channel capture input path Disabled
 * |        |          |The input of PWM channel capture function is always regarded as 0.
 * |        |          |1 = PWM Channel capture input path Enabled
 * |        |          |The input of PWM channel capture function comes from correlative multifunction pin.
 * |[1]     |CAPINEN1  |PWM Channel 1 Capture Input Enable Bits
 * |        |          |0 = PWM Channel capture input path Disabled
 * |        |          |The input of PWM channel capture function is always regarded as 0.
 * |        |          |1 = PWM Channel capture input path Enabled
 * |        |          |The input of PWM channel capture function comes from correlative multifunction pin.
 * |[2]     |CAPINEN2  |PWM Channel 2 Capture Input Enable Bits
 * |        |          |0 = PWM Channel capture input path Disabled
 * |        |          |The input of PWM channel capture function is always regarded as 0.
 * |        |          |1 = PWM Channel capture input path Enabled
 * |        |          |The input of PWM channel capture function comes from correlative multifunction pin.
 * |[3]     |CAPINEN3  |PWM Channel 3 Capture Input Enable Bits
 * |        |          |0 = PWM Channel capture input path Disabled
 * |        |          |The input of PWM channel capture function is always regarded as 0.
 * |        |          |1 = PWM Channel capture input path Enabled
 * |        |          |The input of PWM channel capture function comes from correlative multifunction pin.
 * |[4]     |CAPINEN4  |PWM Channel 4 Capture Input Enable Bits
 * |        |          |0 = PWM Channel capture input path Disabled
 * |        |          |The input of PWM channel capture function is always regarded as 0.
 * |        |          |1 = PWM Channel capture input path Enabled
 * |        |          |The input of PWM channel capture function comes from correlative multifunction pin.
 * |[5]     |CAPINEN5  |PWM Channel 5 Capture Input Enable Bits
 * |        |          |0 = PWM Channel capture input path Disabled
 * |        |          |The input of PWM channel capture function is always regarded as 0.
 * |        |          |1 = PWM Channel capture input path Enabled
 * |        |          |The input of PWM channel capture function comes from correlative multifunction pin.
 * @var PWM_T::CAPCTL
 * Offset: 0x204  PWM Capture Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CAPEN0    |PWM Channel 0 Capture Function Enable Bits
 * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated.
 * |        |          |1 = Capture function Enabled
 * |        |          |Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch).
 * |[1]     |CAPEN1    |PWM Channel 1 Capture Function Enable Bits
 * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated.
 * |        |          |1 = Capture function Enabled
 * |        |          |Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch).
 * |[2]     |CAPEN2    |PWM Channel 2 Capture Function Enable Bits
 * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated.
 * |        |          |1 = Capture function Enabled
 * |        |          |Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch).
 * |[3]     |CAPEN3    |PWM Channel 3 Capture Function Enable Bits
 * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated.
 * |        |          |1 = Capture function Enabled
 * |        |          |Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch).
 * |[4]     |CAPEN4    |PWM Channel 4 Capture Function Enable Bits
 * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated.
 * |        |          |1 = Capture function Enabled
 * |        |          |Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch).
 * |[5]     |CAPEN5    |PWM Channel 5 Capture Function Enable Bits
 * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated.
 * |        |          |1 = Capture function Enabled
 * |        |          |Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch).
 * |[8]     |CAPINV0   |PWM Channel 0 Capture Inverter Enable Bits
 * |        |          |0 = Capture source inverter Disabled.
 * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
 * |[9]     |CAPINV1   |PWM Channel 1 Capture Inverter Enable Bits
 * |        |          |0 = Capture source inverter Disabled.
 * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
 * |[10]    |CAPINV2   |PWM Channel 2 Capture Inverter Enable Bits
 * |        |          |0 = Capture source inverter Disabled.
 * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
 * |[11]    |CAPINV3   |PWM Channel 3 Capture Inverter Enable Bits
 * |        |          |0 = Capture source inverter Disabled.
 * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
 * |[12]    |CAPINV4   |PWM Channel 4 Capture Inverter Enable Bits
 * |        |          |0 = Capture source inverter Disabled.
 * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
 * |[13]    |CAPINV5   |PWM Channel 5 Capture Inverter Enable Bits
 * |        |          |0 = Capture source inverter Disabled.
 * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
 * |[16]    |RCRLDEN0  |PWM Channel 0 Rising Capture Reload Enable Bits
 * |        |          |0 = Rising capture reload counter Disabled.
 * |        |          |1 = Rising capture reload counter Enabled.
 * |[17]    |RCRLDEN1  |PWM Channel 1 Rising Capture Reload Enable Bits
 * |        |          |0 = Rising capture reload counter Disabled.
 * |        |          |1 = Rising capture reload counter Enabled.
 * |[18]    |RCRLDEN2  |PWM Channel 2 Rising Capture Reload Enable Bits
 * |        |          |0 = Rising capture reload counter Disabled.
 * |        |          |1 = Rising capture reload counter Enabled.
 * |[19]    |RCRLDEN3  |PWM Channel 3 Rising Capture Reload Enable Bits
 * |        |          |0 = Rising capture reload counter Disabled.
 * |        |          |1 = Rising capture reload counter Enabled.
 * |[20]    |RCRLDEN4  |PWM Channel 4 Rising Capture Reload Enable Bits
 * |        |          |0 = Rising capture reload counter Disabled.
 * |        |          |1 = Rising capture reload counter Enabled.
 * |[21]    |RCRLDEN5  |PWM Channel 5 Rising Capture Reload Enable Bits
 * |        |          |0 = Rising capture reload counter Disabled.
 * |        |          |1 = Rising capture reload counter Enabled.
 * |[24]    |FCRLDEN0  |PWM Channel 0 Falling Capture Reload Enable Bits
 * |        |          |0 = Falling capture reload counter Disabled.
 * |        |          |1 = Falling capture reload counter Enabled.
 * |[25]    |FCRLDEN1  |PWM Channel 1 Falling Capture Reload Enable Bits
 * |        |          |0 = Falling capture reload counter Disabled.
 * |        |          |1 = Falling capture reload counter Enabled.
 * |[26]    |FCRLDEN2  |PWM Channel 2 Falling Capture Reload Enable Bits
 * |        |          |0 = Falling capture reload counter Disabled.
 * |        |          |1 = Falling capture reload counter Enabled.
 * |[27]    |FCRLDEN3  |PWM Channel 3 Falling Capture Reload Enable Bits
 * |        |          |0 = Falling capture reload counter Disabled.
 * |        |          |1 = Falling capture reload counter Enabled.
 * |[28]    |FCRLDEN4  |PWM Channel 4 Falling Capture Reload Enable Bits
 * |        |          |0 = Falling capture reload counter Disabled.
 * |        |          |1 = Falling capture reload counter Enabled.
 * |[29]    |FCRLDEN5  |PWM Channel 5 Falling Capture Reload Enable Bits
 * |        |          |0 = Falling capture reload counter Disabled.
 * |        |          |1 = Falling capture reload counter Enabled.
 * @var PWM_T::CAPSTS
 * Offset: 0x208  PWM Capture Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CRLIFOV0  |PWM Channel 0 Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
 * |        |          |This flag indicates if rising latch happened when the corresponding CRLIF is 1.
 * |        |          |Note: This bit will be cleared automatically when user clear corresponding CRLIF.
 * |[1]     |CRLIFOV1  |PWM Channel 1 Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
 * |        |          |This flag indicates if rising latch happened when the corresponding CRLIF is 1.
 * |        |          |Note: This bit will be cleared automatically when user clear corresponding CRLIF.
 * |[2]     |CRLIFOV2  |PWM Channel 2 Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
 * |        |          |This flag indicates if rising latch happened when the corresponding CRLIF is 1.
 * |        |          |Note: This bit will be cleared automatically when user clear corresponding CRLIF.
 * |[3]     |CRLIFOV3  |PWM Channel 3 Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
 * |        |          |This flag indicates if rising latch happened when the corresponding CRLIF is 1.
 * |        |          |Note: This bit will be cleared automatically when user clear corresponding CRLIF.
 * |[4]     |CRLIFOV4  |PWM Channel 4 Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
 * |        |          |This flag indicates if rising latch happened when the corresponding CRLIF is 1.
 * |        |          |Note: This bit will be cleared automatically when user clear corresponding CRLIF.
 * |[5]     |CRLIFOV5  |PWM Channel 5 Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
 * |        |          |This flag indicates if rising latch happened when the corresponding CRLIF is 1.
 * |        |          |Note: This bit will be cleared automatically when user clear corresponding CRLIF.
 * |[8]     |CFLIFOV0  |PWM Channel 0 Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
 * |        |          |This flag indicates if falling latch happened when the corresponding CFLIF is 1.
 * |        |          |Note: This bit will be cleared automatically when user clear corresponding CFLIF.
 * |[9]     |CFLIFOV1  |PWM Channel 1 Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
 * |        |          |This flag indicates if falling latch happened when the corresponding CFLIF is 1.
 * |        |          |Note: This bit will be cleared automatically when user clear corresponding CFLIF.
 * |[10]    |CFLIFOV2  |PWM Channel 2 Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
 * |        |          |This flag indicates if falling latch happened when the corresponding CFLIF is 1.
 * |        |          |Note: This bit will be cleared automatically when user clear corresponding CFLIF.
 * |[11]    |CFLIFOV3  |PWM Channel 3 Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
 * |        |          |This flag indicates if falling latch happened when the corresponding CFLIF is 1.
 * |        |          |Note: This bit will be cleared automatically when user clear corresponding CFLIF.
 * |[12]    |CFLIFOV4  |PWM Channel 4 Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
 * |        |          |This flag indicates if falling latch happened when the corresponding CFLIF is 1.
 * |        |          |Note: This bit will be cleared automatically when user clear corresponding CFLIF.
 * |[13]    |CFLIFOV5  |PWM Channel 5 Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
 * |        |          |This flag indicates if falling latch happened when the corresponding CFLIF is 1.
 * |        |          |Note: This bit will be cleared automatically when user clear corresponding CFLIF.
 * @var PWM_T::RCAPDAT0
 * Offset: 0x20C  PWM Rising Capture Data Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
 * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
 * @var PWM_T::FCAPDAT0
 * Offset: 0x210  PWM Falling Capture Data Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
 * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
 * @var PWM_T::RCAPDAT1
 * Offset: 0x214  PWM Rising Capture Data Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
 * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
 * @var PWM_T::FCAPDAT1
 * Offset: 0x218  PWM Falling Capture Data Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
 * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
 * @var PWM_T::RCAPDAT2
 * Offset: 0x21C  PWM Rising Capture Data Register 2
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
 * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
 * @var PWM_T::FCAPDAT2
 * Offset: 0x220  PWM Falling Capture Data Register 2
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
 * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
 * @var PWM_T::RCAPDAT3
 * Offset: 0x224  PWM Rising Capture Data Register 3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
 * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
 * @var PWM_T::FCAPDAT3
 * Offset: 0x228  PWM Falling Capture Data Register 3
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
 * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
 * @var PWM_T::RCAPDAT4
 * Offset: 0x22C  PWM Rising Capture Data Register 4
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
 * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
 * @var PWM_T::FCAPDAT4
 * Offset: 0x230  PWM Falling Capture Data Register 4
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
 * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
 * @var PWM_T::RCAPDAT5
 * Offset: 0x234  PWM Rising Capture Data Register 5
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
 * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
 * @var PWM_T::FCAPDAT5
 * Offset: 0x238  PWM Falling Capture Data Register 5
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
 * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
 * @var PWM_T::PDMACTL
 * Offset: 0x23C  PWM PDMA Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CHEN0_1   |Channel 0/1 PDMA Enable
 * |        |          |0 = Channel 0/1 PDMA function Disabled.
 * |        |          |1 = Channel 0/1 PDMA function Enabled for the channel 0/1 captured data and transfer to memory.
 * |[2:1]   |CAPMOD0_1 |Select PWM_RCAPDAT0/1 or PWM_FCAPDAT0/1 to Do PDMA Transfer
 * |        |          |00 = Reserved.
 * |        |          |01 = PWM_RCAPDAT0/1.
 * |        |          |10 = PWM_FCAPDAT0/1.
 * |        |          |11 = Both PWM_RCAPDAT0/1 and PWM_FCAPDAT0/1. 
 * |[3]     |CAPORD0_1 |Capture Channel 0/1 Rising/Falling Order
 * |        |          |Set this bit to determine whether the PWM_RCAPDAT0/1 or PWM_FCAPDAT0/1 is the first captured data transferred to memory through PDMA when CAPMOD0_1 =11.
 * |        |          |0 = PWM_FCAPDAT0/1 is the first captured data to memory.
 * |        |          |1 = PWM_RCAPDAT0/1 is the first captured data to memory.
 * |[4]     |CHSEL0_1  |Select Channel 0/1 to Do PDMA Transfer
 * |        |          |0 = Channel0.
 * |        |          |1 = Channel1.
 * |[8]     |CHEN2_3   |Channel 2/3 PDMA Enable
 * |        |          |0 = Channel 2/3 PDMA function Disabled.
 * |        |          |1 = Channel 2/3 PDMA function Enabled for the channel 2/3 captured data and transfer to memory. 
 * |[10:9]  |CAPMOD2_3 |Select PWM_RCAPDAT2/3 or PWM_FCAODAT2/3 to Do PDMA Transfer
 * |        |          |00 = Reserved.
 * |        |          |01 = PWM_RCAPDAT2/3.
 * |        |          |10 = PWM_FCAPDAT2/3.
 * |        |          |11 = Both PWM_RCAPDAT2/3 and PWM_FCAPDAT2/3. 
 * |[11]    |CAPORD2_3 |Capture Channel 2/3 Rising/Falling Order
 * |        |          |Set this bit to determine whether the PWM_RCAPDAT2/3 or PWM_FCAPDAT2/3 is the first captured data transferred to memory through PDMA when CAPMOD2_3 =11.
 * |        |          |0 = PWM_FCAPDAT2/3 is the first captured data to memory.
 * |        |          |1 = PWM_RCAPDAT2/3 is the first captured data to memory. 
 * |[12]    |CHSEL2_3  |Select Channel 2/3 to Do PDMA Transfer
 * |        |          |0 = Channel2.
 * |        |          |1 = Channel3.
 * |[16]    |CHEN4_5   |Channel 4/5 PDMA Enable
 * |        |          |0 = Channel 4/5 PDMA function Disabled.
 * |        |          |1 = Channel 4/5 PDMA function Enabled for the channel 4/5 captured data and transfer to memory. 
 * |[18:17] |CAPMOD4_5 |Select PWM_RCAPDAT4/5 or PWM_FCAPDAT4/5 to Do PDMA Transfer
 * |        |          |00 = Reserved.
 * |        |          |01 = PWM_RCAPDAT4/5.
 * |        |          |10 = PWM_FCAPDAT4/5.
 * |        |          |11 = Both PWM_RCAPDAT4/5 and PWM_FCAPDAT4/5. 
 * |[19]    |CAPORD4_5 |Capture Channel 4/5 Rising/Falling Order
 * |        |          |Set this bit to determine whether the PWM_RCAPDAT4/5 or PWM_FCAPDAT4/5 is the first captured data transferred to memory through PDMA when CAPMOD4_5 =11.
 * |        |          |0 = PWM_FCAPDAT4/5 is the first captured data to memory.
 * |        |          |1 = PWM_RCAPDAT4/5 is the first captured data to memory. 
 * |[20]    |CHSEL4_5  |Select Channel 4/5 to Do PDMA Transfer
 * |        |          |0 = Channel4.
 * |        |          |1 = Channel5.
 * @var PWM_T::PDMACAP0_1
 * Offset: 0x240  PWM Capture Channel 01 PDMA Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CAPBUF    |PWM Capture PDMA Register (Read Only)
 * |        |          |This register is use as a buffer to transfer PWM capture rising or falling data to memory by PDMA.
 * @var PWM_T::PDMACAP2_3
 * Offset: 0x244  PWM Capture Channel 23 PDMA Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CAPBUF    |PWM Capture PDMA Register (Read Only)
 * |        |          |This register is use as a buffer to transfer PWM capture rising or falling data to memory by PDMA.
 * @var PWM_T::PDMACAP4_5
 * Offset: 0x248  PWM Capture Channel 45 PDMA Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CAPBUF    |PWM Capture PDMA Register (Read Only)
 * |        |          |This register is use as a buffer to transfer PWM capture rising or falling data to memory by PDMA.
 * @var PWM_T::CAPIEN
 * Offset: 0x250  PWM Capture Interrupt Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CAPRIEN0  |PWM Channel 0 Capture Rising Latch Interrupt Enable Bits
 * |        |          |0 = Capture rising edge latch interrupt Disabled.
 * |        |          |1 = Capture rising edge latch interrupt Enabled.
 * |        |          |Note: When Capture with PDMA operating, CINTENR corresponding channel CAPRIEN must be disabled.
 * |[1]     |CAPRIEN1  |PWM Channel 1 Capture Rising Latch Interrupt Enable Bits
 * |        |          |0 = Capture rising edge latch interrupt Disabled.
 * |        |          |1 = Capture rising edge latch interrupt Enabled.
 * |        |          |Note: When Capture with PDMA operating, CINTENR corresponding channel CAPRIEN must be disabled.
 * |[2]     |CAPRIEN2  |PWM Channel 2 Capture Rising Latch Interrupt Enable Bits
 * |        |          |0 = Capture rising edge latch interrupt Disabled.
 * |        |          |1 = Capture rising edge latch interrupt Enabled.
 * |        |          |Note: When Capture with PDMA operating, CINTENR corresponding channel CAPRIEN must be disabled.
 * |[3]     |CAPRIEN3  |PWM Channel 3 Capture Rising Latch Interrupt Enable Bits
 * |        |          |0 = Capture rising edge latch interrupt Disabled.
 * |        |          |1 = Capture rising edge latch interrupt Enabled.
 * |        |          |Note: When Capture with PDMA operating, CINTENR corresponding channel CAPRIEN must be disabled.
 * |[4]     |CAPRIEN4  |PWM Channel 4 Capture Rising Latch Interrupt Enable Bits
 * |        |          |0 = Capture rising edge latch interrupt Disabled.
 * |        |          |1 = Capture rising edge latch interrupt Enabled.
 * |        |          |Note: When Capture with PDMA operating, CINTENR corresponding channel CAPRIEN must be disabled.
 * |[5]     |CAPRIEN5  |PWM Channel 5 Capture Rising Latch Interrupt Enable Bits
 * |        |          |0 = Capture rising edge latch interrupt Disabled.
 * |        |          |1 = Capture rising edge latch interrupt Enabled.
 * |        |          |Note: When Capture with PDMA operating, CINTENR corresponding channel CAPRIEN must be disabled.
 * |[8]     |CAPFIEN0  |PWM Channel 0 Capture Falling Latch Interrupt Enable Bits
 * |        |          |0 = Capture falling edge latch interrupt Disabled.
 * |        |          |1 = Capture falling edge latch interrupt Enabled.
 * |        |          |Note: When Capture with PDMA operating, CINTENR corresponding channel CAPFIEN must be disabled.
 * |[9]     |CAPFIEN1  |PWM Channel 1 Capture Falling Latch Interrupt Enable Bits
 * |        |          |0 = Capture falling edge latch interrupt Disabled.
 * |        |          |1 = Capture falling edge latch interrupt Enabled.
 * |        |          |Note: When Capture with PDMA operating, CINTENR corresponding channel CAPFIEN must be disabled.
 * |[10]    |CAPFIEN2  |PWM Channel 2 Capture Falling Latch Interrupt Enable Bits
 * |        |          |0 = Capture falling edge latch interrupt Disabled.
 * |        |          |1 = Capture falling edge latch interrupt Enabled.
 * |        |          |Note: When Capture with PDMA operating, CINTENR corresponding channel CAPFIEN must be disabled.
 * |[11]    |CAPFIEN3  |PWM Channel 3 Capture Falling Latch Interrupt Enable Bits
 * |        |          |0 = Capture falling edge latch interrupt Disabled.
 * |        |          |1 = Capture falling edge latch interrupt Enabled.
 * |        |          |Note: When Capture with PDMA operating, CINTENR corresponding channel CAPFIEN must be disabled.
 * |[12]    |CAPFIEN4  |PWM Channel 4 Capture Falling Latch Interrupt Enable Bits
 * |        |          |0 = Capture falling edge latch interrupt Disabled.
 * |        |          |1 = Capture falling edge latch interrupt Enabled.
 * |        |          |Note: When Capture with PDMA operating, CINTENR corresponding channel CAPFIEN must be disabled.
 * |[13]    |CAPFIEN5  |PWM Channel 5 Capture Falling Latch Interrupt Enable Bits
 * |        |          |0 = Capture falling edge latch interrupt Disabled.
 * |        |          |1 = Capture falling edge latch interrupt Enabled.
 * |        |          |Note: When Capture with PDMA operating, CINTENR corresponding channel CAPFIEN must be disabled.
 * @var PWM_T::CAPIF
 * Offset: 0x254  PWM Capture Interrupt Flag Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CRLIF0    |PWM Channel 0 Capture Rising Latch Interrupt Flag
 * |        |          |This bit is writing 1 to clear.
 * |        |          |0 = No capture rising latch condition happened.
 * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
 * |        |          |Note: When Capture with PDMA operating, CAPIF corresponding channel CRLIF will cleared by hardware after PDMA transfer data.
 * |[1]     |CRLIF1    |PWM Channel 1 Capture Rising Latch Interrupt Flag
 * |        |          |This bit is writing 1 to clear.
 * |        |          |0 = No capture rising latch condition happened.
 * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
 * |        |          |Note: When Capture with PDMA operating, CAPIF corresponding channel CRLIF will cleared by hardware after PDMA transfer data.
 * |[2]     |CRLIF2    |PWM Channel 2 Capture Rising Latch Interrupt Flag
 * |        |          |This bit is writing 1 to clear.
 * |        |          |0 = No capture rising latch condition happened.
 * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
 * |        |          |Note: When Capture with PDMA operating, CAPIF corresponding channel CRLIF will cleared by hardware after PDMA transfer data.
 * |[3]     |CRLIF3    |PWM Channel 3 Capture Rising Latch Interrupt Flag
 * |        |          |This bit is writing 1 to clear.
 * |        |          |0 = No capture rising latch condition happened.
 * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
 * |        |          |Note: When Capture with PDMA operating, CAPIF corresponding channel CRLIF will cleared by hardware after PDMA transfer data.
 * |[4]     |CRLIF4    |PWM Channel 4 Capture Rising Latch Interrupt Flag
 * |        |          |This bit is writing 1 to clear.
 * |        |          |0 = No capture rising latch condition happened.
 * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
 * |        |          |Note: When Capture with PDMA operating, CAPIF corresponding channel CRLIF will cleared by hardware after PDMA transfer data.
 * |[5]     |CRLIF5    |PWM Channel 5 Capture Rising Latch Interrupt Flag
 * |        |          |This bit is writing 1 to clear.
 * |        |          |0 = No capture rising latch condition happened.
 * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
 * |        |          |Note: When Capture with PDMA operating, CAPIF corresponding channel CRLIF will cleared by hardware after PDMA transfer data.
 * |[8]     |CFLIF0    |PWM Channel 0 Capture Falling Latch Interrupt Flag
 * |        |          |This bit is writing 1 to clear.
 * |        |          |0 = No capture falling latch condition happened.
 * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
 * |        |          |Note: When Capture with PDMA operating, CAPIF corresponding channel CFLIF will cleared by hardware after PDMA transfer data.
 * |[9]     |CFLIF1    |PWM Channel 1 Capture Falling Latch Interrupt Flag
 * |        |          |This bit is writing 1 to clear.
 * |        |          |0 = No capture falling latch condition happened.
 * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
 * |        |          |Note: When Capture with PDMA operating, CAPIF corresponding channel CFLIF will cleared by hardware after PDMA transfer data.
 * |[10]    |CFLIF2    |PWM Channel 2 Capture Falling Latch Interrupt Flag
 * |        |          |This bit is writing 1 to clear.
 * |        |          |0 = No capture falling latch condition happened.
 * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
 * |        |          |Note: When Capture with PDMA operating, CAPIF corresponding channel CFLIF will cleared by hardware after PDMA transfer data.
 * |[11]    |CFLIF3    |PWM Channel 3 Capture Falling Latch Interrupt Flag
 * |        |          |This bit is writing 1 to clear.
 * |        |          |0 = No capture falling latch condition happened.
 * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
 * |        |          |Note: When Capture with PDMA operating, CAPIF corresponding channel CFLIF will cleared by hardware after PDMA transfer data.
 * |[12]    |CFLIF4    |PWM Channel 4 Capture Falling Latch Interrupt Flag
 * |        |          |This bit is writing 1 to clear.
 * |        |          |0 = No capture falling latch condition happened.
 * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
 * |        |          |Note: When Capture with PDMA operating, CAPIF corresponding channel CFLIF will cleared by hardware after PDMA transfer data.
 * |[13]    |CFLIF5    |PWM Channel 5 Capture Falling Latch Interrupt Flag
 * |        |          |This bit is writing 1 to clear.
 * |        |          |0 = No capture falling latch condition happened.
 * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
 * |        |          |Note: When Capture with PDMA operating, CAPIF corresponding channel CFLIF will cleared by hardware after PDMA transfer data.
 * @var PWM_T::SELFTEST
 * Offset: 0x300  PWM Self-test Mode Enable
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31]    |SELFTEST  |PWM Self-test Mode Enable (Write Protect)
 * |        |          |When PWM self-test mode enabled, the PWM_CH0 capture input source comes from PWM_CH1 output, and PWM_CH1 capture input source comes from PWM_CH0 output
 * |        |          |So as the PWM pair PWM_CH2/3 and PWM_CH4/5.[PT1]
 * |        |          |0 = PWM self-test mode Disabled.
 * |        |          |1 = PWM self-test mode Enabled.
 * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
 * |        |          |[PT1]Not release in TRM
 * @var PWM_T::PBUF0
 * Offset: 0x304  PWM PERIOD0 Buffer
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PBUF      |PWM Period Register Buffer (Read Only)
 * |        |          |Used as PERIOD active register.
 * @var PWM_T::PBUF1
 * Offset: 0x308  PWM PERIOD1 Buffer
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PBUF      |PWM Period Register Buffer (Read Only)
 * |        |          |Used as PERIOD active register.
 * @var PWM_T::PBUF2
 * Offset: 0x30C  PWM PERIOD2 Buffer
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PBUF      |PWM Period Register Buffer (Read Only)
 * |        |          |Used as PERIOD active register.
 * @var PWM_T::PBUF3
 * Offset: 0x310  PWM PERIOD3 Buffer
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PBUF      |PWM Period Register Buffer (Read Only)
 * |        |          |Used as PERIOD active register.
 * @var PWM_T::PBUF4
 * Offset: 0x314  PWM PERIOD4 Buffer
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PBUF      |PWM Period Register Buffer (Read Only)
 * |        |          |Used as PERIOD active register.
 * @var PWM_T::PBUF5
 * Offset: 0x318  PWM PERIOD5 Buffer
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PBUF      |PWM Period Register Buffer (Read Only)
 * |        |          |Used as PERIOD active register.
 * @var PWM_T::CMPBUF0
 * Offset: 0x31C  PWM CMPDAT0 Buffer
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CMPBUF    |PWM Comparator Register Buffer (Read Only)
 * |        |          |Used as CMP active register.
 * @var PWM_T::CMPBUF1
 * Offset: 0x320  PWM CMPDAT1 Buffer
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CMPBUF    |PWM Comparator Register Buffer (Read Only)
 * |        |          |Used as CMP active register.
 * @var PWM_T::CMPBUF2
 * Offset: 0x324  PWM CMPDAT2 Buffer
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CMPBUF    |PWM Comparator Register Buffer (Read Only)
 * |        |          |Used as CMP active register.
 * @var PWM_T::CMPBUF3
 * Offset: 0x328  PWM CMPDAT3 Buffer
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CMPBUF    |PWM Comparator Register Buffer (Read Only)
 * |        |          |Used as CMP active register.
 * @var PWM_T::CMPBUF4
 * Offset: 0x32C  PWM CMPDAT4 Buffer
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CMPBUF    |PWM Comparator Register Buffer (Read Only)
 * |        |          |Used as CMP active register.
 * @var PWM_T::CMPBUF5
 * Offset: 0x330  PWM CMPDAT5 Buffer
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CMPBUF    |PWM Comparator Register Buffer (Read Only)
 * |        |          |Used as CMP active register.
 * @var PWM_T::CPSCBUF0_1
 * Offset: 0x334  PWM CLKPSC0_1 Buffer
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[11:0]  |CPSCBUF   |PWM Counter Clock Pre-scale Buffer
 * |        |          |Use as PWM counter clock pre-scare active register.
 * @var PWM_T::CPSCBUF2_3
 * Offset: 0x338  PWM CLKPSC2_3 Buffer
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[11:0]  |CPSCBUF   |PWM Counter Clock Pre-scale Buffer
 * |        |          |Use as PWM counter clock pre-scare active register.
 * @var PWM_T::CPSCBUF4_5
 * Offset: 0x33C  PWM CLKPSC4_5 Buffer
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[11:0]  |CPSCBUF   |PWM Counter Clock Pre-scale Buffer
 * |        |          |Use as PWM counter clock pre-scare active register.
 * @var PWM_T::FTCBUF0_1
 * Offset: 0x340  PWM FTCMPDAT0_1 Buffer
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |FTCMPBUF  |PWM FTCMPDAT Buffer (Read Only)
 * |        |          |Used as FTCMPDAT active register.
 * @var PWM_T::FTCBUF2_3
 * Offset: 0x344  PWM FTCMPDAT2_3 Buffer
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |FTCMPBUF  |PWM FTCMPDAT Buffer (Read Only)
 * |        |          |Used as FTCMPDAT active register.
 * @var PWM_T::FTCBUF4_5
 * Offset: 0x348  PWM FTCMPDAT4_5 Buffer
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |FTCMPBUF  |PWM FTCMPDAT Buffer (Read Only)
 * |        |          |Used as FTCMPDAT active register.
 * @var PWM_T::FTCI
 * Offset: 0x34C  PWM FTCMPDAT Indicator Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |FTCMU0    |PWM Channel 0 FTCMPDAT Up Indicator
 * |        |          |Indicator will be set to high when FTCMPDAT0_1 equal to PERIODn and DIRF=1, software can write 1 to clear this bit.
 * |[1]     |FTCMU2    |PWM Channel 2 FTCMPDAT Up Indicator
 * |        |          |Indicator will be set to high when FTCMPDAT0_1 equal to PERIODn and DIRF=1, software can write 1 to clear this bit.
 * |[2]     |FTCMU4    |PWM Channel 4 FTCMPDAT Up Indicator
 * |        |          |Indicator will be set to high when FTCMPDAT0_1 equal to PERIODn and DIRF=1, software can write 1 to clear this bit.
 * |[8]     |FTCMD0    |PWM Channel 0 FTCMPDAT Down Indicator
 * |        |          |Indicator will be set to high when FTCMPDAT0_1 equal to PERIOD0 and DIRF=0, software can write 1 to clear this bit.
 * |[9]     |FTCMD2    |PWM Channel 2 FTCMPDAT Down Indicator
 * |        |          |Indicator will be set to high when FTCMPDAT2_3 equal to PERIOD0 and DIRF=0, software can write 1 to clear this bit.
 * |[10]    |FTCMD4    |PWM Channel 4 FTCMPDAT Down Indicator
 * |        |          |Indicator will be set to high when FTCMPDAT4_5 equal to PERIOD0 and DIRF=0, software can write 1 to clear this bit.
 * @var PWM_T::VERSION
 * Offset: 0xFFC  PWM RTL Design Version Number
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |MINOR     |RTL Design MINOR Version Number (Read Only)
 * |        |          |Minor version number is dependent on ECO version control.
 * |        |          |0x0000: (current Minor Version Number).
 * |[23:16] |SUB       |RTL Design SUB Version Number (Read Only)
 * |        |          |Sub version number is relative to key feature.
 * |        |          |0x02: (current Sub Version Number).
 * |[31:24] |MAJOR     |RTL Design MAJOR Version Number (Read Only)
 * |        |          |Major version number is correlated to Product Line.
 * |        |          |0x01: (current Major Version Number).
 */
    __IO uint32_t CTL0;                  /*!< [0x0000] PWM Control Register 0                                           */
    __IO uint32_t CTL1;                  /*!< [0x0004] PWM Control Register 1                                           */
    __IO uint32_t SYNC;                  /*!< [0x0008] PWM Synchronization Register                                     */
    __IO uint32_t SWSYNC;                /*!< [0x000c] PWM Software Control Synchronization Register                    */
    __IO uint32_t CLKSRC;                /*!< [0x0010] PWM Clock Source Register                                        */
    __IO uint32_t CLKPSC0_1;             /*!< [0x0014] PWM Clock Pre-scale Register 0/1                                 */
    __IO uint32_t CLKPSC2_3;             /*!< [0x0018] PWM Clock Pre-scale Register 2/3                                 */
    __IO uint32_t CLKPSC4_5;             /*!< [0x001c] PWM Clock Pre-scale Register 4/5                                 */
    __IO uint32_t CNTEN;                 /*!< [0x0020] PWM Counter Enable Register                                      */
    __IO uint32_t CNTCLR;                /*!< [0x0024] PWM Clear Counter Register                                       */
    __IO uint32_t LOAD;                  /*!< [0x0028] PWM Load Register                                                */
    __I  uint32_t RESERVE0[1];
    __IO uint32_t PERIOD0;               /*!< [0x0030] PWM Period Register 0                                            */
    __IO uint32_t PERIOD1;               /*!< [0x0034] PWM Period Register 1                                            */
    __IO uint32_t PERIOD2;               /*!< [0x0038] PWM Period Register 2                                            */
    __IO uint32_t PERIOD3;               /*!< [0x003c] PWM Period Register 3                                            */
    __IO uint32_t PERIOD4;               /*!< [0x0040] PWM Period Register 4                                            */
    __IO uint32_t PERIOD5;               /*!< [0x0044] PWM Period Register 5                                            */
    __I  uint32_t RESERVE1[2];
    __IO uint32_t CMPDAT0;               /*!< [0x0050] PWM Comparator Register 0                                        */
    __IO uint32_t CMPDAT1;               /*!< [0x0054] PWM Comparator Register 1                                        */
    __IO uint32_t CMPDAT2;               /*!< [0x0058] PWM Comparator Register 2                                        */
    __IO uint32_t CMPDAT3;               /*!< [0x005c] PWM Comparator Register 3                                        */
    __IO uint32_t CMPDAT4;               /*!< [0x0060] PWM Comparator Register 4                                        */
    __IO uint32_t CMPDAT5;               /*!< [0x0064] PWM Comparator Register 5                                        */
    __I  uint32_t RESERVE2[2];
    __IO uint32_t DTCTL0_1;              /*!< [0x0070] PWM Dead-Time Control Register 0/1                               */
    __IO uint32_t DTCTL2_3;              /*!< [0x0074] PWM Dead-Time Control Register 2/3                               */
    __IO uint32_t DTCTL4_5;              /*!< [0x0078] PWM Dead-Time Control Register 4/5                               */
    __I  uint32_t RESERVE3[1];
    __IO uint32_t PHS0_1;                /*!< [0x0080] PWM Counter Phase Register 0/1                                   */
    __IO uint32_t PHS2_3;                /*!< [0x0084] PWM Counter Phase Register 2/3                                   */
    __IO uint32_t PHS4_5;                /*!< [0x0088] PWM Counter Phase Register 4/5                                   */
    __I  uint32_t RESERVE4[1];
    __I  uint32_t CNT0;                  /*!< [0x0090] PWM Counter Register 0                                           */
    __I  uint32_t CNT1;                  /*!< [0x0094] PWM Counter Register 1                                           */
    __I  uint32_t CNT2;                  /*!< [0x0098] PWM Counter Register 2                                           */
    __I  uint32_t CNT3;                  /*!< [0x009c] PWM Counter Register 3                                           */
    __I  uint32_t CNT4;                  /*!< [0x00a0] PWM Counter Register 4                                           */
    __I  uint32_t CNT5;                  /*!< [0x00a4] PWM Counter Register 5                                           */
    __I  uint32_t RESERVE5[2];
    __IO uint32_t WGCTL0;                /*!< [0x00b0] PWM Generation Register 0                                        */
    __IO uint32_t WGCTL1;                /*!< [0x00b4] PWM Generation Register 1                                        */
    __IO uint32_t MSKEN;                 /*!< [0x00b8] PWM Mask Enable Register                                         */
    __IO uint32_t MSK;                   /*!< [0x00bc] PWM Mask Data Register                                           */
    __IO uint32_t BNF;                   /*!< [0x00c0] PWM Brake Noise Filter Register                                  */
    __IO uint32_t FAILBRK;               /*!< [0x00c4] PWM System Fail Brake Control Register                           */
    __IO uint32_t BRKCTL0_1;             /*!< [0x00c8] PWM Brake Edge Detect Control Register 0/1                       */
    __IO uint32_t BRKCTL2_3;             /*!< [0x00cc] PWM Brake Edge Detect Control Register 2/3                       */
    __IO uint32_t BRKCTL4_5;             /*!< [0x00d0] PWM Brake Edge Detect Control Register 4/5                       */
    __IO uint32_t POLCTL;                /*!< [0x00d4] PWM Pin Polar Inverse Register                                   */
    __IO uint32_t POEN;                  /*!< [0x00d8] PWM Output Enable Register                                       */
    __O  uint32_t SWBRK;                 /*!< [0x00dc] PWM Software Brake Control Register                              */
    __IO uint32_t INTEN0;                /*!< [0x00e0] PWM Interrupt Enable Register 0                                  */
    __IO uint32_t INTEN1;                /*!< [0x00e4] PWM Interrupt Enable Register 1                                  */
    __IO uint32_t INTSTS0;               /*!< [0x00e8] PWM Interrupt Flag Register 0                                    */
    __IO uint32_t INTSTS1;               /*!< [0x00ec] PWM Interrupt Flag Register 1                                    */
    __IO uint32_t IFA;                   /*!< [0x00f0] PWM Interrupt Flag Accumulator Register                          */
    __I  uint32_t RESERVE6[1];
    __IO uint32_t EADCTS0;               /*!< [0x00f8] PWM Trigger EADC Source Select Register 0                        */
    __IO uint32_t EADCTS1;               /*!< [0x00fc] PWM Trigger EADC Source Select Register 1                        */
    __IO uint32_t FTCMPDAT0_1;           /*!< [0x0100] PWM Free Trigger Compare Register 0/1                            */
    __IO uint32_t FTCMPDAT2_3;           /*!< [0x0104] PWM Free Trigger Compare Register 2/3                            */
    __IO uint32_t FTCMPDAT4_5;           /*!< [0x0108] PWM Free Trigger Compare Register 4/5                            */
    __I  uint32_t RESERVE7[1];
    __IO uint32_t SSCTL;                 /*!< [0x0110] PWM Synchronous Start Control Register                           */
    __O  uint32_t SSTRG;                 /*!< [0x0114] PWM Synchronous Start Trigger Register                           */
    __I  uint32_t RESERVE8[2];
    __IO uint32_t STATUS;                /*!< [0x0120] PWM Status Register                                              */
    __I  uint32_t RESERVE9[55];
    __IO uint32_t CAPINEN;               /*!< [0x0200] PWM Capture Input Enable Register                                */
    __IO uint32_t CAPCTL;                /*!< [0x0204] PWM Capture Control Register                                     */
    __I  uint32_t CAPSTS;                /*!< [0x0208] PWM Capture Status Register                                      */
    __I  uint32_t RCAPDAT0;              /*!< [0x020c] PWM Rising Capture Data Register 0                               */
    __I  uint32_t FCAPDAT0;              /*!< [0x0210] PWM Falling Capture Data Register 0                              */
    __I  uint32_t RCAPDAT1;              /*!< [0x0214] PWM Rising Capture Data Register 1                               */
    __I  uint32_t FCAPDAT1;              /*!< [0x0218] PWM Falling Capture Data Register 1                              */
    __I  uint32_t RCAPDAT2;              /*!< [0x021c] PWM Rising Capture Data Register 2                               */
    __I  uint32_t FCAPDAT2;              /*!< [0x0220] PWM Falling Capture Data Register 2                              */
    __I  uint32_t RCAPDAT3;              /*!< [0x0224] PWM Rising Capture Data Register 3                               */
    __I  uint32_t FCAPDAT3;              /*!< [0x0228] PWM Falling Capture Data Register 3                              */
    __I  uint32_t RCAPDAT4;              /*!< [0x022c] PWM Rising Capture Data Register 4                               */
    __I  uint32_t FCAPDAT4;              /*!< [0x0230] PWM Falling Capture Data Register 4                              */
    __I  uint32_t RCAPDAT5;              /*!< [0x0234] PWM Rising Capture Data Register 5                               */
    __I  uint32_t FCAPDAT5;              /*!< [0x0238] PWM Falling Capture Data Register 5                              */
    __IO uint32_t PDMACTL;               /*!< [0x023c] PWM PDMA Control Register                                        */
    __I  uint32_t PDMACAP0_1;            /*!< [0x0240] PWM Capture Channel 01 PDMA Register                             */
    __I  uint32_t PDMACAP2_3;            /*!< [0x0244] PWM Capture Channel 23 PDMA Register                             */
    __I  uint32_t PDMACAP4_5;            /*!< [0x0248] PWM Capture Channel 45 PDMA Register                             */
    __I  uint32_t RESERVE10[1];
    __IO uint32_t CAPIEN;                /*!< [0x0250] PWM Capture Interrupt Enable Register                            */
    __IO uint32_t CAPIF;                 /*!< [0x0254] PWM Capture Interrupt Flag Register                              */
    __I  uint32_t RESERVE11[42];
    __IO uint32_t SELFTEST;              /*!< [0x0300] PWM Self-test Mode Enable                                        */
    __I  uint32_t PBUF0;                 /*!< [0x0304] PWM PERIOD0 Buffer                                               */
    __I  uint32_t PBUF1;                 /*!< [0x0308] PWM PERIOD1 Buffer                                               */
    __I  uint32_t PBUF2;                 /*!< [0x030c] PWM PERIOD2 Buffer                                               */
    __I  uint32_t PBUF3;                 /*!< [0x0310] PWM PERIOD3 Buffer                                               */
    __I  uint32_t PBUF4;                 /*!< [0x0314] PWM PERIOD4 Buffer                                               */
    __I  uint32_t PBUF5;                 /*!< [0x0318] PWM PERIOD5 Buffer                                               */
    __I  uint32_t CMPBUF0;               /*!< [0x031c] PWM CMPDAT0 Buffer                                               */
    __I  uint32_t CMPBUF1;               /*!< [0x0320] PWM CMPDAT1 Buffer                                               */
    __I  uint32_t CMPBUF2;               /*!< [0x0324] PWM CMPDAT2 Buffer                                               */
    __I  uint32_t CMPBUF3;               /*!< [0x0328] PWM CMPDAT3 Buffer                                               */
    __I  uint32_t CMPBUF4;               /*!< [0x032c] PWM CMPDAT4 Buffer                                               */
    __I  uint32_t CMPBUF5;               /*!< [0x0330] PWM CMPDAT5 Buffer                                               */
    __I  uint32_t CPSCBUF0_1;            /*!< [0x0334] PWM CLKPSC0_1 Buffer                                             */
    __I  uint32_t CPSCBUF2_3;            /*!< [0x0338] PWM CLKPSC2_3 Buffer                                             */
    __I  uint32_t CPSCBUF4_5;            /*!< [0x033c] PWM CLKPSC4_5 Buffer                                             */
    __I  uint32_t FTCBUF0_1;             /*!< [0x0340] PWM FTCMPDAT0_1 Buffer                                           */
    __I  uint32_t FTCBUF2_3;             /*!< [0x0344] PWM FTCMPDAT2_3 Buffer                                           */
    __I  uint32_t FTCBUF4_5;             /*!< [0x0348] PWM FTCMPDAT4_5 Buffer                                           */
    __IO uint32_t FTCI;                  /*!< [0x034c] PWM FTCMPDAT Indicator Register                                  */
    __I  uint32_t RESERVE12[811];
    __I  uint32_t VERSION;               /*!< [0x0ffc] PWM RTL Design Version Number                                    */

} PWM_T;

/**
    @addtogroup PWM_CONST PWM Bit Field Definition
    Constant Definitions for PWM Controller
@{ */

#define PWM_CTL0_CTRLD0_Pos              (0)                                               /*!< PWM_T::CTL0: CTRLD0 Position           */
#define PWM_CTL0_CTRLD0_Msk              (0x1ul << PWM_CTL0_CTRLD0_Pos)                    /*!< PWM_T::CTL0: CTRLD0 Mask               */

#define PWM_CTL0_CTRLD1_Pos              (1)                                               /*!< PWM_T::CTL0: CTRLD1 Position           */
#define PWM_CTL0_CTRLD1_Msk              (0x1ul << PWM_CTL0_CTRLD1_Pos)                    /*!< PWM_T::CTL0: CTRLD1 Mask               */

#define PWM_CTL0_CTRLD2_Pos              (2)                                               /*!< PWM_T::CTL0: CTRLD2 Position           */
#define PWM_CTL0_CTRLD2_Msk              (0x1ul << PWM_CTL0_CTRLD2_Pos)                    /*!< PWM_T::CTL0: CTRLD2 Mask               */

#define PWM_CTL0_CTRLD3_Pos              (3)                                               /*!< PWM_T::CTL0: CTRLD3 Position           */
#define PWM_CTL0_CTRLD3_Msk              (0x1ul << PWM_CTL0_CTRLD3_Pos)                    /*!< PWM_T::CTL0: CTRLD3 Mask               */

#define PWM_CTL0_CTRLD4_Pos              (4)                                               /*!< PWM_T::CTL0: CTRLD4 Position           */
#define PWM_CTL0_CTRLD4_Msk              (0x1ul << PWM_CTL0_CTRLD4_Pos)                    /*!< PWM_T::CTL0: CTRLD4 Mask               */

#define PWM_CTL0_CTRLD5_Pos              (5)                                               /*!< PWM_T::CTL0: CTRLD5 Position           */
#define PWM_CTL0_CTRLD5_Msk              (0x1ul << PWM_CTL0_CTRLD5_Pos)                    /*!< PWM_T::CTL0: CTRLD5 Mask               */

#define PWM_CTL0_WINLDEN0_Pos            (8)                                               /*!< PWM_T::CTL0: WINLDEN0 Position         */
#define PWM_CTL0_WINLDEN0_Msk            (0x1ul << PWM_CTL0_WINLDEN0_Pos)                  /*!< PWM_T::CTL0: WINLDEN0 Mask             */

#define PWM_CTL0_WINLDEN1_Pos            (9)                                               /*!< PWM_T::CTL0: WINLDEN1 Position         */
#define PWM_CTL0_WINLDEN1_Msk            (0x1ul << PWM_CTL0_WINLDEN1_Pos)                  /*!< PWM_T::CTL0: WINLDEN1 Mask             */

#define PWM_CTL0_WINLDEN2_Pos            (10)                                              /*!< PWM_T::CTL0: WINLDEN2 Position         */
#define PWM_CTL0_WINLDEN2_Msk            (0x1ul << PWM_CTL0_WINLDEN2_Pos)                  /*!< PWM_T::CTL0: WINLDEN2 Mask             */

#define PWM_CTL0_WINLDEN3_Pos            (11)                                              /*!< PWM_T::CTL0: WINLDEN3 Position         */
#define PWM_CTL0_WINLDEN3_Msk            (0x1ul << PWM_CTL0_WINLDEN3_Pos)                  /*!< PWM_T::CTL0: WINLDEN3 Mask             */

#define PWM_CTL0_WINLDEN4_Pos            (12)                                              /*!< PWM_T::CTL0: WINLDEN4 Position         */
#define PWM_CTL0_WINLDEN4_Msk            (0x1ul << PWM_CTL0_WINLDEN4_Pos)                  /*!< PWM_T::CTL0: WINLDEN4 Mask             */

#define PWM_CTL0_WINLDEN5_Pos            (13)                                              /*!< PWM_T::CTL0: WINLDEN5 Position         */
#define PWM_CTL0_WINLDEN5_Msk            (0x1ul << PWM_CTL0_WINLDEN5_Pos)                  /*!< PWM_T::CTL0: WINLDEN5 Mask             */

#define PWM_CTL0_IMMLDEN0_Pos            (16)                                              /*!< PWM_T::CTL0: IMMLDEN0 Position         */
#define PWM_CTL0_IMMLDEN0_Msk            (0x1ul << PWM_CTL0_IMMLDEN0_Pos)                  /*!< PWM_T::CTL0: IMMLDEN0 Mask             */

#define PWM_CTL0_IMMLDEN1_Pos            (17)                                              /*!< PWM_T::CTL0: IMMLDEN1 Position         */
#define PWM_CTL0_IMMLDEN1_Msk            (0x1ul << PWM_CTL0_IMMLDEN1_Pos)                  /*!< PWM_T::CTL0: IMMLDEN1 Mask             */

#define PWM_CTL0_IMMLDEN2_Pos            (18)                                              /*!< PWM_T::CTL0: IMMLDEN2 Position         */
#define PWM_CTL0_IMMLDEN2_Msk            (0x1ul << PWM_CTL0_IMMLDEN2_Pos)                  /*!< PWM_T::CTL0: IMMLDEN2 Mask             */

#define PWM_CTL0_IMMLDEN3_Pos            (19)                                              /*!< PWM_T::CTL0: IMMLDEN3 Position         */
#define PWM_CTL0_IMMLDEN3_Msk            (0x1ul << PWM_CTL0_IMMLDEN3_Pos)                  /*!< PWM_T::CTL0: IMMLDEN3 Mask             */

#define PWM_CTL0_IMMLDEN4_Pos            (20)                                              /*!< PWM_T::CTL0: IMMLDEN4 Position         */
#define PWM_CTL0_IMMLDEN4_Msk            (0x1ul << PWM_CTL0_IMMLDEN4_Pos)                  /*!< PWM_T::CTL0: IMMLDEN4 Mask             */

#define PWM_CTL0_IMMLDEN5_Pos            (21)                                              /*!< PWM_T::CTL0: IMMLDEN5 Position         */
#define PWM_CTL0_IMMLDEN5_Msk            (0x1ul << PWM_CTL0_IMMLDEN5_Pos)                  /*!< PWM_T::CTL0: IMMLDEN5 Mask             */

#define PWM_CTL0_GROUPEN_Pos             (24)                                              /*!< PWM_T::CTL0: GROUPEN Position          */
#define PWM_CTL0_GROUPEN_Msk             (0x1ul << PWM_CTL0_GROUPEN_Pos)                   /*!< PWM_T::CTL0: GROUPEN Mask              */

#define PWM_CTL0_DBGHALT_Pos             (30)                                              /*!< PWM_T::CTL0: DBGHALT Position          */
#define PWM_CTL0_DBGHALT_Msk             (0x1ul << PWM_CTL0_DBGHALT_Pos)                   /*!< PWM_T::CTL0: DBGHALT Mask              */

#define PWM_CTL0_DBGTRIOFF_Pos           (31)                                              /*!< PWM_T::CTL0: DBGTRIOFF Position        */
#define PWM_CTL0_DBGTRIOFF_Msk           (0x1ul << PWM_CTL0_DBGTRIOFF_Pos)                 /*!< PWM_T::CTL0: DBGTRIOFF Mask            */

#define PWM_CTL1_CNTTYPE0_Pos            (0)                                               /*!< PWM_T::CTL1: CNTTYPE0 Position         */
#define PWM_CTL1_CNTTYPE0_Msk            (0x3ul << PWM_CTL1_CNTTYPE0_Pos)                  /*!< PWM_T::CTL1: CNTTYPE0 Mask             */

#define PWM_CTL1_CNTTYPE1_Pos            (2)                                               /*!< PWM_T::CTL1: CNTTYPE1 Position         */
#define PWM_CTL1_CNTTYPE1_Msk            (0x3ul << PWM_CTL1_CNTTYPE1_Pos)                  /*!< PWM_T::CTL1: CNTTYPE1 Mask             */

#define PWM_CTL1_CNTTYPE2_Pos            (4)                                               /*!< PWM_T::CTL1: CNTTYPE2 Position         */
#define PWM_CTL1_CNTTYPE2_Msk            (0x3ul << PWM_CTL1_CNTTYPE2_Pos)                  /*!< PWM_T::CTL1: CNTTYPE2 Mask             */

#define PWM_CTL1_CNTTYPE3_Pos            (6)                                               /*!< PWM_T::CTL1: CNTTYPE3 Position         */
#define PWM_CTL1_CNTTYPE3_Msk            (0x3ul << PWM_CTL1_CNTTYPE3_Pos)                  /*!< PWM_T::CTL1: CNTTYPE3 Mask             */

#define PWM_CTL1_CNTTYPE4_Pos            (8)                                               /*!< PWM_T::CTL1: CNTTYPE4 Position         */
#define PWM_CTL1_CNTTYPE4_Msk            (0x3ul << PWM_CTL1_CNTTYPE4_Pos)                  /*!< PWM_T::CTL1: CNTTYPE4 Mask             */

#define PWM_CTL1_CNTTYPE5_Pos            (10)                                              /*!< PWM_T::CTL1: CNTTYPE5 Position         */
#define PWM_CTL1_CNTTYPE5_Msk            (0x3ul << PWM_CTL1_CNTTYPE5_Pos)                  /*!< PWM_T::CTL1: CNTTYPE5 Mask             */

#define PWM_CTL1_CNTMODE0_Pos            (16)                                              /*!< PWM_T::CTL1: CNTMODE0 Position         */
#define PWM_CTL1_CNTMODE0_Msk            (0x1ul << PWM_CTL1_CNTMODE0_Pos)                  /*!< PWM_T::CTL1: CNTMODE0 Mask             */

#define PWM_CTL1_CNTMODE1_Pos            (17)                                              /*!< PWM_T::CTL1: CNTMODE1 Position         */
#define PWM_CTL1_CNTMODE1_Msk            (0x1ul << PWM_CTL1_CNTMODE1_Pos)                  /*!< PWM_T::CTL1: CNTMODE1 Mask             */

#define PWM_CTL1_CNTMODE2_Pos            (18)                                              /*!< PWM_T::CTL1: CNTMODE2 Position         */
#define PWM_CTL1_CNTMODE2_Msk            (0x1ul << PWM_CTL1_CNTMODE2_Pos)                  /*!< PWM_T::CTL1: CNTMODE2 Mask             */

#define PWM_CTL1_CNTMODE3_Pos            (19)                                              /*!< PWM_T::CTL1: CNTMODE3 Position         */
#define PWM_CTL1_CNTMODE3_Msk            (0x1ul << PWM_CTL1_CNTMODE3_Pos)                  /*!< PWM_T::CTL1: CNTMODE3 Mask             */

#define PWM_CTL1_CNTMODE4_Pos            (20)                                              /*!< PWM_T::CTL1: CNTMODE4 Position         */
#define PWM_CTL1_CNTMODE4_Msk            (0x1ul << PWM_CTL1_CNTMODE4_Pos)                  /*!< PWM_T::CTL1: CNTMODE4 Mask             */

#define PWM_CTL1_CNTMODE5_Pos            (21)                                              /*!< PWM_T::CTL1: CNTMODE5 Position         */
#define PWM_CTL1_CNTMODE5_Msk            (0x1ul << PWM_CTL1_CNTMODE5_Pos)                  /*!< PWM_T::CTL1: CNTMODE5 Mask             */

#define PWM_CTL1_OUTMODE0_Pos            (24)                                              /*!< PWM_T::CTL1: OUTMODE0 Position         */
#define PWM_CTL1_OUTMODE0_Msk            (0x1ul << PWM_CTL1_OUTMODE0_Pos)                  /*!< PWM_T::CTL1: OUTMODE0 Mask             */

#define PWM_CTL1_OUTMODE2_Pos            (25)                                              /*!< PWM_T::CTL1: OUTMODE2 Position         */
#define PWM_CTL1_OUTMODE2_Msk            (0x1ul << PWM_CTL1_OUTMODE2_Pos)                  /*!< PWM_T::CTL1: OUTMODE2 Mask             */

#define PWM_CTL1_OUTMODE4_Pos            (26)                                              /*!< PWM_T::CTL1: OUTMODE4 Position         */
#define PWM_CTL1_OUTMODE4_Msk            (0x1ul << PWM_CTL1_OUTMODE4_Pos)                  /*!< PWM_T::CTL1: OUTMODE4 Mask             */

#define PWM_SYNC_PHSEN0_Pos              (0)                                               /*!< PWM_T::SYNC: PHSEN0 Position           */
#define PWM_SYNC_PHSEN0_Msk              (0x1ul << PWM_SYNC_PHSEN0_Pos)                    /*!< PWM_T::SYNC: PHSEN0 Mask               */

#define PWM_SYNC_PHSEN2_Pos              (1)                                               /*!< PWM_T::SYNC: PHSEN2 Position           */
#define PWM_SYNC_PHSEN2_Msk              (0x1ul << PWM_SYNC_PHSEN2_Pos)                    /*!< PWM_T::SYNC: PHSEN2 Mask               */

#define PWM_SYNC_PHSEN4_Pos              (2)                                               /*!< PWM_T::SYNC: PHSEN4 Position           */
#define PWM_SYNC_PHSEN4_Msk              (0x1ul << PWM_SYNC_PHSEN4_Pos)                    /*!< PWM_T::SYNC: PHSEN4 Mask               */

#define PWM_SYNC_SINSRC0_Pos             (8)                                               /*!< PWM_T::SYNC: SINSRC0 Position          */
#define PWM_SYNC_SINSRC0_Msk             (0x3ul << PWM_SYNC_SINSRC0_Pos)                   /*!< PWM_T::SYNC: SINSRC0 Mask              */

#define PWM_SYNC_SINSRC2_Pos             (10)                                              /*!< PWM_T::SYNC: SINSRC2 Position          */
#define PWM_SYNC_SINSRC2_Msk             (0x3ul << PWM_SYNC_SINSRC2_Pos)                   /*!< PWM_T::SYNC: SINSRC2 Mask              */

#define PWM_SYNC_SINSRC4_Pos             (12)                                              /*!< PWM_T::SYNC: SINSRC4 Position          */
#define PWM_SYNC_SINSRC4_Msk             (0x3ul << PWM_SYNC_SINSRC4_Pos)                   /*!< PWM_T::SYNC: SINSRC4 Mask              */

#define PWM_SYNC_SNFLTEN_Pos             (16)                                              /*!< PWM_T::SYNC: SNFLTEN Position          */
#define PWM_SYNC_SNFLTEN_Msk             (0x1ul << PWM_SYNC_SNFLTEN_Pos)                   /*!< PWM_T::SYNC: SNFLTEN Mask              */

#define PWM_SYNC_SFLTCSEL_Pos            (17)                                              /*!< PWM_T::SYNC: SFLTCSEL Position         */
#define PWM_SYNC_SFLTCSEL_Msk            (0x7ul << PWM_SYNC_SFLTCSEL_Pos)                  /*!< PWM_T::SYNC: SFLTCSEL Mask             */

#define PWM_SYNC_SFLTCNT_Pos             (20)                                              /*!< PWM_T::SYNC: SFLTCNT Position          */
#define PWM_SYNC_SFLTCNT_Msk             (0x7ul << PWM_SYNC_SFLTCNT_Pos)                   /*!< PWM_T::SYNC: SFLTCNT Mask              */

#define PWM_SYNC_SINPINV_Pos             (23)                                              /*!< PWM_T::SYNC: SINPINV Position          */
#define PWM_SYNC_SINPINV_Msk             (0x1ul << PWM_SYNC_SINPINV_Pos)                   /*!< PWM_T::SYNC: SINPINV Mask              */

#define PWM_SYNC_PHSDIR0_Pos             (24)                                              /*!< PWM_T::SYNC: PHSDIR0 Position          */
#define PWM_SYNC_PHSDIR0_Msk             (0x1ul << PWM_SYNC_PHSDIR0_Pos)                   /*!< PWM_T::SYNC: PHSDIR0 Mask              */

#define PWM_SYNC_PHSDIR2_Pos             (25)                                              /*!< PWM_T::SYNC: PHSDIR2 Position          */
#define PWM_SYNC_PHSDIR2_Msk             (0x1ul << PWM_SYNC_PHSDIR2_Pos)                   /*!< PWM_T::SYNC: PHSDIR2 Mask              */

#define PWM_SYNC_PHSDIR4_Pos             (26)                                              /*!< PWM_T::SYNC: PHSDIR4 Position          */
#define PWM_SYNC_PHSDIR4_Msk             (0x1ul << PWM_SYNC_PHSDIR4_Pos)                   /*!< PWM_T::SYNC: PHSDIR4 Mask              */

#define PWM_SWSYNC_SWSYNC0_Pos           (0)                                               /*!< PWM_T::SWSYNC: SWSYNC0 Position        */
#define PWM_SWSYNC_SWSYNC0_Msk           (0x1ul << PWM_SWSYNC_SWSYNC0_Pos)                 /*!< PWM_T::SWSYNC: SWSYNC0 Mask            */

#define PWM_SWSYNC_SWSYNC2_Pos           (1)                                               /*!< PWM_T::SWSYNC: SWSYNC2 Position        */
#define PWM_SWSYNC_SWSYNC2_Msk           (0x1ul << PWM_SWSYNC_SWSYNC2_Pos)                 /*!< PWM_T::SWSYNC: SWSYNC2 Mask            */

#define PWM_SWSYNC_SWSYNC4_Pos           (2)                                               /*!< PWM_T::SWSYNC: SWSYNC4 Position        */
#define PWM_SWSYNC_SWSYNC4_Msk           (0x1ul << PWM_SWSYNC_SWSYNC4_Pos)                 /*!< PWM_T::SWSYNC: SWSYNC4 Mask            */

#define PWM_CLKSRC_ECLKSRC0_Pos          (0)                                               /*!< PWM_T::CLKSRC: ECLKSRC0 Position       */
#define PWM_CLKSRC_ECLKSRC0_Msk          (0x7ul << PWM_CLKSRC_ECLKSRC0_Pos)                /*!< PWM_T::CLKSRC: ECLKSRC0 Mask           */

#define PWM_CLKSRC_ECLKSRC2_Pos          (8)                                               /*!< PWM_T::CLKSRC: ECLKSRC2 Position       */
#define PWM_CLKSRC_ECLKSRC2_Msk          (0x7ul << PWM_CLKSRC_ECLKSRC2_Pos)                /*!< PWM_T::CLKSRC: ECLKSRC2 Mask           */

#define PWM_CLKSRC_ECLKSRC4_Pos          (16)                                              /*!< PWM_T::CLKSRC: ECLKSRC4 Position       */
#define PWM_CLKSRC_ECLKSRC4_Msk          (0x7ul << PWM_CLKSRC_ECLKSRC4_Pos)                /*!< PWM_T::CLKSRC: ECLKSRC4 Mask           */

#define PWM_CLKPSC0_1_CLKPSC_Pos         (0)                                               /*!< PWM_T::CLKPSC0_1: CLKPSC Position      */
#define PWM_CLKPSC0_1_CLKPSC_Msk         (0xffful << PWM_CLKPSC0_1_CLKPSC_Pos)             /*!< PWM_T::CLKPSC0_1: CLKPSC Mask          */

#define PWM_CLKPSC2_3_CLKPSC_Pos         (0)                                               /*!< PWM_T::CLKPSC2_3: CLKPSC Position      */
#define PWM_CLKPSC2_3_CLKPSC_Msk         (0xffful << PWM_CLKPSC2_3_CLKPSC_Pos)             /*!< PWM_T::CLKPSC2_3: CLKPSC Mask          */

#define PWM_CLKPSC4_5_CLKPSC_Pos         (0)                                               /*!< PWM_T::CLKPSC4_5: CLKPSC Position      */
#define PWM_CLKPSC4_5_CLKPSC_Msk         (0xffful << PWM_CLKPSC4_5_CLKPSC_Pos)             /*!< PWM_T::CLKPSC4_5: CLKPSC Mask          */

#define PWM_CNTEN_CNTEN0_Pos             (0)                                               /*!< PWM_T::CNTEN: CNTEN0 Position          */
#define PWM_CNTEN_CNTEN0_Msk             (0x1ul << PWM_CNTEN_CNTEN0_Pos)                   /*!< PWM_T::CNTEN: CNTEN0 Mask              */

#define PWM_CNTEN_CNTEN1_Pos             (1)                                               /*!< PWM_T::CNTEN: CNTEN1 Position          */
#define PWM_CNTEN_CNTEN1_Msk             (0x1ul << PWM_CNTEN_CNTEN1_Pos)                   /*!< PWM_T::CNTEN: CNTEN1 Mask              */

#define PWM_CNTEN_CNTEN2_Pos             (2)                                               /*!< PWM_T::CNTEN: CNTEN2 Position          */
#define PWM_CNTEN_CNTEN2_Msk             (0x1ul << PWM_CNTEN_CNTEN2_Pos)                   /*!< PWM_T::CNTEN: CNTEN2 Mask              */

#define PWM_CNTEN_CNTEN3_Pos             (3)                                               /*!< PWM_T::CNTEN: CNTEN3 Position          */
#define PWM_CNTEN_CNTEN3_Msk             (0x1ul << PWM_CNTEN_CNTEN3_Pos)                   /*!< PWM_T::CNTEN: CNTEN3 Mask              */

#define PWM_CNTEN_CNTEN4_Pos             (4)                                               /*!< PWM_T::CNTEN: CNTEN4 Position          */
#define PWM_CNTEN_CNTEN4_Msk             (0x1ul << PWM_CNTEN_CNTEN4_Pos)                   /*!< PWM_T::CNTEN: CNTEN4 Mask              */

#define PWM_CNTEN_CNTEN5_Pos             (5)                                               /*!< PWM_T::CNTEN: CNTEN5 Position          */
#define PWM_CNTEN_CNTEN5_Msk             (0x1ul << PWM_CNTEN_CNTEN5_Pos)                   /*!< PWM_T::CNTEN: CNTEN5 Mask              */

#define PWM_CNTCLR_CNTCLR0_Pos           (0)                                               /*!< PWM_T::CNTCLR: CNTCLR0 Position        */
#define PWM_CNTCLR_CNTCLR0_Msk           (0x1ul << PWM_CNTCLR_CNTCLR0_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR0 Mask            */

#define PWM_CNTCLR_CNTCLR1_Pos           (1)                                               /*!< PWM_T::CNTCLR: CNTCLR1 Position        */
#define PWM_CNTCLR_CNTCLR1_Msk           (0x1ul << PWM_CNTCLR_CNTCLR1_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR1 Mask            */

#define PWM_CNTCLR_CNTCLR2_Pos           (2)                                               /*!< PWM_T::CNTCLR: CNTCLR2 Position        */
#define PWM_CNTCLR_CNTCLR2_Msk           (0x1ul << PWM_CNTCLR_CNTCLR2_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR2 Mask            */

#define PWM_CNTCLR_CNTCLR3_Pos           (3)                                               /*!< PWM_T::CNTCLR: CNTCLR3 Position        */
#define PWM_CNTCLR_CNTCLR3_Msk           (0x1ul << PWM_CNTCLR_CNTCLR3_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR3 Mask            */

#define PWM_CNTCLR_CNTCLR4_Pos           (4)                                               /*!< PWM_T::CNTCLR: CNTCLR4 Position        */
#define PWM_CNTCLR_CNTCLR4_Msk           (0x1ul << PWM_CNTCLR_CNTCLR4_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR4 Mask            */

#define PWM_CNTCLR_CNTCLR5_Pos           (5)                                               /*!< PWM_T::CNTCLR: CNTCLR5 Position        */
#define PWM_CNTCLR_CNTCLR5_Msk           (0x1ul << PWM_CNTCLR_CNTCLR5_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR5 Mask            */

#define PWM_LOAD_LOAD0_Pos               (0)                                               /*!< PWM_T::LOAD: LOAD0 Position            */
#define PWM_LOAD_LOAD0_Msk               (0x1ul << PWM_LOAD_LOAD0_Pos)                     /*!< PWM_T::LOAD: LOAD0 Mask                */

#define PWM_LOAD_LOAD1_Pos               (1)                                               /*!< PWM_T::LOAD: LOAD1 Position            */
#define PWM_LOAD_LOAD1_Msk               (0x1ul << PWM_LOAD_LOAD1_Pos)                     /*!< PWM_T::LOAD: LOAD1 Mask                */

#define PWM_LOAD_LOAD2_Pos               (2)                                               /*!< PWM_T::LOAD: LOAD2 Position            */
#define PWM_LOAD_LOAD2_Msk               (0x1ul << PWM_LOAD_LOAD2_Pos)                     /*!< PWM_T::LOAD: LOAD2 Mask                */

#define PWM_LOAD_LOAD3_Pos               (3)                                               /*!< PWM_T::LOAD: LOAD3 Position            */
#define PWM_LOAD_LOAD3_Msk               (0x1ul << PWM_LOAD_LOAD3_Pos)                     /*!< PWM_T::LOAD: LOAD3 Mask                */

#define PWM_LOAD_LOAD4_Pos               (4)                                               /*!< PWM_T::LOAD: LOAD4 Position            */
#define PWM_LOAD_LOAD4_Msk               (0x1ul << PWM_LOAD_LOAD4_Pos)                     /*!< PWM_T::LOAD: LOAD4 Mask                */

#define PWM_LOAD_LOAD5_Pos               (5)                                               /*!< PWM_T::LOAD: LOAD5 Position            */
#define PWM_LOAD_LOAD5_Msk               (0x1ul << PWM_LOAD_LOAD5_Pos)                     /*!< PWM_T::LOAD: LOAD5 Mask                */

#define PWM_PERIOD0_PERIOD_Pos           (0)                                               /*!< PWM_T::PERIOD0: PERIOD Position        */
#define PWM_PERIOD0_PERIOD_Msk           (0xfffful << PWM_PERIOD0_PERIOD_Pos)              /*!< PWM_T::PERIOD0: PERIOD Mask            */

#define PWM_PERIOD1_PERIOD_Pos           (0)                                               /*!< PWM_T::PERIOD1: PERIOD Position        */
#define PWM_PERIOD1_PERIOD_Msk           (0xfffful << PWM_PERIOD1_PERIOD_Pos)              /*!< PWM_T::PERIOD1: PERIOD Mask            */

#define PWM_PERIOD2_PERIOD_Pos           (0)                                               /*!< PWM_T::PERIOD2: PERIOD Position        */
#define PWM_PERIOD2_PERIOD_Msk           (0xfffful << PWM_PERIOD2_PERIOD_Pos)              /*!< PWM_T::PERIOD2: PERIOD Mask            */

#define PWM_PERIOD3_PERIOD_Pos           (0)                                               /*!< PWM_T::PERIOD3: PERIOD Position        */
#define PWM_PERIOD3_PERIOD_Msk           (0xfffful << PWM_PERIOD3_PERIOD_Pos)              /*!< PWM_T::PERIOD3: PERIOD Mask            */

#define PWM_PERIOD4_PERIOD_Pos           (0)                                               /*!< PWM_T::PERIOD4: PERIOD Position        */
#define PWM_PERIOD4_PERIOD_Msk           (0xfffful << PWM_PERIOD4_PERIOD_Pos)              /*!< PWM_T::PERIOD4: PERIOD Mask            */

#define PWM_PERIOD5_PERIOD_Pos           (0)                                               /*!< PWM_T::PERIOD5: PERIOD Position        */
#define PWM_PERIOD5_PERIOD_Msk           (0xfffful << PWM_PERIOD5_PERIOD_Pos)              /*!< PWM_T::PERIOD5: PERIOD Mask            */

#define PWM_CMPDAT0_CMP_Pos              (0)                                               /*!< PWM_T::CMPDAT0: CMP Position           */
#define PWM_CMPDAT0_CMP_Msk              (0xfffful << PWM_CMPDAT0_CMP_Pos)                 /*!< PWM_T::CMPDAT0: CMP Mask               */

#define PWM_CMPDAT1_CMP_Pos              (0)                                               /*!< PWM_T::CMPDAT1: CMP Position           */
#define PWM_CMPDAT1_CMP_Msk              (0xfffful << PWM_CMPDAT1_CMP_Pos)                 /*!< PWM_T::CMPDAT1: CMP Mask               */

#define PWM_CMPDAT2_CMP_Pos              (0)                                               /*!< PWM_T::CMPDAT2: CMP Position           */
#define PWM_CMPDAT2_CMP_Msk              (0xfffful << PWM_CMPDAT2_CMP_Pos)                 /*!< PWM_T::CMPDAT2: CMP Mask               */

#define PWM_CMPDAT3_CMP_Pos              (0)                                               /*!< PWM_T::CMPDAT3: CMP Position           */
#define PWM_CMPDAT3_CMP_Msk              (0xfffful << PWM_CMPDAT3_CMP_Pos)                 /*!< PWM_T::CMPDAT3: CMP Mask               */

#define PWM_CMPDAT4_CMP_Pos              (0)                                               /*!< PWM_T::CMPDAT4: CMP Position           */
#define PWM_CMPDAT4_CMP_Msk              (0xfffful << PWM_CMPDAT4_CMP_Pos)                 /*!< PWM_T::CMPDAT4: CMP Mask               */

#define PWM_CMPDAT5_CMP_Pos              (0)                                               /*!< PWM_T::CMPDAT5: CMP Position           */
#define PWM_CMPDAT5_CMP_Msk              (0xfffful << PWM_CMPDAT5_CMP_Pos)                 /*!< PWM_T::CMPDAT5: CMP Mask               */

#define PWM_DTCTL0_1_DTCNT_Pos           (0)                                               /*!< PWM_T::DTCTL0_1: DTCNT Position        */
#define PWM_DTCTL0_1_DTCNT_Msk           (0xffful << PWM_DTCTL0_1_DTCNT_Pos)               /*!< PWM_T::DTCTL0_1: DTCNT Mask            */

#define PWM_DTCTL0_1_DTEN_Pos            (16)                                              /*!< PWM_T::DTCTL0_1: DTEN Position         */
#define PWM_DTCTL0_1_DTEN_Msk            (0x1ul << PWM_DTCTL0_1_DTEN_Pos)                  /*!< PWM_T::DTCTL0_1: DTEN Mask             */

#define PWM_DTCTL0_1_DTCKSEL_Pos         (24)                                              /*!< PWM_T::DTCTL0_1: DTCKSEL Position      */
#define PWM_DTCTL0_1_DTCKSEL_Msk         (0x1ul << PWM_DTCTL0_1_DTCKSEL_Pos)               /*!< PWM_T::DTCTL0_1: DTCKSEL Mask          */

#define PWM_DTCTL2_3_DTCNT_Pos           (0)                                               /*!< PWM_T::DTCTL2_3: DTCNT Position        */
#define PWM_DTCTL2_3_DTCNT_Msk           (0xffful << PWM_DTCTL2_3_DTCNT_Pos)               /*!< PWM_T::DTCTL2_3: DTCNT Mask            */

#define PWM_DTCTL2_3_DTEN_Pos            (16)                                              /*!< PWM_T::DTCTL2_3: DTEN Position         */
#define PWM_DTCTL2_3_DTEN_Msk            (0x1ul << PWM_DTCTL2_3_DTEN_Pos)                  /*!< PWM_T::DTCTL2_3: DTEN Mask             */

#define PWM_DTCTL2_3_DTCKSEL_Pos         (24)                                              /*!< PWM_T::DTCTL2_3: DTCKSEL Position      */
#define PWM_DTCTL2_3_DTCKSEL_Msk         (0x1ul << PWM_DTCTL2_3_DTCKSEL_Pos)               /*!< PWM_T::DTCTL2_3: DTCKSEL Mask          */

#define PWM_DTCTL4_5_DTCNT_Pos           (0)                                               /*!< PWM_T::DTCTL4_5: DTCNT Position        */
#define PWM_DTCTL4_5_DTCNT_Msk           (0xffful << PWM_DTCTL4_5_DTCNT_Pos)               /*!< PWM_T::DTCTL4_5: DTCNT Mask            */

#define PWM_DTCTL4_5_DTEN_Pos            (16)                                              /*!< PWM_T::DTCTL4_5: DTEN Position         */
#define PWM_DTCTL4_5_DTEN_Msk            (0x1ul << PWM_DTCTL4_5_DTEN_Pos)                  /*!< PWM_T::DTCTL4_5: DTEN Mask             */

#define PWM_DTCTL4_5_DTCKSEL_Pos         (24)                                              /*!< PWM_T::DTCTL4_5: DTCKSEL Position      */
#define PWM_DTCTL4_5_DTCKSEL_Msk         (0x1ul << PWM_DTCTL4_5_DTCKSEL_Pos)               /*!< PWM_T::DTCTL4_5: DTCKSEL Mask          */

#define PWM_PHS0_1_PHS_Pos               (0)                                               /*!< PWM_T::PHS0_1: PHS Position            */
#define PWM_PHS0_1_PHS_Msk               (0xfffful << PWM_PHS0_1_PHS_Pos)                  /*!< PWM_T::PHS0_1: PHS Mask                */

#define PWM_PHS2_3_PHS_Pos               (0)                                               /*!< PWM_T::PHS2_3: PHS Position            */
#define PWM_PHS2_3_PHS_Msk               (0xfffful << PWM_PHS2_3_PHS_Pos)                  /*!< PWM_T::PHS2_3: PHS Mask                */

#define PWM_PHS4_5_PHS_Pos               (0)                                               /*!< PWM_T::PHS4_5: PHS Position            */
#define PWM_PHS4_5_PHS_Msk               (0xfffful << PWM_PHS4_5_PHS_Pos)                  /*!< PWM_T::PHS4_5: PHS Mask                */

#define PWM_CNT0_CNT_Pos                 (0)                                               /*!< PWM_T::CNT0: CNT Position              */
#define PWM_CNT0_CNT_Msk                 (0xfffful << PWM_CNT0_CNT_Pos)                    /*!< PWM_T::CNT0: CNT Mask                  */

#define PWM_CNT0_DIRF_Pos                (16)                                              /*!< PWM_T::CNT0: DIRF Position             */
#define PWM_CNT0_DIRF_Msk                (0x1ul << PWM_CNT0_DIRF_Pos)                      /*!< PWM_T::CNT0: DIRF Mask                 */

#define PWM_CNT1_CNT_Pos                 (0)                                               /*!< PWM_T::CNT1: CNT Position              */
#define PWM_CNT1_CNT_Msk                 (0xfffful << PWM_CNT1_CNT_Pos)                    /*!< PWM_T::CNT1: CNT Mask                  */

#define PWM_CNT1_DIRF_Pos                (16)                                              /*!< PWM_T::CNT1: DIRF Position             */
#define PWM_CNT1_DIRF_Msk                (0x1ul << PWM_CNT1_DIRF_Pos)                      /*!< PWM_T::CNT1: DIRF Mask                 */

#define PWM_CNT2_CNT_Pos                 (0)                                               /*!< PWM_T::CNT2: CNT Position              */
#define PWM_CNT2_CNT_Msk                 (0xfffful << PWM_CNT2_CNT_Pos)                    /*!< PWM_T::CNT2: CNT Mask                  */

#define PWM_CNT2_DIRF_Pos                (16)                                              /*!< PWM_T::CNT2: DIRF Position             */
#define PWM_CNT2_DIRF_Msk                (0x1ul << PWM_CNT2_DIRF_Pos)                      /*!< PWM_T::CNT2: DIRF Mask                 */

#define PWM_CNT3_CNT_Pos                 (0)                                               /*!< PWM_T::CNT3: CNT Position              */
#define PWM_CNT3_CNT_Msk                 (0xfffful << PWM_CNT3_CNT_Pos)                    /*!< PWM_T::CNT3: CNT Mask                  */

#define PWM_CNT3_DIRF_Pos                (16)                                              /*!< PWM_T::CNT3: DIRF Position             */
#define PWM_CNT3_DIRF_Msk                (0x1ul << PWM_CNT3_DIRF_Pos)                      /*!< PWM_T::CNT3: DIRF Mask                 */

#define PWM_CNT4_CNT_Pos                 (0)                                               /*!< PWM_T::CNT4: CNT Position              */
#define PWM_CNT4_CNT_Msk                 (0xfffful << PWM_CNT4_CNT_Pos)                    /*!< PWM_T::CNT4: CNT Mask                  */

#define PWM_CNT4_DIRF_Pos                (16)                                              /*!< PWM_T::CNT4: DIRF Position             */
#define PWM_CNT4_DIRF_Msk                (0x1ul << PWM_CNT4_DIRF_Pos)                      /*!< PWM_T::CNT4: DIRF Mask                 */

#define PWM_CNT5_CNT_Pos                 (0)                                               /*!< PWM_T::CNT5: CNT Position              */
#define PWM_CNT5_CNT_Msk                 (0xfffful << PWM_CNT5_CNT_Pos)                    /*!< PWM_T::CNT5: CNT Mask                  */

#define PWM_CNT5_DIRF_Pos                (16)                                              /*!< PWM_T::CNT5: DIRF Position             */
#define PWM_CNT5_DIRF_Msk                (0x1ul << PWM_CNT5_DIRF_Pos)                      /*!< PWM_T::CNT5: DIRF Mask                 */

#define PWM_WGCTL0_ZPCTL0_Pos            (0)                                               /*!< PWM_T::WGCTL0: ZPCTL0 Position         */
#define PWM_WGCTL0_ZPCTL0_Msk            (0x3ul << PWM_WGCTL0_ZPCTL0_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL0 Mask             */

#define PWM_WGCTL0_ZPCTL1_Pos            (2)                                               /*!< PWM_T::WGCTL0: ZPCTL1 Position         */
#define PWM_WGCTL0_ZPCTL1_Msk            (0x3ul << PWM_WGCTL0_ZPCTL1_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL1 Mask             */

#define PWM_WGCTL0_ZPCTL2_Pos            (4)                                               /*!< PWM_T::WGCTL0: ZPCTL2 Position         */
#define PWM_WGCTL0_ZPCTL2_Msk            (0x3ul << PWM_WGCTL0_ZPCTL2_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL2 Mask             */

#define PWM_WGCTL0_ZPCTL3_Pos            (6)                                               /*!< PWM_T::WGCTL0: ZPCTL3 Position         */
#define PWM_WGCTL0_ZPCTL3_Msk            (0x3ul << PWM_WGCTL0_ZPCTL3_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL3 Mask             */

#define PWM_WGCTL0_ZPCTL4_Pos            (8)                                               /*!< PWM_T::WGCTL0: ZPCTL4 Position         */
#define PWM_WGCTL0_ZPCTL4_Msk            (0x3ul << PWM_WGCTL0_ZPCTL4_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL4 Mask             */

#define PWM_WGCTL0_ZPCTL5_Pos            (10)                                              /*!< PWM_T::WGCTL0: ZPCTL5 Position         */
#define PWM_WGCTL0_ZPCTL5_Msk            (0x3ul << PWM_WGCTL0_ZPCTL5_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL5 Mask             */

#define PWM_WGCTL0_PRDPCTL0_Pos          (16)                                              /*!< PWM_T::WGCTL0: PRDPCTL0 Position       */
#define PWM_WGCTL0_PRDPCTL0_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL0_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL0 Mask           */

#define PWM_WGCTL0_PRDPCTL1_Pos          (18)                                              /*!< PWM_T::WGCTL0: PRDPCTL1 Position       */
#define PWM_WGCTL0_PRDPCTL1_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL1_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL1 Mask           */

#define PWM_WGCTL0_PRDPCTL2_Pos          (20)                                              /*!< PWM_T::WGCTL0: PRDPCTL2 Position       */
#define PWM_WGCTL0_PRDPCTL2_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL2_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL2 Mask           */

#define PWM_WGCTL0_PRDPCTL3_Pos          (22)                                              /*!< PWM_T::WGCTL0: PRDPCTL3 Position       */
#define PWM_WGCTL0_PRDPCTL3_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL3_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL3 Mask           */

#define PWM_WGCTL0_PRDPCTL4_Pos          (24)                                              /*!< PWM_T::WGCTL0: PRDPCTL4 Position       */
#define PWM_WGCTL0_PRDPCTL4_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL4_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL4 Mask           */

#define PWM_WGCTL0_PRDPCTL5_Pos          (26)                                              /*!< PWM_T::WGCTL0: PRDPCTL5 Position       */
#define PWM_WGCTL0_PRDPCTL5_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL5_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL5 Mask           */

#define PWM_WGCTL1_CMPUCTL0_Pos          (0)                                               /*!< PWM_T::WGCTL1: CMPUCTL0 Position       */
#define PWM_WGCTL1_CMPUCTL0_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL0_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL0 Mask           */

#define PWM_WGCTL1_CMPUCTL1_Pos          (2)                                               /*!< PWM_T::WGCTL1: CMPUCTL1 Position       */
#define PWM_WGCTL1_CMPUCTL1_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL1_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL1 Mask           */

#define PWM_WGCTL1_CMPUCTL2_Pos          (4)                                               /*!< PWM_T::WGCTL1: CMPUCTL2 Position       */
#define PWM_WGCTL1_CMPUCTL2_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL2_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL2 Mask           */

#define PWM_WGCTL1_CMPUCTL3_Pos          (6)                                               /*!< PWM_T::WGCTL1: CMPUCTL3 Position       */
#define PWM_WGCTL1_CMPUCTL3_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL3_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL3 Mask           */

#define PWM_WGCTL1_CMPUCTL4_Pos          (8)                                               /*!< PWM_T::WGCTL1: CMPUCTL4 Position       */
#define PWM_WGCTL1_CMPUCTL4_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL4_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL4 Mask           */

#define PWM_WGCTL1_CMPUCTL5_Pos          (10)                                              /*!< PWM_T::WGCTL1: CMPUCTL5 Position       */
#define PWM_WGCTL1_CMPUCTL5_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL5_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL5 Mask           */

#define PWM_WGCTL1_CMPDCTL0_Pos          (16)                                              /*!< PWM_T::WGCTL1: CMPDCTL0 Position       */
#define PWM_WGCTL1_CMPDCTL0_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL0_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL0 Mask           */

#define PWM_WGCTL1_CMPDCTL1_Pos          (18)                                              /*!< PWM_T::WGCTL1: CMPDCTL1 Position       */
#define PWM_WGCTL1_CMPDCTL1_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL1_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL1 Mask           */

#define PWM_WGCTL1_CMPDCTL2_Pos          (20)                                              /*!< PWM_T::WGCTL1: CMPDCTL2 Position       */
#define PWM_WGCTL1_CMPDCTL2_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL2_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL2 Mask           */

#define PWM_WGCTL1_CMPDCTL3_Pos          (22)                                              /*!< PWM_T::WGCTL1: CMPDCTL3 Position       */
#define PWM_WGCTL1_CMPDCTL3_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL3_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL3 Mask           */

#define PWM_WGCTL1_CMPDCTL4_Pos          (24)                                              /*!< PWM_T::WGCTL1: CMPDCTL4 Position       */
#define PWM_WGCTL1_CMPDCTL4_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL4_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL4 Mask           */

#define PWM_WGCTL1_CMPDCTL5_Pos          (26)                                              /*!< PWM_T::WGCTL1: CMPDCTL5 Position       */
#define PWM_WGCTL1_CMPDCTL5_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL5_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL5 Mask           */

#define PWM_MSKEN_MSKEN0_Pos             (0)                                               /*!< PWM_T::MSKEN: MSKEN0 Position          */
#define PWM_MSKEN_MSKEN0_Msk             (0x1ul << PWM_MSKEN_MSKEN0_Pos)                   /*!< PWM_T::MSKEN: MSKEN0 Mask              */

#define PWM_MSKEN_MSKEN1_Pos             (1)                                               /*!< PWM_T::MSKEN: MSKEN1 Position          */
#define PWM_MSKEN_MSKEN1_Msk             (0x1ul << PWM_MSKEN_MSKEN1_Pos)                   /*!< PWM_T::MSKEN: MSKEN1 Mask              */

#define PWM_MSKEN_MSKEN2_Pos             (2)                                               /*!< PWM_T::MSKEN: MSKEN2 Position          */
#define PWM_MSKEN_MSKEN2_Msk             (0x1ul << PWM_MSKEN_MSKEN2_Pos)                   /*!< PWM_T::MSKEN: MSKEN2 Mask              */

#define PWM_MSKEN_MSKEN3_Pos             (3)                                               /*!< PWM_T::MSKEN: MSKEN3 Position          */
#define PWM_MSKEN_MSKEN3_Msk             (0x1ul << PWM_MSKEN_MSKEN3_Pos)                   /*!< PWM_T::MSKEN: MSKEN3 Mask              */

#define PWM_MSKEN_MSKEN4_Pos             (4)                                               /*!< PWM_T::MSKEN: MSKEN4 Position          */
#define PWM_MSKEN_MSKEN4_Msk             (0x1ul << PWM_MSKEN_MSKEN4_Pos)                   /*!< PWM_T::MSKEN: MSKEN4 Mask              */

#define PWM_MSKEN_MSKEN5_Pos             (5)                                               /*!< PWM_T::MSKEN: MSKEN5 Position          */
#define PWM_MSKEN_MSKEN5_Msk             (0x1ul << PWM_MSKEN_MSKEN5_Pos)                   /*!< PWM_T::MSKEN: MSKEN5 Mask              */

#define PWM_MSK_MSKDAT0_Pos              (0)                                               /*!< PWM_T::MSK: MSKDAT0 Position           */
#define PWM_MSK_MSKDAT0_Msk              (0x1ul << PWM_MSK_MSKDAT0_Pos)                    /*!< PWM_T::MSK: MSKDAT0 Mask               */

#define PWM_MSK_MSKDAT1_Pos              (1)                                               /*!< PWM_T::MSK: MSKDAT1 Position           */
#define PWM_MSK_MSKDAT1_Msk              (0x1ul << PWM_MSK_MSKDAT1_Pos)                    /*!< PWM_T::MSK: MSKDAT1 Mask               */

#define PWM_MSK_MSKDAT2_Pos              (2)                                               /*!< PWM_T::MSK: MSKDAT2 Position           */
#define PWM_MSK_MSKDAT2_Msk              (0x1ul << PWM_MSK_MSKDAT2_Pos)                    /*!< PWM_T::MSK: MSKDAT2 Mask               */

#define PWM_MSK_MSKDAT3_Pos              (3)                                               /*!< PWM_T::MSK: MSKDAT3 Position           */
#define PWM_MSK_MSKDAT3_Msk              (0x1ul << PWM_MSK_MSKDAT3_Pos)                    /*!< PWM_T::MSK: MSKDAT3 Mask               */

#define PWM_MSK_MSKDAT4_Pos              (4)                                               /*!< PWM_T::MSK: MSKDAT4 Position           */
#define PWM_MSK_MSKDAT4_Msk              (0x1ul << PWM_MSK_MSKDAT4_Pos)                    /*!< PWM_T::MSK: MSKDAT4 Mask               */

#define PWM_MSK_MSKDAT5_Pos              (5)                                               /*!< PWM_T::MSK: MSKDAT5 Position           */
#define PWM_MSK_MSKDAT5_Msk              (0x1ul << PWM_MSK_MSKDAT5_Pos)                    /*!< PWM_T::MSK: MSKDAT5 Mask               */

#define PWM_BNF_BRK0NFEN_Pos             (0)                                               /*!< PWM_T::BNF: BRK0NFEN Position          */
#define PWM_BNF_BRK0NFEN_Msk             (0x1ul << PWM_BNF_BRK0NFEN_Pos)                   /*!< PWM_T::BNF: BRK0NFEN Mask              */

#define PWM_BNF_BRK0NFSEL_Pos            (1)                                               /*!< PWM_T::BNF: BRK0NFSEL Position         */
#define PWM_BNF_BRK0NFSEL_Msk            (0x7ul << PWM_BNF_BRK0NFSEL_Pos)                  /*!< PWM_T::BNF: BRK0NFSEL Mask             */

#define PWM_BNF_BRK0FCNT_Pos             (4)                                               /*!< PWM_T::BNF: BRK0FCNT Position          */
#define PWM_BNF_BRK0FCNT_Msk             (0x7ul << PWM_BNF_BRK0FCNT_Pos)                   /*!< PWM_T::BNF: BRK0FCNT Mask              */

#define PWM_BNF_BRK0PINV_Pos             (7)                                               /*!< PWM_T::BNF: BRK0PINV Position          */
#define PWM_BNF_BRK0PINV_Msk             (0x1ul << PWM_BNF_BRK0PINV_Pos)                   /*!< PWM_T::BNF: BRK0PINV Mask              */

#define PWM_BNF_BRK1NFEN_Pos             (8)                                               /*!< PWM_T::BNF: BRK1NFEN Position          */
#define PWM_BNF_BRK1NFEN_Msk             (0x1ul << PWM_BNF_BRK1NFEN_Pos)                   /*!< PWM_T::BNF: BRK1NFEN Mask              */

#define PWM_BNF_BRK1NFSEL_Pos            (9)                                               /*!< PWM_T::BNF: BRK1NFSEL Position         */
#define PWM_BNF_BRK1NFSEL_Msk            (0x7ul << PWM_BNF_BRK1NFSEL_Pos)                  /*!< PWM_T::BNF: BRK1NFSEL Mask             */

#define PWM_BNF_BRK1FCNT_Pos             (12)                                              /*!< PWM_T::BNF: BRK1FCNT Position          */
#define PWM_BNF_BRK1FCNT_Msk             (0x7ul << PWM_BNF_BRK1FCNT_Pos)                   /*!< PWM_T::BNF: BRK1FCNT Mask              */

#define PWM_BNF_BRK1PINV_Pos             (15)                                              /*!< PWM_T::BNF: BRK1PINV Position          */
#define PWM_BNF_BRK1PINV_Msk             (0x1ul << PWM_BNF_BRK1PINV_Pos)                   /*!< PWM_T::BNF: BRK1PINV Mask              */

#define PWM_FAILBRK_CSSBRKEN_Pos         (0)                                               /*!< PWM_T::FAILBRK: CSSBRKEN Position      */
#define PWM_FAILBRK_CSSBRKEN_Msk         (0x1ul << PWM_FAILBRK_CSSBRKEN_Pos)               /*!< PWM_T::FAILBRK: CSSBRKEN Mask          */

#define PWM_FAILBRK_BODBRKEN_Pos         (1)                                               /*!< PWM_T::FAILBRK: BODBRKEN Position      */
#define PWM_FAILBRK_BODBRKEN_Msk         (0x1ul << PWM_FAILBRK_BODBRKEN_Pos)               /*!< PWM_T::FAILBRK: BODBRKEN Mask          */

#define PWM_FAILBRK_RAMBRKEN_Pos         (2)                                               /*!< PWM_T::FAILBRK: RAMBRKEN Position      */
#define PWM_FAILBRK_RAMBRKEN_Msk         (0x1ul << PWM_FAILBRK_RAMBRKEN_Pos)               /*!< PWM_T::FAILBRK: RAMBRKEN Mask          */

#define PWM_FAILBRK_CORBRKEN_Pos         (3)                                               /*!< PWM_T::FAILBRK: CORBRKEN Position      */
#define PWM_FAILBRK_CORBRKEN_Msk         (0x1ul << PWM_FAILBRK_CORBRKEN_Pos)               /*!< PWM_T::FAILBRK: CORBRKEN Mask          */

#define PWM_BRKCTL0_1_BRKP0EEN_Pos       (4)                                               /*!< PWM_T::BRKCTL0_1: BRKP0EEN Position    */
#define PWM_BRKCTL0_1_BRKP0EEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP0EEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKP0EEN Mask        */

#define PWM_BRKCTL0_1_BRKP1EEN_Pos       (5)                                               /*!< PWM_T::BRKCTL0_1: BRKP1EEN Position    */
#define PWM_BRKCTL0_1_BRKP1EEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP1EEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKP1EEN Mask        */

#define PWM_BRKCTL0_1_SYSEBEN_Pos        (7)                                               /*!< PWM_T::BRKCTL0_1: SYSEBEN Position     */
#define PWM_BRKCTL0_1_SYSEBEN_Msk        (0x1ul << PWM_BRKCTL0_1_SYSEBEN_Pos)              /*!< PWM_T::BRKCTL0_1: SYSEBEN Mask         */

#define PWM_BRKCTL0_1_BRKP0LEN_Pos       (12)                                              /*!< PWM_T::BRKCTL0_1: BRKP0LEN Position    */
#define PWM_BRKCTL0_1_BRKP0LEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP0LEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKP0LEN Mask        */

#define PWM_BRKCTL0_1_BRKP1LEN_Pos       (13)                                              /*!< PWM_T::BRKCTL0_1: BRKP1LEN Position    */
#define PWM_BRKCTL0_1_BRKP1LEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP1LEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKP1LEN Mask        */

#define PWM_BRKCTL0_1_SYSLBEN_Pos        (15)                                              /*!< PWM_T::BRKCTL0_1: SYSLBEN Position     */
#define PWM_BRKCTL0_1_SYSLBEN_Msk        (0x1ul << PWM_BRKCTL0_1_SYSLBEN_Pos)              /*!< PWM_T::BRKCTL0_1: SYSLBEN Mask         */

#define PWM_BRKCTL0_1_BRKAEVEN_Pos       (16)                                              /*!< PWM_T::BRKCTL0_1: BRKAEVEN Position    */
#define PWM_BRKCTL0_1_BRKAEVEN_Msk       (0x3ul << PWM_BRKCTL0_1_BRKAEVEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKAEVEN Mask        */

#define PWM_BRKCTL0_1_BRKAODD_Pos        (18)                                              /*!< PWM_T::BRKCTL0_1: BRKAODD Position     */
#define PWM_BRKCTL0_1_BRKAODD_Msk        (0x3ul << PWM_BRKCTL0_1_BRKAODD_Pos)              /*!< PWM_T::BRKCTL0_1: BRKAODD Mask         */

#define PWM_BRKCTL0_1_ADCEBEN_Pos        (20)                                              /*!< PWM_T::BRKCTL0_1: ADCEBEN Position     */
#define PWM_BRKCTL0_1_ADCEBEN_Msk        (0x1ul << PWM_BRKCTL0_1_ADCEBEN_Pos)              /*!< PWM_T::BRKCTL0_1: ADCEBEN Mask         */

#define PWM_BRKCTL0_1_ADCLBEN_Pos        (28)                                              /*!< PWM_T::BRKCTL0_1: ADCLBEN Position     */
#define PWM_BRKCTL0_1_ADCLBEN_Msk        (0x1ul << PWM_BRKCTL0_1_ADCLBEN_Pos)              /*!< PWM_T::BRKCTL0_1: ADCLBEN Mask         */

#define PWM_BRKCTL2_3_BRKP0EEN_Pos       (4)                                               /*!< PWM_T::BRKCTL2_3: BRKP0EEN Position    */
#define PWM_BRKCTL2_3_BRKP0EEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP0EEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKP0EEN Mask        */

#define PWM_BRKCTL2_3_BRKP1EEN_Pos       (5)                                               /*!< PWM_T::BRKCTL2_3: BRKP1EEN Position    */
#define PWM_BRKCTL2_3_BRKP1EEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP1EEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKP1EEN Mask        */

#define PWM_BRKCTL2_3_SYSEBEN_Pos        (7)                                               /*!< PWM_T::BRKCTL2_3: SYSEBEN Position     */
#define PWM_BRKCTL2_3_SYSEBEN_Msk        (0x1ul << PWM_BRKCTL2_3_SYSEBEN_Pos)              /*!< PWM_T::BRKCTL2_3: SYSEBEN Mask         */

#define PWM_BRKCTL2_3_BRKP0LEN_Pos       (12)                                              /*!< PWM_T::BRKCTL2_3: BRKP0LEN Position    */
#define PWM_BRKCTL2_3_BRKP0LEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP0LEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKP0LEN Mask        */

#define PWM_BRKCTL2_3_BRKP1LEN_Pos       (13)                                              /*!< PWM_T::BRKCTL2_3: BRKP1LEN Position    */
#define PWM_BRKCTL2_3_BRKP1LEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP1LEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKP1LEN Mask        */

#define PWM_BRKCTL2_3_SYSLBEN_Pos        (15)                                              /*!< PWM_T::BRKCTL2_3: SYSLBEN Position     */
#define PWM_BRKCTL2_3_SYSLBEN_Msk        (0x1ul << PWM_BRKCTL2_3_SYSLBEN_Pos)              /*!< PWM_T::BRKCTL2_3: SYSLBEN Mask         */

#define PWM_BRKCTL2_3_BRKAEVEN_Pos       (16)                                              /*!< PWM_T::BRKCTL2_3: BRKAEVEN Position    */
#define PWM_BRKCTL2_3_BRKAEVEN_Msk       (0x3ul << PWM_BRKCTL2_3_BRKAEVEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKAEVEN Mask        */

#define PWM_BRKCTL2_3_BRKAODD_Pos        (18)                                              /*!< PWM_T::BRKCTL2_3: BRKAODD Position     */
#define PWM_BRKCTL2_3_BRKAODD_Msk        (0x3ul << PWM_BRKCTL2_3_BRKAODD_Pos)              /*!< PWM_T::BRKCTL2_3: BRKAODD Mask         */

#define PWM_BRKCTL2_3_ADCEBEN_Pos        (20)                                              /*!< PWM_T::BRKCTL2_3: ADCEBEN Position     */
#define PWM_BRKCTL2_3_ADCEBEN_Msk        (0x1ul << PWM_BRKCTL2_3_ADCEBEN_Pos)              /*!< PWM_T::BRKCTL2_3: ADCEBEN Mask         */

#define PWM_BRKCTL2_3_ADCLBEN_Pos        (28)                                              /*!< PWM_T::BRKCTL2_3: ADCLBEN Position     */
#define PWM_BRKCTL2_3_ADCLBEN_Msk        (0x1ul << PWM_BRKCTL2_3_ADCLBEN_Pos)              /*!< PWM_T::BRKCTL2_3: ADCLBEN Mask         */

#define PWM_BRKCTL4_5_BRKP0EEN_Pos       (4)                                               /*!< PWM_T::BRKCTL4_5: BRKP0EEN Position    */
#define PWM_BRKCTL4_5_BRKP0EEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP0EEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKP0EEN Mask        */

#define PWM_BRKCTL4_5_BRKP1EEN_Pos       (5)                                               /*!< PWM_T::BRKCTL4_5: BRKP1EEN Position    */
#define PWM_BRKCTL4_5_BRKP1EEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP1EEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKP1EEN Mask        */

#define PWM_BRKCTL4_5_SYSEBEN_Pos        (7)                                               /*!< PWM_T::BRKCTL4_5: SYSEBEN Position     */
#define PWM_BRKCTL4_5_SYSEBEN_Msk        (0x1ul << PWM_BRKCTL4_5_SYSEBEN_Pos)              /*!< PWM_T::BRKCTL4_5: SYSEBEN Mask         */

#define PWM_BRKCTL4_5_BRKP0LEN_Pos       (12)                                              /*!< PWM_T::BRKCTL4_5: BRKP0LEN Position    */
#define PWM_BRKCTL4_5_BRKP0LEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP0LEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKP0LEN Mask        */

#define PWM_BRKCTL4_5_BRKP1LEN_Pos       (13)                                              /*!< PWM_T::BRKCTL4_5: BRKP1LEN Position    */
#define PWM_BRKCTL4_5_BRKP1LEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP1LEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKP1LEN Mask        */

#define PWM_BRKCTL4_5_SYSLBEN_Pos        (15)                                              /*!< PWM_T::BRKCTL4_5: SYSLBEN Position     */
#define PWM_BRKCTL4_5_SYSLBEN_Msk        (0x1ul << PWM_BRKCTL4_5_SYSLBEN_Pos)              /*!< PWM_T::BRKCTL4_5: SYSLBEN Mask         */

#define PWM_BRKCTL4_5_BRKAEVEN_Pos       (16)                                              /*!< PWM_T::BRKCTL4_5: BRKAEVEN Position    */
#define PWM_BRKCTL4_5_BRKAEVEN_Msk       (0x3ul << PWM_BRKCTL4_5_BRKAEVEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKAEVEN Mask        */

#define PWM_BRKCTL4_5_BRKAODD_Pos        (18)                                              /*!< PWM_T::BRKCTL4_5: BRKAODD Position     */
#define PWM_BRKCTL4_5_BRKAODD_Msk        (0x3ul << PWM_BRKCTL4_5_BRKAODD_Pos)              /*!< PWM_T::BRKCTL4_5: BRKAODD Mask         */

#define PWM_BRKCTL4_5_ADCEBEN_Pos        (20)                                              /*!< PWM_T::BRKCTL4_5: ADCEBEN Position     */
#define PWM_BRKCTL4_5_ADCEBEN_Msk        (0x1ul << PWM_BRKCTL4_5_ADCEBEN_Pos)              /*!< PWM_T::BRKCTL4_5: ADCEBEN Mask         */

#define PWM_BRKCTL4_5_ADCLBEN_Pos        (28)                                              /*!< PWM_T::BRKCTL4_5: ADCLBEN Position     */
#define PWM_BRKCTL4_5_ADCLBEN_Msk        (0x1ul << PWM_BRKCTL4_5_ADCLBEN_Pos)              /*!< PWM_T::BRKCTL4_5: ADCLBEN Mask         */

#define PWM_POLCTL_PINV0_Pos             (0)                                               /*!< PWM_T::POLCTL: PINV0 Position          */
#define PWM_POLCTL_PINV0_Msk             (0x1ul << PWM_POLCTL_PINV0_Pos)                   /*!< PWM_T::POLCTL: PINV0 Mask              */

#define PWM_POLCTL_PINV1_Pos             (1)                                               /*!< PWM_T::POLCTL: PINV1 Position          */
#define PWM_POLCTL_PINV1_Msk             (0x1ul << PWM_POLCTL_PINV1_Pos)                   /*!< PWM_T::POLCTL: PINV1 Mask              */

#define PWM_POLCTL_PINV2_Pos             (2)                                               /*!< PWM_T::POLCTL: PINV2 Position          */
#define PWM_POLCTL_PINV2_Msk             (0x1ul << PWM_POLCTL_PINV2_Pos)                   /*!< PWM_T::POLCTL: PINV2 Mask              */

#define PWM_POLCTL_PINV3_Pos             (3)                                               /*!< PWM_T::POLCTL: PINV3 Position          */
#define PWM_POLCTL_PINV3_Msk             (0x1ul << PWM_POLCTL_PINV3_Pos)                   /*!< PWM_T::POLCTL: PINV3 Mask              */

#define PWM_POLCTL_PINV4_Pos             (4)                                               /*!< PWM_T::POLCTL: PINV4 Position          */
#define PWM_POLCTL_PINV4_Msk             (0x1ul << PWM_POLCTL_PINV4_Pos)                   /*!< PWM_T::POLCTL: PINV4 Mask              */

#define PWM_POLCTL_PINV5_Pos             (5)                                               /*!< PWM_T::POLCTL: PINV5 Position          */
#define PWM_POLCTL_PINV5_Msk             (0x1ul << PWM_POLCTL_PINV5_Pos)                   /*!< PWM_T::POLCTL: PINV5 Mask              */

#define PWM_POEN_POEN0_Pos               (0)                                               /*!< PWM_T::POEN: POEN0 Position            */
#define PWM_POEN_POEN0_Msk               (0x1ul << PWM_POEN_POEN0_Pos)                     /*!< PWM_T::POEN: POEN0 Mask                */

#define PWM_POEN_POEN1_Pos               (1)                                               /*!< PWM_T::POEN: POEN1 Position            */
#define PWM_POEN_POEN1_Msk               (0x1ul << PWM_POEN_POEN1_Pos)                     /*!< PWM_T::POEN: POEN1 Mask                */

#define PWM_POEN_POEN2_Pos               (2)                                               /*!< PWM_T::POEN: POEN2 Position            */
#define PWM_POEN_POEN2_Msk               (0x1ul << PWM_POEN_POEN2_Pos)                     /*!< PWM_T::POEN: POEN2 Mask                */

#define PWM_POEN_POEN3_Pos               (3)                                               /*!< PWM_T::POEN: POEN3 Position            */
#define PWM_POEN_POEN3_Msk               (0x1ul << PWM_POEN_POEN3_Pos)                     /*!< PWM_T::POEN: POEN3 Mask                */

#define PWM_POEN_POEN4_Pos               (4)                                               /*!< PWM_T::POEN: POEN4 Position            */
#define PWM_POEN_POEN4_Msk               (0x1ul << PWM_POEN_POEN4_Pos)                     /*!< PWM_T::POEN: POEN4 Mask                */

#define PWM_POEN_POEN5_Pos               (5)                                               /*!< PWM_T::POEN: POEN5 Position            */
#define PWM_POEN_POEN5_Msk               (0x1ul << PWM_POEN_POEN5_Pos)                     /*!< PWM_T::POEN: POEN5 Mask                */

#define PWM_SWBRK_BRKETRG0_Pos           (0)                                               /*!< PWM_T::SWBRK: BRKETRG0 Position        */
#define PWM_SWBRK_BRKETRG0_Msk           (0x1ul << PWM_SWBRK_BRKETRG0_Pos)                 /*!< PWM_T::SWBRK: BRKETRG0 Mask            */

#define PWM_SWBRK_BRKETRG2_Pos           (1)                                               /*!< PWM_T::SWBRK: BRKETRG2 Position        */
#define PWM_SWBRK_BRKETRG2_Msk           (0x1ul << PWM_SWBRK_BRKETRG2_Pos)                 /*!< PWM_T::SWBRK: BRKETRG2 Mask            */

#define PWM_SWBRK_BRKETRG4_Pos           (2)                                               /*!< PWM_T::SWBRK: BRKETRG4 Position        */
#define PWM_SWBRK_BRKETRG4_Msk           (0x1ul << PWM_SWBRK_BRKETRG4_Pos)                 /*!< PWM_T::SWBRK: BRKETRG4 Mask            */

#define PWM_SWBRK_BRKLTRG0_Pos           (8)                                               /*!< PWM_T::SWBRK: BRKLTRG0 Position        */
#define PWM_SWBRK_BRKLTRG0_Msk           (0x1ul << PWM_SWBRK_BRKLTRG0_Pos)                 /*!< PWM_T::SWBRK: BRKLTRG0 Mask            */

#define PWM_SWBRK_BRKLTRG2_Pos           (9)                                               /*!< PWM_T::SWBRK: BRKLTRG2 Position        */
#define PWM_SWBRK_BRKLTRG2_Msk           (0x1ul << PWM_SWBRK_BRKLTRG2_Pos)                 /*!< PWM_T::SWBRK: BRKLTRG2 Mask            */

#define PWM_SWBRK_BRKLTRG4_Pos           (10)                                              /*!< PWM_T::SWBRK: BRKLTRG4 Position        */
#define PWM_SWBRK_BRKLTRG4_Msk           (0x1ul << PWM_SWBRK_BRKLTRG4_Pos)                 /*!< PWM_T::SWBRK: BRKLTRG4 Mask            */

#define PWM_INTEN0_ZIEN0_Pos             (0)                                               /*!< PWM_T::INTEN0: ZIEN0 Position          */
#define PWM_INTEN0_ZIEN0_Msk             (0x1ul << PWM_INTEN0_ZIEN0_Pos)                   /*!< PWM_T::INTEN0: ZIEN0 Mask              */

#define PWM_INTEN0_ZIEN1_Pos             (1)                                               /*!< PWM_T::INTEN0: ZIEN1 Position          */
#define PWM_INTEN0_ZIEN1_Msk             (0x1ul << PWM_INTEN0_ZIEN1_Pos)                   /*!< PWM_T::INTEN0: ZIEN1 Mask              */

#define PWM_INTEN0_ZIEN2_Pos             (2)                                               /*!< PWM_T::INTEN0: ZIEN2 Position          */
#define PWM_INTEN0_ZIEN2_Msk             (0x1ul << PWM_INTEN0_ZIEN2_Pos)                   /*!< PWM_T::INTEN0: ZIEN2 Mask              */

#define PWM_INTEN0_ZIEN3_Pos             (3)                                               /*!< PWM_T::INTEN0: ZIEN3 Position          */
#define PWM_INTEN0_ZIEN3_Msk             (0x1ul << PWM_INTEN0_ZIEN3_Pos)                   /*!< PWM_T::INTEN0: ZIEN3 Mask              */

#define PWM_INTEN0_ZIEN4_Pos             (4)                                               /*!< PWM_T::INTEN0: ZIEN4 Position          */
#define PWM_INTEN0_ZIEN4_Msk             (0x1ul << PWM_INTEN0_ZIEN4_Pos)                   /*!< PWM_T::INTEN0: ZIEN4 Mask              */

#define PWM_INTEN0_ZIEN5_Pos             (5)                                               /*!< PWM_T::INTEN0: ZIEN5 Position          */
#define PWM_INTEN0_ZIEN5_Msk             (0x1ul << PWM_INTEN0_ZIEN5_Pos)                   /*!< PWM_T::INTEN0: ZIEN5 Mask              */

#define PWM_INTEN0_IFAIEN0_1_Pos         (7)                                               /*!< PWM_T::INTEN0: IFAIEN0_1 Position      */
#define PWM_INTEN0_IFAIEN0_1_Msk         (0x1ul << PWM_INTEN0_IFAIEN0_1_Pos)               /*!< PWM_T::INTEN0: IFAIEN0_1 Mask          */

#define PWM_INTEN0_PIEN0_Pos             (8)                                               /*!< PWM_T::INTEN0: PIEN0 Position          */
#define PWM_INTEN0_PIEN0_Msk             (0x1ul << PWM_INTEN0_PIEN0_Pos)                   /*!< PWM_T::INTEN0: PIEN0 Mask              */

#define PWM_INTEN0_PIEN1_Pos             (9)                                               /*!< PWM_T::INTEN0: PIEN1 Position          */
#define PWM_INTEN0_PIEN1_Msk             (0x1ul << PWM_INTEN0_PIEN1_Pos)                   /*!< PWM_T::INTEN0: PIEN1 Mask              */

#define PWM_INTEN0_PIEN2_Pos             (10)                                              /*!< PWM_T::INTEN0: PIEN2 Position          */
#define PWM_INTEN0_PIEN2_Msk             (0x1ul << PWM_INTEN0_PIEN2_Pos)                   /*!< PWM_T::INTEN0: PIEN2 Mask              */

#define PWM_INTEN0_PIEN3_Pos             (11)                                              /*!< PWM_T::INTEN0: PIEN3 Position          */
#define PWM_INTEN0_PIEN3_Msk             (0x1ul << PWM_INTEN0_PIEN3_Pos)                   /*!< PWM_T::INTEN0: PIEN3 Mask              */

#define PWM_INTEN0_PIEN4_Pos             (12)                                              /*!< PWM_T::INTEN0: PIEN4 Position          */
#define PWM_INTEN0_PIEN4_Msk             (0x1ul << PWM_INTEN0_PIEN4_Pos)                   /*!< PWM_T::INTEN0: PIEN4 Mask              */

#define PWM_INTEN0_PIEN5_Pos             (13)                                              /*!< PWM_T::INTEN0: PIEN5 Position          */
#define PWM_INTEN0_PIEN5_Msk             (0x1ul << PWM_INTEN0_PIEN5_Pos)                   /*!< PWM_T::INTEN0: PIEN5 Mask              */

#define PWM_INTEN0_IFAIEN2_3_Pos         (15)                                              /*!< PWM_T::INTEN0: IFAIEN2_3 Position      */
#define PWM_INTEN0_IFAIEN2_3_Msk         (0x1ul << PWM_INTEN0_IFAIEN2_3_Pos)               /*!< PWM_T::INTEN0: IFAIEN2_3 Mask          */

#define PWM_INTEN0_CMPUIEN0_Pos          (16)                                              /*!< PWM_T::INTEN0: CMPUIEN0 Position       */
#define PWM_INTEN0_CMPUIEN0_Msk          (0x1ul << PWM_INTEN0_CMPUIEN0_Pos)                /*!< PWM_T::INTEN0: CMPUIEN0 Mask           */

#define PWM_INTEN0_CMPUIEN1_Pos          (17)                                              /*!< PWM_T::INTEN0: CMPUIEN1 Position       */
#define PWM_INTEN0_CMPUIEN1_Msk          (0x1ul << PWM_INTEN0_CMPUIEN1_Pos)                /*!< PWM_T::INTEN0: CMPUIEN1 Mask           */

#define PWM_INTEN0_CMPUIEN2_Pos          (18)                                              /*!< PWM_T::INTEN0: CMPUIEN2 Position       */
#define PWM_INTEN0_CMPUIEN2_Msk          (0x1ul << PWM_INTEN0_CMPUIEN2_Pos)                /*!< PWM_T::INTEN0: CMPUIEN2 Mask           */

#define PWM_INTEN0_CMPUIEN3_Pos          (19)                                              /*!< PWM_T::INTEN0: CMPUIEN3 Position       */
#define PWM_INTEN0_CMPUIEN3_Msk          (0x1ul << PWM_INTEN0_CMPUIEN3_Pos)                /*!< PWM_T::INTEN0: CMPUIEN3 Mask           */

#define PWM_INTEN0_CMPUIEN4_Pos          (20)                                              /*!< PWM_T::INTEN0: CMPUIEN4 Position       */
#define PWM_INTEN0_CMPUIEN4_Msk          (0x1ul << PWM_INTEN0_CMPUIEN4_Pos)                /*!< PWM_T::INTEN0: CMPUIEN4 Mask           */

#define PWM_INTEN0_CMPUIEN5_Pos          (21)                                              /*!< PWM_T::INTEN0: CMPUIEN5 Position       */
#define PWM_INTEN0_CMPUIEN5_Msk          (0x1ul << PWM_INTEN0_CMPUIEN5_Pos)                /*!< PWM_T::INTEN0: CMPUIEN5 Mask           */

#define PWM_INTEN0_IFAIEN4_5_Pos         (23)                                              /*!< PWM_T::INTEN0: IFAIEN4_5 Position      */
#define PWM_INTEN0_IFAIEN4_5_Msk         (0x1ul << PWM_INTEN0_IFAIEN4_5_Pos)               /*!< PWM_T::INTEN0: IFAIEN4_5 Mask          */

#define PWM_INTEN0_CMPDIEN0_Pos          (24)                                              /*!< PWM_T::INTEN0: CMPDIEN0 Position       */
#define PWM_INTEN0_CMPDIEN0_Msk          (0x1ul << PWM_INTEN0_CMPDIEN0_Pos)                /*!< PWM_T::INTEN0: CMPDIEN0 Mask           */

#define PWM_INTEN0_CMPDIEN1_Pos          (25)                                              /*!< PWM_T::INTEN0: CMPDIEN1 Position       */
#define PWM_INTEN0_CMPDIEN1_Msk          (0x1ul << PWM_INTEN0_CMPDIEN1_Pos)                /*!< PWM_T::INTEN0: CMPDIEN1 Mask           */

#define PWM_INTEN0_CMPDIEN2_Pos          (26)                                              /*!< PWM_T::INTEN0: CMPDIEN2 Position       */
#define PWM_INTEN0_CMPDIEN2_Msk          (0x1ul << PWM_INTEN0_CMPDIEN2_Pos)                /*!< PWM_T::INTEN0: CMPDIEN2 Mask           */

#define PWM_INTEN0_CMPDIEN3_Pos          (27)                                              /*!< PWM_T::INTEN0: CMPDIEN3 Position       */
#define PWM_INTEN0_CMPDIEN3_Msk          (0x1ul << PWM_INTEN0_CMPDIEN3_Pos)                /*!< PWM_T::INTEN0: CMPDIEN3 Mask           */

#define PWM_INTEN0_CMPDIEN4_Pos          (28)                                              /*!< PWM_T::INTEN0: CMPDIEN4 Position       */
#define PWM_INTEN0_CMPDIEN4_Msk          (0x1ul << PWM_INTEN0_CMPDIEN4_Pos)                /*!< PWM_T::INTEN0: CMPDIEN4 Mask           */

#define PWM_INTEN0_CMPDIEN5_Pos          (29)                                              /*!< PWM_T::INTEN0: CMPDIEN5 Position       */
#define PWM_INTEN0_CMPDIEN5_Msk          (0x1ul << PWM_INTEN0_CMPDIEN5_Pos)                /*!< PWM_T::INTEN0: CMPDIEN5 Mask           */

#define PWM_INTEN1_BRKEIEN0_1_Pos        (0)                                               /*!< PWM_T::INTEN1: BRKEIEN0_1 Position     */
#define PWM_INTEN1_BRKEIEN0_1_Msk        (0x1ul << PWM_INTEN1_BRKEIEN0_1_Pos)              /*!< PWM_T::INTEN1: BRKEIEN0_1 Mask         */

#define PWM_INTEN1_BRKEIEN2_3_Pos        (1)                                               /*!< PWM_T::INTEN1: BRKEIEN2_3 Position     */
#define PWM_INTEN1_BRKEIEN2_3_Msk        (0x1ul << PWM_INTEN1_BRKEIEN2_3_Pos)              /*!< PWM_T::INTEN1: BRKEIEN2_3 Mask         */

#define PWM_INTEN1_BRKEIEN4_5_Pos        (2)                                               /*!< PWM_T::INTEN1: BRKEIEN4_5 Position     */
#define PWM_INTEN1_BRKEIEN4_5_Msk        (0x1ul << PWM_INTEN1_BRKEIEN4_5_Pos)              /*!< PWM_T::INTEN1: BRKEIEN4_5 Mask         */

#define PWM_INTEN1_BRKLIEN0_1_Pos        (8)                                               /*!< PWM_T::INTEN1: BRKLIEN0_1 Position     */
#define PWM_INTEN1_BRKLIEN0_1_Msk        (0x1ul << PWM_INTEN1_BRKLIEN0_1_Pos)              /*!< PWM_T::INTEN1: BRKLIEN0_1 Mask         */

#define PWM_INTEN1_BRKLIEN2_3_Pos        (9)                                               /*!< PWM_T::INTEN1: BRKLIEN2_3 Position     */
#define PWM_INTEN1_BRKLIEN2_3_Msk        (0x1ul << PWM_INTEN1_BRKLIEN2_3_Pos)              /*!< PWM_T::INTEN1: BRKLIEN2_3 Mask         */

#define PWM_INTEN1_BRKLIEN4_5_Pos        (10)                                              /*!< PWM_T::INTEN1: BRKLIEN4_5 Position     */
#define PWM_INTEN1_BRKLIEN4_5_Msk        (0x1ul << PWM_INTEN1_BRKLIEN4_5_Pos)              /*!< PWM_T::INTEN1: BRKLIEN4_5 Mask         */

#define PWM_INTSTS0_ZIF0_Pos             (0)                                               /*!< PWM_T::INTSTS0: ZIF0 Position          */
#define PWM_INTSTS0_ZIF0_Msk             (0x1ul << PWM_INTSTS0_ZIF0_Pos)                   /*!< PWM_T::INTSTS0: ZIF0 Mask              */

#define PWM_INTSTS0_ZIF1_Pos             (1)                                               /*!< PWM_T::INTSTS0: ZIF1 Position          */
#define PWM_INTSTS0_ZIF1_Msk             (0x1ul << PWM_INTSTS0_ZIF1_Pos)                   /*!< PWM_T::INTSTS0: ZIF1 Mask              */

#define PWM_INTSTS0_ZIF2_Pos             (2)                                               /*!< PWM_T::INTSTS0: ZIF2 Position          */
#define PWM_INTSTS0_ZIF2_Msk             (0x1ul << PWM_INTSTS0_ZIF2_Pos)                   /*!< PWM_T::INTSTS0: ZIF2 Mask              */

#define PWM_INTSTS0_ZIF3_Pos             (3)                                               /*!< PWM_T::INTSTS0: ZIF3 Position          */
#define PWM_INTSTS0_ZIF3_Msk             (0x1ul << PWM_INTSTS0_ZIF3_Pos)                   /*!< PWM_T::INTSTS0: ZIF3 Mask              */

#define PWM_INTSTS0_ZIF4_Pos             (4)                                               /*!< PWM_T::INTSTS0: ZIF4 Position          */
#define PWM_INTSTS0_ZIF4_Msk             (0x1ul << PWM_INTSTS0_ZIF4_Pos)                   /*!< PWM_T::INTSTS0: ZIF4 Mask              */

#define PWM_INTSTS0_ZIF5_Pos             (5)                                               /*!< PWM_T::INTSTS0: ZIF5 Position          */
#define PWM_INTSTS0_ZIF5_Msk             (0x1ul << PWM_INTSTS0_ZIF5_Pos)                   /*!< PWM_T::INTSTS0: ZIF5 Mask              */

#define PWM_INTSTS0_IFAIF0_1_Pos         (7)                                               /*!< PWM_T::INTSTS0: IFAIF0_1 Position      */
#define PWM_INTSTS0_IFAIF0_1_Msk         (0x1ul << PWM_INTSTS0_IFAIF0_1_Pos)               /*!< PWM_T::INTSTS0: IFAIF0_1 Mask          */

#define PWM_INTSTS0_PIF0_Pos             (8)                                               /*!< PWM_T::INTSTS0: PIF0 Position          */
#define PWM_INTSTS0_PIF0_Msk             (0x1ul << PWM_INTSTS0_PIF0_Pos)                   /*!< PWM_T::INTSTS0: PIF0 Mask              */

#define PWM_INTSTS0_PIF1_Pos             (9)                                               /*!< PWM_T::INTSTS0: PIF1 Position          */
#define PWM_INTSTS0_PIF1_Msk             (0x1ul << PWM_INTSTS0_PIF1_Pos)                   /*!< PWM_T::INTSTS0: PIF1 Mask              */

#define PWM_INTSTS0_PIF2_Pos             (10)                                              /*!< PWM_T::INTSTS0: PIF2 Position          */
#define PWM_INTSTS0_PIF2_Msk             (0x1ul << PWM_INTSTS0_PIF2_Pos)                   /*!< PWM_T::INTSTS0: PIF2 Mask              */

#define PWM_INTSTS0_PIF3_Pos             (11)                                              /*!< PWM_T::INTSTS0: PIF3 Position          */
#define PWM_INTSTS0_PIF3_Msk             (0x1ul << PWM_INTSTS0_PIF3_Pos)                   /*!< PWM_T::INTSTS0: PIF3 Mask              */

#define PWM_INTSTS0_PIF4_Pos             (12)                                              /*!< PWM_T::INTSTS0: PIF4 Position          */
#define PWM_INTSTS0_PIF4_Msk             (0x1ul << PWM_INTSTS0_PIF4_Pos)                   /*!< PWM_T::INTSTS0: PIF4 Mask              */

#define PWM_INTSTS0_PIF5_Pos             (13)                                              /*!< PWM_T::INTSTS0: PIF5 Position          */
#define PWM_INTSTS0_PIF5_Msk             (0x1ul << PWM_INTSTS0_PIF5_Pos)                   /*!< PWM_T::INTSTS0: PIF5 Mask              */

#define PWM_INTSTS0_IFAIF2_3_Pos         (15)                                              /*!< PWM_T::INTSTS0: IFAIF2_3 Position      */
#define PWM_INTSTS0_IFAIF2_3_Msk         (0x1ul << PWM_INTSTS0_IFAIF2_3_Pos)               /*!< PWM_T::INTSTS0: IFAIF2_3 Mask          */

#define PWM_INTSTS0_CMPUIF0_Pos          (16)                                              /*!< PWM_T::INTSTS0: CMPUIF0 Position       */
#define PWM_INTSTS0_CMPUIF0_Msk          (0x1ul << PWM_INTSTS0_CMPUIF0_Pos)                /*!< PWM_T::INTSTS0: CMPUIF0 Mask           */

#define PWM_INTSTS0_CMPUIF1_Pos          (17)                                              /*!< PWM_T::INTSTS0: CMPUIF1 Position       */
#define PWM_INTSTS0_CMPUIF1_Msk          (0x1ul << PWM_INTSTS0_CMPUIF1_Pos)                /*!< PWM_T::INTSTS0: CMPUIF1 Mask           */

#define PWM_INTSTS0_CMPUIF2_Pos          (18)                                              /*!< PWM_T::INTSTS0: CMPUIF2 Position       */
#define PWM_INTSTS0_CMPUIF2_Msk          (0x1ul << PWM_INTSTS0_CMPUIF2_Pos)                /*!< PWM_T::INTSTS0: CMPUIF2 Mask           */

#define PWM_INTSTS0_CMPUIF3_Pos          (19)                                              /*!< PWM_T::INTSTS0: CMPUIF3 Position       */
#define PWM_INTSTS0_CMPUIF3_Msk          (0x1ul << PWM_INTSTS0_CMPUIF3_Pos)                /*!< PWM_T::INTSTS0: CMPUIF3 Mask           */

#define PWM_INTSTS0_CMPUIF4_Pos          (20)                                              /*!< PWM_T::INTSTS0: CMPUIF4 Position       */
#define PWM_INTSTS0_CMPUIF4_Msk          (0x1ul << PWM_INTSTS0_CMPUIF4_Pos)                /*!< PWM_T::INTSTS0: CMPUIF4 Mask           */

#define PWM_INTSTS0_CMPUIF5_Pos          (21)                                              /*!< PWM_T::INTSTS0: CMPUIF5 Position       */
#define PWM_INTSTS0_CMPUIF5_Msk          (0x1ul << PWM_INTSTS0_CMPUIF5_Pos)                /*!< PWM_T::INTSTS0: CMPUIF5 Mask           */

#define PWM_INTSTS0_IFAIF4_5_Pos         (23)                                              /*!< PWM_T::INTSTS0: IFAIF4_5 Position      */
#define PWM_INTSTS0_IFAIF4_5_Msk         (0x1ul << PWM_INTSTS0_IFAIF4_5_Pos)               /*!< PWM_T::INTSTS0: IFAIF4_5 Mask          */

#define PWM_INTSTS0_CMPDIF0_Pos          (24)                                              /*!< PWM_T::INTSTS0: CMPDIF0 Position       */
#define PWM_INTSTS0_CMPDIF0_Msk          (0x1ul << PWM_INTSTS0_CMPDIF0_Pos)                /*!< PWM_T::INTSTS0: CMPDIF0 Mask           */

#define PWM_INTSTS0_CMPDIF1_Pos          (25)                                              /*!< PWM_T::INTSTS0: CMPDIF1 Position       */
#define PWM_INTSTS0_CMPDIF1_Msk          (0x1ul << PWM_INTSTS0_CMPDIF1_Pos)                /*!< PWM_T::INTSTS0: CMPDIF1 Mask           */

#define PWM_INTSTS0_CMPDIF2_Pos          (26)                                              /*!< PWM_T::INTSTS0: CMPDIF2 Position       */
#define PWM_INTSTS0_CMPDIF2_Msk          (0x1ul << PWM_INTSTS0_CMPDIF2_Pos)                /*!< PWM_T::INTSTS0: CMPDIF2 Mask           */

#define PWM_INTSTS0_CMPDIF3_Pos          (27)                                              /*!< PWM_T::INTSTS0: CMPDIF3 Position       */
#define PWM_INTSTS0_CMPDIF3_Msk          (0x1ul << PWM_INTSTS0_CMPDIF3_Pos)                /*!< PWM_T::INTSTS0: CMPDIF3 Mask           */

#define PWM_INTSTS0_CMPDIF4_Pos          (28)                                              /*!< PWM_T::INTSTS0: CMPDIF4 Position       */
#define PWM_INTSTS0_CMPDIF4_Msk          (0x1ul << PWM_INTSTS0_CMPDIF4_Pos)                /*!< PWM_T::INTSTS0: CMPDIF4 Mask           */

#define PWM_INTSTS0_CMPDIF5_Pos          (29)                                              /*!< PWM_T::INTSTS0: CMPDIF5 Position       */
#define PWM_INTSTS0_CMPDIF5_Msk          (0x1ul << PWM_INTSTS0_CMPDIF5_Pos)                /*!< PWM_T::INTSTS0: CMPDIF5 Mask           */

#define PWM_INTSTS1_BRKEIF0_Pos          (0)                                               /*!< PWM_T::INTSTS1: BRKEIF0 Position       */
#define PWM_INTSTS1_BRKEIF0_Msk          (0x1ul << PWM_INTSTS1_BRKEIF0_Pos)                /*!< PWM_T::INTSTS1: BRKEIF0 Mask           */

#define PWM_INTSTS1_BRKEIF1_Pos          (1)                                               /*!< PWM_T::INTSTS1: BRKEIF1 Position       */
#define PWM_INTSTS1_BRKEIF1_Msk          (0x1ul << PWM_INTSTS1_BRKEIF1_Pos)                /*!< PWM_T::INTSTS1: BRKEIF1 Mask           */

#define PWM_INTSTS1_BRKEIF2_Pos          (2)                                               /*!< PWM_T::INTSTS1: BRKEIF2 Position       */
#define PWM_INTSTS1_BRKEIF2_Msk          (0x1ul << PWM_INTSTS1_BRKEIF2_Pos)                /*!< PWM_T::INTSTS1: BRKEIF2 Mask           */

#define PWM_INTSTS1_BRKEIF3_Pos          (3)                                               /*!< PWM_T::INTSTS1: BRKEIF3 Position       */
#define PWM_INTSTS1_BRKEIF3_Msk          (0x1ul << PWM_INTSTS1_BRKEIF3_Pos)                /*!< PWM_T::INTSTS1: BRKEIF3 Mask           */

#define PWM_INTSTS1_BRKEIF4_Pos          (4)                                               /*!< PWM_T::INTSTS1: BRKEIF4 Position       */
#define PWM_INTSTS1_BRKEIF4_Msk          (0x1ul << PWM_INTSTS1_BRKEIF4_Pos)                /*!< PWM_T::INTSTS1: BRKEIF4 Mask           */

#define PWM_INTSTS1_BRKEIF5_Pos          (5)                                               /*!< PWM_T::INTSTS1: BRKEIF5 Position       */
#define PWM_INTSTS1_BRKEIF5_Msk          (0x1ul << PWM_INTSTS1_BRKEIF5_Pos)                /*!< PWM_T::INTSTS1: BRKEIF5 Mask           */

#define PWM_INTSTS1_BRKLIF0_Pos          (8)                                               /*!< PWM_T::INTSTS1: BRKLIF0 Position       */
#define PWM_INTSTS1_BRKLIF0_Msk          (0x1ul << PWM_INTSTS1_BRKLIF0_Pos)                /*!< PWM_T::INTSTS1: BRKLIF0 Mask           */

#define PWM_INTSTS1_BRKLIF1_Pos          (9)                                               /*!< PWM_T::INTSTS1: BRKLIF1 Position       */
#define PWM_INTSTS1_BRKLIF1_Msk          (0x1ul << PWM_INTSTS1_BRKLIF1_Pos)                /*!< PWM_T::INTSTS1: BRKLIF1 Mask           */

#define PWM_INTSTS1_BRKLIF2_Pos          (10)                                              /*!< PWM_T::INTSTS1: BRKLIF2 Position       */
#define PWM_INTSTS1_BRKLIF2_Msk          (0x1ul << PWM_INTSTS1_BRKLIF2_Pos)                /*!< PWM_T::INTSTS1: BRKLIF2 Mask           */

#define PWM_INTSTS1_BRKLIF3_Pos          (11)                                              /*!< PWM_T::INTSTS1: BRKLIF3 Position       */
#define PWM_INTSTS1_BRKLIF3_Msk          (0x1ul << PWM_INTSTS1_BRKLIF3_Pos)                /*!< PWM_T::INTSTS1: BRKLIF3 Mask           */

#define PWM_INTSTS1_BRKLIF4_Pos          (12)                                              /*!< PWM_T::INTSTS1: BRKLIF4 Position       */
#define PWM_INTSTS1_BRKLIF4_Msk          (0x1ul << PWM_INTSTS1_BRKLIF4_Pos)                /*!< PWM_T::INTSTS1: BRKLIF4 Mask           */

#define PWM_INTSTS1_BRKLIF5_Pos          (13)                                              /*!< PWM_T::INTSTS1: BRKLIF5 Position       */
#define PWM_INTSTS1_BRKLIF5_Msk          (0x1ul << PWM_INTSTS1_BRKLIF5_Pos)                /*!< PWM_T::INTSTS1: BRKLIF5 Mask           */

#define PWM_INTSTS1_BRKESTS0_Pos         (16)                                              /*!< PWM_T::INTSTS1: BRKESTS0 Position      */
#define PWM_INTSTS1_BRKESTS0_Msk         (0x1ul << PWM_INTSTS1_BRKESTS0_Pos)               /*!< PWM_T::INTSTS1: BRKESTS0 Mask          */

#define PWM_INTSTS1_BRKESTS1_Pos         (17)                                              /*!< PWM_T::INTSTS1: BRKESTS1 Position      */
#define PWM_INTSTS1_BRKESTS1_Msk         (0x1ul << PWM_INTSTS1_BRKESTS1_Pos)               /*!< PWM_T::INTSTS1: BRKESTS1 Mask          */

#define PWM_INTSTS1_BRKESTS2_Pos         (18)                                              /*!< PWM_T::INTSTS1: BRKESTS2 Position      */
#define PWM_INTSTS1_BRKESTS2_Msk         (0x1ul << PWM_INTSTS1_BRKESTS2_Pos)               /*!< PWM_T::INTSTS1: BRKESTS2 Mask          */

#define PWM_INTSTS1_BRKESTS3_Pos         (19)                                              /*!< PWM_T::INTSTS1: BRKESTS3 Position      */
#define PWM_INTSTS1_BRKESTS3_Msk         (0x1ul << PWM_INTSTS1_BRKESTS3_Pos)               /*!< PWM_T::INTSTS1: BRKESTS3 Mask          */

#define PWM_INTSTS1_BRKESTS4_Pos         (20)                                              /*!< PWM_T::INTSTS1: BRKESTS4 Position      */
#define PWM_INTSTS1_BRKESTS4_Msk         (0x1ul << PWM_INTSTS1_BRKESTS4_Pos)               /*!< PWM_T::INTSTS1: BRKESTS4 Mask          */

#define PWM_INTSTS1_BRKESTS5_Pos         (21)                                              /*!< PWM_T::INTSTS1: BRKESTS5 Position      */
#define PWM_INTSTS1_BRKESTS5_Msk         (0x1ul << PWM_INTSTS1_BRKESTS5_Pos)               /*!< PWM_T::INTSTS1: BRKESTS5 Mask          */

#define PWM_INTSTS1_BRKLSTS0_Pos         (24)                                              /*!< PWM_T::INTSTS1: BRKLSTS0 Position      */
#define PWM_INTSTS1_BRKLSTS0_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS0_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS0 Mask          */

#define PWM_INTSTS1_BRKLSTS1_Pos         (25)                                              /*!< PWM_T::INTSTS1: BRKLSTS1 Position      */
#define PWM_INTSTS1_BRKLSTS1_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS1_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS1 Mask          */

#define PWM_INTSTS1_BRKLSTS2_Pos         (26)                                              /*!< PWM_T::INTSTS1: BRKLSTS2 Position      */
#define PWM_INTSTS1_BRKLSTS2_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS2_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS2 Mask          */

#define PWM_INTSTS1_BRKLSTS3_Pos         (27)                                              /*!< PWM_T::INTSTS1: BRKLSTS3 Position      */
#define PWM_INTSTS1_BRKLSTS3_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS3_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS3 Mask          */

#define PWM_INTSTS1_BRKLSTS4_Pos         (28)                                              /*!< PWM_T::INTSTS1: BRKLSTS4 Position      */
#define PWM_INTSTS1_BRKLSTS4_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS4_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS4 Mask          */

#define PWM_INTSTS1_BRKLSTS5_Pos         (29)                                              /*!< PWM_T::INTSTS1: BRKLSTS5 Position      */
#define PWM_INTSTS1_BRKLSTS5_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS5_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS5 Mask          */

#define PWM_IFA_IFCNT0_1_Pos             (0)                                               /*!< PWM_T::IFA: IFCNT0_1 Position          */
#define PWM_IFA_IFCNT0_1_Msk             (0xful << PWM_IFA_IFCNT0_1_Pos)                   /*!< PWM_T::IFA: IFCNT0_1 Mask              */

#define PWM_IFA_IFSEL0_1_Pos             (4)                                               /*!< PWM_T::IFA: IFSEL0_1 Position          */
#define PWM_IFA_IFSEL0_1_Msk             (0x7ul << PWM_IFA_IFSEL0_1_Pos)                   /*!< PWM_T::IFA: IFSEL0_1 Mask              */

#define PWM_IFA_IFAEN0_1_Pos             (7)                                               /*!< PWM_T::IFA: IFAEN0_1 Position          */
#define PWM_IFA_IFAEN0_1_Msk             (0x1ul << PWM_IFA_IFAEN0_1_Pos)                   /*!< PWM_T::IFA: IFAEN0_1 Mask              */

#define PWM_IFA_IFCNT2_3_Pos             (8)                                               /*!< PWM_T::IFA: IFCNT2_3 Position          */
#define PWM_IFA_IFCNT2_3_Msk             (0xful << PWM_IFA_IFCNT2_3_Pos)                   /*!< PWM_T::IFA: IFCNT2_3 Mask              */

#define PWM_IFA_IFSEL2_3_Pos             (12)                                              /*!< PWM_T::IFA: IFSEL2_3 Position          */
#define PWM_IFA_IFSEL2_3_Msk             (0x7ul << PWM_IFA_IFSEL2_3_Pos)                   /*!< PWM_T::IFA: IFSEL2_3 Mask              */

#define PWM_IFA_IFAEN2_3_Pos             (15)                                              /*!< PWM_T::IFA: IFAEN2_3 Position          */
#define PWM_IFA_IFAEN2_3_Msk             (0x1ul << PWM_IFA_IFAEN2_3_Pos)                   /*!< PWM_T::IFA: IFAEN2_3 Mask              */

#define PWM_IFA_IFCNT4_5_Pos             (16)                                              /*!< PWM_T::IFA: IFCNT4_5 Position          */
#define PWM_IFA_IFCNT4_5_Msk             (0xful << PWM_IFA_IFCNT4_5_Pos)                   /*!< PWM_T::IFA: IFCNT4_5 Mask              */

#define PWM_IFA_IFSEL4_5_Pos             (20)                                              /*!< PWM_T::IFA: IFSEL4_5 Position          */
#define PWM_IFA_IFSEL4_5_Msk             (0x7ul << PWM_IFA_IFSEL4_5_Pos)                   /*!< PWM_T::IFA: IFSEL4_5 Mask              */

#define PWM_IFA_IFAEN4_5_Pos             (23)                                              /*!< PWM_T::IFA: IFAEN4_5 Position          */
#define PWM_IFA_IFAEN4_5_Msk             (0x1ul << PWM_IFA_IFAEN4_5_Pos)                   /*!< PWM_T::IFA: IFAEN4_5 Mask              */

#define PWM_EADCTS0_TRGSEL0_Pos          (0)                                               /*!< PWM_T::EADCTS0: TRGSEL0 Position       */
#define PWM_EADCTS0_TRGSEL0_Msk          (0xful << PWM_EADCTS0_TRGSEL0_Pos)                /*!< PWM_T::EADCTS0: TRGSEL0 Mask           */

#define PWM_EADCTS0_TRGEN0_Pos           (7)                                               /*!< PWM_T::EADCTS0: TRGEN0 Position        */
#define PWM_EADCTS0_TRGEN0_Msk           (0x1ul << PWM_EADCTS0_TRGEN0_Pos)                 /*!< PWM_T::EADCTS0: TRGEN0 Mask            */

#define PWM_EADCTS0_TRGSEL1_Pos          (8)                                               /*!< PWM_T::EADCTS0: TRGSEL1 Position       */
#define PWM_EADCTS0_TRGSEL1_Msk          (0xful << PWM_EADCTS0_TRGSEL1_Pos)                /*!< PWM_T::EADCTS0: TRGSEL1 Mask           */

#define PWM_EADCTS0_TRGEN1_Pos           (15)                                              /*!< PWM_T::EADCTS0: TRGEN1 Position        */
#define PWM_EADCTS0_TRGEN1_Msk           (0x1ul << PWM_EADCTS0_TRGEN1_Pos)                 /*!< PWM_T::EADCTS0: TRGEN1 Mask            */

#define PWM_EADCTS0_TRGSEL2_Pos          (16)                                              /*!< PWM_T::EADCTS0: TRGSEL2 Position       */
#define PWM_EADCTS0_TRGSEL2_Msk          (0xful << PWM_EADCTS0_TRGSEL2_Pos)                /*!< PWM_T::EADCTS0: TRGSEL2 Mask           */

#define PWM_EADCTS0_TRGEN2_Pos           (23)                                              /*!< PWM_T::EADCTS0: TRGEN2 Position        */
#define PWM_EADCTS0_TRGEN2_Msk           (0x1ul << PWM_EADCTS0_TRGEN2_Pos)                 /*!< PWM_T::EADCTS0: TRGEN2 Mask            */

#define PWM_EADCTS0_TRGSEL3_Pos          (24)                                              /*!< PWM_T::EADCTS0: TRGSEL3 Position       */
#define PWM_EADCTS0_TRGSEL3_Msk          (0xful << PWM_EADCTS0_TRGSEL3_Pos)                /*!< PWM_T::EADCTS0: TRGSEL3 Mask           */

#define PWM_EADCTS0_TRGEN3_Pos           (31)                                              /*!< PWM_T::EADCTS0: TRGEN3 Position        */
#define PWM_EADCTS0_TRGEN3_Msk           (0x1ul << PWM_EADCTS0_TRGEN3_Pos)                 /*!< PWM_T::EADCTS0: TRGEN3 Mask            */

#define PWM_EADCTS1_TRGSEL4_Pos          (0)                                               /*!< PWM_T::EADCTS1: TRGSEL4 Position       */
#define PWM_EADCTS1_TRGSEL4_Msk          (0xful << PWM_EADCTS1_TRGSEL4_Pos)                /*!< PWM_T::EADCTS1: TRGSEL4 Mask           */

#define PWM_EADCTS1_TRGEN4_Pos           (7)                                               /*!< PWM_T::EADCTS1: TRGEN4 Position        */
#define PWM_EADCTS1_TRGEN4_Msk           (0x1ul << PWM_EADCTS1_TRGEN4_Pos)                 /*!< PWM_T::EADCTS1: TRGEN4 Mask            */

#define PWM_EADCTS1_TRGSEL5_Pos          (8)                                               /*!< PWM_T::EADCTS1: TRGSEL5 Position       */
#define PWM_EADCTS1_TRGSEL5_Msk          (0xful << PWM_EADCTS1_TRGSEL5_Pos)                /*!< PWM_T::EADCTS1: TRGSEL5 Mask           */

#define PWM_EADCTS1_TRGEN5_Pos           (15)                                              /*!< PWM_T::EADCTS1: TRGEN5 Position        */
#define PWM_EADCTS1_TRGEN5_Msk           (0x1ul << PWM_EADCTS1_TRGEN5_Pos)                 /*!< PWM_T::EADCTS1: TRGEN5 Mask            */

#define PWM_FTCMPDAT0_1_FTCMP_Pos        (0)                                               /*!< PWM_T::FTCMPDAT0_1: FTCMP Position     */
#define PWM_FTCMPDAT0_1_FTCMP_Msk        (0xfffful << PWM_FTCMPDAT0_1_FTCMP_Pos)           /*!< PWM_T::FTCMPDAT0_1: FTCMP Mask         */

#define PWM_FTCMPDAT2_3_FTCMP_Pos        (0)                                               /*!< PWM_T::FTCMPDAT2_3: FTCMP Position     */
#define PWM_FTCMPDAT2_3_FTCMP_Msk        (0xfffful << PWM_FTCMPDAT2_3_FTCMP_Pos)           /*!< PWM_T::FTCMPDAT2_3: FTCMP Mask         */

#define PWM_FTCMPDAT4_5_FTCMP_Pos        (0)                                               /*!< PWM_T::FTCMPDAT4_5: FTCMP Position     */
#define PWM_FTCMPDAT4_5_FTCMP_Msk        (0xfffful << PWM_FTCMPDAT4_5_FTCMP_Pos)           /*!< PWM_T::FTCMPDAT4_5: FTCMP Mask         */

#define PWM_SSCTL_SSEN0_Pos              (0)                                               /*!< PWM_T::SSCTL: SSEN0 Position           */
#define PWM_SSCTL_SSEN0_Msk              (0x1ul << PWM_SSCTL_SSEN0_Pos)                    /*!< PWM_T::SSCTL: SSEN0 Mask               */

#define PWM_SSCTL_SSEN1_Pos              (1)                                               /*!< PWM_T::SSCTL: SSEN1 Position           */
#define PWM_SSCTL_SSEN1_Msk              (0x1ul << PWM_SSCTL_SSEN1_Pos)                    /*!< PWM_T::SSCTL: SSEN1 Mask               */

#define PWM_SSCTL_SSEN2_Pos              (2)                                               /*!< PWM_T::SSCTL: SSEN2 Position           */
#define PWM_SSCTL_SSEN2_Msk              (0x1ul << PWM_SSCTL_SSEN2_Pos)                    /*!< PWM_T::SSCTL: SSEN2 Mask               */

#define PWM_SSCTL_SSEN3_Pos              (3)                                               /*!< PWM_T::SSCTL: SSEN3 Position           */
#define PWM_SSCTL_SSEN3_Msk              (0x1ul << PWM_SSCTL_SSEN3_Pos)                    /*!< PWM_T::SSCTL: SSEN3 Mask               */

#define PWM_SSCTL_SSEN4_Pos              (4)                                               /*!< PWM_T::SSCTL: SSEN4 Position           */
#define PWM_SSCTL_SSEN4_Msk              (0x1ul << PWM_SSCTL_SSEN4_Pos)                    /*!< PWM_T::SSCTL: SSEN4 Mask               */

#define PWM_SSCTL_SSEN5_Pos              (5)                                               /*!< PWM_T::SSCTL: SSEN5 Position           */
#define PWM_SSCTL_SSEN5_Msk              (0x1ul << PWM_SSCTL_SSEN5_Pos)                    /*!< PWM_T::SSCTL: SSEN5 Mask               */

#define PWM_SSCTL_SSRC_Pos               (8)                                               /*!< PWM_T::SSCTL: SSRC Position            */
#define PWM_SSCTL_SSRC_Msk               (0x3ul << PWM_SSCTL_SSRC_Pos)                     /*!< PWM_T::SSCTL: SSRC Mask                */

#define PWM_SSTRG_CNTSEN_Pos             (0)                                               /*!< PWM_T::SSTRG: CNTSEN Position          */
#define PWM_SSTRG_CNTSEN_Msk             (0x1ul << PWM_SSTRG_CNTSEN_Pos)                   /*!< PWM_T::SSTRG: CNTSEN Mask              */

#define PWM_STATUS_CNTMAXF0_Pos          (0)                                               /*!< PWM_T::STATUS: CNTMAXF0 Position       */
#define PWM_STATUS_CNTMAXF0_Msk          (0x1ul << PWM_STATUS_CNTMAXF0_Pos)                /*!< PWM_T::STATUS: CNTMAXF0 Mask           */

#define PWM_STATUS_CNTMAXF1_Pos          (1)                                               /*!< PWM_T::STATUS: CNTMAXF1 Position       */
#define PWM_STATUS_CNTMAXF1_Msk          (0x1ul << PWM_STATUS_CNTMAXF1_Pos)                /*!< PWM_T::STATUS: CNTMAXF1 Mask           */

#define PWM_STATUS_CNTMAXF2_Pos          (2)                                               /*!< PWM_T::STATUS: CNTMAXF2 Position       */
#define PWM_STATUS_CNTMAXF2_Msk          (0x1ul << PWM_STATUS_CNTMAXF2_Pos)                /*!< PWM_T::STATUS: CNTMAXF2 Mask           */

#define PWM_STATUS_CNTMAXF3_Pos          (3)                                               /*!< PWM_T::STATUS: CNTMAXF3 Position       */
#define PWM_STATUS_CNTMAXF3_Msk          (0x1ul << PWM_STATUS_CNTMAXF3_Pos)                /*!< PWM_T::STATUS: CNTMAXF3 Mask           */

#define PWM_STATUS_CNTMAXF4_Pos          (4)                                               /*!< PWM_T::STATUS: CNTMAXF4 Position       */
#define PWM_STATUS_CNTMAXF4_Msk          (0x1ul << PWM_STATUS_CNTMAXF4_Pos)                /*!< PWM_T::STATUS: CNTMAXF4 Mask           */

#define PWM_STATUS_CNTMAXF5_Pos          (5)                                               /*!< PWM_T::STATUS: CNTMAXF5 Position       */
#define PWM_STATUS_CNTMAXF5_Msk          (0x1ul << PWM_STATUS_CNTMAXF5_Pos)                /*!< PWM_T::STATUS: CNTMAXF5 Mask           */

#define PWM_STATUS_SYNCINF0_Pos          (8)                                               /*!< PWM_T::STATUS: SYNCINF0 Position       */
#define PWM_STATUS_SYNCINF0_Msk          (0x1ul << PWM_STATUS_SYNCINF0_Pos)                /*!< PWM_T::STATUS: SYNCINF0 Mask           */

#define PWM_STATUS_SYNCINF2_Pos          (9)                                               /*!< PWM_T::STATUS: SYNCINF2 Position       */
#define PWM_STATUS_SYNCINF2_Msk          (0x1ul << PWM_STATUS_SYNCINF2_Pos)                /*!< PWM_T::STATUS: SYNCINF2 Mask           */

#define PWM_STATUS_SYNCINF4_Pos          (10)                                              /*!< PWM_T::STATUS: SYNCINF4 Position       */
#define PWM_STATUS_SYNCINF4_Msk          (0x1ul << PWM_STATUS_SYNCINF4_Pos)                /*!< PWM_T::STATUS: SYNCINF4 Mask           */



#define PWM_STATUS_ADCTRGF0_Pos          (16)                                              /*!< PWM_T::STATUS: ADCTRGF0 Position       */
#define PWM_STATUS_ADCTRGF0_Msk          (0x1ul << PWM_STATUS_ADCTRGF0_Pos)                /*!< PWM_T::STATUS: ADCTRGF0 Mask           */

#define PWM_STATUS_ADCTRGF1_Pos          (17)                                              /*!< PWM_T::STATUS: ADCTRGF1 Position       */
#define PWM_STATUS_ADCTRGF1_Msk          (0x1ul << PWM_STATUS_ADCTRGF1_Pos)                /*!< PWM_T::STATUS: ADCTRGF1 Mask           */

#define PWM_STATUS_ADCTRGF2_Pos          (18)                                              /*!< PWM_T::STATUS: ADCTRGF2 Position       */
#define PWM_STATUS_ADCTRGF2_Msk          (0x1ul << PWM_STATUS_ADCTRGF2_Pos)                /*!< PWM_T::STATUS: ADCTRGF2 Mask           */

#define PWM_STATUS_ADCTRGF3_Pos          (19)                                              /*!< PWM_T::STATUS: ADCTRGF3 Position       */
#define PWM_STATUS_ADCTRGF3_Msk          (0x1ul << PWM_STATUS_ADCTRGF3_Pos)                /*!< PWM_T::STATUS: ADCTRGF3 Mask           */

#define PWM_STATUS_ADCTRGF4_Pos          (20)                                              /*!< PWM_T::STATUS: ADCTRGF4 Position       */
#define PWM_STATUS_ADCTRGF4_Msk          (0x1ul << PWM_STATUS_ADCTRGF4_Pos)                /*!< PWM_T::STATUS: ADCTRGF4 Mask           */

#define PWM_STATUS_ADCTRGF5_Pos          (21)                                              /*!< PWM_T::STATUS: ADCTRGF5 Position       */
#define PWM_STATUS_ADCTRGF5_Msk          (0x1ul << PWM_STATUS_ADCTRGF5_Pos)                /*!< PWM_T::STATUS: ADCTRGF5 Mask           */

#define PWM_CAPINEN_CAPINEN0_Pos         (0)                                               /*!< PWM_T::CAPINEN: CAPINEN0 Position      */
#define PWM_CAPINEN_CAPINEN0_Msk         (0x1ul << PWM_CAPINEN_CAPINEN0_Pos)               /*!< PWM_T::CAPINEN: CAPINEN0 Mask          */

#define PWM_CAPINEN_CAPINEN1_Pos         (1)                                               /*!< PWM_T::CAPINEN: CAPINEN1 Position      */
#define PWM_CAPINEN_CAPINEN1_Msk         (0x1ul << PWM_CAPINEN_CAPINEN1_Pos)               /*!< PWM_T::CAPINEN: CAPINEN1 Mask          */

#define PWM_CAPINEN_CAPINEN2_Pos         (2)                                               /*!< PWM_T::CAPINEN: CAPINEN2 Position      */
#define PWM_CAPINEN_CAPINEN2_Msk         (0x1ul << PWM_CAPINEN_CAPINEN2_Pos)               /*!< PWM_T::CAPINEN: CAPINEN2 Mask          */

#define PWM_CAPINEN_CAPINEN3_Pos         (3)                                               /*!< PWM_T::CAPINEN: CAPINEN3 Position      */
#define PWM_CAPINEN_CAPINEN3_Msk         (0x1ul << PWM_CAPINEN_CAPINEN3_Pos)               /*!< PWM_T::CAPINEN: CAPINEN3 Mask          */

#define PWM_CAPINEN_CAPINEN4_Pos         (4)                                               /*!< PWM_T::CAPINEN: CAPINEN4 Position      */
#define PWM_CAPINEN_CAPINEN4_Msk         (0x1ul << PWM_CAPINEN_CAPINEN4_Pos)               /*!< PWM_T::CAPINEN: CAPINEN4 Mask          */

#define PWM_CAPINEN_CAPINEN5_Pos         (5)                                               /*!< PWM_T::CAPINEN: CAPINEN5 Position      */
#define PWM_CAPINEN_CAPINEN5_Msk         (0x1ul << PWM_CAPINEN_CAPINEN5_Pos)               /*!< PWM_T::CAPINEN: CAPINEN5 Mask          */

#define PWM_CAPCTL_CAPEN0_Pos            (0)                                               /*!< PWM_T::CAPCTL: CAPEN0 Position         */
#define PWM_CAPCTL_CAPEN0_Msk            (0x1ul << PWM_CAPCTL_CAPEN0_Pos)                  /*!< PWM_T::CAPCTL: CAPEN0 Mask             */

#define PWM_CAPCTL_CAPEN1_Pos            (1)                                               /*!< PWM_T::CAPCTL: CAPEN1 Position         */
#define PWM_CAPCTL_CAPEN1_Msk            (0x1ul << PWM_CAPCTL_CAPEN1_Pos)                  /*!< PWM_T::CAPCTL: CAPEN1 Mask             */

#define PWM_CAPCTL_CAPEN2_Pos            (2)                                               /*!< PWM_T::CAPCTL: CAPEN2 Position         */
#define PWM_CAPCTL_CAPEN2_Msk            (0x1ul << PWM_CAPCTL_CAPEN2_Pos)                  /*!< PWM_T::CAPCTL: CAPEN2 Mask             */

#define PWM_CAPCTL_CAPEN3_Pos            (3)                                               /*!< PWM_T::CAPCTL: CAPEN3 Position         */
#define PWM_CAPCTL_CAPEN3_Msk            (0x1ul << PWM_CAPCTL_CAPEN3_Pos)                  /*!< PWM_T::CAPCTL: CAPEN3 Mask             */

#define PWM_CAPCTL_CAPEN4_Pos            (4)                                               /*!< PWM_T::CAPCTL: CAPEN4 Position         */
#define PWM_CAPCTL_CAPEN4_Msk            (0x1ul << PWM_CAPCTL_CAPEN4_Pos)                  /*!< PWM_T::CAPCTL: CAPEN4 Mask             */

#define PWM_CAPCTL_CAPEN5_Pos            (5)                                               /*!< PWM_T::CAPCTL: CAPEN5 Position         */
#define PWM_CAPCTL_CAPEN5_Msk            (0x1ul << PWM_CAPCTL_CAPEN5_Pos)                  /*!< PWM_T::CAPCTL: CAPEN5 Mask             */

#define PWM_CAPCTL_CAPINV0_Pos           (8)                                               /*!< PWM_T::CAPCTL: CAPINV0 Position        */
#define PWM_CAPCTL_CAPINV0_Msk           (0x1ul << PWM_CAPCTL_CAPINV0_Pos)                 /*!< PWM_T::CAPCTL: CAPINV0 Mask            */

#define PWM_CAPCTL_CAPINV1_Pos           (9)                                               /*!< PWM_T::CAPCTL: CAPINV1 Position        */
#define PWM_CAPCTL_CAPINV1_Msk           (0x1ul << PWM_CAPCTL_CAPINV1_Pos)                 /*!< PWM_T::CAPCTL: CAPINV1 Mask            */

#define PWM_CAPCTL_CAPINV2_Pos           (10)                                              /*!< PWM_T::CAPCTL: CAPINV2 Position        */
#define PWM_CAPCTL_CAPINV2_Msk           (0x1ul << PWM_CAPCTL_CAPINV2_Pos)                 /*!< PWM_T::CAPCTL: CAPINV2 Mask            */

#define PWM_CAPCTL_CAPINV3_Pos           (11)                                              /*!< PWM_T::CAPCTL: CAPINV3 Position        */
#define PWM_CAPCTL_CAPINV3_Msk           (0x1ul << PWM_CAPCTL_CAPINV3_Pos)                 /*!< PWM_T::CAPCTL: CAPINV3 Mask            */

#define PWM_CAPCTL_CAPINV4_Pos           (12)                                              /*!< PWM_T::CAPCTL: CAPINV4 Position        */
#define PWM_CAPCTL_CAPINV4_Msk           (0x1ul << PWM_CAPCTL_CAPINV4_Pos)                 /*!< PWM_T::CAPCTL: CAPINV4 Mask            */

#define PWM_CAPCTL_CAPINV5_Pos           (13)                                              /*!< PWM_T::CAPCTL: CAPINV5 Position        */
#define PWM_CAPCTL_CAPINV5_Msk           (0x1ul << PWM_CAPCTL_CAPINV5_Pos)                 /*!< PWM_T::CAPCTL: CAPINV5 Mask            */

#define PWM_CAPCTL_RCRLDEN0_Pos          (16)                                              /*!< PWM_T::CAPCTL: RCRLDEN0 Position       */
#define PWM_CAPCTL_RCRLDEN0_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN0_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN0 Mask           */

#define PWM_CAPCTL_RCRLDEN1_Pos          (17)                                              /*!< PWM_T::CAPCTL: RCRLDEN1 Position       */
#define PWM_CAPCTL_RCRLDEN1_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN1_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN1 Mask           */

#define PWM_CAPCTL_RCRLDEN2_Pos          (18)                                              /*!< PWM_T::CAPCTL: RCRLDEN2 Position       */
#define PWM_CAPCTL_RCRLDEN2_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN2_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN2 Mask           */

#define PWM_CAPCTL_RCRLDEN3_Pos          (19)                                              /*!< PWM_T::CAPCTL: RCRLDEN3 Position       */
#define PWM_CAPCTL_RCRLDEN3_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN3_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN3 Mask           */

#define PWM_CAPCTL_RCRLDEN4_Pos          (20)                                              /*!< PWM_T::CAPCTL: RCRLDEN4 Position       */
#define PWM_CAPCTL_RCRLDEN4_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN4_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN4 Mask           */

#define PWM_CAPCTL_RCRLDEN5_Pos          (21)                                              /*!< PWM_T::CAPCTL: RCRLDEN5 Position       */
#define PWM_CAPCTL_RCRLDEN5_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN5_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN5 Mask           */

#define PWM_CAPCTL_FCRLDEN0_Pos          (24)                                              /*!< PWM_T::CAPCTL: FCRLDEN0 Position       */
#define PWM_CAPCTL_FCRLDEN0_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN0_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN0 Mask           */

#define PWM_CAPCTL_FCRLDEN1_Pos          (25)                                              /*!< PWM_T::CAPCTL: FCRLDEN1 Position       */
#define PWM_CAPCTL_FCRLDEN1_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN1_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN1 Mask           */

#define PWM_CAPCTL_FCRLDEN2_Pos          (26)                                              /*!< PWM_T::CAPCTL: FCRLDEN2 Position       */
#define PWM_CAPCTL_FCRLDEN2_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN2_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN2 Mask           */

#define PWM_CAPCTL_FCRLDEN3_Pos          (27)                                              /*!< PWM_T::CAPCTL: FCRLDEN3 Position       */
#define PWM_CAPCTL_FCRLDEN3_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN3_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN3 Mask           */

#define PWM_CAPCTL_FCRLDEN4_Pos          (28)                                              /*!< PWM_T::CAPCTL: FCRLDEN4 Position       */
#define PWM_CAPCTL_FCRLDEN4_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN4_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN4 Mask           */

#define PWM_CAPCTL_FCRLDEN5_Pos          (29)                                              /*!< PWM_T::CAPCTL: FCRLDEN5 Position       */
#define PWM_CAPCTL_FCRLDEN5_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN5_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN5 Mask           */

#define PWM_CAPSTS_CRLIFOV0_Pos          (0)                                               /*!< PWM_T::CAPSTS: CRLIFOV0 Position       */
#define PWM_CAPSTS_CRLIFOV0_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV0_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV0 Mask           */

#define PWM_CAPSTS_CRLIFOV1_Pos          (1)                                               /*!< PWM_T::CAPSTS: CRLIFOV1 Position       */
#define PWM_CAPSTS_CRLIFOV1_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV1_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV1 Mask           */

#define PWM_CAPSTS_CRLIFOV2_Pos          (2)                                               /*!< PWM_T::CAPSTS: CRLIFOV2 Position       */
#define PWM_CAPSTS_CRLIFOV2_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV2_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV2 Mask           */

#define PWM_CAPSTS_CRLIFOV3_Pos          (3)                                               /*!< PWM_T::CAPSTS: CRLIFOV3 Position       */
#define PWM_CAPSTS_CRLIFOV3_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV3_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV3 Mask           */

#define PWM_CAPSTS_CRLIFOV4_Pos          (4)                                               /*!< PWM_T::CAPSTS: CRLIFOV4 Position       */
#define PWM_CAPSTS_CRLIFOV4_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV4_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV4 Mask           */

#define PWM_CAPSTS_CRLIFOV5_Pos          (5)                                               /*!< PWM_T::CAPSTS: CRLIFOV5 Position       */
#define PWM_CAPSTS_CRLIFOV5_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV5_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV5 Mask           */

#define PWM_CAPSTS_CFLIFOV0_Pos          (8)                                               /*!< PWM_T::CAPSTS: CFLIFOV0 Position       */
#define PWM_CAPSTS_CFLIFOV0_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV0_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV0 Mask           */

#define PWM_CAPSTS_CFLIFOV1_Pos          (9)                                               /*!< PWM_T::CAPSTS: CFLIFOV1 Position       */
#define PWM_CAPSTS_CFLIFOV1_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV1_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV1 Mask           */

#define PWM_CAPSTS_CFLIFOV2_Pos          (10)                                              /*!< PWM_T::CAPSTS: CFLIFOV2 Position       */
#define PWM_CAPSTS_CFLIFOV2_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV2_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV2 Mask           */

#define PWM_CAPSTS_CFLIFOV3_Pos          (11)                                              /*!< PWM_T::CAPSTS: CFLIFOV3 Position       */
#define PWM_CAPSTS_CFLIFOV3_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV3_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV3 Mask           */

#define PWM_CAPSTS_CFLIFOV4_Pos          (12)                                              /*!< PWM_T::CAPSTS: CFLIFOV4 Position       */
#define PWM_CAPSTS_CFLIFOV4_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV4_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV4 Mask           */

#define PWM_CAPSTS_CFLIFOV5_Pos          (13)                                              /*!< PWM_T::CAPSTS: CFLIFOV5 Position       */
#define PWM_CAPSTS_CFLIFOV5_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV5_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV5 Mask           */

#define PWM_RCAPDAT0_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT0: RCAPDAT Position      */
#define PWM_RCAPDAT0_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT0_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT0: RCAPDAT Mask          */

#define PWM_FCAPDAT0_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT0: FCAPDAT Position      */
#define PWM_FCAPDAT0_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT0_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT0: FCAPDAT Mask          */

#define PWM_RCAPDAT1_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT1: RCAPDAT Position      */
#define PWM_RCAPDAT1_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT1_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT1: RCAPDAT Mask          */

#define PWM_FCAPDAT1_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT1: FCAPDAT Position      */
#define PWM_FCAPDAT1_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT1_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT1: FCAPDAT Mask          */

#define PWM_RCAPDAT2_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT2: RCAPDAT Position      */
#define PWM_RCAPDAT2_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT2_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT2: RCAPDAT Mask          */

#define PWM_FCAPDAT2_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT2: FCAPDAT Position      */
#define PWM_FCAPDAT2_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT2_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT2: FCAPDAT Mask          */

#define PWM_RCAPDAT3_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT3: RCAPDAT Position      */
#define PWM_RCAPDAT3_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT3_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT3: RCAPDAT Mask          */

#define PWM_FCAPDAT3_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT3: FCAPDAT Position      */
#define PWM_FCAPDAT3_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT3_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT3: FCAPDAT Mask          */

#define PWM_RCAPDAT4_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT4: RCAPDAT Position      */
#define PWM_RCAPDAT4_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT4_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT4: RCAPDAT Mask          */

#define PWM_FCAPDAT4_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT4: FCAPDAT Position      */
#define PWM_FCAPDAT4_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT4_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT4: FCAPDAT Mask          */

#define PWM_RCAPDAT5_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT5: RCAPDAT Position      */
#define PWM_RCAPDAT5_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT5_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT5: RCAPDAT Mask          */

#define PWM_FCAPDAT5_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT5: FCAPDAT Position      */
#define PWM_FCAPDAT5_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT5_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT5: FCAPDAT Mask          */

#define PWM_PDMACTL_CHEN0_1_Pos          (0)                                               /*!< PWM_T::PDMACTL: CHEN0_1 Position       */
#define PWM_PDMACTL_CHEN0_1_Msk          (0x1ul << PWM_PDMACTL_CHEN0_1_Pos)                /*!< PWM_T::PDMACTL: CHEN0_1 Mask           */

#define PWM_PDMACTL_CAPMOD0_1_Pos        (1)                                               /*!< PWM_T::PDMACTL: CAPMOD0_1 Position     */
#define PWM_PDMACTL_CAPMOD0_1_Msk        (0x3ul << PWM_PDMACTL_CAPMOD0_1_Pos)              /*!< PWM_T::PDMACTL: CAPMOD0_1 Mask         */

#define PWM_PDMACTL_CAPORD0_1_Pos        (3)                                               /*!< PWM_T::PDMACTL: CAPORD0_1 Position     */
#define PWM_PDMACTL_CAPORD0_1_Msk        (0x1ul << PWM_PDMACTL_CAPORD0_1_Pos)              /*!< PWM_T::PDMACTL: CAPORD0_1 Mask         */

#define PWM_PDMACTL_CHSEL0_1_Pos         (4)                                               /*!< PWM_T::PDMACTL: CHSEL0_1 Position      */
#define PWM_PDMACTL_CHSEL0_1_Msk         (0x1ul << PWM_PDMACTL_CHSEL0_1_Pos)               /*!< PWM_T::PDMACTL: CHSEL0_1 Mask          */

#define PWM_PDMACTL_CHEN2_3_Pos          (8)                                               /*!< PWM_T::PDMACTL: CHEN2_3 Position       */
#define PWM_PDMACTL_CHEN2_3_Msk          (0x1ul << PWM_PDMACTL_CHEN2_3_Pos)                /*!< PWM_T::PDMACTL: CHEN2_3 Mask           */

#define PWM_PDMACTL_CAPMOD2_3_Pos        (9)                                               /*!< PWM_T::PDMACTL: CAPMOD2_3 Position     */
#define PWM_PDMACTL_CAPMOD2_3_Msk        (0x3ul << PWM_PDMACTL_CAPMOD2_3_Pos)              /*!< PWM_T::PDMACTL: CAPMOD2_3 Mask         */

#define PWM_PDMACTL_CAPORD2_3_Pos        (11)                                              /*!< PWM_T::PDMACTL: CAPORD2_3 Position     */
#define PWM_PDMACTL_CAPORD2_3_Msk        (0x1ul << PWM_PDMACTL_CAPORD2_3_Pos)              /*!< PWM_T::PDMACTL: CAPORD2_3 Mask         */

#define PWM_PDMACTL_CHSEL2_3_Pos         (12)                                              /*!< PWM_T::PDMACTL: CHSEL2_3 Position      */
#define PWM_PDMACTL_CHSEL2_3_Msk         (0x1ul << PWM_PDMACTL_CHSEL2_3_Pos)               /*!< PWM_T::PDMACTL: CHSEL2_3 Mask          */

#define PWM_PDMACTL_CHEN4_5_Pos          (16)                                              /*!< PWM_T::PDMACTL: CHEN4_5 Position       */
#define PWM_PDMACTL_CHEN4_5_Msk          (0x1ul << PWM_PDMACTL_CHEN4_5_Pos)                /*!< PWM_T::PDMACTL: CHEN4_5 Mask           */

#define PWM_PDMACTL_CAPMOD4_5_Pos        (17)                                              /*!< PWM_T::PDMACTL: CAPMOD4_5 Position     */
#define PWM_PDMACTL_CAPMOD4_5_Msk        (0x3ul << PWM_PDMACTL_CAPMOD4_5_Pos)              /*!< PWM_T::PDMACTL: CAPMOD4_5 Mask         */

#define PWM_PDMACTL_CAPORD4_5_Pos        (19)                                              /*!< PWM_T::PDMACTL: CAPORD4_5 Position     */
#define PWM_PDMACTL_CAPORD4_5_Msk        (0x1ul << PWM_PDMACTL_CAPORD4_5_Pos)              /*!< PWM_T::PDMACTL: CAPORD4_5 Mask         */

#define PWM_PDMACTL_CHSEL4_5_Pos         (20)                                              /*!< PWM_T::PDMACTL: CHSEL4_5 Position      */
#define PWM_PDMACTL_CHSEL4_5_Msk         (0x1ul << PWM_PDMACTL_CHSEL4_5_Pos)               /*!< PWM_T::PDMACTL: CHSEL4_5 Mask          */

#define PWM_PDMACAP0_1_CAPBUF_Pos        (0)                                               /*!< PWM_T::PDMACAP0_1: CAPBUF Position     */
#define PWM_PDMACAP0_1_CAPBUF_Msk        (0xfffful << PWM_PDMACAP0_1_CAPBUF_Pos)           /*!< PWM_T::PDMACAP0_1: CAPBUF Mask         */

#define PWM_PDMACAP2_3_CAPBUF_Pos        (0)                                               /*!< PWM_T::PDMACAP2_3: CAPBUF Position     */
#define PWM_PDMACAP2_3_CAPBUF_Msk        (0xfffful << PWM_PDMACAP2_3_CAPBUF_Pos)           /*!< PWM_T::PDMACAP2_3: CAPBUF Mask         */

#define PWM_PDMACAP4_5_CAPBUF_Pos        (0)                                               /*!< PWM_T::PDMACAP4_5: CAPBUF Position     */
#define PWM_PDMACAP4_5_CAPBUF_Msk        (0xfffful << PWM_PDMACAP4_5_CAPBUF_Pos)           /*!< PWM_T::PDMACAP4_5: CAPBUF Mask         */

#define PWM_CAPIEN_CAPRIEN0_Pos          (0)                                               /*!< PWM_T::CAPIEN: CAPRIEN0 Position       */
#define PWM_CAPIEN_CAPRIEN0_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN0_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN0 Mask           */

#define PWM_CAPIEN_CAPRIEN1_Pos          (1)                                               /*!< PWM_T::CAPIEN: CAPRIEN1 Position       */
#define PWM_CAPIEN_CAPRIEN1_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN1_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN1 Mask           */

#define PWM_CAPIEN_CAPRIEN2_Pos          (2)                                               /*!< PWM_T::CAPIEN: CAPRIEN2 Position       */
#define PWM_CAPIEN_CAPRIEN2_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN2_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN2 Mask           */

#define PWM_CAPIEN_CAPRIEN3_Pos          (3)                                               /*!< PWM_T::CAPIEN: CAPRIEN3 Position       */
#define PWM_CAPIEN_CAPRIEN3_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN3_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN3 Mask           */

#define PWM_CAPIEN_CAPRIEN4_Pos          (4)                                               /*!< PWM_T::CAPIEN: CAPRIEN4 Position       */
#define PWM_CAPIEN_CAPRIEN4_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN4_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN4 Mask           */

#define PWM_CAPIEN_CAPRIEN5_Pos          (5)                                               /*!< PWM_T::CAPIEN: CAPRIEN5 Position       */
#define PWM_CAPIEN_CAPRIEN5_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN5_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN5 Mask           */

#define PWM_CAPIEN_CAPFIEN0_Pos          (8)                                               /*!< PWM_T::CAPIEN: CAPFIEN0 Position       */
#define PWM_CAPIEN_CAPFIEN0_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN0_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN0 Mask           */

#define PWM_CAPIEN_CAPFIEN1_Pos          (9)                                               /*!< PWM_T::CAPIEN: CAPFIEN1 Position       */
#define PWM_CAPIEN_CAPFIEN1_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN1_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN1 Mask           */

#define PWM_CAPIEN_CAPFIEN2_Pos          (10)                                              /*!< PWM_T::CAPIEN: CAPFIEN2 Position       */
#define PWM_CAPIEN_CAPFIEN2_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN2_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN2 Mask           */

#define PWM_CAPIEN_CAPFIEN3_Pos          (11)                                              /*!< PWM_T::CAPIEN: CAPFIEN3 Position       */
#define PWM_CAPIEN_CAPFIEN3_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN3_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN3 Mask           */

#define PWM_CAPIEN_CAPFIEN4_Pos          (12)                                              /*!< PWM_T::CAPIEN: CAPFIEN4 Position       */
#define PWM_CAPIEN_CAPFIEN4_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN4_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN4 Mask           */

#define PWM_CAPIEN_CAPFIEN5_Pos          (13)                                              /*!< PWM_T::CAPIEN: CAPFIEN5 Position       */
#define PWM_CAPIEN_CAPFIEN5_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN5_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN5 Mask           */

#define PWM_CAPIF_CRLIF0_Pos             (0)                                               /*!< PWM_T::CAPIF: CRLIF0 Position          */
#define PWM_CAPIF_CRLIF0_Msk             (0x1ul << PWM_CAPIF_CRLIF0_Pos)                   /*!< PWM_T::CAPIF: CRLIF0 Mask              */

#define PWM_CAPIF_CRLIF1_Pos             (1)                                               /*!< PWM_T::CAPIF: CRLIF1 Position          */
#define PWM_CAPIF_CRLIF1_Msk             (0x1ul << PWM_CAPIF_CRLIF1_Pos)                   /*!< PWM_T::CAPIF: CRLIF1 Mask              */

#define PWM_CAPIF_CRLIF2_Pos             (2)                                               /*!< PWM_T::CAPIF: CRLIF2 Position          */
#define PWM_CAPIF_CRLIF2_Msk             (0x1ul << PWM_CAPIF_CRLIF2_Pos)                   /*!< PWM_T::CAPIF: CRLIF2 Mask              */

#define PWM_CAPIF_CRLIF3_Pos             (3)                                               /*!< PWM_T::CAPIF: CRLIF3 Position          */
#define PWM_CAPIF_CRLIF3_Msk             (0x1ul << PWM_CAPIF_CRLIF3_Pos)                   /*!< PWM_T::CAPIF: CRLIF3 Mask              */

#define PWM_CAPIF_CRLIF4_Pos             (4)                                               /*!< PWM_T::CAPIF: CRLIF4 Position          */
#define PWM_CAPIF_CRLIF4_Msk             (0x1ul << PWM_CAPIF_CRLIF4_Pos)                   /*!< PWM_T::CAPIF: CRLIF4 Mask              */

#define PWM_CAPIF_CRLIF5_Pos             (5)                                               /*!< PWM_T::CAPIF: CRLIF5 Position          */
#define PWM_CAPIF_CRLIF5_Msk             (0x1ul << PWM_CAPIF_CRLIF5_Pos)                   /*!< PWM_T::CAPIF: CRLIF5 Mask              */

#define PWM_CAPIF_CFLIF0_Pos             (8)                                               /*!< PWM_T::CAPIF: CFLIF0 Position          */
#define PWM_CAPIF_CFLIF0_Msk             (0x1ul << PWM_CAPIF_CFLIF0_Pos)                   /*!< PWM_T::CAPIF: CFLIF0 Mask              */

#define PWM_CAPIF_CFLIF1_Pos             (9)                                               /*!< PWM_T::CAPIF: CFLIF1 Position          */
#define PWM_CAPIF_CFLIF1_Msk             (0x1ul << PWM_CAPIF_CFLIF1_Pos)                   /*!< PWM_T::CAPIF: CFLIF1 Mask              */

#define PWM_CAPIF_CFLIF2_Pos             (10)                                              /*!< PWM_T::CAPIF: CFLIF2 Position          */
#define PWM_CAPIF_CFLIF2_Msk             (0x1ul << PWM_CAPIF_CFLIF2_Pos)                   /*!< PWM_T::CAPIF: CFLIF2 Mask              */

#define PWM_CAPIF_CFLIF3_Pos             (11)                                              /*!< PWM_T::CAPIF: CFLIF3 Position          */
#define PWM_CAPIF_CFLIF3_Msk             (0x1ul << PWM_CAPIF_CFLIF3_Pos)                   /*!< PWM_T::CAPIF: CFLIF3 Mask              */

#define PWM_CAPIF_CFLIF4_Pos             (12)                                              /*!< PWM_T::CAPIF: CFLIF4 Position          */
#define PWM_CAPIF_CFLIF4_Msk             (0x1ul << PWM_CAPIF_CFLIF4_Pos)                   /*!< PWM_T::CAPIF: CFLIF4 Mask              */

#define PWM_CAPIF_CFLIF5_Pos             (13)                                              /*!< PWM_T::CAPIF: CFLIF5 Position          */
#define PWM_CAPIF_CFLIF5_Msk             (0x1ul << PWM_CAPIF_CFLIF5_Pos)                   /*!< PWM_T::CAPIF: CFLIF5 Mask              */

#define PWM_SELFTEST_SELFTEST_Pos        (31)                                              /*!< PWM_T::SELFTEST: SELFTEST Position     */
#define PWM_SELFTEST_SELFTEST_Msk        (0x1ul << PWM_SELFTEST_SELFTEST_Pos)              /*!< PWM_T::SELFTEST: SELFTEST Mask         */

#define PWM_PBUF0_PBUF_Pos               (0)                                               /*!< PWM_T::PBUF0: PBUF Position            */
#define PWM_PBUF0_PBUF_Msk               (0xfffful << PWM_PBUF0_PBUF_Pos)                  /*!< PWM_T::PBUF0: PBUF Mask                */

#define PWM_PBUF1_PBUF_Pos               (0)                                               /*!< PWM_T::PBUF1: PBUF Position            */
#define PWM_PBUF1_PBUF_Msk               (0xfffful << PWM_PBUF1_PBUF_Pos)                  /*!< PWM_T::PBUF1: PBUF Mask                */

#define PWM_PBUF2_PBUF_Pos               (0)                                               /*!< PWM_T::PBUF2: PBUF Position            */
#define PWM_PBUF2_PBUF_Msk               (0xfffful << PWM_PBUF2_PBUF_Pos)                  /*!< PWM_T::PBUF2: PBUF Mask                */

#define PWM_PBUF3_PBUF_Pos               (0)                                               /*!< PWM_T::PBUF3: PBUF Position            */
#define PWM_PBUF3_PBUF_Msk               (0xfffful << PWM_PBUF3_PBUF_Pos)                  /*!< PWM_T::PBUF3: PBUF Mask                */

#define PWM_PBUF4_PBUF_Pos               (0)                                               /*!< PWM_T::PBUF4: PBUF Position            */
#define PWM_PBUF4_PBUF_Msk               (0xfffful << PWM_PBUF4_PBUF_Pos)                  /*!< PWM_T::PBUF4: PBUF Mask                */

#define PWM_PBUF5_PBUF_Pos               (0)                                               /*!< PWM_T::PBUF5: PBUF Position            */
#define PWM_PBUF5_PBUF_Msk               (0xfffful << PWM_PBUF5_PBUF_Pos)                  /*!< PWM_T::PBUF5: PBUF Mask                */

#define PWM_CMPBUF0_CMPBUF_Pos           (0)                                               /*!< PWM_T::CMPBUF0: CMPBUF Position        */
#define PWM_CMPBUF0_CMPBUF_Msk           (0xfffful << PWM_CMPBUF0_CMPBUF_Pos)              /*!< PWM_T::CMPBUF0: CMPBUF Mask            */

#define PWM_CMPBUF1_CMPBUF_Pos           (0)                                               /*!< PWM_T::CMPBUF1: CMPBUF Position        */
#define PWM_CMPBUF1_CMPBUF_Msk           (0xfffful << PWM_CMPBUF1_CMPBUF_Pos)              /*!< PWM_T::CMPBUF1: CMPBUF Mask            */

#define PWM_CMPBUF2_CMPBUF_Pos           (0)                                               /*!< PWM_T::CMPBUF2: CMPBUF Position        */
#define PWM_CMPBUF2_CMPBUF_Msk           (0xfffful << PWM_CMPBUF2_CMPBUF_Pos)              /*!< PWM_T::CMPBUF2: CMPBUF Mask            */

#define PWM_CMPBUF3_CMPBUF_Pos           (0)                                               /*!< PWM_T::CMPBUF3: CMPBUF Position        */
#define PWM_CMPBUF3_CMPBUF_Msk           (0xfffful << PWM_CMPBUF3_CMPBUF_Pos)              /*!< PWM_T::CMPBUF3: CMPBUF Mask            */

#define PWM_CMPBUF4_CMPBUF_Pos           (0)                                               /*!< PWM_T::CMPBUF4: CMPBUF Position        */
#define PWM_CMPBUF4_CMPBUF_Msk           (0xfffful << PWM_CMPBUF4_CMPBUF_Pos)              /*!< PWM_T::CMPBUF4: CMPBUF Mask            */

#define PWM_CMPBUF5_CMPBUF_Pos           (0)                                               /*!< PWM_T::CMPBUF5: CMPBUF Position        */
#define PWM_CMPBUF5_CMPBUF_Msk           (0xfffful << PWM_CMPBUF5_CMPBUF_Pos)              /*!< PWM_T::CMPBUF5: CMPBUF Mask            */

#define PWM_CPSCBUF0_1_CPSCBUF_Pos       (0)                                               /*!< PWM_T::CPSCBUF0_1: CPSCBUF Position    */
#define PWM_CPSCBUF0_1_CPSCBUF_Msk       (0xffful << PWM_CPSCBUF0_1_CPSCBUF_Pos)           /*!< PWM_T::CPSCBUF0_1: CPSCBUF Mask        */

#define PWM_CPSCBUF2_3_CPSCBUF_Pos       (0)                                               /*!< PWM_T::CPSCBUF2_3: CPSCBUF Position    */
#define PWM_CPSCBUF2_3_CPSCBUF_Msk       (0xffful << PWM_CPSCBUF2_3_CPSCBUF_Pos)           /*!< PWM_T::CPSCBUF2_3: CPSCBUF Mask        */

#define PWM_CPSCBUF4_5_CPSCBUF_Pos       (0)                                               /*!< PWM_T::CPSCBUF4_5: CPSCBUF Position    */
#define PWM_CPSCBUF4_5_CPSCBUF_Msk       (0xffful << PWM_CPSCBUF4_5_CPSCBUF_Pos)           /*!< PWM_T::CPSCBUF4_5: CPSCBUF Mask        */

#define PWM_FTCBUF0_1_FTCMPBUF_Pos       (0)                                               /*!< PWM_T::FTCBUF0_1: FTCMPBUF Position    */
#define PWM_FTCBUF0_1_FTCMPBUF_Msk       (0xfffful << PWM_FTCBUF0_1_FTCMPBUF_Pos)          /*!< PWM_T::FTCBUF0_1: FTCMPBUF Mask        */

#define PWM_FTCBUF2_3_FTCMPBUF_Pos       (0)                                               /*!< PWM_T::FTCBUF2_3: FTCMPBUF Position    */
#define PWM_FTCBUF2_3_FTCMPBUF_Msk       (0xfffful << PWM_FTCBUF2_3_FTCMPBUF_Pos)          /*!< PWM_T::FTCBUF2_3: FTCMPBUF Mask        */

#define PWM_FTCBUF4_5_FTCMPBUF_Pos       (0)                                               /*!< PWM_T::FTCBUF4_5: FTCMPBUF Position    */
#define PWM_FTCBUF4_5_FTCMPBUF_Msk       (0xfffful << PWM_FTCBUF4_5_FTCMPBUF_Pos)          /*!< PWM_T::FTCBUF4_5: FTCMPBUF Mask        */

#define PWM_FTCI_FTCMU0_Pos              (0)                                               /*!< PWM_T::FTCI: FTCMU0 Position           */
#define PWM_FTCI_FTCMU0_Msk              (0x1ul << PWM_FTCI_FTCMU0_Pos)                    /*!< PWM_T::FTCI: FTCMU0 Mask               */

#define PWM_FTCI_FTCMU2_Pos              (1)                                               /*!< PWM_T::FTCI: FTCMU2 Position           */
#define PWM_FTCI_FTCMU2_Msk              (0x1ul << PWM_FTCI_FTCMU2_Pos)                    /*!< PWM_T::FTCI: FTCMU2 Mask               */

#define PWM_FTCI_FTCMU4_Pos              (2)                                               /*!< PWM_T::FTCI: FTCMU4 Position           */
#define PWM_FTCI_FTCMU4_Msk              (0x1ul << PWM_FTCI_FTCMU4_Pos)                    /*!< PWM_T::FTCI: FTCMU4 Mask               */

#define PWM_FTCI_FTCMD0_Pos              (8)                                               /*!< PWM_T::FTCI: FTCMD0 Position           */
#define PWM_FTCI_FTCMD0_Msk              (0x1ul << PWM_FTCI_FTCMD0_Pos)                    /*!< PWM_T::FTCI: FTCMD0 Mask               */

#define PWM_FTCI_FTCMD2_Pos              (9)                                               /*!< PWM_T::FTCI: FTCMD2 Position           */
#define PWM_FTCI_FTCMD2_Msk              (0x1ul << PWM_FTCI_FTCMD2_Pos)                    /*!< PWM_T::FTCI: FTCMD2 Mask               */

#define PWM_FTCI_FTCMD4_Pos              (10)                                              /*!< PWM_T::FTCI: FTCMD4 Position           */
#define PWM_FTCI_FTCMD4_Msk              (0x1ul << PWM_FTCI_FTCMD4_Pos)                    /*!< PWM_T::FTCI: FTCMD4 Mask               */

#define PWM_VERSION_MINOR_Pos            (0)                                               /*!< PWM_T::VERSION: MINOR Position         */
#define PWM_VERSION_MINOR_Msk            (0xfffful << PWM_VERSION_MINOR_Pos)               /*!< PWM_T::VERSION: MINOR Mask             */

#define PWM_VERSION_SUB_Pos              (16)                                              /*!< PWM_T::VERSION: SUB Position           */
#define PWM_VERSION_SUB_Msk              (0xfful << PWM_VERSION_SUB_Pos)                   /*!< PWM_T::VERSION: SUB Mask               */

#define PWM_VERSION_MAJOR_Pos            (24)                                              /*!< PWM_T::VERSION: MAJOR Position         */
#define PWM_VERSION_MAJOR_Msk            (0xfful << PWM_VERSION_MAJOR_Pos)                 /*!< PWM_T::VERSION: MAJOR Mask             */

/**@}*/ /* PWM_CONST */
/**@}*/ /* end of PWM register group */


/*---------------------- Real Time Clock Controller -------------------------*/
/**
    @addtogroup RTC Real Time Clock Controller(RTC)
    Memory Mapped Structure for RTC Controller
@{ */
 
typedef struct
{


/**
 * @var RTC_T::INIT
 * Offset: 0x00  RTC Initiation Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |INIT_ACTIVE|RTC Active Status (Read Only)
 * |        |          |0 = RTC is at reset state.
 * |        |          |1 = RTC is at normal active state.[WH1]
 * |        |          |[WH1]Tag50, initial control
 * |[31:1]  |INIT      |RTC Initiation
 * |        |          |When RTC block is powered on, RTC is at reset state
 * |        |          |User has to write a number (0x a5eb1357) to INIT to make RTC leaving reset state
 * |        |          |Once the INIT is written as 0xa5eb1357, the RTC will be in un-reset state permanently.
 * |        |          |The INIT is a write-only field and read value will be always 0.
 * @var RTC_T::RWEN
 * Offset: 0x04  RTC Access Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |RWEN      |RTC Register Access Enable Password (Write Only)
 * |        |          |Writing 0xA965 to this field will enable RTC accessible period keeps 1024 RTC clocks.
 * |        |          |Note: Writing other vaule will clear RWENF and disable RTC register access function immediately.[WH1]
 * |        |          |[WH1]Tag52, R/W accessable
 * |[16]    |RWENF     |RTC Register Access Enable Flag (Read Only)
 * |        |          |0 = RTC register read/write Disabled.
 * |        |          |1 = RTC register read/write Enabled.
 * |        |          |This bit will be set after RTC_RWEN[15:0] register is load a 0xA965, and be cleared automatically after 1024 RTC clocks expired.
 * |        |          |Note: RWENF will be mask to 0 during RTCBUSY is 1, and first turn on RTCCKEN (CLK_APBCLK[1]) also.
 * |[24]    |RTCBUSY   |RTC Write Busy Flag
 * |        |          |This bit indicates RTC registers are writable or not.
 * |        |          |0: RTC registers are writable.
 * |        |          |1: RTC registers can't write, RTC under Busy Status.
 * |        |          |Note: RTCBUSY falg will be set when execute write RTC register command exceed 6 times within 1120 PCLK cycles.
 * |        |          |Note: Maximum write counts and interval can be adjusted in RTC_BUSYCTL.[WH1]
 * |        |          |[WH1]Tag51, write busy status
 * @var RTC_T::FREQADJ
 * Offset: 0x08  RTC Frequency Compensation Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[21:0]  |FREQADJ   |Frequency Compensation Register
 * |        |          |User must to get actual LXT freqency for RTC application.
 * |        |          |FCR = 0x200000 * (32768 / LXT freqency).
 * |        |          |Note: This formula is suitable only when RTC clock source is from LXT, RTCSEL (CLK_CLKSEL3[8]) is 0.
 * |        |          |If set RTCSEL (CLK_CLKSEL3[8]) to 1, RTC clock source is from LIRC.
 * |        |          |User can set FREQADJ to execute LIRC compensation for RTC counter more accurate and the formula as below,
 * |        |          |FCR = 0x80000 * (32768 / LIRC freqency).[WH1]
 * |        |          |[WH1]Tag53, FCR, LXT and LIRC
 * @var RTC_T::TIME
 * Offset: 0x0C  RTC Time Loading Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |SEC       |1-Sec Time Digit (0~9)
 * |[6:4]   |TENSEC    |10-Sec Time Digit (0~5)
 * |[11:8]  |MIN       |1-Min Time Digit (0~9)
 * |[14:12] |TENMIN    |10-Min Time Digit (0~5)
 * |[19:16] |HR        |1-Hour Time Digit (0~9)
 * |[21:20] |TENHR     |10-Hour Time Digit (0~2) When RTC runs as 12-hour time scale mode, RTC_TIME[21] (the high bit of TENHR[1:0]) means AM/PM indication (If RTC_TIME[21] is 1, it indicates PM time message.)
 * |[30:24] |HZCNT     |Index of sub-second counter(0x00 ~0x7F)
 * @var RTC_T::CAL
 * Offset: 0x10  RTC Calendar Loading Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |DAY       |1-Day Calendar Digit (0~9)
 * |[5:4]   |TENDAY    |10-Day Calendar Digit (0~3)
 * |[11:8]  |MON       |1-Month Calendar Digit (0~9)
 * |[12]    |TENMON    |10-Month Calendar Digit (0~1)
 * |[19:16] |YEAR      |1-Year Calendar Digit (0~9)
 * |[23:20] |TENYEAR   |10-Year Calendar Digit (0~9)
 * @var RTC_T::CLKFMT
 * Offset: 0x14  RTC Time Scale Selection Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |24HEN     |24-hour / 12-hour Time Scale Selection
 * |        |          |Indicates that RTC_TIME and RTC_TALM are in 24-hour time scale or 12-hour time scale
 * |        |          |0 = 12-hour time scale with AM and PM indication selected.
 * |        |          |1 = 24-hour time scale selected.[WH1]
 * |        |          |[WH1]Tag58, 12/24HR mode
 * |[8]     |HZCNTEN   |Sub-second Counter Enable Bit
 * |        |          |0 = HZCNT disabled in RTC_TIME and RTC_TALM.
 * |        |          |1 = HZCNT enabled in RTC_TIME and RTC_TALM .[WH1]
 * |        |          |[WH1]Tag57, 1/128 HZ mode
 * |[31]    |RTC_SPEED |RTC_TIME High Speed Test Mode
 * |        |          |RTC day, hour, min and sec digits speed up x64.
 * |        |          |0 = RTC time with normal speed.
 * |        |          |1 = RTC time with high speed.[WH1]
 * |        |          |[WH1]Tag56, high speed test mode
 * @var RTC_T::WEEKDAY
 * Offset: 0x18  RTC Day of the Week Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[2:0]   |WEEKDAY   |Day of the Week Register
 * |        |          |000 = Sunday.
 * |        |          |001 = Monday.
 * |        |          |010 = Tuesday.
 * |        |          |011 = Wednesday.
 * |        |          |100 = Thursday.
 * |        |          |101 = Friday.
 * |        |          |110 = Saturday.
 * |        |          |111 = Reserved.[WH1]
 * |        |          |[WH1]Tag59, weekday
 * @var RTC_T::TALM
 * Offset: 0x1C  RTC Time Alarm Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |SEC       |1-Sec Time Digit of Alarm Setting (0~9)
 * |[6:4]   |TENSEC    |10-Sec Time Digit of Alarm Setting (0~5)
 * |[11:8]  |MIN       |1-Min Time Digit of Alarm Setting (0~9)
 * |[14:12] |TENMIN    |10-Min Time Digit of Alarm Setting (0~5)
 * |[19:16] |HR        |1-Hour Time Digit of Alarm Setting (0~9)
 * |[21:20] |TENHR     |10-Hour Time Digit of Alarm Setting (0~2) When RTC runs as 12-hour time scale mode, RTC_TIME[21] (the high bit of TENHR[1:0]) means AM/PM indication (If RTC_TIME[21] is 1, it indicates PM time message.)
 * |[30:24] |HZCNT     |Index of sub-second counter(0x00 ~0x7F)
 * @var RTC_T::CALM
 * Offset: 0x20  RTC Calendar Alarm Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |DAY       |1-Day Calendar Digit of Alarm Setting (0~9)
 * |[5:4]   |TENDAY    |10-Day Calendar Digit of Alarm Setting (0~3)
 * |[11:8]  |MON       |1-Month Calendar Digit of Alarm Setting (0~9)
 * |[12]    |TENMON    |10-Month Calendar Digit of Alarm Setting (0~1)
 * |[19:16] |YEAR      |1-Year Calendar Digit of Alarm Setting (0~9)
 * |[23:20] |TENYEAR   |10-Year Calendar Digit of Alarm Setting (0~9)
 * @var RTC_T::LEAPYEAR
 * Offset: 0x24  RTC Leap Year Indicator Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |LEAPYEAR  |Leap Year Indication Register (Read Only)
 * |        |          |0 = This year is not a leap year.
 * |        |          |1 = This year is leap year.[WH1]
 * |        |          |[WH1]Tag62, leap year indicate
 * @var RTC_T::INTEN
 * Offset: 0x28  RTC Interrupt Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ALMIEN    |Alarm Interrupt Enable Bit
 * |        |          |Set ALMIEN to 1 can also enable chip wake-up function when RTC alarm interrupt event is generated.
 * |        |          |0 = RTC Alarm interrupt Disabled.
 * |        |          |1 = RTC Alarm interrupt Enabled.[WH1]
 * |        |          |[WH1]Tag63, interrupt enable control
 * |[1]     |TICKIEN   |Time Tick Interrupt Enable Bit
 * |        |          |Set TICKIEN to 1 can also enable chip wake-up function when RTC tick interrupt event is generated.
 * |        |          |0 = RTC Time Tick interrupt Disabled.
 * |        |          |1 = RTC Time Tick interrupt Enabled.
 * @var RTC_T::INTSTS
 * Offset: 0x2C  RTC Interrupt Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ALMIF     |RTC Alarm Interrupt Flag
 * |        |          |0 = Alarm condition is not matched.
 * |        |          |1 = Alarm condition is matched.
 * |        |          |Note: Write 1 to clear this bit.[WH1]
 * |        |          |[WH1]Tag64, interrupt status
 * |[1]     |TICKIF    |RTC Time Tick Interrupt Flag
 * |        |          |0 = Tick condition does not occur.
 * |        |          |1 = Tick condition occur.
 * |        |          |Note: Write 1 to clear this bit.
 * @var RTC_T::TICK
 * Offset: 0x30  RTC Time Tick Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[2:0]   |TICK      |Time Tick Register
 * |        |          |These bits are used to select RTC time tick period for Periodic Time Tick Interrupt request.
 * |        |          |000 = Time tick is 1 second.
 * |        |          |001 = Time tick is 1/2 second.
 * |        |          |010 = Time tick is 1/4 second.
 * |        |          |011 = Time tick is 1/8 second.
 * |        |          |100 = Time tick is 1/16 second.
 * |        |          |101 = Time tick is 1/32 second.
 * |        |          |110 = Time tick is 1/64 second.
 * |        |          |111 = Time tick is 1/128 second.
 * |        |          |Note: This register can be read back after the RTC register access enable bit RWENF (RTC_RWEN[16]) is active.[WH1]
 * |        |          |[WH1]Tag65, tick period
 * @var RTC_T::TAMSK
 * Offset: 0x34  RTC Time Alarm Mask Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |MSEC      |Mask 1-Sec Time Digit of Alarm Setting (0~9)
 * |[1]     |MTENSEC   |Mask 10-Sec Time Digit of Alarm Setting (0~5)
 * |[2]     |MMIN      |Mask 1-Min Time Digit of Alarm Setting (0~9)
 * |[3]     |MTENMIN   |Mask 10-Min Time Digit of Alarm Setting (0~5)
 * |[4]     |MHR       |Mask 1-Hour Time Digit of Alarm Setting (0~9)
 * |[5]     |MTENHR    |Mask 10-Hour Time Digit of Alarm Setting (0~2)
 * @var RTC_T::CAMSK
 * Offset: 0x38  RTC Calendar Alarm Mask Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |MDAY      |Mask 1-Day Calendar Digit of Alarm Setting (0~9)
 * |[1]     |MTENDAY   |Mask 10-Day Calendar Digit of Alarm Setting (0~3)
 * |[2]     |MMON      |Mask 1-Month Calendar Digit of Alarm Setting (0~9)
 * |[3]     |MTENMON   |Mask 10-Month Calendar Digit of Alarm Setting (0~1)
 * |[4]     |MYEAR     |Mask 1-Year Calendar Digit of Alarm Setting (0~9)
 * |[5]     |MTENYEAR  |Mask 10-Year Calendar Digit of Alarm Setting (0~9)
 * @var RTC_T::LXTCTL
 * Offset: 0x100  RTC 32.768 kHz Oscillator Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:1]   |GAIN      |Oscillator Gain Option
 * |        |          |User can select oscillator gain according to crystal external loading and operating temperature range
 * |        |          |The larger gain value corresponding to stronger driving capability and higher power consumption.
 * |        |          |000 = L0 mode.
 * |        |          |001 = L1 mode.
 * |        |          |010 = L2 mode.
 * |        |          |011 = L3 mode.
 * |        |          |100 = L4 mode.
 * |        |          |101 = L5 mode.
 * |        |          |110 = L6 mode.
 * |        |          |111 = L7 mode (Default).[WH1]
 * |        |          |[WH1]Tag72, LXT attribute. Test in real chip.
 * |[4]     |INVTYPE   |Crystal Oscillator Mode Option
 * |        |          |0 = GM type is Enabled. (Default)
 * |        |          |1 = Invert type is Enabled.
 * |        |          |Note: This bit is used for Nuvoton Lab test only, it won't release to end-customer.
 * |[5]     |BYPASS    |Bypass Mode Enable Bit
 * |        |          |0 = Internal 32K clock is from 32K oscillator output.
 * |        |          |1 = internal 32K clock is from X32K_IN pin.
 * |        |          |Note: This bit is used for Nuvoton Lab test only, it won't release to end-customer.
 * @var RTC_T::DSTCTL
 * Offset: 0x110  RTC Daylight Saving Time Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ADDHR     |Add 1 Hour
 * |        |          |0 = No effect.
 * |        |          |1 = Indicates RTC hour digit has been added one hour for summer time change.[WH1]
 * |        |          |[WH1]Tag81, SW DSC control
 * |[1]     |SUBHR     |Subtract 1 Hour
 * |        |          |0 = No effect.
 * |        |          |1 = Indicates RTC hour digit has been subtracted one hour for winter time change.
 * |[2]     |DSBAK     |Daylight Saving Back
 * |        |          |0= Daylight Saving Change is not performed.
 * |        |          |1= Daylight Saving Change is performed.
 * @var RTC_T::TEST
 * Offset: 0x1F0  RTC Test Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |LDOTEST   |RTC LDO Test Enable Bit
 * |        |          |0 = RTC LDO 1.8V output to PF.1 pin is Disabled.
 * |        |          |1 = RTC LDO 1.8V output to PF.1 pin is Enabled.
 * |        |          |Note: This bit is designed for Nuvoton internal Lab test use only, do not release it to end customer
 * |        |          |User writes this bit 1 to enable RTC LDO macro output switch ON to connect LDO output 1.8V to X32K I/O pin for LDO output voltage level measure.[WH1]
 * |        |          |[WH1]Tag101, test mode and test in real chip
 * |[1]     |RTCBGTEST |RTC BandgapTest Enable Bit (Write Protect)
 * |        |          |0 = RTC bandgap output to PF.0 pin is Disabled.
 * |        |          |1 = RTC bandgap output to PF.0 pin is Enabled.
 * |        |          |Note: This bit only workable when LDOTEST = 0.
 * |[2]     |LXT33VSEL |XOSC32K Select Bit (Write Protect)
 * |        |          |0 = XOSC32K12V macro is selected.
 * |        |          |1 = XOSC32K33V macro is selected.
 * |        |          |Note: User should set this bit before configure LXT corrlate register.
 * |[30]    |X32K_OFF  |X32K Logic OFF
 * |        |          |0: X32K Logic ON
 * |        |          |1: X32K Logic OFF.[WH1]
 * |        |          |[WH1]Tag100, LXT logic off
 * @var RTC_T::BUSYCTL
 * Offset: 0x1F4  RTC Write Busy Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[2:0]   |PUNIT     |Maximum Process Count Per Unit
 * |        |          |User can process (PUNIT + 1) times write commands during per unit time.
 * |        |          |Note: Default is 6 times write command within 1120 PCLK cycles.[WH1]
 * |        |          |[WH1]Tag102. Write busy control
 * |[6:4]   |UTIME     |Time of Per Unit ( n)
 * |        |          |n : Unit Time as PCLK0 Div (224*n)
 * |        |          |Note: n = 0 : disable busy function.
 * |        |          |Time of Per Unit
 * |        |          |Per uint time period is (224 * UTIME) * PCLK.
 * |        |          |Note1: Set UTIME to 0 will disable RTCBUSY function.
 * |        |          |Note2: Default is 6 times write command within 1120 PCLK cycles.
 * |[15:8]  |WRITECODE |Write Code Passwoed
 * |        |          |0xA6:
 * |        |          |Program 0xA6 in WRITECODE will enable RTC_BUSYCTL register programmable function.
 * |        |          |Others :
 * |        |          |Program others value will disable RTC_BUSYCTL register programmable function.
 * @var RTC_T::VERSION
 * Offset: 0xFFC  RTC RTL Design Version Number Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |MINOR     |RTC RTL Design Minor Version
 * |        |          |Minor version number is dependent on ECO version control.[WH1]
 * |        |          |[WH1]Tag103, RTL version
 * |[23:16] |SUB       |RTC RTL Design Sub Version Number
 * |        |          |Major version number is correlated to product line.
 * |[31:24] |MAJOR     |RTC RTL Design Major Version Number
 * |        |          |Major version number is correlated to product line.
 */
    __IO uint32_t INIT;                  /*!< [0x0000] RTC Initiation Register                                          */
    __IO uint32_t RWEN;                  /*!< [0x0004] RTC Access Enable Register                                       */
    __IO uint32_t FREQADJ;               /*!< [0x0008] RTC Frequency Compensation Register                              */
    __IO uint32_t TIME;                  /*!< [0x000c] RTC Time Loading Register                                        */
    __IO uint32_t CAL;                   /*!< [0x0010] RTC Calendar Loading Register                                    */
    __IO uint32_t CLKFMT;                /*!< [0x0014] RTC Time Scale Selection Register                                */
    __IO uint32_t WEEKDAY;               /*!< [0x0018] RTC Day of the Week Register                                     */
    __IO uint32_t TALM;                  /*!< [0x001c] RTC Time Alarm Register                                          */
    __IO uint32_t CALM;                  /*!< [0x0020] RTC Calendar Alarm Register                                      */
    __I  uint32_t LEAPYEAR;              /*!< [0x0024] RTC Leap Year Indicator Register                                 */
    __IO uint32_t INTEN;                 /*!< [0x0028] RTC Interrupt Enable Register                                    */
    __IO uint32_t INTSTS;                /*!< [0x002c] RTC Interrupt Status Register                                    */
    __IO uint32_t TICK;                  /*!< [0x0030] RTC Time Tick Register                                           */
    __IO uint32_t TAMSK;                 /*!< [0x0034] RTC Time Alarm Mask Register                                     */
    __IO uint32_t CAMSK;                 /*!< [0x0038] RTC Calendar Alarm Mask Register                                 */
    __I  uint32_t RESERVE0[49];
    __IO uint32_t LXTCTL;                /*!< [0x0100] RTC 32.768 kHz Oscillator Control Register                       */
    __I  uint32_t RESERVE1[3];
    __IO uint32_t DSTCTL;                /*!< [0x0110] RTC Daylight Saving Time Control Register                        */
    __I  uint32_t RESERVE2[55];
    __IO uint32_t TEST;                  /*!< [0x01f0] RTC Test Control Register                                        */
    __IO uint32_t BUSYCTL;               /*!< [0x01f4] RTC Write Busy Control Register                                  */
    __I  uint32_t RESERVE3[897];
    __I  uint32_t VERSION;               /*!< [0x0ffc] RTC RTL Design Version Number Register                           */

} RTC_T;

/**
    @addtogroup RTC_CONST RTC Bit Field Definition
    Constant Definitions for RTC Controller
@{ */

#define RTC_INIT_INIT_ACTIVE_Pos         (0)                                               /*!< RTC_T::INIT: INIT_ACTIVE Position      */
#define RTC_INIT_INIT_ACTIVE_Msk         (0x1ul << RTC_INIT_INIT_ACTIVE_Pos)               /*!< RTC_T::INIT: INIT_ACTIVE Mask          */

#define RTC_INIT_INIT_Pos                (1)                                               /*!< RTC_T::INIT: INIT Position             */
#define RTC_INIT_INIT_Msk                (0x7ffffffful << RTC_INIT_INIT_Pos)               /*!< RTC_T::INIT: INIT Mask                 */

#define RTC_RWEN_RWEN_Pos                (0)                                               /*!< RTC_T::RWEN: RWEN Position             */
#define RTC_RWEN_RWEN_Msk                (0xfffful << RTC_RWEN_RWEN_Pos)                   /*!< RTC_T::RWEN: RWEN Mask                 */

#define RTC_RWEN_RWENF_Pos               (16)                                              /*!< RTC_T::RWEN: RWENF Position            */
#define RTC_RWEN_RWENF_Msk               (0x1ul << RTC_RWEN_RWENF_Pos)                     /*!< RTC_T::RWEN: RWENF Mask                */

#define RTC_RWEN_RTCBUSY_Pos             (24)                                              /*!< RTC_T::RWEN: RTCBUSY Position          */
#define RTC_RWEN_RTCBUSY_Msk             (0x1ul << RTC_RWEN_RTCBUSY_Pos)                   /*!< RTC_T::RWEN: RTCBUSY Mask              */

#define RTC_FREQADJ_FREQADJ_Pos          (0)                                               /*!< RTC_T::FREQADJ: FREQADJ Position       */
#define RTC_FREQADJ_FREQADJ_Msk          (0x3ffffful << RTC_FREQADJ_FREQADJ_Pos)           /*!< RTC_T::FREQADJ: FREQADJ Mask           */

#define RTC_TIME_SEC_Pos                 (0)                                               /*!< RTC_T::TIME: SEC Position              */
#define RTC_TIME_SEC_Msk                 (0xful << RTC_TIME_SEC_Pos)                       /*!< RTC_T::TIME: SEC Mask                  */

#define RTC_TIME_TENSEC_Pos              (4)                                               /*!< RTC_T::TIME: TENSEC Position           */
#define RTC_TIME_TENSEC_Msk              (0x7ul << RTC_TIME_TENSEC_Pos)                    /*!< RTC_T::TIME: TENSEC Mask               */

#define RTC_TIME_MIN_Pos                 (8)                                               /*!< RTC_T::TIME: MIN Position              */
#define RTC_TIME_MIN_Msk                 (0xful << RTC_TIME_MIN_Pos)                       /*!< RTC_T::TIME: MIN Mask                  */

#define RTC_TIME_TENMIN_Pos              (12)                                              /*!< RTC_T::TIME: TENMIN Position           */
#define RTC_TIME_TENMIN_Msk              (0x7ul << RTC_TIME_TENMIN_Pos)                    /*!< RTC_T::TIME: TENMIN Mask               */

#define RTC_TIME_HR_Pos                  (16)                                              /*!< RTC_T::TIME: HR Position               */
#define RTC_TIME_HR_Msk                  (0xful << RTC_TIME_HR_Pos)                        /*!< RTC_T::TIME: HR Mask                   */

#define RTC_TIME_TENHR_Pos               (20)                                              /*!< RTC_T::TIME: TENHR Position            */
#define RTC_TIME_TENHR_Msk               (0x3ul << RTC_TIME_TENHR_Pos)                     /*!< RTC_T::TIME: TENHR Mask                */

#define RTC_TIME_HZCNT_Pos               (24)                                              /*!< RTC_T::TIME: HZCNT Position            */
#define RTC_TIME_HZCNT_Msk               (0x7ful << RTC_TIME_HZCNT_Pos)                    /*!< RTC_T::TIME: HZCNT Mask                */

#define RTC_CAL_DAY_Pos                  (0)                                               /*!< RTC_T::CAL: DAY Position               */
#define RTC_CAL_DAY_Msk                  (0xful << RTC_CAL_DAY_Pos)                        /*!< RTC_T::CAL: DAY Mask                   */

#define RTC_CAL_TENDAY_Pos               (4)                                               /*!< RTC_T::CAL: TENDAY Position            */
#define RTC_CAL_TENDAY_Msk               (0x3ul << RTC_CAL_TENDAY_Pos)                     /*!< RTC_T::CAL: TENDAY Mask                */

#define RTC_CAL_MON_Pos                  (8)                                               /*!< RTC_T::CAL: MON Position               */
#define RTC_CAL_MON_Msk                  (0xful << RTC_CAL_MON_Pos)                        /*!< RTC_T::CAL: MON Mask                   */

#define RTC_CAL_TENMON_Pos               (12)                                              /*!< RTC_T::CAL: TENMON Position            */
#define RTC_CAL_TENMON_Msk               (0x1ul << RTC_CAL_TENMON_Pos)                     /*!< RTC_T::CAL: TENMON Mask                */

#define RTC_CAL_YEAR_Pos                 (16)                                              /*!< RTC_T::CAL: YEAR Position              */
#define RTC_CAL_YEAR_Msk                 (0xful << RTC_CAL_YEAR_Pos)                       /*!< RTC_T::CAL: YEAR Mask                  */

#define RTC_CAL_TENYEAR_Pos              (20)                                              /*!< RTC_T::CAL: TENYEAR Position           */
#define RTC_CAL_TENYEAR_Msk              (0xful << RTC_CAL_TENYEAR_Pos)                    /*!< RTC_T::CAL: TENYEAR Mask               */

#define RTC_CLKFMT_24HEN_Pos             (0)                                               /*!< RTC_T::CLKFMT: 24HEN Position          */
#define RTC_CLKFMT_24HEN_Msk             (0x1ul << RTC_CLKFMT_24HEN_Pos)                   /*!< RTC_T::CLKFMT: 24HEN Mask              */

#define RTC_CLKFMT_HZCNTEN_Pos           (8)                                               /*!< RTC_T::CLKFMT: HZCNTEN Position        */
#define RTC_CLKFMT_HZCNTEN_Msk           (0x1ul << RTC_CLKFMT_HZCNTEN_Pos)                 /*!< RTC_T::CLKFMT: HZCNTEN Mask            */

#define RTC_CLKFMT_RTC_SPEED_Pos         (31)                                              /*!< RTC_T::CLKFMT: RTC_SPEED Position      */
#define RTC_CLKFMT_RTC_SPEED_Msk         (0x1ul << RTC_CLKFMT_RTC_SPEED_Pos)               /*!< RTC_T::CLKFMT: RTC_SPEED Mask          */

#define RTC_WEEKDAY_WEEKDAY_Pos          (0)                                               /*!< RTC_T::WEEKDAY: WEEKDAY Position       */
#define RTC_WEEKDAY_WEEKDAY_Msk          (0x7ul << RTC_WEEKDAY_WEEKDAY_Pos)                /*!< RTC_T::WEEKDAY: WEEKDAY Mask           */

#define RTC_TALM_SEC_Pos                 (0)                                               /*!< RTC_T::TALM: SEC Position              */
#define RTC_TALM_SEC_Msk                 (0xful << RTC_TALM_SEC_Pos)                       /*!< RTC_T::TALM: SEC Mask                  */

#define RTC_TALM_TENSEC_Pos              (4)                                               /*!< RTC_T::TALM: TENSEC Position           */
#define RTC_TALM_TENSEC_Msk              (0x7ul << RTC_TALM_TENSEC_Pos)                    /*!< RTC_T::TALM: TENSEC Mask               */

#define RTC_TALM_MIN_Pos                 (8)                                               /*!< RTC_T::TALM: MIN Position              */
#define RTC_TALM_MIN_Msk                 (0xful << RTC_TALM_MIN_Pos)                       /*!< RTC_T::TALM: MIN Mask                  */

#define RTC_TALM_TENMIN_Pos              (12)                                              /*!< RTC_T::TALM: TENMIN Position           */
#define RTC_TALM_TENMIN_Msk              (0x7ul << RTC_TALM_TENMIN_Pos)                    /*!< RTC_T::TALM: TENMIN Mask               */

#define RTC_TALM_HR_Pos                  (16)                                              /*!< RTC_T::TALM: HR Position               */
#define RTC_TALM_HR_Msk                  (0xful << RTC_TALM_HR_Pos)                        /*!< RTC_T::TALM: HR Mask                   */

#define RTC_TALM_TENHR_Pos               (20)                                              /*!< RTC_T::TALM: TENHR Position            */
#define RTC_TALM_TENHR_Msk               (0x3ul << RTC_TALM_TENHR_Pos)                     /*!< RTC_T::TALM: TENHR Mask                */

#define RTC_TALM_HZCNT_Pos               (24)                                              /*!< RTC_T::TALM: HZCNT Position            */
#define RTC_TALM_HZCNT_Msk               (0x7ful << RTC_TALM_HZCNT_Pos)                    /*!< RTC_T::TALM: HZCNT Mask                */

#define RTC_CALM_DAY_Pos                 (0)                                               /*!< RTC_T::CALM: DAY Position              */
#define RTC_CALM_DAY_Msk                 (0xful << RTC_CALM_DAY_Pos)                       /*!< RTC_T::CALM: DAY Mask                  */

#define RTC_CALM_TENDAY_Pos              (4)                                               /*!< RTC_T::CALM: TENDAY Position           */
#define RTC_CALM_TENDAY_Msk              (0x3ul << RTC_CALM_TENDAY_Pos)                    /*!< RTC_T::CALM: TENDAY Mask               */

#define RTC_CALM_MON_Pos                 (8)                                               /*!< RTC_T::CALM: MON Position              */
#define RTC_CALM_MON_Msk                 (0xful << RTC_CALM_MON_Pos)                       /*!< RTC_T::CALM: MON Mask                  */

#define RTC_CALM_TENMON_Pos              (12)                                              /*!< RTC_T::CALM: TENMON Position           */
#define RTC_CALM_TENMON_Msk              (0x1ul << RTC_CALM_TENMON_Pos)                    /*!< RTC_T::CALM: TENMON Mask               */

#define RTC_CALM_YEAR_Pos                (16)                                              /*!< RTC_T::CALM: YEAR Position             */
#define RTC_CALM_YEAR_Msk                (0xful << RTC_CALM_YEAR_Pos)                      /*!< RTC_T::CALM: YEAR Mask                 */

#define RTC_CALM_TENYEAR_Pos             (20)                                              /*!< RTC_T::CALM: TENYEAR Position          */
#define RTC_CALM_TENYEAR_Msk             (0xful << RTC_CALM_TENYEAR_Pos)                   /*!< RTC_T::CALM: TENYEAR Mask              */

#define RTC_LEAPYEAR_LEAPYEAR_Pos        (0)                                               /*!< RTC_T::LEAPYEAR: LEAPYEAR Position     */
#define RTC_LEAPYEAR_LEAPYEAR_Msk        (0x1ul << RTC_LEAPYEAR_LEAPYEAR_Pos)              /*!< RTC_T::LEAPYEAR: LEAPYEAR Mask         */

#define RTC_INTEN_ALMIEN_Pos             (0)                                               /*!< RTC_T::INTEN: ALMIEN Position          */
#define RTC_INTEN_ALMIEN_Msk             (0x1ul << RTC_INTEN_ALMIEN_Pos)                   /*!< RTC_T::INTEN: ALMIEN Mask              */

#define RTC_INTEN_TICKIEN_Pos            (1)                                               /*!< RTC_T::INTEN: TICKIEN Position         */
#define RTC_INTEN_TICKIEN_Msk            (0x1ul << RTC_INTEN_TICKIEN_Pos)                  /*!< RTC_T::INTEN: TICKIEN Mask             */

#define RTC_INTSTS_ALMIF_Pos             (0)                                               /*!< RTC_T::INTSTS: ALMIF Position          */
#define RTC_INTSTS_ALMIF_Msk             (0x1ul << RTC_INTSTS_ALMIF_Pos)                   /*!< RTC_T::INTSTS: ALMIF Mask              */

#define RTC_INTSTS_TICKIF_Pos            (1)                                               /*!< RTC_T::INTSTS: TICKIF Position         */
#define RTC_INTSTS_TICKIF_Msk            (0x1ul << RTC_INTSTS_TICKIF_Pos)                  /*!< RTC_T::INTSTS: TICKIF Mask             */

#define RTC_TICK_TICK_Pos                (0)                                               /*!< RTC_T::TICK: TICK Position             */
#define RTC_TICK_TICK_Msk                (0x7ul << RTC_TICK_TICK_Pos)                      /*!< RTC_T::TICK: TICK Mask                 */

#define RTC_TAMSK_MSEC_Pos               (0)                                               /*!< RTC_T::TAMSK: MSEC Position            */
#define RTC_TAMSK_MSEC_Msk               (0x1ul << RTC_TAMSK_MSEC_Pos)                     /*!< RTC_T::TAMSK: MSEC Mask                */

#define RTC_TAMSK_MTENSEC_Pos            (1)                                               /*!< RTC_T::TAMSK: MTENSEC Position         */
#define RTC_TAMSK_MTENSEC_Msk            (0x1ul << RTC_TAMSK_MTENSEC_Pos)                  /*!< RTC_T::TAMSK: MTENSEC Mask             */

#define RTC_TAMSK_MMIN_Pos               (2)                                               /*!< RTC_T::TAMSK: MMIN Position            */
#define RTC_TAMSK_MMIN_Msk               (0x1ul << RTC_TAMSK_MMIN_Pos)                     /*!< RTC_T::TAMSK: MMIN Mask                */

#define RTC_TAMSK_MTENMIN_Pos            (3)                                               /*!< RTC_T::TAMSK: MTENMIN Position         */
#define RTC_TAMSK_MTENMIN_Msk            (0x1ul << RTC_TAMSK_MTENMIN_Pos)                  /*!< RTC_T::TAMSK: MTENMIN Mask             */

#define RTC_TAMSK_MHR_Pos                (4)                                               /*!< RTC_T::TAMSK: MHR Position             */
#define RTC_TAMSK_MHR_Msk                (0x1ul << RTC_TAMSK_MHR_Pos)                      /*!< RTC_T::TAMSK: MHR Mask                 */

#define RTC_TAMSK_MTENHR_Pos             (5)                                               /*!< RTC_T::TAMSK: MTENHR Position          */
#define RTC_TAMSK_MTENHR_Msk             (0x1ul << RTC_TAMSK_MTENHR_Pos)                   /*!< RTC_T::TAMSK: MTENHR Mask              */

#define RTC_CAMSK_MDAY_Pos               (0)                                               /*!< RTC_T::CAMSK: MDAY Position            */
#define RTC_CAMSK_MDAY_Msk               (0x1ul << RTC_CAMSK_MDAY_Pos)                     /*!< RTC_T::CAMSK: MDAY Mask                */

#define RTC_CAMSK_MTENDAY_Pos            (1)                                               /*!< RTC_T::CAMSK: MTENDAY Position         */
#define RTC_CAMSK_MTENDAY_Msk            (0x1ul << RTC_CAMSK_MTENDAY_Pos)                  /*!< RTC_T::CAMSK: MTENDAY Mask             */

#define RTC_CAMSK_MMON_Pos               (2)                                               /*!< RTC_T::CAMSK: MMON Position            */
#define RTC_CAMSK_MMON_Msk               (0x1ul << RTC_CAMSK_MMON_Pos)                     /*!< RTC_T::CAMSK: MMON Mask                */

#define RTC_CAMSK_MTENMON_Pos            (3)                                               /*!< RTC_T::CAMSK: MTENMON Position         */
#define RTC_CAMSK_MTENMON_Msk            (0x1ul << RTC_CAMSK_MTENMON_Pos)                  /*!< RTC_T::CAMSK: MTENMON Mask             */

#define RTC_CAMSK_MYEAR_Pos              (4)                                               /*!< RTC_T::CAMSK: MYEAR Position           */
#define RTC_CAMSK_MYEAR_Msk              (0x1ul << RTC_CAMSK_MYEAR_Pos)                    /*!< RTC_T::CAMSK: MYEAR Mask               */

#define RTC_CAMSK_MTENYEAR_Pos           (5)                                               /*!< RTC_T::CAMSK: MTENYEAR Position        */
#define RTC_CAMSK_MTENYEAR_Msk           (0x1ul << RTC_CAMSK_MTENYEAR_Pos)                 /*!< RTC_T::CAMSK: MTENYEAR Mask            */

#define RTC_LXTCTL_GAIN_Pos              (1)                                               /*!< RTC_T::LXTCTL: GAIN Position           */
#define RTC_LXTCTL_GAIN_Msk              (0x7ul << RTC_LXTCTL_GAIN_Pos)                    /*!< RTC_T::LXTCTL: GAIN Mask               */

#define RTC_LXTCTL_INVTYPE_Pos           (4)                                               /*!< RTC_T::LXTCTL: INVTYPE Position        */
#define RTC_LXTCTL_INVTYPE_Msk           (0x1ul << RTC_LXTCTL_INVTYPE_Pos)                 /*!< RTC_T::LXTCTL: INVTYPE Mask            */

#define RTC_LXTCTL_BYPASS_Pos            (5)                                               /*!< RTC_T::LXTCTL: BYPASS Position         */
#define RTC_LXTCTL_BYPASS_Msk            (0x1ul << RTC_LXTCTL_BYPASS_Pos)                  /*!< RTC_T::LXTCTL: BYPASS Mask             */

#define RTC_DSTCTL_ADDHR_Pos             (0)                                               /*!< RTC_T::DSTCTL: ADDHR Position          */
#define RTC_DSTCTL_ADDHR_Msk             (0x1ul << RTC_DSTCTL_ADDHR_Pos)                   /*!< RTC_T::DSTCTL: ADDHR Mask              */

#define RTC_DSTCTL_SUBHR_Pos             (1)                                               /*!< RTC_T::DSTCTL: SUBHR Position          */
#define RTC_DSTCTL_SUBHR_Msk             (0x1ul << RTC_DSTCTL_SUBHR_Pos)                   /*!< RTC_T::DSTCTL: SUBHR Mask              */

#define RTC_DSTCTL_DSBAK_Pos             (2)                                               /*!< RTC_T::DSTCTL: DSBAK Position          */
#define RTC_DSTCTL_DSBAK_Msk             (0x1ul << RTC_DSTCTL_DSBAK_Pos)                   /*!< RTC_T::DSTCTL: DSBAK Mask              */

#define RTC_TEST_LDOTEST_Pos             (0)                                               /*!< RTC_T::TEST: LDOTEST Position          */
#define RTC_TEST_LDOTEST_Msk             (0x1ul << RTC_TEST_LDOTEST_Pos)                   /*!< RTC_T::TEST: LDOTEST Mask              */

#define RTC_TEST_RTCBGTEST_Pos           (1)                                               /*!< RTC_T::TEST: RTCBGTEST Position        */
#define RTC_TEST_RTCBGTEST_Msk           (0x1ul << RTC_TEST_RTCBGTEST_Pos)                 /*!< RTC_T::TEST: RTCBGTEST Mask            */

#define RTC_TEST_LXT33VSEL_Pos           (2)                                               /*!< RTC_T::TEST: LXT33VSEL Position        */
#define RTC_TEST_LXT33VSEL_Msk           (0x1ul << RTC_TEST_LXT33VSEL_Pos)                 /*!< RTC_T::TEST: LXT33VSEL Mask            */

#define RTC_TEST_X32K_OFF_Pos            (30)                                              /*!< RTC_T::TEST: X32K_OFF Position         */
#define RTC_TEST_X32K_OFF_Msk            (0x1ul << RTC_TEST_X32K_OFF_Pos)                  /*!< RTC_T::TEST: X32K_OFF Mask             */

#define RTC_BUSYCTL_PUNIT_Pos            (0)                                               /*!< RTC_T::BUSYCTL: PUNIT Position         */
#define RTC_BUSYCTL_PUNIT_Msk            (0x7ul << RTC_BUSYCTL_PUNIT_Pos)                  /*!< RTC_T::BUSYCTL: PUNIT Mask             */

#define RTC_BUSYCTL_UTIME_Pos            (4)                                               /*!< RTC_T::BUSYCTL: UTIME Position         */
#define RTC_BUSYCTL_UTIME_Msk            (0x7ul << RTC_BUSYCTL_UTIME_Pos)                  /*!< RTC_T::BUSYCTL: UTIME Mask             */

#define RTC_BUSYCTL_WRITECODE_Pos        (8)                                               /*!< RTC_T::BUSYCTL: WRITECODE Position     */
#define RTC_BUSYCTL_WRITECODE_Msk        (0xfful << RTC_BUSYCTL_WRITECODE_Pos)             /*!< RTC_T::BUSYCTL: WRITECODE Mask         */

#define RTC_VERSION_MINOR_Pos            (0)                                               /*!< RTC_T::VERSION: MINOR Position         */
#define RTC_VERSION_MINOR_Msk            (0xfffful << RTC_VERSION_MINOR_Pos)               /*!< RTC_T::VERSION: MINOR Mask             */

#define RTC_VERSION_SUB_Pos              (16)                                              /*!< RTC_T::VERSION: SUB Position           */
#define RTC_VERSION_SUB_Msk              (0xfful << RTC_VERSION_SUB_Pos)                   /*!< RTC_T::VERSION: SUB Mask               */

#define RTC_VERSION_MAJOR_Pos            (24)                                              /*!< RTC_T::VERSION: MAJOR Position         */
#define RTC_VERSION_MAJOR_Msk            (0xfful << RTC_VERSION_MAJOR_Pos)                 /*!< RTC_T::VERSION: MAJOR Mask             */

/**@}*/ /* RTC_CONST */
/**@}*/ /* end of RTC register group */


/*---------------------- Serial Peripheral Interface Controller -------------------------*/
/**
    @addtogroup SPI Serial Peripheral Interface Controller(SPI)
    Memory Mapped Structure for SPI Controller
@{ */
 
typedef struct
{


/**
 * @var SPI_T::CTL
 * Offset: 0x00  SPI Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |SPIEN     |SPI Transfer Control Enable Bit
 * |        |          |In Master mode, the transfer will start when there is data in the FIFO buffer after this bit is set to 1
 * |        |          |In Slave mode, this device is ready to receive data when this bit is set to 1.
 * |        |          |0 = Transfer control Disabled.
 * |        |          |1 = Transfer control Enabled.
 * |        |          |Note: Before changing the configurations of SPIn_CTL, SPIn_CLKDIV, SPIn_SSCTL and SPIn_FIFOCTL registers, user shall clear the SPIEN (SPIn_CTL[0]) and confirm the SPIENSTS (SPIn_STATUS[15]) is 0.
 * |[1]     |RXNEG     |Receive on Negative Edge
 * |        |          |0 = Received data input signal is latched on the rising edge of SPI bus clock.
 * |        |          |1 = Received data input signal is latched on the falling edge of SPI bus clock.
 * |[2]     |TXNEG     |Transmit on Negative Edge
 * |        |          |0 = Transmitted data output signal is changed on the rising edge of SPI bus clock.
 * |        |          |1 = Transmitted data output signal is changed on the falling edge of SPI bus clock.
 * |[3]     |CLKPOL    |Clock Polarity
 * |        |          |0 = SPI bus clock is idle low.
 * |        |          |1 = SPI bus clock is idle high.
 * |[7:4]   |SUSPITV   |Suspend Interval (Master Only)
 * |        |          |The four bits provide configurable suspend interval between two successive transmit/receive transaction in a transfer
 * |        |          |The definition of the suspend interval is the interval between the last clock edge of the preceding transaction word and the first clock edge of the following transaction word
 * |        |          |The default value is 0x3
 * |        |          |The period of the suspend interval is obtained according to the following equation.
 * |        |          |(SUSPITV[3:0] + 0.5) * period of SPICLK clock cycle
 * |        |          |Example:
 * |        |          |SUSPITV = 0x0 .... 0.5 SPICLK clock cycle.
 * |        |          |SUSPITV = 0x1 .... 1.5 SPICLK clock cycle.
 * |        |          |.....
 * |        |          |SUSPITV = 0xE .... 14.5 SPICLK clock cycle.
 * |        |          |SUSPITV = 0xF .... 15.5 SPICLK clock cycle.
 * |[12:8]  |DWIDTH    |Data Width
 * |        |          |This field specifies how many bits can be transmitted / received in one transaction
 * |        |          |The minimum bit length is 8 bits and can up to 32 bits.
 * |        |          |DWIDTH = 0x08 .... 8 bits.
 * |        |          |DWIDTH = 0x09 .... 9 bits.
 * |        |          |.....
 * |        |          |DWIDTH = 0x1F .... 31 bits.
 * |        |          |DWIDTH = 0x00 .... 32 bits.
 * |        |          |Note: For SPI1~SPI2, this bit field will decide the depth of TX/RX FIFO configuration in SPI mode
 * |        |          |Therefore, changing this bit field will clear TX/RX FIFO by hardware automatically in SPI1~SPI2.
 * |[13]    |LSB       |Send LSB First
 * |        |          |0 = The MSB, which bit of transmit/receive register depends on the setting of DWIDTH, is transmitted/received first.
 * |        |          |1 = The LSB, bit 0 of the SPI TX register, is sent first to the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of the RX register (bit 0 of SPIn_RX).
 * |[14]    |HALFDPX   |SPI Half-duplex Transfer Enable Bit
 * |        |          |This bit is used to select full-duplex or half-duplex for SPI transfer
 * |        |          |The bit field DATDIR (SPIn_CTL[20]) can be used to set the data direction in half-duplex transfer.
 * |        |          |0 = SPI operates in full-duplex transfer.
 * |        |          |1 = SPI operates in half-duplex transfer.
 * |[15]    |RXONLY    |Receive-only Mode Enable Bit (Master Only)
 * |        |          |This bit field is only available in Master mode
 * |        |          |In receive-only mode, SPI Master will generate SPI bus clock continuously for receiving data bit from SPI slave device and assert the BUSY status.
 * |        |          |0 = Receive-only mode Disabled.
 * |        |          |1 = Receive-only mode Enabled.
 * |[16]    |TWOBIT    |2-bit Transfer Mode Enable Bit (Only Supported in SPI0)
 * |        |          |0 = 2-Bit Transfer mode Disabled.
 * |        |          |1 = 2-Bit Transfer mode Enabled.
 * |        |          |Note: When 2-Bit Transfer mode is enabled, the first serial transmitted bit data is from the first FIFO buffer data, and the 2nd serial transmitted bit data is from the second FIFO buffer data
 * |        |          |As the same as transmitted function, the first received bit data is stored into the first FIFO buffer and the 2nd received bit data is stored into the second FIFO buffer at the same time.
 * |[17]    |UNITIEN   |Unit Transfer Interrupt Enable Bit
 * |        |          |0 = SPI unit transfer interrupt Disabled.
 * |        |          |1 = SPI unit transfer interrupt Enabled.
 * |[18]    |SLAVE     |Slave Mode Control
 * |        |          |0 = Master mode.
 * |        |          |1 = Slave mode.
 * |[19]    |REORDER   |Byte Reorder Function Enable Bit
 * |        |          |0 = Byte Reorder function Disabled.
 * |        |          |1 = Byte Reorder function Enabled
 * |        |          |A byte suspend interval will be inserted among each byte
 * |        |          |The period of the byte suspend interval depends on the setting of SUSPITV.
 * |        |          |Note: Byte Reorder function is only available if DWIDTH is defined as 16, 24, and 32 bits.
 * |[20]    |DATDIR    |Data Port Direction Control
 * |        |          |This bit is used to select the data input/output direction in half-duplex transfer and Dual/Quad transfer
 * |        |          |0 = SPI data is input direction.
 * |        |          |1 = SPI data is output direction.
 * |[21]    |DUALIOEN  |Dual I/O Mode Enable Bit (Only Supported in SPI0)
 * |        |          |0 = Dual I/O mode Disabled.
 * |        |          |1 = Dual I/O mode Enabled.
 * |[22]    |QUADIOEN  |Quad I/O Mode Enable Bit (Only Supported in SPI0)
 * |        |          |0 = Quad I/O mode Disabled.
 * |        |          |1 = Quad I/O mode Enabled.
 * @var SPI_T::CLKDIV
 * Offset: 0x04  SPI Clock Divider Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:0]   |DIVIDER   |Clock Divider
 * |        |          |The value in this field is the frequency divider for generating the peripheral clock, fspi_eclk, and the SPI bus clock of SPI Master
 * |        |          |The frequency is obtained according to the following equation.
 * |        |          |where
 * |        |          |is the peripheral clock source, which is defined in the clock control register, CLK_CLKSEL2.
 * |        |          |Note: Not supported in I2S mode.
 * @var SPI_T::SSCTL
 * Offset: 0x08  SPI Slave Select Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |SS        |Slave Selection Control (Master Only)
 * |        |          |If AUTOSS bit is cleared to 0,
 * |        |          |0 = Set the SPI0_SS0 or SPI1/2_SS line to inactive state.
 * |        |          |1 = Set the SPI0_SS0 or SPI1/2_SS line to active state.
 * |        |          |If the AUTOSS bit is set to 1,
 * |        |          |0 = Keep the SPI0_SS0 or SPI1/2_SS line at inactive state.
 * |        |          |1 = SPI0_SS0 or SPI1/2_SS line will be automatically driven to active state for the duration of data transfer, and will be driven to inactive state for the rest of the time
 * |        |          |The active state of slave select line is specified in SSACTPOL (SPIn_SSCTL[2]).
 * |        |          |Note:For SPI0, SPI0_SS0 is defined as the slave select input in Slave mode.
 * |[1]     |SS1       |Slave Selection Control 1 (Only supported in SPI0 Master mode)
 * |        |          |If AUTOSS bit is cleared to 0,
 * |        |          |0 = Set the SPI0_SS1 line to inactive state.
 * |        |          |1 = Set the SPI0_SS1 line to active state.
 * |        |          |If the AUTOSS bit is set to 1,
 * |        |          |0 = Keep the SPI0_SS1 line at inactive state.
 * |        |          |1 = SPI0_SS1 line will be automatically driven to active state for the duration of data transfer, and will be driven to inactive state for the rest of the time
 * |        |          |The active state of slave select line is specified in SSACTPOL (SPIn_SSCTL[2]).
 * |        |          |Note:For SPI0, SPI0_SS0 is defined as the slave select input in Slave mode.
 * |[2]     |SSACTPOL  |Slave Selection Active Polarity
 * |        |          |This bit defines the active polarity of slave selection signal.
 * |        |          |0 = The slave selection signal is active low.
 * |        |          |1 = The slave selection signal is active high.
 * |[3]     |AUTOSS    |Automatic Slave Selection Function Enable Bit (Master Only)
 * |        |          |0 = Automatic slave selection function Disabled
 * |        |          |Slave selection signal will be asserted/de-asserted according to SS (SPIn_SSCTL[1:0]).
 * |        |          |1 = Automatic slave selection function Enabled.
 * |[4]     |SLV3WIRE  |Slave 3-wire Mode Enable Bit (Only Supported in SPI0)
 * |        |          |Slave 3-wire mode is only available in SPI0
 * |        |          |In Slave 3-wire mode, the SPI controller can work with 3-wire interface including SPI0_CLK, SPI0_MISO and SPI0_MOSI pins.
 * |        |          |0 = 4-wire bi-direction interface.
 * |        |          |1 = 3-wire bi-direction interface.
 * |[5]     |SLVTOIEN  |Slave Mode Time-out Interrupt Enable Bit (Only Supported in SPI0)
 * |        |          |0 = Slave mode time-out interrupt Disabled.
 * |        |          |1 = Slave mode time-out interrupt Enabled.
 * |[6]     |SLVTORST  |Slave Mode Time-out Reset Control (Only Supported in SPI0)
 * |        |          |0 = When Slave mode time-out event occurs, the TX and RX control circuit will not be reset.
 * |        |          |1 = When Slave mode time-out event occurs, the TX and RX control circuit will be reset by hardware.
 * |[8]     |SLVBEIEN  |Slave Mode Bit Count Error Interrupt Enable Bit
 * |        |          |0 = Slave mode bit count error interrupt Disabled.
 * |        |          |1 = Slave mode bit count error interrupt Enabled. 
 * |[9]     |SLVURIEN  |Slave Mode TX Under Run Interrupt Enable Bit
 * |        |          |0 = Slave mode TX under run interrupt Disabled.
 * |        |          |1 = Slave mode TX under run interrupt Enabled.
 * |[12]    |SSACTIEN  |Slave Select Active Interrupt Enable Bit
 * |        |          |0 = Slave select active interrupt Disabled.
 * |        |          |1 = Slave select active interrupt Enabled. 
 * |[13]    |SSINAIEN  |Slave Select Inactive Interrupt Enable Bit
 * |        |          |0 = Slave select inactive interrupt Disabled.
 * |        |          |1 = Slave select inactive interrupt Enabled. 
 * |[31:16] |SLVTOCNT  |Slave Mode Time-out Period (Only Supported in SPI0)
 * |        |          |In Slave mode, these bits indicate the time-out period when there is bus clock input during slave select active
 * |        |          |The clock source of the time-out counter is Slave peripheral clock
 * |        |          |If the value is 0, it indicates the slave mode time-out function is disabled.
 * @var SPI_T::PDMACTL
 * Offset: 0x0C  SPI PDMA Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |TXPDMAEN  |Transmit PDMA Enable Bit
 * |        |          |0 = Transmit PDMA function Disabled.
 * |        |          |1 = Transmit PDMA function Enabled.
 * |        |          |Note: In SPI Master mode with full duplex transfer, if both TX and RX PDMA functions are enabled, RX PDMA function cannot be enabled prior to TX PDMA function
 * |        |          |User can enable TX PDMA function firstly or enable both functions simultaneously.
 * |[1]     |RXPDMAEN  |Receive PDMA Enable Bit
 * |        |          |0 = Receive PDMA function Disabled.
 * |        |          |1 = Receive PDMA function Enabled.
 * |[2]     |PDMARST   |PDMA Reset
 * |        |          |0 = No effect.
 * |        |          |1 = Reset the PDMA control logic of the SPI controller. This bit will be automatically cleared to 0.
 * @var SPI_T::FIFOCTL
 * Offset: 0x10  SPI FIFO Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |RXRST     |Receive Reset
 * |        |          |0 = No effect.
 * |        |          |1 = Reset receive FIFO pointer and receive circuit
 * |        |          |The RXFULL bit will be cleared to 0 and the RXEMPTY bit will be set to 1
 * |        |          |This bit will be cleared to 0 by hardware about 3 system clock cycles + 2 peripheral clock cycles after it is set to 1
 * |        |          |User can read TXRXRST (SPIn_STATUS[23]) to check if reset is accomplished or not.
 * |[1]     |TXRST     |Transmit Reset
 * |        |          |0 = No effect.
 * |        |          |1 = Reset transmit FIFO pointer and transmit circuit
 * |        |          |The TXFULL bit will be cleared to 0 and the TXEMPTY bit will be set to 1
 * |        |          |This bit will be cleared to 0 by hardware about 3 system clock cycles + 2 peripheral clock cycles after it is set to 1
 * |        |          |User can read TXRXRST (SPIn_STATUS[23]) to check if reset is accomplished or not.
 * |        |          |Note: If TX underflow event occurs in SPI Slave mode, this bit can be used to make SPI return to idle state.
 * |[2]     |RXTHIEN   |Receive FIFO Threshold Interrupt Enable Bit
 * |        |          |0 = RX FIFO threshold interrupt Disabled.
 * |        |          |1 = RX FIFO threshold interrupt Enabled.
 * |[3]     |TXTHIEN   |Transmit FIFO Threshold Interrupt Enable Bit
 * |        |          |0 = TX FIFO threshold interrupt Disabled.
 * |        |          |1 = TX FIFO threshold interrupt Enabled.
 * |[4]     |RXTOIEN   |Slave Receive Time-out Interrupt Enable Bit
 * |        |          |0 = Receive time-out interrupt Disabled.
 * |        |          |1 = Receive time-out interrupt Enabled.
 * |[5]     |RXOVIEN   |Receive FIFO Overrun Interrupt Enable Bit
 * |        |          |0 = Receive FIFO overrun interrupt Disabled.
 * |        |          |1 = Receive FIFO overrun interrupt Enabled.
 * |[6]     |TXUFPOL   |TX Underflow Data Polarity
 * |        |          |0 = The SPI data out is keep 0 if there is TX underflow event in Slave mode.
 * |        |          |1 = The SPI data out is keep 1 if there is TX underflow event in Slave mode.
 * |        |          |Note:
 * |        |          |1
 * |        |          |The TX underflow event occurs if there is no any data in TX FIFO when the slave selection signal is active.
 * |        |          |2. This bit should be set as 0 in I2S mode.
 * |        |          |3
 * |        |          |When TX underflow event occurs, SPI0_MISO0 and SPIx_MISO (x=1, 2) pin state will be determined by this setting even though TX FIFO is not empty afterward
 * |        |          |Data stored in TX FIFO will be sent through SPI0_MISO and SPIx_MISO (x=1, 2) pin in the next transfer frame.
 * |[7]     |TXUFIEN   |TX Underflow Interrupt Enable Bit
 * |        |          |When TX underflow event occurs in Slave mode, TXUFIF (SPIn_STATUS[19]) will be set to 1
 * |        |          |This bit is used to enable the TX underflow interrupt.
 * |        |          |0 = Slave TX underflow interrupt Disabled.
 * |        |          |1 = Slave TX underflow interrupt Enabled.
 * |[8]     |RXFBCLR   |Receive FIFO Buffer Clear
 * |        |          |0 = No effect.
 * |        |          |1 = Clear receive FIFO pointer
 * |        |          |The RXFULL bit will be cleared to 0 and the RXEMPTY bit will be set to 1
 * |        |          |This bit will be cleared to 0 by hardware about 1 system clock after it is set to 1.
 * |        |          |Note: The RX shift register will not be cleared.
 * |[9]     |TXFBCLR   |Transmit FIFO Buffer Clear
 * |        |          |0 = No effect.
 * |        |          |1 = Clear transmit FIFO pointer
 * |        |          |The TXFULL bit will be cleared to 0 and the TXEMPTY bit will be set to 1
 * |        |          |This bit will be cleared to 0 by hardware about 1 system clock after it is set to 1.
 * |        |          |Note: The TX shift register will not be cleared.
 * |[26:24] |RXTH      |Receive FIFO Threshold
 * |        |          |If the valid data count of the receive FIFO buffer is larger than the RXTH setting, the RXTHIF bit will be set to 1, else the RXTHIF bit will be cleared to 0
 * |        |          |For SPI1~SPI2, the MSB of this bit field is only meaningful while SPI mode 8~16 bits of data length.
 * |[30:28] |TXTH      |Transmit FIFO Threshold
 * |        |          |If the valid data count of the transmit FIFO buffer is less than or equal to the TXTH setting, the TXTHIF bit will be set to 1, else the TXTHIF bit will be cleared to 0
 * |        |          |For SPI1~SPI2, the MSB of this bit field is only meaningful while SPI mode 8~16 bits of data length
 * @var SPI_T::STATUS
 * Offset: 0x14  SPI Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BUSY      |Busy Status (Read Only)
 * |        |          |0 = SPI controller is in idle state.
 * |        |          |1 = SPI controller is in busy state.
 * |        |          |The following listing are the bus busy conditions:
 * |        |          |a. SPIn_CTL[0] = 1 and TXEMPTY = 0.
 * |        |          |b
 * |        |          |For SPI Master mode, SPIn_CTL[0] = 1 and TXEMPTY = 1 but the current transaction is not finished yet.
 * |        |          |c. For SPI Master mode, SPIn_CTL[0] = 1 and RXONLY = 1.
 * |        |          |d
 * |        |          |For SPI Slave mode, the SPIn_CTL[0] = 1 and there is serial clock input into the SPI core logic when slave select is active.
 * |        |          |For SPI Slave mode, the SPIn_CTL[0] = 1 and the transmit buffer or transmit shift register is not empty even if the slave select is inactive.
 * |[1]     |UNITIF    |Unit Transfer Interrupt Flag
 * |        |          |0 = No transaction has been finished since this bit was cleared to 0.
 * |        |          |1 = SPI controller has finished one unit transfer.
 * |        |          |Note: This bit will be cleared by writing 1 to it.
 * |[2]     |SSACTIF   |Slave Select Active Interrupt Flag
 * |        |          |0 = Slave select active interrupt was cleared or not occurred.
 * |        |          |1 = Slave select active interrupt event occurred.
 * |        |          |Note: Only available in Slave mode. This bit will be cleared by writing 1 to it.
 * |[3]     |SSINAIF   |Slave Select Inactive Interrupt Flag
 * |        |          |0 = Slave select inactive interrupt was cleared or not occurred.
 * |        |          |1 = Slave select inactive interrupt event occurred.
 * |        |          |Note: Only available in Slave mode. This bit will be cleared by writing 1 to it.
 * |[4]     |SSLINE    |Slave Select Line Bus Status (Read Only)
 * |        |          |0 = The slave select line status is 0.
 * |        |          |1 = The slave select line status is 1.
 * |        |          |Note: This bit is only available in Slave mode
 * |        |          |If SSACTPOL (SPIn_SSCTL[2]) is set 0, and the SSLINE is 1, the SPI slave select is in inactive status.
 * |[5]     |SLVTOIF   |Slave Time-out Interrupt Flag (Only Supported in SPI0)
 * |        |          |When the slave select is active and the value of SLVTOCNT is not 0, as the bus clock is detected, the slave time-out counter in SPI controller logic will be started
 * |        |          |When the value of time-out counter is greater than or equal to the value of SLVTOCNT (SPI0_SSCTL[31:16]) before one transaction is done, the slave time-out interrupt event will be asserted.
 * |        |          |0 = Slave time-out is not active.
 * |        |          |1 = Slave time-out is active.
 * |        |          |Note: This bit will be cleared by writing 1 to it.
 * |[6]     |SLVBEIF   |Slave Mode Bit Count Error Interrupt Flag
 * |        |          |In Slave mode, when the slave select line goes to inactive state, if bit counter is mismatch with DWIDTH, this interrupt flag will be set to 1.
 * |        |          |0 = No Slave mode bit count error event.
 * |        |          |1 = Slave mode bit count error event occurs.
 * |        |          |Note: If the slave select active but there is no any bus clock input, the SLVBEIF also active when the slave select goes to inactive state
 * |        |          |This bit will be cleared by writing 1 to it.
 * |[7]     |SLVURIF   |Slave Mode TX Under Run Interrupt Flag
 * |        |          |In Slave mode, if TX underflow event occurs and the slave select line goes to inactive state, this interrupt flag will be set to 1.
 * |        |          |0 = No Slave TX under run event.
 * |        |          |1 = Slave TX under run event occurs.
 * |        |          |Note: This bit will be cleared by writing 1 to it.
 * |[8]     |RXEMPTY   |Receive FIFO Buffer Empty Indicator (Read Only)
 * |        |          |0 = Receive FIFO buffer is not empty.
 * |        |          |1 = Receive FIFO buffer is empty. 
 * |[9]     |RXFULL    |Receive FIFO Buffer Full Indicator (Read Only)
 * |        |          |0 = Receive FIFO buffer is not full.
 * |        |          |1 = Receive FIFO buffer is full.
 * |[10]    |RXTHIF    |Receive FIFO Threshold Interrupt Flag (Read Only)
 * |        |          |0 = The valid data count within the receive FIFO buffer is smaller than or equal to the setting value of RXTH.
 * |        |          |1 = The valid data count within the receive FIFO buffer is larger than the setting value of RXTH.
 * |[11]    |RXOVIF    |Receive FIFO Overrun Interrupt Flag
 * |        |          |When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.
 * |        |          |0 = No FIFO is overrun.
 * |        |          |1 = Receive FIFO is overrun.
 * |        |          |Note: This bit will be cleared by writing 1 to it.
 * |[12]    |RXTOIF    |Receive Time-out Interrupt Flag
 * |        |          |0 = No receive FIFO time-out event.
 * |        |          |1 = Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI peripheral clock periods in Master mode or over 576 SPI peripheral clock periods in Slave mode
 * |        |          |When the received FIFO buffer is read by software, the time-out status will be cleared automatically.
 * |        |          |Note: This bit will be cleared by writing 1 to it.
 * |[15]    |SPIENSTS  |SPI Enable Status (Read Only)
 * |        |          |0 = The SPI controller is disabled.
 * |        |          |1 = The SPI controller is enabled.
 * |        |          |Note: The SPI peripheral clock is asynchronous with the system clock
 * |        |          |In order to make sure the SPI control logic is disabled, this bit indicates the real status of SPI controller.
 * |[16]    |TXEMPTY   |Transmit FIFO Buffer Empty Indicator (Read Only)
 * |        |          |0 = Transmit FIFO buffer is not empty.
 * |        |          |1 = Transmit FIFO buffer is empty. 
 * |[17]    |TXFULL    |Transmit FIFO Buffer Full Indicator (Read Only)
 * |        |          |0 = Transmit FIFO buffer is not full.
 * |        |          |1 = Transmit FIFO buffer is full. 
 * |[18]    |TXTHIF    |Transmit FIFO Threshold Interrupt Flag (Read Only)
 * |        |          |0 = The valid data count within the transmit FIFO buffer is larger than the setting value of TXTH.
 * |        |          |1 = The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TXTH.
 * |[19]    |TXUFIF    |TX Underflow Interrupt Flag
 * |        |          |When the TX underflow event occurs, this bit will be set to 1, the state of data output pin depends on the setting of TXUFPOL.
 * |        |          |0 = No effect.
 * |        |          |1 = No data in Transmit FIFO and TX shift register when the slave selection signal is active.
 * |        |          |Note 1: This bit will be cleared by writing 1 to it.
 * |        |          |Note 2: If reset slave's transmission circuit when slave selection signal is active, this flag will be set to 1 after 2 peripheral clock cycles + 3 system clock cycles since the reset operation is done.
 * |[23]    |TXRXRST   |TX or RX Reset Status (Read Only)
 * |        |          |0 = The reset function of TXRST or RXRST is done.
 * |        |          |1 = Doing the reset function of TXRST or RXRST.
 * |        |          |Note: Both the reset operations of TXRST and RXRST need 3 system clock cycles + 2 peripheral clock cycles
 * |        |          |User can check the status of this bit to monitor the reset function is doing or done.
 * |[27:24] |RXCNT     |Receive FIFO Data Count (Read Only)
 * |        |          |This bit field indicates the valid data count of receive FIFO buffer.
 * |[31:28] |TXCNT     |Transmit FIFO Data Count (Read Only)
 * |        |          |This bit field indicates the valid data count of transmit FIFO buffer.
 * @var SPI_T::TX
 * Offset: 0x20  SPI Data Transmit Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |TX        |Data Transmit Register
 * |        |          |The data transmit registers pass through the transmitted data into the 4-level transmit FIFO buffers
 * |        |          |The number of valid bits depends on the setting of DWIDTH (SPIn_CTL[12:8]) in SPI mode or WDWIDTH (SPIn_I2SCTL[5:4]) in I2S mode.
 * |        |          |In SPI mode, if DWIDTH is set to 0x08, the bits TX[7:0] will be transmitted
 * |        |          |If DWIDTH is set to 0x00 , the SPI controller will perform a 32-bit transfer.
 * |        |          |In I2S mode, if WDWIDTH (SPIn_I2SCTL[5:4]) is set to 0x2, the data width of audio channel is 24-bit and corresponding to TX[23:0]
 * |        |          |If WDWIDTH is set as 0x0, 0x1, or 0x3, all bits of this field are valid and referred to the data arrangement in I2S mode FIFO operation section
 * |        |          |Note: In Master mode, SPI controller will start to transfer the SPI bus clock after 1 APB clock and 6 peripheral clock cycles after user writes to this register.
 * @var SPI_T::RX
 * Offset: 0x30  SPI Data Receive Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |RX        |Data Receive Register
 * |        |          |There are 4-level FIFO buffers in this controller
 * |        |          |The data receive register holds the data received from SPI data input pin
 * |        |          |If the RXEMPTY (SPIn_STATUS[8] or SPIn_I2SSTS[8]) is not set to 1, the receive FIFO buffers can be accessed through software by reading this register
 * |        |          |This is a read only register.
 * @var SPI_T::INTERNAL
 * Offset: 0x48  SPI Internal Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3]     |DLATCH    |Data Latch Mode (INTERNAL ONLY)
 * |        |          |It is used to adjust the input data source in data received direction
 * |        |          |If the output clock delay by PAD and the system loading is less than half cycle of SPICLK in Master mode, the internal data shall be latched by the negative edge of SPI module clock to fix the data is available
 * |        |          |On the contrary, if the output clock delay is over than half cycle of SPICLK in Master mode, the internal data shall be latched by the positive edge of SPI module clock
 * |        |          |This bit is used to enable /disable the data latched cycle which is tuned by hardware circuit
 * |        |          |If the output clock delay is less than half cycle of SPICLK, there is active high signal in SPI internal hardware
 * |        |          |If the active high signal is fail, the user can set the DATMODE as 1 to force the latched data in the right cycle.
 * |[7]     |SELFTEST  |Self-test Enable Bit
 * |        |          |0 = The self-test function Disabled.
 * |        |          |1 = Enable the self-test function. The Master received data will be the same as the transmit datum. 
 * |[8]     |DEGOFF    |SPI Bus Clock Deglitch Circuit Disable Bit
 * |        |          |0 = The SPI bus clock Input deglitch circuit
 * |        |          |It can filter 1~2ns glitch on the SPI bus clock bus Enabled.
 * |        |          |1 = The SPI bus clock Input deglitch circuit Disabled. 
 * |[14:12] |MRXPHASE  |SPI Master Receive Phase Selection (INTERNAL ONLY)
 * |        |          |It is used to adjust the timing of receive data sampled into RX skew buffer while SPI Master mode due to the PAD I/O latency (send SPI_CLK to Slave device through the output pin and then wait the receive data from Slave device through the input pin)
 * |        |          |0x0: Sample RX data by the Master feedback SPI_CLK (Chip PAD-out loopback to PAD-in)
 * |        |          |0x1: Sample RX data latter the half-period of sending SPI_CLK
 * |        |          |0x2: Sample RX data latter the one-period of sending SPI_CLK
 * |        |          |0x3: Sample RX data latter the 1.5 period of sending SPI_CLK
 * |        |          |0x4: Sample RX data latter the 2 periods of sending SPI_CLK
 * |        |          |Others are reserved.
 * |[19:16] |RXRP      |RX FIFO Read Pointer (INTERNAL ONLY)
 * |[23:20] |RXWP      |RX FIFO Write Pointer (INTERNAL ONLY)
 * |[27:24] |TXRP      |TX FIFO Read Pointer (INTERNAL ONLY)
 * |[31:28] |TXWP      |TX FIFO Write Pointer (INTERNAL ONLY)
 * @var SPI_T::I2SCTL
 * Offset: 0x60  I2S Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |I2SEN     |I2S Controller Enable Bit
 * |        |          |0 = Disabled I2S mode.
 * |        |          |1 = Enabled I2S mode.
 * |        |          |Note:
 * |        |          |1. If enable this bit, I2Sx_BCLK will start to output in Master mode.
 * |        |          |2
 * |        |          |Before changing the configurations of SPIn_I2SCTL, SPIn_I2SCLK, and SPIn_FIFOCTL registers, user shall clear the I2SEN (SPIn_I2SCTL[0]) and confirm the I2SENSTS (SPIn_I2SSTS[15]) is 0.
 * |[1]     |TXEN      |Transmit Enable Bit
 * |        |          |0 = Data transmit Disabled.
 * |        |          |1 = Data transmit Enabled. 
 * |[2]     |RXEN      |Receive Enable Bit
 * |        |          |0 = Data receive Disabled.
 * |        |          |1 = Data receive Enabled.
 * |[3]     |MUTE      |Transmit Mute Enable Bit
 * |        |          |0 = Transmit data is shifted from buffer.
 * |        |          |1 = Transmit channel zero. 
 * |[5:4]   |WDWIDTH   |Word Width
 * |        |          |00 = data size is 8-bit.
 * |        |          |01 = data size is 16-bit.
 * |        |          |10 = data size is 24-bit.
 * |        |          |11 = data size is 32-bit.
 * |[6]     |MONO      |Monaural Data
 * |        |          |0 = Data is stereo format.
 * |        |          |1 = Data is monaural format. 
 * |[7]     |ORDER     |Stereo Data Order in FIFO
 * |        |          |0 = Left channel data at high byte.
 * |        |          |1 = Left channel data at low byte.
 * |[8]     |SLAVE     |Slave Mode
 * |        |          |I2S can operate as master or slave
 * |        |          |For Master mode, I2Sx_BCLK and I2Sx_LRCLK pins are output mode and send bit clock from NuMicro M0564 series to audio CODEC chip
 * |        |          |In Slave mode, I2Sx_BCLK and I2Sx_LRCLK pins are input mode and I2Sx_BCLK and I2Sx_LRCLK signals are received from outer audio CODEC chip.
 * |        |          |0 = Master mode.
 * |        |          |1 = Slave mode. 
 * |[15]    |MCLKEN    |Master Clock Enable Bit
 * |        |          |If MCLKEN is set to 1, I2S controller will generate master clock on SPIx_I2SMCLK pin for external audio devices.
 * |        |          |0 = Master clock Disabled.
 * |        |          |1 = Master clock Enabled.
 * |[16]    |RZCEN     |Right Channel Zero Cross Detection Enable Bit
 * |        |          |If this bit is set to 1, when right channel data sign bit change or next shift data bits are all 0 then RZCIF flag in SPIn_I2SSTS register is set to 1
 * |        |          |This function is only available in transmit operation.
 * |        |          |0 = Right channel zero cross detection Disabled.
 * |        |          |1 = Right channel zero cross detection Enabled.
 * |[17]    |LZCEN     |Left Channel Zero Cross Detection Enable Bit
 * |        |          |If this bit is set to 1, when left channel data sign bit changes or next shift data bits are all 0 then LZCIF flag in SPIn_I2SSTS register is set to 1
 * |        |          |This function is only available in transmit operation.
 * |        |          |0 = Left channel zero cross detection Disabled.
 * |        |          |1 = Left channel zero cross detection Enabled.
 * |[23]    |RXLCH     |Receive Left Channel Enable Bit
 * |        |          |When monaural format is selected (MONO = 1), I2S controller will receive right channel data if RXLCH is set to 0, and receive left channel data if RXLCH is set to 1.
 * |        |          |0 = Receive right channel data in Mono mode.
 * |        |          |1 = Receive left channel data in Mono mode.
 * |[24]    |RZCIEN    |Right Channel Zero Cross Interrupt Enable Bit
 * |        |          |Interrupt occurs if this bit is set to 1 and right channel zero cross event occurs.
 * |        |          |0 = Interrupt Disabled.
 * |        |          |1 = Interrupt Enabled.
 * |[25]    |LZCIEN    |Left Channel Zero Cross Interrupt Enable Bit
 * |        |          |Interrupt occurs if this bit is set to 1 and left channel zero cross event occurs.
 * |        |          |0 = Interrupt Disabled.
 * |        |          |1 = Interrupt Enabled. 
 * |[29:28] |FORMAT    |Data Format Selection
 * |        |          |00 = I2S data format.
 * |        |          |01 = MSB justified data format.
 * |        |          |10 = PCM mode A.
 * |        |          |11 = PCM mode B.
 * @var SPI_T::I2SCLK
 * Offset: 0x64  I2S Clock Divider Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[6:0]   |MCLKDIV   |Master Clock Divider
 * |        |          |If MCLKEN is set to 1, I2S controller will generate master clock for external audio devices
 * |        |          |The frequency of master clock, fMCLK, is determined by the following expressions:
 * |        |          |If MCLKDIV >= 1,.
 * |        |          |If MCLKDIV = 0,.
 * |        |          |where
 * |        |          |is the frequency of I2S peripheral clock source, which is defined in the clock control register CLK_CLKSEL2
 * |        |          |In general, the master clock rate is 256 times sampling clock rate.
 * |[17:8]  |BCLKDIV   |Bit Clock Divider
 * |        |          |The I2S controller will generate bit clock in Master mode
 * |        |          |The clock frequency of bit clock , fBCLK, is determined by the following expression:
 * |        |          |where
 * |        |          |is the frequency of I2S peripheral clock source, which is defined in the clock control register CLK_CLKSEL2.
 * |        |          |In I2S Slave mode, this field is used to define the frequency of peripheral clock and it's determined by .
 * |        |          |The peripheral clock frequency in I2S Slave mode must be equal to or faster than 6 times of input bit clock.
 * @var SPI_T::I2SSTS
 * Offset: 0x68  I2S Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[4]     |RIGHT     |Right Channel (Read Only)
 * |        |          |This bit indicates the current transmit data is belong to which channel.
 * |        |          |0 = Left channel.
 * |        |          |1 = Right channel.
 * |[8]     |RXEMPTY   |Receive FIFO Buffer Empty Indicator (Read Only)
 * |        |          |0 = Receive FIFO buffer is not empty.
 * |        |          |1 = Receive FIFO buffer is empty.
 * |[9]     |RXFULL    |Receive FIFO Buffer Full Indicator (Read Only)
 * |        |          |0 = Receive FIFO buffer is not full.
 * |        |          |1 = Receive FIFO buffer is full.
 * |[10]    |RXTHIF    |Receive FIFO Threshold Interrupt Flag (Read Only)
 * |        |          |0 = The valid data count within the receive FIFO buffer is smaller than or equal to the setting value of RXTH.
 * |        |          |1 = The valid data count within the receive FIFO buffer is larger than the setting value of RXTH.
 * |        |          |Note: If RXTHIEN = 1 and RXTHIF = 1, the SPI/I2S controller will generate a SPI interrupt request.
 * |[11]    |RXOVIF    |Receive FIFO Overrun Interrupt Flag
 * |        |          |When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.
 * |        |          |Note: This bit will be cleared by writing 1 to it.
 * |[12]    |RXTOIF    |Receive Time-out Interrupt Flag
 * |        |          |0 = No receive FIFO time-out event.
 * |        |          |1 = Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI peripheral clock period in Master mode or over 576 SPI peripheral clock period in Slave mode
 * |        |          |When the received FIFO buffer is read by software, the time-out status will be cleared automatically.
 * |        |          |Note: This bit will be cleared by writing 1 to it.
 * |[15]    |I2SENSTS  |I2S Enable Status (Read Only)
 * |        |          |0 = The SPI/I2S control logic is disabled.
 * |        |          |1 = The SPI/I2S control logic is enabled.
 * |        |          |Note: The SPI peripheral clock is asynchronous with the system clock
 * |        |          |In order to make sure the SPI/I2S control logic is disabled, this bit indicates the real status of SPI/I2S control logic for user.
 * |[16]    |TXEMPTY   |Transmit FIFO Buffer Empty Indicator (Read Only)
 * |        |          |0 = Transmit FIFO buffer is not empty.
 * |        |          |1 = Transmit FIFO buffer is empty. 
 * |[17]    |TXFULL    |Transmit FIFO Buffer Full Indicator (Read Only)
 * |        |          |0 = Transmit FIFO buffer is not full.
 * |        |          |1 = Transmit FIFO buffer is full.
 * |[18]    |TXTHIF    |Transmit FIFO Threshold Interrupt Flag (Read Only)
 * |        |          |0 = The valid data count within the transmit FIFO buffer is larger than the setting value of TXTH.
 * |        |          |1 = The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TXTH.
 * |        |          |Note: If TXTHIEN = 1 and TXTHIF = 1, the SPI/I2S controller will generate a SPI interrupt request.
 * |[19]    |TXUFIF    |Transmit FIFO Underflow Interrupt Flag
 * |        |          |When the transmit FIFO buffer is empty and there is no datum written into the FIFO buffer, if there is more bus clock input, this bit will be set to 1.
 * |        |          |Note: This bit will be cleared by writing 1 to it.
 * |[20]    |RZCIF     |Right Channel Zero Cross Interrupt Flag
 * |        |          |0 = No zero cross event occurred on right channel.
 * |        |          |1 = Zero cross event occurred on right channel.
 * |[21]    |LZCIF     |Left Channel Zero Cross Interrupt Flag
 * |        |          |0 = No zero cross event occurred on left channel.
 * |        |          |1 = Zero cross event occurred on left channel.
 * |[23]    |TXRXRST   |TX or RX Reset Status (Read Only)
 * |        |          |0 = The reset function of TXRST or RXRST is done.
 * |        |          |1 = Doing the reset function of TXRST or RXRST.
 * |        |          |Note: Both the reset operations of TXRST and RXRST need 3 system clock cycles + 2 peripheral clock cycles
 * |        |          |User can check the status of this bit to monitor the reset function is doing or done.
 * |[26:24] |RXCNT     |Receive FIFO Data Count (Read Only)
 * |        |          |This bit field indicates the valid data count of receive FIFO buffer.
 * |[30:28] |TXCNT     |Transmit FIFO Data Count (Read Only)
 * |        |          |This bit field indicates the valid data count of transmit FIFO buffer.
 * @var SPI_T::VERSION
 * Offset: 0xFFC  SPI Version Number Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |MINOR     |Minor Version Number (INTERNAL ONLY)
 * |        |          |Minor version number is dependent on ECO version control
 * |        |          |0x0000: (current Minor Version Number)
 * |[23:16] |SUB       |Sub Version Number (INTERNAL ONLY)
 * |        |          |Sub version number is relative to key feature
 * |        |          |0x02: (current Sub Version Number)
 * |[31:24] |MAJOR     |Major Version Number (INTERNAL ONLY)
 * |        |          |Major version number is correlated to Product Line
 * |        |          |0x01: (current Major Version Number)
 */
    __IO uint32_t CTL;                   /*!< [0x0000] SPI Control Register                                             */
    __IO uint32_t CLKDIV;                /*!< [0x0004] SPI Clock Divider Register                                       */
    __IO uint32_t SSCTL;                 /*!< [0x0008] SPI Slave Select Control Register                                */
    __IO uint32_t PDMACTL;               /*!< [0x000c] SPI PDMA Control Register                                        */
    __IO uint32_t FIFOCTL;               /*!< [0x0010] SPI FIFO Control Register                                        */
    __IO uint32_t STATUS;                /*!< [0x0014] SPI Status Register                                              */
    __I  uint32_t RESERVE0[2];
    __O  uint32_t TX;                    /*!< [0x0020] SPI Data Transmit Register                                       */
    __I  uint32_t RESERVE1[3];
    __I  uint32_t RX;                    /*!< [0x0030] SPI Data Receive Register                                        */
    __I  uint32_t RESERVE2[5];
    __IO uint32_t INTERNAL;              /*!< [0x0048] SPI Internal Control Register                                    */
    __I  uint32_t RESERVE3[5];
    __IO uint32_t I2SCTL;                /*!< [0x0060] I2S Control Register                                             */
    __IO uint32_t I2SCLK;                /*!< [0x0064] I2S Clock Divider Control Register                               */
    __IO uint32_t I2SSTS;                /*!< [0x0068] I2S Status Register                                              */
    __I  uint32_t RESERVE4[996];
    __I  uint32_t VERSION;               /*!< [0x0ffc] SPI Version Number Register                                      */

} SPI_T;

/**
    @addtogroup SPI_CONST SPI Bit Field Definition
    Constant Definitions for SPI Controller
@{ */

#define SPI_CTL_SPIEN_Pos                (0)                                               /*!< SPI_T::CTL: SPIEN Position             */
#define SPI_CTL_SPIEN_Msk                (0x1ul << SPI_CTL_SPIEN_Pos)                      /*!< SPI_T::CTL: SPIEN Mask                 */

#define SPI_CTL_RXNEG_Pos                (1)                                               /*!< SPI_T::CTL: RXNEG Position             */
#define SPI_CTL_RXNEG_Msk                (0x1ul << SPI_CTL_RXNEG_Pos)                      /*!< SPI_T::CTL: RXNEG Mask                 */

#define SPI_CTL_TXNEG_Pos                (2)                                               /*!< SPI_T::CTL: TXNEG Position             */
#define SPI_CTL_TXNEG_Msk                (0x1ul << SPI_CTL_TXNEG_Pos)                      /*!< SPI_T::CTL: TXNEG Mask                 */

#define SPI_CTL_CLKPOL_Pos               (3)                                               /*!< SPI_T::CTL: CLKPOL Position            */
#define SPI_CTL_CLKPOL_Msk               (0x1ul << SPI_CTL_CLKPOL_Pos)                     /*!< SPI_T::CTL: CLKPOL Mask                */

#define SPI_CTL_SUSPITV_Pos              (4)                                               /*!< SPI_T::CTL: SUSPITV Position           */
#define SPI_CTL_SUSPITV_Msk              (0xful << SPI_CTL_SUSPITV_Pos)                    /*!< SPI_T::CTL: SUSPITV Mask               */

#define SPI_CTL_DWIDTH_Pos               (8)                                               /*!< SPI_T::CTL: DWIDTH Position            */
#define SPI_CTL_DWIDTH_Msk               (0x1ful << SPI_CTL_DWIDTH_Pos)                    /*!< SPI_T::CTL: DWIDTH Mask                */

#define SPI_CTL_LSB_Pos                  (13)                                              /*!< SPI_T::CTL: LSB Position               */
#define SPI_CTL_LSB_Msk                  (0x1ul << SPI_CTL_LSB_Pos)                        /*!< SPI_T::CTL: LSB Mask                   */

#define SPI_CTL_HALFDPX_Pos              (14)                                              /*!< SPI_T::CTL: HALFDPX Position           */
#define SPI_CTL_HALFDPX_Msk              (0x1ul << SPI_CTL_HALFDPX_Pos)                    /*!< SPI_T::CTL: HALFDPX Mask               */

#define SPI_CTL_RXONLY_Pos               (15)                                              /*!< SPI_T::CTL: RXONLY Position            */
#define SPI_CTL_RXONLY_Msk               (0x1ul << SPI_CTL_RXONLY_Pos)                     /*!< SPI_T::CTL: RXONLY Mask                */

#define SPI_CTL_TWOBIT_Pos               (16)                                              /*!< SPI_T::CTL: TWOBIT Position            */
#define SPI_CTL_TWOBIT_Msk               (0x1ul << SPI_CTL_TWOBIT_Pos)                     /*!< SPI_T::CTL: TWOBIT Mask                */

#define SPI_CTL_UNITIEN_Pos              (17)                                              /*!< SPI_T::CTL: UNITIEN Position           */
#define SPI_CTL_UNITIEN_Msk              (0x1ul << SPI_CTL_UNITIEN_Pos)                    /*!< SPI_T::CTL: UNITIEN Mask               */

#define SPI_CTL_SLAVE_Pos                (18)                                              /*!< SPI_T::CTL: SLAVE Position             */
#define SPI_CTL_SLAVE_Msk                (0x1ul << SPI_CTL_SLAVE_Pos)                      /*!< SPI_T::CTL: SLAVE Mask                 */

#define SPI_CTL_REORDER_Pos              (19)                                              /*!< SPI_T::CTL: REORDER Position           */
#define SPI_CTL_REORDER_Msk              (0x1ul << SPI_CTL_REORDER_Pos)                    /*!< SPI_T::CTL: REORDER Mask               */

#define SPI_CTL_DATDIR_Pos               (20)                                              /*!< SPI_T::CTL: DATDIR Position            */
#define SPI_CTL_DATDIR_Msk               (0x1ul << SPI_CTL_DATDIR_Pos)                     /*!< SPI_T::CTL: DATDIR Mask                */

#define SPI_CTL_DUALIOEN_Pos             (21)                                              /*!< SPI_T::CTL: DUALIOEN Position          */
#define SPI_CTL_DUALIOEN_Msk             (0x1ul << SPI_CTL_DUALIOEN_Pos)                   /*!< SPI_T::CTL: DUALIOEN Mask              */

#define SPI_CTL_QUADIOEN_Pos             (22)                                              /*!< SPI_T::CTL: QUADIOEN Position          */
#define SPI_CTL_QUADIOEN_Msk             (0x1ul << SPI_CTL_QUADIOEN_Pos)                   /*!< SPI_T::CTL: QUADIOEN Mask              */

#define SPI_CLKDIV_DIVIDER_Pos           (0)                                               /*!< SPI_T::CLKDIV: DIVIDER Position        */
#define SPI_CLKDIV_DIVIDER_Msk           (0x1fful << SPI_CLKDIV_DIVIDER_Pos)               /*!< SPI_T::CLKDIV: DIVIDER Mask            */

#define SPI_SSCTL_SS_Pos                 (0)                                               /*!< SPI_T::SSCTL: SS Position              */
#define SPI_SSCTL_SS_Msk                 (0x1ul << SPI_SSCTL_SS_Pos)                       /*!< SPI_T::SSCTL: SS Mask                  */

#define SPI_SSCTL_SS1_Pos                (1)                                               /*!< SPI_T::SSCTL: SS1 Position             */
#define SPI_SSCTL_SS1_Msk                (0x1ul << SPI_SSCTL_SS1_Pos)                      /*!< SPI_T::SSCTL: SS1 Mask                 */

#define SPI_SSCTL_SSACTPOL_Pos           (2)                                               /*!< SPI_T::SSCTL: SSACTPOL Position        */
#define SPI_SSCTL_SSACTPOL_Msk           (0x1ul << SPI_SSCTL_SSACTPOL_Pos)                 /*!< SPI_T::SSCTL: SSACTPOL Mask            */

#define SPI_SSCTL_AUTOSS_Pos             (3)                                               /*!< SPI_T::SSCTL: AUTOSS Position          */
#define SPI_SSCTL_AUTOSS_Msk             (0x1ul << SPI_SSCTL_AUTOSS_Pos)                   /*!< SPI_T::SSCTL: AUTOSS Mask              */

#define SPI_SSCTL_SLV3WIRE_Pos           (4)                                               /*!< SPI_T::SSCTL: SLV3WIRE Position        */
#define SPI_SSCTL_SLV3WIRE_Msk           (0x1ul << SPI_SSCTL_SLV3WIRE_Pos)                 /*!< SPI_T::SSCTL: SLV3WIRE Mask            */

#define SPI_SSCTL_SLVTOIEN_Pos           (5)                                               /*!< SPI_T::SSCTL: SLVTOIEN Position        */
#define SPI_SSCTL_SLVTOIEN_Msk           (0x1ul << SPI_SSCTL_SLVTOIEN_Pos)                 /*!< SPI_T::SSCTL: SLVTOIEN Mask            */

#define SPI_SSCTL_SLVTORST_Pos           (6)                                               /*!< SPI_T::SSCTL: SLVTORST Position        */
#define SPI_SSCTL_SLVTORST_Msk           (0x1ul << SPI_SSCTL_SLVTORST_Pos)                 /*!< SPI_T::SSCTL: SLVTORST Mask            */

#define SPI_SSCTL_SLVBEIEN_Pos           (8)                                               /*!< SPI_T::SSCTL: SLVBEIEN Position        */
#define SPI_SSCTL_SLVBEIEN_Msk           (0x1ul << SPI_SSCTL_SLVBEIEN_Pos)                 /*!< SPI_T::SSCTL: SLVBEIEN Mask            */

#define SPI_SSCTL_SLVURIEN_Pos           (9)                                               /*!< SPI_T::SSCTL: SLVURIEN Position        */
#define SPI_SSCTL_SLVURIEN_Msk           (0x1ul << SPI_SSCTL_SLVURIEN_Pos)                 /*!< SPI_T::SSCTL: SLVURIEN Mask            */

#define SPI_SSCTL_SSACTIEN_Pos           (12)                                              /*!< SPI_T::SSCTL: SSACTIEN Position        */
#define SPI_SSCTL_SSACTIEN_Msk           (0x1ul << SPI_SSCTL_SSACTIEN_Pos)                 /*!< SPI_T::SSCTL: SSACTIEN Mask            */

#define SPI_SSCTL_SSINAIEN_Pos           (13)                                              /*!< SPI_T::SSCTL: SSINAIEN Position        */
#define SPI_SSCTL_SSINAIEN_Msk           (0x1ul << SPI_SSCTL_SSINAIEN_Pos)                 /*!< SPI_T::SSCTL: SSINAIEN Mask            */

#define SPI_SSCTL_SLVTOCNT_Pos           (16)                                              /*!< SPI_T::SSCTL: SLVTOCNT Position        */
#define SPI_SSCTL_SLVTOCNT_Msk           (0xfffful << SPI_SSCTL_SLVTOCNT_Pos)              /*!< SPI_T::SSCTL: SLVTOCNT Mask            */

#define SPI_PDMACTL_TXPDMAEN_Pos         (0)                                               /*!< SPI_T::PDMACTL: TXPDMAEN Position      */
#define SPI_PDMACTL_TXPDMAEN_Msk         (0x1ul << SPI_PDMACTL_TXPDMAEN_Pos)               /*!< SPI_T::PDMACTL: TXPDMAEN Mask          */

#define SPI_PDMACTL_RXPDMAEN_Pos         (1)                                               /*!< SPI_T::PDMACTL: RXPDMAEN Position      */
#define SPI_PDMACTL_RXPDMAEN_Msk         (0x1ul << SPI_PDMACTL_RXPDMAEN_Pos)               /*!< SPI_T::PDMACTL: RXPDMAEN Mask          */

#define SPI_PDMACTL_PDMARST_Pos          (2)                                               /*!< SPI_T::PDMACTL: PDMARST Position       */
#define SPI_PDMACTL_PDMARST_Msk          (0x1ul << SPI_PDMACTL_PDMARST_Pos)                /*!< SPI_T::PDMACTL: PDMARST Mask           */

#define SPI_FIFOCTL_RXRST_Pos            (0)                                               /*!< SPI_T::FIFOCTL: RXRST Position         */
#define SPI_FIFOCTL_RXRST_Msk            (0x1ul << SPI_FIFOCTL_RXRST_Pos)                  /*!< SPI_T::FIFOCTL: RXRST Mask             */

#define SPI_FIFOCTL_TXRST_Pos            (1)                                               /*!< SPI_T::FIFOCTL: TXRST Position         */
#define SPI_FIFOCTL_TXRST_Msk            (0x1ul << SPI_FIFOCTL_TXRST_Pos)                  /*!< SPI_T::FIFOCTL: TXRST Mask             */

#define SPI_FIFOCTL_RXTHIEN_Pos          (2)                                               /*!< SPI_T::FIFOCTL: RXTHIEN Position       */
#define SPI_FIFOCTL_RXTHIEN_Msk          (0x1ul << SPI_FIFOCTL_RXTHIEN_Pos)                /*!< SPI_T::FIFOCTL: RXTHIEN Mask           */

#define SPI_FIFOCTL_TXTHIEN_Pos          (3)                                               /*!< SPI_T::FIFOCTL: TXTHIEN Position       */
#define SPI_FIFOCTL_TXTHIEN_Msk          (0x1ul << SPI_FIFOCTL_TXTHIEN_Pos)                /*!< SPI_T::FIFOCTL: TXTHIEN Mask           */

#define SPI_FIFOCTL_RXTOIEN_Pos          (4)                                               /*!< SPI_T::FIFOCTL: RXTOIEN Position       */
#define SPI_FIFOCTL_RXTOIEN_Msk          (0x1ul << SPI_FIFOCTL_RXTOIEN_Pos)                /*!< SPI_T::FIFOCTL: RXTOIEN Mask           */

#define SPI_FIFOCTL_RXOVIEN_Pos          (5)                                               /*!< SPI_T::FIFOCTL: RXOVIEN Position       */
#define SPI_FIFOCTL_RXOVIEN_Msk          (0x1ul << SPI_FIFOCTL_RXOVIEN_Pos)                /*!< SPI_T::FIFOCTL: RXOVIEN Mask           */

#define SPI_FIFOCTL_TXUFPOL_Pos          (6)                                               /*!< SPI_T::FIFOCTL: TXUFPOL Position       */
#define SPI_FIFOCTL_TXUFPOL_Msk          (0x1ul << SPI_FIFOCTL_TXUFPOL_Pos)                /*!< SPI_T::FIFOCTL: TXUFPOL Mask           */

#define SPI_FIFOCTL_TXUFIEN_Pos          (7)                                               /*!< SPI_T::FIFOCTL: TXUFIEN Position       */
#define SPI_FIFOCTL_TXUFIEN_Msk          (0x1ul << SPI_FIFOCTL_TXUFIEN_Pos)                /*!< SPI_T::FIFOCTL: TXUFIEN Mask           */

#define SPI_FIFOCTL_RXFBCLR_Pos          (8)                                               /*!< SPI_T::FIFOCTL: RXFBCLR Position       */
#define SPI_FIFOCTL_RXFBCLR_Msk          (0x1ul << SPI_FIFOCTL_RXFBCLR_Pos)                /*!< SPI_T::FIFOCTL: RXFBCLR Mask           */

#define SPI_FIFOCTL_TXFBCLR_Pos          (9)                                               /*!< SPI_T::FIFOCTL: TXFBCLR Position       */
#define SPI_FIFOCTL_TXFBCLR_Msk          (0x1ul << SPI_FIFOCTL_TXFBCLR_Pos)                /*!< SPI_T::FIFOCTL: TXFBCLR Mask           */

#define SPI_FIFOCTL_RXTH_Pos             (24)                                              /*!< SPI_T::FIFOCTL: RXTH Position          */
#define SPI_FIFOCTL_RXTH_Msk             (0x7ul << SPI_FIFOCTL_RXTH_Pos)                   /*!< SPI_T::FIFOCTL: RXTH Mask              */

#define SPI_FIFOCTL_TXTH_Pos             (28)                                              /*!< SPI_T::FIFOCTL: TXTH Position          */
#define SPI_FIFOCTL_TXTH_Msk             (0x7ul << SPI_FIFOCTL_TXTH_Pos)                   /*!< SPI_T::FIFOCTL: TXTH Mask              */

#define SPI_STATUS_BUSY_Pos              (0)                                               /*!< SPI_T::STATUS: BUSY Position           */
#define SPI_STATUS_BUSY_Msk              (0x1ul << SPI_STATUS_BUSY_Pos)                    /*!< SPI_T::STATUS: BUSY Mask               */

#define SPI_STATUS_UNITIF_Pos            (1)                                               /*!< SPI_T::STATUS: UNITIF Position         */
#define SPI_STATUS_UNITIF_Msk            (0x1ul << SPI_STATUS_UNITIF_Pos)                  /*!< SPI_T::STATUS: UNITIF Mask             */

#define SPI_STATUS_SSACTIF_Pos           (2)                                               /*!< SPI_T::STATUS: SSACTIF Position        */
#define SPI_STATUS_SSACTIF_Msk           (0x1ul << SPI_STATUS_SSACTIF_Pos)                 /*!< SPI_T::STATUS: SSACTIF Mask            */

#define SPI_STATUS_SSINAIF_Pos           (3)                                               /*!< SPI_T::STATUS: SSINAIF Position        */
#define SPI_STATUS_SSINAIF_Msk           (0x1ul << SPI_STATUS_SSINAIF_Pos)                 /*!< SPI_T::STATUS: SSINAIF Mask            */

#define SPI_STATUS_SSLINE_Pos            (4)                                               /*!< SPI_T::STATUS: SSLINE Position         */
#define SPI_STATUS_SSLINE_Msk            (0x1ul << SPI_STATUS_SSLINE_Pos)                  /*!< SPI_T::STATUS: SSLINE Mask             */

#define SPI_STATUS_SLVTOIF_Pos           (5)                                               /*!< SPI_T::STATUS: SLVTOIF Position        */
#define SPI_STATUS_SLVTOIF_Msk           (0x1ul << SPI_STATUS_SLVTOIF_Pos)                 /*!< SPI_T::STATUS: SLVTOIF Mask            */

#define SPI_STATUS_SLVBEIF_Pos           (6)                                               /*!< SPI_T::STATUS: SLVBEIF Position        */
#define SPI_STATUS_SLVBEIF_Msk           (0x1ul << SPI_STATUS_SLVBEIF_Pos)                 /*!< SPI_T::STATUS: SLVBEIF Mask            */

#define SPI_STATUS_SLVURIF_Pos           (7)                                               /*!< SPI_T::STATUS: SLVURIF Position        */
#define SPI_STATUS_SLVURIF_Msk           (0x1ul << SPI_STATUS_SLVURIF_Pos)                 /*!< SPI_T::STATUS: SLVURIF Mask            */

#define SPI_STATUS_RXEMPTY_Pos           (8)                                               /*!< SPI_T::STATUS: RXEMPTY Position        */
#define SPI_STATUS_RXEMPTY_Msk           (0x1ul << SPI_STATUS_RXEMPTY_Pos)                 /*!< SPI_T::STATUS: RXEMPTY Mask            */

#define SPI_STATUS_RXFULL_Pos            (9)                                               /*!< SPI_T::STATUS: RXFULL Position         */
#define SPI_STATUS_RXFULL_Msk            (0x1ul << SPI_STATUS_RXFULL_Pos)                  /*!< SPI_T::STATUS: RXFULL Mask             */

#define SPI_STATUS_RXTHIF_Pos            (10)                                              /*!< SPI_T::STATUS: RXTHIF Position         */
#define SPI_STATUS_RXTHIF_Msk            (0x1ul << SPI_STATUS_RXTHIF_Pos)                  /*!< SPI_T::STATUS: RXTHIF Mask             */

#define SPI_STATUS_RXOVIF_Pos            (11)                                              /*!< SPI_T::STATUS: RXOVIF Position         */
#define SPI_STATUS_RXOVIF_Msk            (0x1ul << SPI_STATUS_RXOVIF_Pos)                  /*!< SPI_T::STATUS: RXOVIF Mask             */

#define SPI_STATUS_RXTOIF_Pos            (12)                                              /*!< SPI_T::STATUS: RXTOIF Position         */
#define SPI_STATUS_RXTOIF_Msk            (0x1ul << SPI_STATUS_RXTOIF_Pos)                  /*!< SPI_T::STATUS: RXTOIF Mask             */

#define SPI_STATUS_SPIENSTS_Pos          (15)                                              /*!< SPI_T::STATUS: SPIENSTS Position       */
#define SPI_STATUS_SPIENSTS_Msk          (0x1ul << SPI_STATUS_SPIENSTS_Pos)                /*!< SPI_T::STATUS: SPIENSTS Mask           */

#define SPI_STATUS_TXEMPTY_Pos           (16)                                              /*!< SPI_T::STATUS: TXEMPTY Position        */
#define SPI_STATUS_TXEMPTY_Msk           (0x1ul << SPI_STATUS_TXEMPTY_Pos)                 /*!< SPI_T::STATUS: TXEMPTY Mask            */

#define SPI_STATUS_TXFULL_Pos            (17)                                              /*!< SPI_T::STATUS: TXFULL Position         */
#define SPI_STATUS_TXFULL_Msk            (0x1ul << SPI_STATUS_TXFULL_Pos)                  /*!< SPI_T::STATUS: TXFULL Mask             */

#define SPI_STATUS_TXTHIF_Pos            (18)                                              /*!< SPI_T::STATUS: TXTHIF Position         */
#define SPI_STATUS_TXTHIF_Msk            (0x1ul << SPI_STATUS_TXTHIF_Pos)                  /*!< SPI_T::STATUS: TXTHIF Mask             */

#define SPI_STATUS_TXUFIF_Pos            (19)                                              /*!< SPI_T::STATUS: TXUFIF Position         */
#define SPI_STATUS_TXUFIF_Msk            (0x1ul << SPI_STATUS_TXUFIF_Pos)                  /*!< SPI_T::STATUS: TXUFIF Mask             */

#define SPI_STATUS_TXRXRST_Pos           (23)                                              /*!< SPI_T::STATUS: TXRXRST Position        */
#define SPI_STATUS_TXRXRST_Msk           (0x1ul << SPI_STATUS_TXRXRST_Pos)                 /*!< SPI_T::STATUS: TXRXRST Mask            */

#define SPI_STATUS_RXCNT_Pos             (24)                                              /*!< SPI_T::STATUS: RXCNT Position          */
#define SPI_STATUS_RXCNT_Msk             (0xful << SPI_STATUS_RXCNT_Pos)                   /*!< SPI_T::STATUS: RXCNT Mask              */

#define SPI_STATUS_TXCNT_Pos             (28)                                              /*!< SPI_T::STATUS: TXCNT Position          */
#define SPI_STATUS_TXCNT_Msk             (0xful << SPI_STATUS_TXCNT_Pos)                   /*!< SPI_T::STATUS: TXCNT Mask              */

#define SPI_TX_TX_Pos                    (0)                                               /*!< SPI_T::TX: TX Position                 */
#define SPI_TX_TX_Msk                    (0xfffffffful << SPI_TX_TX_Pos)                   /*!< SPI_T::TX: TX Mask                     */

#define SPI_RX_RX_Pos                    (0)                                               /*!< SPI_T::RX: RX Position                 */
#define SPI_RX_RX_Msk                    (0xfffffffful << SPI_RX_RX_Pos)                   /*!< SPI_T::RX: RX Mask                     */

#define SPI_INTERNAL_DLATCH_Pos          (3)                                               /*!< SPI_T::INTERNAL: DLATCH Position       */
#define SPI_INTERNAL_DLATCH_Msk          (0x1ul << SPI_INTERNAL_DLATCH_Pos)                /*!< SPI_T::INTERNAL: DLATCH Mask           */

#define SPI_INTERNAL_SELFTEST_Pos        (7)                                               /*!< SPI_T::INTERNAL: SELFTEST Position     */
#define SPI_INTERNAL_SELFTEST_Msk        (0x1ul << SPI_INTERNAL_SELFTEST_Pos)              /*!< SPI_T::INTERNAL: SELFTEST Mask         */

#define SPI_INTERNAL_DEGOFF_Pos          (8)                                               /*!< SPI_T::INTERNAL: DEGOFF Position       */
#define SPI_INTERNAL_DEGOFF_Msk          (0x1ul << SPI_INTERNAL_DEGOFF_Pos)                /*!< SPI_T::INTERNAL: DEGOFF Mask           */

#define SPI_INTERNAL_MRXPHASE_Pos        (12)                                              /*!< SPI_T::INTERNAL: MRXPHASE Position     */
#define SPI_INTERNAL_MRXPHASE_Msk        (0x7ul << SPI_INTERNAL_MRXPHASE_Pos)              /*!< SPI_T::INTERNAL: MRXPHASE Mask         */

#define SPI_INTERNAL_RXRP_Pos            (16)                                              /*!< SPI_T::INTERNAL: RXRP Position         */
#define SPI_INTERNAL_RXRP_Msk            (0xful << SPI_INTERNAL_RXRP_Pos)                  /*!< SPI_T::INTERNAL: RXRP Mask             */

#define SPI_INTERNAL_RXWP_Pos            (20)                                              /*!< SPI_T::INTERNAL: RXWP Position         */
#define SPI_INTERNAL_RXWP_Msk            (0xful << SPI_INTERNAL_RXWP_Pos)                  /*!< SPI_T::INTERNAL: RXWP Mask             */

#define SPI_INTERNAL_TXRP_Pos            (24)                                              /*!< SPI_T::INTERNAL: TXRP Position         */
#define SPI_INTERNAL_TXRP_Msk            (0xful << SPI_INTERNAL_TXRP_Pos)                  /*!< SPI_T::INTERNAL: TXRP Mask             */

#define SPI_INTERNAL_TXWP_Pos            (28)                                              /*!< SPI_T::INTERNAL: TXWP Position         */
#define SPI_INTERNAL_TXWP_Msk            (0xful << SPI_INTERNAL_TXWP_Pos)                  /*!< SPI_T::INTERNAL: TXWP Mask             */

#define SPI_I2SCTL_I2SEN_Pos             (0)                                               /*!< SPI_T::I2SCTL: I2SEN Position          */
#define SPI_I2SCTL_I2SEN_Msk             (0x1ul << SPI_I2SCTL_I2SEN_Pos)                   /*!< SPI_T::I2SCTL: I2SEN Mask              */

#define SPI_I2SCTL_TXEN_Pos              (1)                                               /*!< SPI_T::I2SCTL: TXEN Position           */
#define SPI_I2SCTL_TXEN_Msk              (0x1ul << SPI_I2SCTL_TXEN_Pos)                    /*!< SPI_T::I2SCTL: TXEN Mask               */

#define SPI_I2SCTL_RXEN_Pos              (2)                                               /*!< SPI_T::I2SCTL: RXEN Position           */
#define SPI_I2SCTL_RXEN_Msk              (0x1ul << SPI_I2SCTL_RXEN_Pos)                    /*!< SPI_T::I2SCTL: RXEN Mask               */

#define SPI_I2SCTL_MUTE_Pos              (3)                                               /*!< SPI_T::I2SCTL: MUTE Position           */
#define SPI_I2SCTL_MUTE_Msk              (0x1ul << SPI_I2SCTL_MUTE_Pos)                    /*!< SPI_T::I2SCTL: MUTE Mask               */

#define SPI_I2SCTL_WDWIDTH_Pos           (4)                                               /*!< SPI_T::I2SCTL: WDWIDTH Position        */
#define SPI_I2SCTL_WDWIDTH_Msk           (0x3ul << SPI_I2SCTL_WDWIDTH_Pos)                 /*!< SPI_T::I2SCTL: WDWIDTH Mask            */

#define SPI_I2SCTL_MONO_Pos              (6)                                               /*!< SPI_T::I2SCTL: MONO Position           */
#define SPI_I2SCTL_MONO_Msk              (0x1ul << SPI_I2SCTL_MONO_Pos)                    /*!< SPI_T::I2SCTL: MONO Mask               */

#define SPI_I2SCTL_ORDER_Pos             (7)                                               /*!< SPI_T::I2SCTL: ORDER Position          */
#define SPI_I2SCTL_ORDER_Msk             (0x1ul << SPI_I2SCTL_ORDER_Pos)                   /*!< SPI_T::I2SCTL: ORDER Mask              */

#define SPI_I2SCTL_SLAVE_Pos             (8)                                               /*!< SPI_T::I2SCTL: SLAVE Position          */
#define SPI_I2SCTL_SLAVE_Msk             (0x1ul << SPI_I2SCTL_SLAVE_Pos)                   /*!< SPI_T::I2SCTL: SLAVE Mask              */

#define SPI_I2SCTL_MCLKEN_Pos            (15)                                              /*!< SPI_T::I2SCTL: MCLKEN Position         */
#define SPI_I2SCTL_MCLKEN_Msk            (0x1ul << SPI_I2SCTL_MCLKEN_Pos)                  /*!< SPI_T::I2SCTL: MCLKEN Mask             */

#define SPI_I2SCTL_RZCEN_Pos             (16)                                              /*!< SPI_T::I2SCTL: RZCEN Position          */
#define SPI_I2SCTL_RZCEN_Msk             (0x1ul << SPI_I2SCTL_RZCEN_Pos)                   /*!< SPI_T::I2SCTL: RZCEN Mask              */

#define SPI_I2SCTL_LZCEN_Pos             (17)                                              /*!< SPI_T::I2SCTL: LZCEN Position          */
#define SPI_I2SCTL_LZCEN_Msk             (0x1ul << SPI_I2SCTL_LZCEN_Pos)                   /*!< SPI_T::I2SCTL: LZCEN Mask              */

#define SPI_I2SCTL_RXLCH_Pos             (23)                                              /*!< SPI_T::I2SCTL: RXLCH Position          */
#define SPI_I2SCTL_RXLCH_Msk             (0x1ul << SPI_I2SCTL_RXLCH_Pos)                   /*!< SPI_T::I2SCTL: RXLCH Mask              */

#define SPI_I2SCTL_RZCIEN_Pos            (24)                                              /*!< SPI_T::I2SCTL: RZCIEN Position         */
#define SPI_I2SCTL_RZCIEN_Msk            (0x1ul << SPI_I2SCTL_RZCIEN_Pos)                  /*!< SPI_T::I2SCTL: RZCIEN Mask             */

#define SPI_I2SCTL_LZCIEN_Pos            (25)                                              /*!< SPI_T::I2SCTL: LZCIEN Position         */
#define SPI_I2SCTL_LZCIEN_Msk            (0x1ul << SPI_I2SCTL_LZCIEN_Pos)                  /*!< SPI_T::I2SCTL: LZCIEN Mask             */

#define SPI_I2SCTL_FORMAT_Pos            (28)                                              /*!< SPI_T::I2SCTL: FORMAT Position         */
#define SPI_I2SCTL_FORMAT_Msk            (0x3ul << SPI_I2SCTL_FORMAT_Pos)                  /*!< SPI_T::I2SCTL: FORMAT Mask             */

#define SPI_I2SCLK_MCLKDIV_Pos           (0)                                               /*!< SPI_T::I2SCLK: MCLKDIV Position        */
#define SPI_I2SCLK_MCLKDIV_Msk           (0x7ful << SPI_I2SCLK_MCLKDIV_Pos)                /*!< SPI_T::I2SCLK: MCLKDIV Mask            */

#define SPI_I2SCLK_BCLKDIV_Pos           (8)                                               /*!< SPI_T::I2SCLK: BCLKDIV Position        */
#define SPI_I2SCLK_BCLKDIV_Msk           (0x3fful << SPI_I2SCLK_BCLKDIV_Pos)               /*!< SPI_T::I2SCLK: BCLKDIV Mask            */

#define SPI_I2SSTS_PLUS_Ros             (4)                                               /*!< SPI_T::I2SSTS: RIGHT Position          */
#define SPI_I2SSTS_MINUS_Rsk             (0x1ul << SPI_I2SSTS_PLUS_Ros)                   /*!< SPI_T::I2SSTS: RIGHT Mask              */

#define SPI_I2SSTS_RXEMPTY_Pos           (8)                                               /*!< SPI_T::I2SSTS: RXEMPTY Position        */
#define SPI_I2SSTS_RXEMPTY_Msk           (0x1ul << SPI_I2SSTS_RXEMPTY_Pos)                 /*!< SPI_T::I2SSTS: RXEMPTY Mask            */

#define SPI_I2SSTS_RXFULL_Pos            (9)                                               /*!< SPI_T::I2SSTS: RXFULL Position         */
#define SPI_I2SSTS_RXFULL_Msk            (0x1ul << SPI_I2SSTS_RXFULL_Pos)                  /*!< SPI_T::I2SSTS: RXFULL Mask             */

#define SPI_I2SSTS_RXTHIF_Pos            (10)                                              /*!< SPI_T::I2SSTS: RXTHIF Position         */
#define SPI_I2SSTS_RXTHIF_Msk            (0x1ul << SPI_I2SSTS_RXTHIF_Pos)                  /*!< SPI_T::I2SSTS: RXTHIF Mask             */

#define SPI_I2SSTS_RXOVIF_Pos            (11)                                              /*!< SPI_T::I2SSTS: RXOVIF Position         */
#define SPI_I2SSTS_RXOVIF_Msk            (0x1ul << SPI_I2SSTS_RXOVIF_Pos)                  /*!< SPI_T::I2SSTS: RXOVIF Mask             */

#define SPI_I2SSTS_RXTOIF_Pos            (12)                                              /*!< SPI_T::I2SSTS: RXTOIF Position         */
#define SPI_I2SSTS_RXTOIF_Msk            (0x1ul << SPI_I2SSTS_RXTOIF_Pos)                  /*!< SPI_T::I2SSTS: RXTOIF Mask             */

#define SPI_I2SSTS_I2SENSTS_Pos          (15)                                              /*!< SPI_T::I2SSTS: I2SENSTS Position       */
#define SPI_I2SSTS_I2SENSTS_Msk          (0x1ul << SPI_I2SSTS_I2SENSTS_Pos)                /*!< SPI_T::I2SSTS: I2SENSTS Mask           */

#define SPI_I2SSTS_TXEMPTY_Pos           (16)                                              /*!< SPI_T::I2SSTS: TXEMPTY Position        */
#define SPI_I2SSTS_TXEMPTY_Msk           (0x1ul << SPI_I2SSTS_TXEMPTY_Pos)                 /*!< SPI_T::I2SSTS: TXEMPTY Mask            */

#define SPI_I2SSTS_TXFULL_Pos            (17)                                              /*!< SPI_T::I2SSTS: TXFULL Position         */
#define SPI_I2SSTS_TXFULL_Msk            (0x1ul << SPI_I2SSTS_TXFULL_Pos)                  /*!< SPI_T::I2SSTS: TXFULL Mask             */

#define SPI_I2SSTS_TXTHIF_Pos            (18)                                              /*!< SPI_T::I2SSTS: TXTHIF Position         */
#define SPI_I2SSTS_TXTHIF_Msk            (0x1ul << SPI_I2SSTS_TXTHIF_Pos)                  /*!< SPI_T::I2SSTS: TXTHIF Mask             */

#define SPI_I2SSTS_TXUFIF_Pos            (19)                                              /*!< SPI_T::I2SSTS: TXUFIF Position         */
#define SPI_I2SSTS_TXUFIF_Msk            (0x1ul << SPI_I2SSTS_TXUFIF_Pos)                  /*!< SPI_T::I2SSTS: TXUFIF Mask             */

#define SPI_I2SSTS_RZCIF_Pos             (20)                                              /*!< SPI_T::I2SSTS: RZCIF Position          */
#define SPI_I2SSTS_RZCIF_Msk             (0x1ul << SPI_I2SSTS_RZCIF_Pos)                   /*!< SPI_T::I2SSTS: RZCIF Mask              */

#define SPI_I2SSTS_LZCIF_Pos             (21)                                              /*!< SPI_T::I2SSTS: LZCIF Position          */
#define SPI_I2SSTS_LZCIF_Msk             (0x1ul << SPI_I2SSTS_LZCIF_Pos)                   /*!< SPI_T::I2SSTS: LZCIF Mask              */

#define SPI_I2SSTS_TXRXRST_Pos           (23)                                              /*!< SPI_T::I2SSTS: TXRXRST Position        */
#define SPI_I2SSTS_TXRXRST_Msk           (0x1ul << SPI_I2SSTS_TXRXRST_Pos)                 /*!< SPI_T::I2SSTS: TXRXRST Mask            */

#define SPI_I2SSTS_RXCNT_Pos             (24)                                              /*!< SPI_T::I2SSTS: RXCNT Position          */
#define SPI_I2SSTS_RXCNT_Msk             (0x7ul << SPI_I2SSTS_RXCNT_Pos)                   /*!< SPI_T::I2SSTS: RXCNT Mask              */

#define SPI_I2SSTS_TXCNT_Pos             (28)                                              /*!< SPI_T::I2SSTS: TXCNT Position          */
#define SPI_I2SSTS_TXCNT_Msk             (0x7ul << SPI_I2SSTS_TXCNT_Pos)                   /*!< SPI_T::I2SSTS: TXCNT Mask              */

#define SPI_VERSION_MINOR_Pos            (0)                                               /*!< SPI_T::VERSION: MINOR Position         */
#define SPI_VERSION_MINOR_Msk            (0xfffful << SPI_VERSION_MINOR_Pos)               /*!< SPI_T::VERSION: MINOR Mask             */

#define SPI_VERSION_SUB_Pos              (16)                                              /*!< SPI_T::VERSION: SUB Position           */
#define SPI_VERSION_SUB_Msk              (0xfful << SPI_VERSION_SUB_Pos)                   /*!< SPI_T::VERSION: SUB Mask               */

#define SPI_VERSION_MAJOR_Pos            (24)                                              /*!< SPI_T::VERSION: MAJOR Position         */
#define SPI_VERSION_MAJOR_Msk            (0xfful << SPI_VERSION_MAJOR_Pos)                 /*!< SPI_T::VERSION: MAJOR Mask             */

/**@}*/ /* SPI_CONST */
/**@}*/ /* end of SPI register group */


/*---------------------- System Manger Controller -------------------------*/
/**
    @addtogroup SYS System Manger Controller(SYS)
    Memory Mapped Structure for SYS Controller
@{ */
 
typedef struct
{


/**
 * @var SYS_T::PDID
 * Offset: 0x00  Part Device Identification Number Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |PDID      |Part Device Identification Number (Read Only)
 * |        |          |This register reflects device part number code
 * |        |          |Software can read this register to identify which device is used.
 * @var SYS_T::RSTSTS
 * Offset: 0x04  System Reset Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PORF      |POR Reset Flag
 * |        |          |The POR reset flag is set by the ...Reset Signalu201D from the Power-on Reset (POR) Controller or bit CHIPRST (SYS_IPRST0[0]) to indicate the previous reset source.
 * |        |          |0 = No reset from POR or CHIPRST.
 * |        |          |1 = Power-on Reset (POR) or CHIPRST had issued the reset signal to reset the system.
 * |        |          |Note: Write 1 to clear this bit to 0.
 * |[1]     |PINRF     |NRESET Pin Reset Flag
 * |        |          |The nRESET pin reset flag is set by the ...Reset Signalu201D from the nRESET Pin to indicate the previous reset source.
 * |        |          |0 = No reset from nRESET pin.
 * |        |          |1 = Pin nRESET had issued the reset signal to reset the system.
 * |        |          |Note: Write 1 to clear this bit to 0.
 * |[2]     |WDTRF     |WDT Reset Flag
 * |        |          |The WDT reset flag is set by the ...Reset Signalu201D from the Watchdog Timer or Window Watchdog Timer to indicate the previous reset source.
 * |        |          |0 = No reset from watchdog timer or window watchdog timer.
 * |        |          |1 = The watchdog timer or window watchdog timer had issued the reset signal to reset the system.
 * |        |          |Note1: Write 1 to clear this bit to 0.
 * |        |          |Note2: Watchdog Timer register RSTF(WDT_CTL[2]) bit is set if the system has been reset by WDT time-out reset
 * |        |          |Window Watchdog Timer register WWDTRF(WWDT_STATUS[1]) bit is set if the system has been reset by WWDT time-out reset.
 * |[3]     |LVRF      |LVR Reset Flag
 * |        |          |The LVR reset flag is set by the ...Reset Signalu201D from the Low Voltage Reset Controller to indicate the previous reset source.
 * |        |          |0 = No reset from LVR.
 * |        |          |1 = LVR controller had issued the reset signal to reset the system.
 * |        |          |Note: Write 1 to clear this bit to 0.
 * |[4]     |BODRF     |BOD Reset Flag
 * |        |          |The BOD reset flag is set by the ...Reset Signalu201D from the Brown-Out Detector to indicate the previous reset source.
 * |        |          |0 = No reset from BOD.
 * |        |          |1 = The BOD had issued the reset signal to reset the system.
 * |        |          |Note: Write 1 to clear this bit to 0.
 * |[5]     |SYSRF     |System Reset Flag
 * |        |          |The system reset flag is set by the ...Reset Signalu201D from the Cortex-M4 Core to indicate the previous reset source.
 * |        |          |0 = No reset from Cortex-M4.
 * |        |          |1 = The Cortex-M4 had issued the reset signal to reset the system by writing 1 to the bit SYSRESETREQ(AIRCR[2], Application Interrupt and Reset Control Register, address = 0xE000ED0C) in system control registers of Cortex-M4 core.
 * |        |          |Note: Write 1 to clear this bit to 0.
 * |[7]     |CPURF     |CPU Reset Flag
 * |        |          |The CPU reset flag is set by hardware if software writes CPURST (SYS_IPRST0[1]) 1 to reset Cortex-M4 Core and Flash Memory Controller (FMC).
 * |        |          |0 = No reset from CPU.
 * |        |          |1 = The Cortex-M4 Core and FMC are reset by software setting CPURST to 1.
 * |        |          |Note: Write to clear this bit to 0.
 * |[8]     |CPULKRF   |the CPULK Reset Flag Is Set by Hardware If Cortex-m4 Lockup Happened
 * |        |          |0 = No reset from CPU lockup happened.
 * |        |          |1 = The Cortex-M4 lockup happened and chip is reset.
 * |        |          |Note: Write 1 to clear this bit to 0.
 * |        |          |Note2: When CPU lockup happened under ICE is connected, This flag will set to 1 but chip will not reset.
 * @var SYS_T::IPRST0
 * Offset: 0x08  Peripheral  Reset Control Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CHIPRST   |Chip One-shot Reset (Write Protect)
 * |        |          |Setting this bit will reset the whole chip, including Processor core and all peripherals, and this bit will automatically return to 0 after the 2 clock cycles.
 * |        |          |The CHIPRST is same as the POR reset, all the chip controllers is reset and the chip setting from flash are also reload.
 * |        |          |About the difference between CHIPRST and SYSRESETREQ(AIRCR[2]), please refer to section 6.2.2
 * |        |          |0 = Chip normal operation.
 * |        |          |1 = Chip one-shot reset.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[1]     |CPURST    |Processor Core One-shot Reset (Write Protect)
 * |        |          |Setting this bit will only reset the processor core and Flash Memory Controller(FMC), and this bit will automatically return to 0 after the 2 clock cycles.
 * |        |          |0 = Processor core normal operation.
 * |        |          |1 = Processor core one-shot reset.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[2]     |PDMARST   |PDMA Controller Reset (Write Protect)
 * |        |          |Setting this bit to 1 will generate a reset signal to the PDMA
 * |        |          |User needs to set this bit to 0 to release from reset state.
 * |        |          |0 = PDMA controller normal operation.
 * |        |          |1 = PDMA controller reset.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[7]     |CRCRST    |CRC Calculation Controller Reset (Write Protect)
 * |        |          |Set this bit to 1 will generate a reset signal to the CRC calculation controller
 * |        |          |User needs to set this bit to 0 to release from the reset state.
 * |        |          |0 = CRC calculation controller normal operation.
 * |        |          |1 = CRC calculation controller reset.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * @var SYS_T::IPRST1
 * Offset: 0x0C  Peripheral Reset Control Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1]     |GPIORST   |GPIO Controller Reset
 * |        |          |0 = GPIO controller normal operation.
 * |        |          |1 = GPIO controller reset.
 * |[2]     |TMR0RST   |Timer0 Controller Reset
 * |        |          |0 = Timer0 controller normal operation.
 * |        |          |1 = Timer0 controller reset.
 * |[3]     |TMR1RST   |Timer1 Controller Reset
 * |        |          |0 = Timer1 controller normal operation.
 * |        |          |1 = Timer1 controller reset.
 * |[4]     |TMR2RST   |Timer2 Controller Reset
 * |        |          |0 = Timer2 controller normal operation.
 * |        |          |1 = Timer2 controller reset.
 * |[5]     |TMR3RST   |Timer3 Controller Reset
 * |        |          |0 = Timer3 controller normal operation.
 * |        |          |1 = Timer3 controller reset.
 * |[8]     |I2C0RST   |I2C0 Controller Reset
 * |        |          |0 = I2C0 controller normal operation.
 * |        |          |1 = I2C0 controller reset.
 * |[9]     |I2C1RST   |I2C1 Controller Reset
 * |        |          |0 = I2C1 controller normal operation.
 * |        |          |1 = I2C1 controller reset.
 * |[12]    |SPI0RST   |SPI0 Controller Reset
 * |        |          |0 = SPI0 controller normal operation.
 * |        |          |1 = SPI0 controller reset.
 * |[13]    |SPI1RST   |SPI1 Controller Reset
 * |        |          |0 = SPI1 controller normal operation.
 * |        |          |1 = SPI1 controller reset.
 * |[14]    |SPI2RST   |SPI2 Controller Reset
 * |        |          |0 = SPI2 controller normal operation.
 * |        |          |1 = SPI2 controller reset.
 * |[16]    |UART0RST  |UART0 Controller Reset
 * |        |          |0 = UART0 controller normal operation.
 * |        |          |1 = UART0 controller reset.
 * |[27]    |USBDRST   |USBD Controller Reset
 * |        |          |0 = USBD controller normal operation.
 * |        |          |1 = USBD controller reset.
 * |[28]    |EADCRST   |EADC Controller Reset
 * |        |          |0 = EADC controller normal operation.
 * |        |          |1 = EADC controller reset.
 * |[29]    |I2S0RST   |I2S0 Controller Reset
 * |        |          |0 = I2S0 controller normal operation.
 * |        |          |1 = I2S0 controller reset.
 * @var SYS_T::IPRST2
 * Offset: 0x10  Peripheral Reset Control Register 2
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[16]    |PWM0RST   |PWM0 Controller Reset
 * |        |          |0 = PWM0 controller normal operation.
 * |        |          |1 = PWM0 controller reset.
 * @var SYS_T::ALTCTL
 * Offset: 0x14  Miscellaneous Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[23:0]  |MISC      |Miscellaneous Control
 * |        |          |These bits are used for miscellaneous control for R&D testing. (For internal use)
 * @var SYS_T::BODCTL
 * Offset: 0x18  Brown-Out Detector Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BODEN     |Brown-out Detector Enable Bit (Write Protect)
 * |        |          |The default value is set by flash controller user configuration register CBODEN (CONFIG0 [19]).
 * |        |          |0 = Brown-out Detector function Disabled.
 * |        |          |1 = Brown-out Detector function Enabled.
 * |        |          |Note1: The reset value of SYS_BODCTL[3:0] is X00Xb in binary form.
 * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[3]     |BODRSTEN  |Brown-out Reset Enable Bit (Write Protect)
 * |        |          |The default value is set by flash controller user configuration register CBORST(CONFIG0[20]) bit .
 * |        |          |0 = Brown-out ...INTERRUPTu201D function Enabled.
 * |        |          |1 = Brown-out ...RESETu201D function Enabled.
 * |        |          |Note1:
 * |        |          |While the Brown-out Detector function is enabled (BODEN high) and BOD reset function is enabled (BODRSTEN high), BOD will assert a signal to reset chip when the detected voltage is lower than the threshold (BODOUT high).
 * |        |          |While the BOD function is enabled (BODEN high) and BOD interrupt function is enabled (BODRSTEN low), BOD will assert an interrupt if BODOUT is high
 * |        |          |BOD interrupt will keep till to the BODEN set to 0
 * |        |          |BOD interrupt can be blocked by disabling the NVIC BOD interrupt or disabling BOD function (set BODEN low).
 * |        |          |Note2: The reset value of SYS_BODCTL[3:0] is X00Xb in binary form.
 * |        |          |Note3: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[4]     |BODIF     |Brown-out Detector Interrupt Flag
 * |        |          |0 = Brown-out Detector does not detect any voltage draft at VDD down through or up through the voltage of BODVL setting.
 * |        |          |1 = When Brown-out Detector detects the VDD is dropped down through the voltage of BODVL setting or the VDD is raised up through the voltage of BODVL setting, this bit is set to 1 and the brown-out interrupt is requested if brown-out interrupt is enabled.
 * |        |          |Note: Write 1 to clear this bit to 0.
 * |[5]     |BODLPM    |Brown-out Detector Low Power Mode (Write Protect)
 * |        |          |0 = BOD operate in normal mode (default).
 * |        |          |1 = BOD Low Power mode Enabled.
 * |        |          |Note1: The BOD consumes about 100uA in normal mode, the low power mode can reduce the current to about 1/10 but slow the BOD response.
 * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[6]     |BODOUT    |Brown-out Detector Output Status
 * |        |          |0 = Brown-out Detector output status is 0.
 * |        |          |It means the detected voltage is higher than BODVL setting or BODEN is 0.
 * |        |          |1 = Brown-out Detector output status is 1.
 * |        |          |It means the detected voltage is lower than BODVL setting
 * |        |          |If the BODEN is 0, BOD function disabled , this bit always responds 0000.
 * |[7]     |LVREN     |Low Voltage Reset Enable Bit (Write Protect)
 * |        |          |The LVR function resets the chip when the input power voltage is lower than LVR circuit setting
 * |        |          |LVR function is enabled by default.
 * |        |          |0 = Low Voltage Reset function Disabled.
 * |        |          |1 = Low Voltage Reset function Enabled.
 * |        |          |Note1: After enabling the bit, the LVR function will be active with 100us delay for LVR output stable (default).
 * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[10:8]  |BODDGSEL  |Brown-out Detector Output De-glitch Time Select (Write Protect)
 * |        |          |000 = BOD output is sampled by RC10K clock.
 * |        |          |001 = 4 system clock (HCLK).
 * |        |          |010 = 8 system clock (HCLK).
 * |        |          |011 = 16 system clock (HCLK).
 * |        |          |100 = 32 system clock (HCLK).
 * |        |          |101 = 64 system clock (HCLK).
 * |        |          |110 = 128 system clock (HCLK).
 * |        |          |111 = 256 system clock (HCLK).
 * |        |          |Note: These bits are write protected. Refer to the SYS_REGLCTL register.
 * |[14:12] |LVRDGSEL  |LVR Output De-glitch Time Select (Write Protect)
 * |        |          |000 = Without de-glitch function.
 * |        |          |001 = 4 system clock (HCLK).
 * |        |          |010 = 8 system clock (HCLK).
 * |        |          |011 = 16 system clock (HCLK).
 * |        |          |100 = 32 system clock (HCLK).
 * |        |          |101 = 64 system clock (HCLK).
 * |        |          |110 = 128 system clock (HCLK).
 * |        |          |111 = 256 system clock (HCLK).
 * |        |          |Note: These bits are write protected. Refer to the SYS_REGLCTL register.
 * |[18:16] |BODVL     |Brown-out Detector Threshold Voltage Selection (Write Protect)
 * |        |          |The default value is set by flash controller user configuration register CBOV (CONFIG0 [23:21]).
 * |        |          |000 = Brown-Out Detector threshold voltage is 1.6V.
 * |        |          |001 = Brown-Out Detector threshold voltage is 1.8V.
 * |        |          |010 = Brown-Out Detector threshold voltage is 2.0V.
 * |        |          |011 = Brown-Out Detector threshold voltage is 2.0V.
 * |        |          |100 = Brown-Out Detector threshold voltage is 2.4V.
 * |        |          |101 = Brown-Out Detector threshold voltage is 2.6V.
 * |        |          |110 = Brown-Out Detector threshold voltage is 2.8V.
 * |        |          |111 = Brown-Out Detector threshold voltage is 3.0V.
 * |        |          |Note1: The reset value of SYS_BODCTL[19:16] is 0XXXb in binary form.
 * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
 * @var SYS_T::IVSCTL
 * Offset: 0x1C  Internal Voltage Source Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |VTEMPEN   |Temperature Sensor Enable Bit
 * |        |          |This bit is used to enable/disable temperature sensor function.
 * |        |          |0 = Temperature sensor function Disabled (default).
 * |        |          |1 = Temperature sensor function Enabled.
 * |        |          |Note: After this bit is set to 1, the value of temperature sensor output can be obtained from ADC conversion result
 * |        |          |Please refer to ADC function chapter for details.
 * @var SYS_T::PORCTL
 * Offset: 0x24  Power-On-Reset Controller Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |POROFF    |Power-on Reset Enable Bit (Write Protect)
 * |        |          |When powered on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again
 * |        |          |User can disable internal POR circuit to avoid unpredictable noise to cause chip reset by writing 0x5AA5 to this field.
 * |        |          |The POR function will be active again when this field is set to another value or chip is reset by other reset source, including:
 * |        |          |nRESET, Watchdog, LVR reset, BOD reset, ICE reset command and the software-chip reset function.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * @var SYS_T::VREFCTL
 * Offset: 0x28  VREF Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[4:0]   |VREFCTL   |VREF Control Bits (Write Protect)
 * |        |          |10000 = VREF is from AVDD.
 * |        |          |Others = Reserved.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * @var SYS_T::USBPHY
 * Offset: 0x2C  USB PHY Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |USBROLE   |USB Role Option (Write Protect)
 * |        |          |These two bits are used to select the role of USB.
 * |        |          |00 = Standard USB Device mode.
 * |        |          |other = None.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[2]     |SBO       |Note: This bit must always be kept 1. If set to 0, the result is unpredictable
 * |[8]     |USB_PHY_EN|USB PHY Enable (Write Protect)
 * |        |          |This bit is used to enable/disable USB PHY function.
 * |        |          |0 = USB PHY function Disabled (default).
 * |        |          |1 = USB PHY function Enabled.
 * |[23]    |VBUSPULLON|USB1.1 VBUS Pull-down Enable (Write Protect)
 * |        |          |This bit is used to enable/disable VBUS pull-down function.
 * |        |          |0 = VBUS pull-down function Disabled.
 * |        |          |1 = VBUS pull-down function Enabled. (default).
 * @var SYS_T::GPA_MFPL
 * Offset: 0x30  GPIOA Low Byte Multiple Function Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |PA0MFP    |PA.0 Multi-function Pin Selection
 * |[7:4]   |PA1MFP    |PA.1 Multi-function Pin Selection
 * |[11:8]  |PA2MFP    |PA.2 Multi-function Pin Selection
 * |[15:12] |PA3MFP    |PA.3 Multi-function Pin Selection
 * |[19:16] |PA4MFP    |PA.4 Multi-function Pin Selection
 * |[23:20] |PA5MFP    |PA.5 Multi-function Pin Selection
 * |[27:24] |PA6MFP    |PA.6 Multi-function Pin Selection
 * |[31:28] |PA7MFP    |PA.7 Multi-function Pin Selection
 * @var SYS_T::GPA_MFPH
 * Offset: 0x34  GPIOA High Byte Multiple Function Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |PA8MFP    |PA.8 Multi-function Pin Selection
 * |[7:4]   |PA9MFP    |PA.9 Multi-function Pin Selection
 * |[11:8]  |PA10MFP   |PA.10 Multi-function Pin Selection
 * |[15:12] |PA11MFP   |PA.11 Multi-function Pin Selection
 * |[19:16] |PA12MFP   |PA.12 Multi-function Pin Selection
 * |[23:20] |PA13MFP   |PA.13 Multi-function Pin Selection
 * |[27:24] |PA14MFP   |PA.14 Multi-function Pin Selection
 * |[31:28] |PA15MFP   |PA.15 Multi-function Pin Selection
 * @var SYS_T::GPB_MFPL
 * Offset: 0x38  GPIOB Low Byte Multiple Function Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |PB0MFP    |PB.0 Multi-function Pin Selection
 * |[7:4]   |PB1MFP    |PB.1 Multi-function Pin Selection
 * |[11:8]  |PB2MFP    |PB.2 Multi-function Pin Selection
 * |[15:12] |PB3MFP    |PB.3 Multi-function Pin Selection
 * |[19:16] |PB4MFP    |PB.4 Multi-function Pin Selection
 * |[23:20] |PB5MFP    |PB.5 Multi-function Pin Selection
 * |[27:24] |PB6MFP    |PB.6 Multi-function Pin Selection
 * |[31:28] |PB7MFP    |PB.7 Multi-function Pin Selection
 * @var SYS_T::GPB_MFPH
 * Offset: 0x3C  GPIOB High Byte Multiple Function Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |PB8MFP    |PB.8 Multi-function Pin Selection
 * |[7:4]   |PB9MFP    |PB.9 Multi-function Pin Selection
 * |[19:16] |PB12MFP   |PB.12 Multi-function Pin Selection
 * |[23:20] |PB13MFP   |PB.13 Multi-function Pin Selection
 * |[27:24] |PB14MFP   |PB.14 Multi-function Pin Selection
 * @var SYS_T::GPC_MFPL
 * Offset: 0x40  GPIOC Low Byte Multiple Function Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |PC0MFP    |PC.0 Multi-function Pin Selection
 * |[7:4]   |PC1MFP    |PC.1 Multi-function Pin Selection
 * |[11:8]  |PC2MFP    |PC.2 Multi-function Pin Selection
 * |[15:12] |PC3MFP    |PC.3 Multi-function Pin Selection
 * |[19:16] |PC4MFP    |PC.4 Multi-function Pin Selection
 * |[23:20] |PC5MFP    |PC.5 Multi-function Pin Selection
 * |[27:24] |PC6MFP    |PC.6 Multi-function Pin Selection
 * |[31:28] |PC7MFP    |PC.7 Multi-function Pin Selection
 * @var SYS_T::GPC_MFPH
 * Offset: 0x44  GPIOC High Byte Multiple Function Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |PC8MFP    |PC.8 Multi-function Pin Selection
 * |[7:4]   |PC9MFP    |PC.9 Multi-function Pin Selection
 * |[11:8]  |PC10MFP   |PC.10 Multi-function Pin Selection
 * |[15:12] |PC11MFP   |PC.11 Multi-function Pin Selection
 * |[19:16] |PC12MFP   |PC.12 Multi-function Pin Selection
 * |[23:20] |PC13MFP   |PC.13 Multi-function Pin Selection
 * |[27:24] |PC14MFP   |PC.14 Multi-function Pin Selection
 * |[31:28] |PC15MFP   |PC.15 Multi-function Pin Selection
 * @var SYS_T::GPD_MFPL
 * Offset: 0x48  GPIOD Low Byte Multiple Function Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |PD0MFP    |PD.0 Multi-function Pin Selection
 * |[7:4]   |PD1MFP    |PD.1 Multi-function Pin Selection
 * |[11:8]  |PD2MFP    |PD.2 Multi-function Pin Selection
 * |[15:12] |PD3MFP    |PD.3 Multi-function Pin Selection
 * |[19:16] |PD4MFP    |PD.4 Multi-function Pin Selection
 * |[23:20] |PD5MFP    |PD.5 Multi-function Pin Selection
 * |[27:24] |PD6MFP    |PD.6 Multi-function Pin Selection
 * |[31:28] |PD7MFP    |PD.7 Multi-function Pin Selection
 * @var SYS_T::GPD_MFPH
 * Offset: 0x4C  GPIOD High Byte Multiple Function Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |PD8MFP    |PD.8 Multi-function Pin Selection
 * |[7:4]   |PD9MFP    |PD.9 Multi-function Pin Selection
 * |[11:8]  |PD10MFP   |PD.10 Multi-function Pin Selection
 * |[15:12] |PD11MFP   |PD.11 Multi-function Pin Selection
 * |[19:16] |PD12MFP   |PD.12 Multi-function Pin Selection
 * |[23:20] |PD13MFP   |PD.13 Multi-function Pin Selection
 * |[27:24] |PD14MFP   |PD.14 Multi-function Pin Selection
 * |[31:28] |PD15MFP   |PD.15 Multi-function Pin Selection
 * @var SYS_T::SRAM_INTCTL
 * Offset: 0xC0  System SRAM Interrupt Enable Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PERRIEN   |SRAM Parity Check Error Interrupt Enable Bit
 * |        |          |0 = SRAM parity check error interrupt Disabled.
 * |        |          |1 = SRAM parity check error interrupt Enabled. 
 * @var SYS_T::SRAM_STATUS
 * Offset: 0xC4  System SRAM Parity Error Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PERRIF    |SRAM Parity Check Error Flag
 * |        |          |This bit indicates the System SRAM parity error occurred. Write 1 to clear this to 0.
 * |        |          |0 = No System SRAM parity error.
 * |        |          |1 = System SRAM parity error occur.
 * @var SYS_T::SRAM_ERRADDR
 * Offset: 0xC8  System SRAM Parity Check Error Address Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |ERRADDR   |System SRAM Parity Error Address
 * |        |          |This register shows system SRAM parity error byte address.
 * @var SYS_T::SRAM_BISTCTL
 * Offset: 0xD0  System SRAM BIST Test Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |SRBIST0   |SRAM Bank0 BIST Enable Bit (Write Protect)
 * |        |          |This bit enables BIST test for SRAM bank0.
 * |        |          |0 = system SRAM bank0 BIST Disabled.
 * |        |          |1 = system SRAM bank0 BIST Enabled.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[1]     |SRBIST1   |SRAM Bank1 BIST Enable Bit (Write Protect)
 * |        |          |This bit enables BIST test for SRAM bank1.
 * |        |          |0 = system SRAM bank1 BIST Disabled.
 * |        |          |1 = system SRAM bank1 BIST Enabled.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * @var SYS_T::SRAM_BISTSTS
 * Offset: 0xD4  System SRAM BIST Test Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |SRBISTEF0 |1st System SRAM BIST Fail Flag
 * |        |          |0 = 1st system SRAM BIST test pass.
 * |        |          |1 = 1st system SRAM BIST test fail.
 * |[1]     |SRBISTEF1 |2nd System SRAM BIST Fail Flag
 * |        |          |0 = 2nd system SRAM BIST test pass.
 * |        |          |1 = 2nd system SRAM BIST test fail.
 * |[16]    |SRBEND0   |1st SRAM BIST Test Finish
 * |        |          |0 = 1st system SRAM BIST active.
 * |        |          |1 =1st system SRAM BIST finish. 
 * |[17]    |SRBEND1   |2nd SRAM BIST Test Finish
 * |        |          |0 = 2nd system SRAM BIST is active.
 * |        |          |1 = 2nd system SRAM BIST finish. 
 * @var SYS_T::SRAM_PARITY
 * Offset: 0xD8  System SRAM Parity Test Control Register (Only for Testing)
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PTESTEN   |SRAM Parity Test Mode Enable Bit (Write Protect)
 * |        |          |0: SRAM parity test mode Disabled
 * |        |          |1: SRAM parity test mode Enabled.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[7:4]   |PTESTPB   |SRAM Test Mode Parity Bit (Write Protect)
 * |        |          |When SRAM test mode is disabled, the parity bit is calculated by even parity generate circuit for each SRAM write action.
 * |        |          |When SRAM test mode is enabled, the parity bit is replace by TEST_PB for each SRAM write action
 * |        |          |The four bit TEST_PB are corresponding mapping to the four byte in a word.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * @var SYS_T::IRCTCTL
 * Offset: 0xF0  HIRC Trim Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |FREQSEL   |Trim Frequency Selection
 * |        |          |This field indicates the target frequency of 12 MHz internal high speed RC oscillator (HIRC) auto trim.
 * |        |          |During auto trim operation, if clock error detected with CESTOPEN is set to 1 or trim retry limitation count reached, this field will be cleared to 00 automatically.
 * |        |          |00 = Disable HIRC auto trim function.
 * |        |          |01 = Enable HIRC auto trim function and trim HIRC to 12 MHz.
 * |        |          |10 = Reserved.
 * |        |          |11 = Reserved.
 * |[5:4]   |LOOPSEL   |Trim Calculation Loop Selection
 * |        |          |This field defines that trim value calculation is based on how many reference clocks.
 * |        |          |00 = Trim value calculation is based on average difference in 4 clocks of reference clock.
 * |        |          |01 = Trim value calculation is based on average difference in 8 clocks of reference clock.
 * |        |          |10 = Trim value calculation is based on average difference in 16 clocks of reference clock.
 * |        |          |11 = Trim value calculation is based on average difference in 32 clocks of reference clock.
 * |        |          |Note: For example, if LOOPSEL is set as 00, auto trim circuit will calculate trim value based on the average frequency difference in 4 clocks of reference clock.
 * |[7:6]   |RETRYCNT  |Trim Value Update Limitation Count
 * |        |          |This field defines that how many times the auto trim circuit will try to update the HIRC trim value before the frequency of HIRC locked.
 * |        |          |Once the HIRC locked, the internal trim value update counter will be reset.
 * |        |          |If the trim value update counter reached this limitation value and frequency of HIRC still doesn't lock, the auto trim operation will be disabled and FREQSEL will be cleared to 00.
 * |        |          |00 = Trim retry count limitation is 64 loops.
 * |        |          |01 = Trim retry count limitation is 128 loops.
 * |        |          |10 = Trim retry count limitation is 256 loops.
 * |        |          |11 = Trim retry count limitation is 512 loops.
 * |[8]     |CESTOPEN  |Clock Error Stop Enable Bit
 * |        |          |0 = The trim operation is keep going if clock is inaccuracy.
 * |        |          |1 = The trim operation is stopped if clock is inaccuracy.
 * |[10]    |REFCKSEL  |Reference Clock Selection
 * |        |          |0 = HIRC trim reference clock is from LXT (32.768 kHz).
 * |        |          |1 = HIRC trim reference clock is from USB SOF (Start-Of-Frame) packet.
 * |        |          |Note: HIRC trim reference clock is 20Khz in test mode.
 * |[11]    |IGNORE    |Ignore HIRC Unstable Period Selection
 * |        |          |0 = Enable function of ignoring the counting cycles in HIRC unstable period.
 * |        |          |1 = Disable function of ignoring the counting cycles in HIRC unstable period.
 * |        |          |Note: For the current version of HIRC12M, its clock frequency will shift when trim bits change from 0 to 1 or 1 to 0
 * |        |          |To solve this problem, RC_TRIM ignore the counting clock of unstable HIRC clock period to prevent trim bit Inaccuracies.
 * @var SYS_T::IRCTIEN
 * Offset: 0xF4  HIRC Trim Interrupt Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1]     |TFAILIEN  |Trim Failure Interrupt Enable Bit
 * |        |          |This bit controls if an interrupt will be triggered while HIRC trim value update limitation count reached and HIRC frequency still not locked on target frequency set by FREQSEL(SYS_IRCTCTL[1:0]).
 * |        |          |If this bit is high and TFAILIF(SYS_IRCTSTS[1]) is set during auto trim operation, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached.
 * |        |          |0 = Disable TFAILIF(SYS_IRCTSTS[1]) status to trigger an interrupt to CPU.
 * |        |          |1 = Enable TFAILIF(SYS_IRCTSTS[1]) status to trigger an interrupt to CPU.
 * |[2]     |CLKEIEN   |Clock Error Interrupt Enable Bit
 * |        |          |This bit controls if CPU would get an interrupt while clock is inaccuracy during auto trim operation.
 * |        |          |If this bit is set to1, and CLKERRIF(SYS_IRCTSTS[2]) is set during auto trim operation, an interrupt will be triggered to notify the clock frequency is inaccuracy.
 * |        |          |0 = Disable CLKERRIF(SYS_IRCTSTS[2]) status to trigger an interrupt to CPU.
 * |        |          |1 = Enable CLKERRIF(SYS_IRCTSTS[2]) status to trigger an interrupt to CPU.
 * @var SYS_T::IRCTISTS
 * Offset: 0xF8  HIRC Trim Interrupt Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |FREQLOCK  |HIRC Frequency Lock Status
 * |        |          |This bit indicates the HIRC frequency is locked.
 * |        |          |This is a status bit and doesn't trigger any interrupt
 * |        |          |Write 1 to clear this to 0
 * |        |          |This bit will be set automatically, if the frequecy is lock and the RC_TRIM is enabled.0 = The internal high-speed oscillator frequency doesn't lock at 12 MHz yet.
 * |        |          |1 = The internal high-speed oscillator frequency locked at 12 MHz.
 * |[1]     |TFAILIF   |Trim Failure Interrupt Status
 * |        |          |This bit indicates that HIRC trim value update limitation count reached and the HIRC clock frequency still doesn't be locked
 * |        |          |Once this bit is set, the auto trim operation stopped and FREQSEL(SYS_iRCTCTL[1:0]) will be cleared to 00 by hardware automatically.
 * |        |          |If this bit is set and TFAILIEN(SYS_IRCTIEN[1]) is high, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached
 * |        |          |Write 1 to clear this to 0.
 * |        |          |0 = Trim value update limitation count does not reach.
 * |        |          |1 = Trim value update limitation count reached and HIRC frequency still not locked.
 * |[2]     |CLKERRIF  |Clock Error Interrupt Status
 * |        |          |When the frequency of 32.768 kHz external low speed crystal oscillator (LXT) or 12MHz internal high speed RC oscillator (HIRC) is shift larger to unreasonable value, this bit will be set and to be an indicate that clock frequency is inaccuracy
 * |        |          |Once this bit is set to 1, the auto trim operation stopped and FREQSEL(SYS_IRCTCL[1:0]) will be cleared to 00 by hardware automatically if CESTOPEN(SYS_IRCTCTL[8]) is set to 1.
 * |        |          |If this bit is set and CLKEIEN(SYS_IRCTIEN[2]) is high, an interrupt will be triggered to notify the clock frequency is inaccuracy
 * |        |          |Write 1 to clear this to 0.
 * |        |          |0 = Clock frequency is accuracy.
 * |        |          |1 = Clock frequency is inaccuracy.
 * @var SYS_T::REGLCTL
 * Offset: 0x100  Register Lock Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[7:0]   |REGLCTL   |Register Lock Control Code (Write Only)
 * |        |          |Some registers have write-protection function
 * |        |          |Writing these registers have to disable the protected function by writing the sequence value ...59hu201D, ...16hu201D, ...88hu201D to this field
 * |        |          |After this sequence is completed, the REGLCTL bit will be set to 1 and write-protection registers can be normal write.
 * |        |          |Register Lock Control Disable Index (Read Only)
 * |        |          |0 = Write-protection Enabled for writing protected registers
 * |        |          |Any write to the protected register is ignored.
 * |        |          |1 = Write-protection Disabled for writing protected registers.
 * |        |          |The Protected registers are:
 * |        |          |SYS_IPRST0: address 0x4000_0008
 * |        |          |SYS_BODCTL: address 0x4000_0018
 * |        |          |SYS_PORCTL: address 0x4000_0024
 * |        |          |SYS_USBPHY: address 0x4000_002C
 * |        |          |CLK_PWRCTL: address 0x4000_0200 (bit[6] is not protected for power-down wake-up interrupt clear)
 * |        |          |SYS_SRAM_BISTCTL: address 0x4000_00D0
 * |        |          |SYS_SRAM_PARITY: address 0x4000_00D8 [PP1]
 * |        |          |SYS_RCADJ: address 0x4000_0110
 * |        |          |CLK_APBCLK0 [0]: address 0x4000_0208 (bit[0] is watchdog clock enable)
 * |        |          |CLK_CLKSEL0: address 0x4000_0210 (for HCLK and CPU STCLK clock source select)
 * |        |          |CLK_CLKSEL1 [1:0]: address 0x4000_0214 (for watchdog clock source select)
 * |        |          |CLK_CLKSEL1 [31:30]: address 0x4000_0214 (for window watchdog clock source select)
 * |        |          |CLK_CLKDSTS: address 0x4000_0274
 * |        |          |NMIEN: address 0x4000_0300
 * |        |          |FMC_ISPCTL: address 0x4000_C000 (Flash ISP Control register)
 * |        |          |FMC_ISPTRG: address 0x4000_C010 (ISP Trigger Control register)
 * |        |          |FMC_ISPSTS: address 0x4000_C040
 * |        |          |WDT_CTL: address 0x4004_0000
 * |        |          |FMC_FTCTL: address 0x4000_5018
 * |        |          |FMC_ICPCMD: address 0x4000_501C
 * |        |          |EADC_TEST: address 0x4004_3200
 * |        |          |AHBMCTL: address 0x40000400
 * |        |          |CLK_PLLCTL: address 0x40000240
 * |        |          |SYS_ALTCTL: address 0x4000_0014
 * |        |          |PWM_CTL0: address 0x4005_8000
 * |        |          |PWM_CTL0: address 0x4005_9000
 * |        |          |PWM_DTCTL0_1: address 0x4005_8070
 * |        |          |PWM_DTCTL0_1: address 0x4005_9070
 * |        |          |PWM_DTCTL2_3: address 0x4005_8074
 * |        |          |PWM_DTCTL2_3: address 0x4005_9074
 * |        |          |PWM_DTCTL4_5: address 0x4005_8078
 * |        |          |PWM_DTCTL4_5: address 0x4005_9078
 * |        |          |PWM_BRKCTL0_1: address 0x4005_80C8
 * |        |          |PWM_BRKCTL0_1: address 0x4005_90C8
 * |        |          |PWM_BRKCTL2_3: address 0x4005_80CC
 * |        |          |PWM_BRKCTL2_3: address 0x4005_90CC
 * |        |          |PWM_BRKCTL4_5: address 0x4005_80D0
 * |        |          |PWM_BRKCTL4_5: address 0x4005_90D0
 * |        |          |PWM_INTEN1: address 0x4005_80E4
 * |        |          |PWM_INTEN1: address 0x4005_90E4
 * |        |          |PWM_INTSTS1: address 0x4005_80EC
 * |        |          |PWM_INTSTS1: address 0x4005_90EC
 * |        |          |PWM_SELFTEST: address 0x4005_8300
 * |        |          |PWM_SELFTEST: address 0x4005_9300
 * |        |          |[PP1]Not released in TRM
 * @var SYS_T::RCADJ
 * Offset: 0x110  HIRC Trim Value Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:0]   |RCADJ     |RC12M Trim Value (Write Protect)
 * |        |          |This bit is the protected bit, which means programming it needs to write ...59hu201D, ...16hu201D, ...88hu201D to address 0x5000_0100 to disable register protection
 * |        |          |Refer to the register SYS_REGLCTL at address SYS_BA+0x100.
 * |        |          |This field reflects the RC12M trim value.
 * |        |          |Software can update RC12m trim value by writing this field.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * @var SYS_T::TSOFFSET
 * Offset: 0x114  Temperature sensor offset Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[11:0]  |VTEMP     |Temperature Sensor Offset Value
 * |        |          |This field reflects temperature sensor output voltage offset at 25oC.
 * @var SYS_T::LDOTRIM
 * Offset: 0x120  LDO Trim Code Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[5:0]   |LDOTRIM   |LDO Trim Code Value
 * |        |          |This field reflects factory LDO trim code. (for internal use only) 
 * @var SYS_T::LDOLVT
 * Offset: 0x130  Main LDO Low Voltage Trim Code Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[4:0]   |LDOLVTRIM |Main LDO Low Voltage Trim Code Value
 * |        |          |This field reflects factory LDO low voltage trim code. (for internal use only) 
 * @var SYS_T::LDOHVT
 * Offset: 0x134  Main LDO High Voltage Trim Code Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[4:0]   |LDOHVTRIM |Main LDO High Voltage Trim Code Value
 * |        |          |This field reflects factory LDO high voltage trim code. (for internal use only)
 * @var SYS_T::LIRCT
 * Offset: 0x138  Low Speed Internal Oscillator Trim Code Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[2:0]   |LIRCTRIM  |Low Speed Internal Oscillator Trim Code Value
 * |        |          |This field reflects factory low speed internal oscillator adjust code. (for internal use only) 
 * |[16]    |LIRCTEN   |Low Speed Internal Oscillator Test Mode Enable Bit
 * |        |          |0 = Low Speed Internal Oscillator Internal test mode Disabled.
 * |        |          |1 = Low Speed Internal Oscillator Internal test mode Enabled.
 * |        |          |When internal test mode enabled, GP?.? & GP?.? should add 10K resister to VDD to provide current for testing
 * @var SYS_T::LDOEAT
 * Offset: 0x168  LDO Error Amplifier Trim Code Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |LDOEAT    |LDO Error Amplifier Trim Code Value
 * |        |          |This field reflects factory LDO error amplifier trim code. (for internal use only) 
 * |[18:16] |LDO_MODE  |LDO Operation Mode
 * |        |          |000 = Normal.
 * |        |          |001 = Low-power.
 * |        |          |010 = Normal Power down.
 * |        |          |011 = Low-power Power down.
 * |        |          |100 = Retention.
 * |        |          |101 = Standby Power-down.
 * |        |          |110 = Reserved.
 * |        |          |111 = Deep Power-down.
 * |[24]    |SW_LDO_PU |Software Switch LDO Operation Mode Power Up
 * |        |          |Set LDO operation Mode to Normal run mode (000)
 * |[25]    |SW_LDO_PD |Software Switch LDO Operation Mode Power Down
 * |        |          |Write one to update LDO Operation Mode to Macro
 * |[26]    |LDOSET_BYPASS|LDE Operation Mode Bypass
 * |        |          |Bypass LDO Operation Mode to LDO macro
 * @var SYS_T::LDOMDSL
 * Offset: 0x16C  LDO Mode Select Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |LDOMD     |LDO Mode Select
 * |        |          |000 = MLDO is enable, SLDO is enable,.
 * |        |          |001 =.
 * |        |          |010 =.
 * |        |          |011 =.
 * |        |          |100 =.
 * |        |          |101 =.
 * |        |          |110 =.
 * |        |          |111 =.
 * |[7]     |LDOMDTEN  |LDO Mode Test Enable Bit
 * |        |          |0 = LDO mode select working normally.
 * |        |          |1 = LDO mode select is controlled by LDOMD when entering DPD or SPD mode. 
 * @var SYS_T::TCHIPCTL
 * Offset: 0x180  Test Chip Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |LIRC2EN   |LIRC 2 Enable Bit
 * |        |          |0 = Low speed internal oscillator Disabled.
 * |        |          |1 = Low speed internal oscillator Enabled.
 * |[1]     |HVLIRC2EN |High Voltage LIRC 2 Enable Bit
 * |        |          |0 = High Voltage Low speed internal oscillator Disabled.
 * |        |          |1 = High Voltage Low speed internal oscillator Enabled.
 * |[8]     |RTCLDOEN  |RTC LDO Enable Bit
 * |        |          |0 = RTC LDO Disabled.
 * |        |          |1 = RTC LDO Enabled.
 * |[16]    |TEMP12TE  |Temperature Sensor (1.2V) Test Mode Enable Bit
 * |        |          |When Temperature sensor (1.2V) analog macro test mode enable, the temperature sensor output voltage can be monitored by GPB.5
 * |        |          |0 = Temperature sensor test mode Disabled.
 * |        |          |1 = Temperature sensor test mode Enabled.
 * |[17]    |TEMP33TE  |Temperature Sensor (3.3V) Test Mode Enable Bit
 * |        |          |When Temperature sensor (3.3V) analog macro test mode enable, the temperature sensor output voltage can be monitored by GPB.6
 * |        |          |0 = Temperature sensor test mode Disabled.
 * |        |          |1 = Temperature sensor test mode Enabled.
 * |[18]    |VBATD2TE  |VBAT Divide 2 Test Mode Enable Bit
 * |        |          |When VBAT Divide 2 analog macro test mode enable, the half voltage of VBAT can be monitored by GPB.7
 * |        |          |0 = VBAT Divide 2 test mode Disabled.
 * |        |          |1 = VBAT Divide 2 test mode Enabled.
 * |[19]    |VBGTE     |Bandgap Test Mode Enable Bit
 * |        |          |When bandgap analog macro test mode enable, the bandgap voltage can be monitored by GPB.0
 * |        |          |0 = Bandgap test mode Disabled.
 * |        |          |1 = Bandgap test mode Enabled.
 * |[20]    |MBIASTE   |MEGBIAS Test Mode Enable Bit
 * |        |          |When MEGBIAS analog macro test mode enable, the switch control output signal is controlled by GPC.11
 * |        |          |0 = MEGBIAS test mode Disabled.
 * |        |          |1 = MEGBIAS test mode Enabled.
 * @var SYS_T::SRAMRMC
 * Offset: 0x184  SRAM Read Margin Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |RM        |Read Margin Value
 * |        |          |When SRAM read margin mode enable, user can set this field to control system SRAM read margin value
 * |        |          |Default is 0111 for Synopsys default value.
 * |[7]     |RMEN      |Read Margin Enable Bit
 * |        |          |When SRAM read margin mode enable, user can set system SRAM read margin value by RM[3:0].
 * |        |          |0 = SRAM read margin mode Disabled.
 * |        |          |1 = SRAM read margin mode Enabled.
 * |[11:8]  |RM_P      |PARITY RAM Read Margin Value
 * |        |          |When PARITY SRAM read margin mode enable, user can set this field to control system PARITY SRAM read margin value
 * |        |          |Default is 0111 for Synopsys default value.
 * |[15]    |RMEN_P    |PARITY RAM Read Margin Enable Bit
 * |        |          |When PARITY SRAM read margin mode enable, user can set system PARITY SRAM read margin value by RM[3:0].
 * |        |          |0 = SRAM read margin mode Disabled.
 * |        |          |1 = SRAM read margin mode Enabled.
 * @var SYS_T::HIRCTCTL
 * Offset: 0x188  HIRC Test Mode Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |RS        |Resister Select Control
 * |        |          |This bit field is used to control internal resister for HIRC frequency adjusting
 * |        |          |Default value is 10
 * |[5:4]   |CS        |Capcitance Select Control
 * |        |          |This bit field is used to control internal capcitance for HIRC frequency adjusting
 * |        |          |Default value is 00
 * |[10:8]  |PTC       |Postive Tc Adjust
 * |        |          |This bit field is used to control positive tc for HIRC frequency adjusting
 * |        |          |Default value is 100
 * |[14:12] |NTC       |Nagtive Tc Adjust
 * |        |          |This bit field is used to control negaitive tc for HIRC frequency adjusting
 * |        |          |Default value is 100
 * |[16]    |X2        |Adjust Charging Current
 * |        |          |This bit field is used to adjust HIRC charging current
 * |        |          |Default value is 1
 * @var SYS_T::HIRC2TCTL
 * Offset: 0x18C  HIRC2 Test Mode Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |HIRCBK_EN |Backup OSC12M Enable (Write Protect)
 * |        |          |This bit is used to enable Backup OSC12M.
 * |[1]     |HIRCBK_GATE_EN|Backup OSC12M Gating Clock Enable (Write Protect)
 * |        |          |This bit is used to gate Backup OSC12M to 0.
 * |[4]     |BGEN_OLDO |MEGBIAS Backup OSC12M Band Gap Enalbe (Write Protect)
 * |        |          |This bit is used to enable MEGBIAS Backup OSC12M band gap circuit.
 * |[5]     |OLDO_EN   |Backup OSC12M LDO Enalbe (Write Protect)
 * |        |          |This bit is used to enable Backup OSC12M LDO.
 * |[10:8]  |PTC       |Postive Tc Adjust (Write Protect)
 * |        |          |This field is used to control positive tc for Backup OSC12M frequency adjusting
 * |        |          |Default value is 100
 * |[14:12] |NTC       |Nagtive Tc Adjust (Write Protect)
 * |        |          |This field is used to control negaitive tc for Backup OSC12M frequency adjusting
 * |        |          |Default value is 011
 * |[24:16] |RCADJ     |RC12M Trim Value (Write Protect)
 * |        |          |This bit is the protected bit, which means programming it needs to write ...59hu201D, ...16hu201D, ...88hu201D to address 0x5000_0100 to disable register protection
 * |        |          |Refer to the register SYS_REGLCTL at address SYS_BA+0x100.
 * |        |          |This field reflects the RC12M trim value.
 * |        |          |Software can update RC12m trim value by writing this field.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[31]    |HIRCBKSL  |HIRC Backup Source Select (Write Protect)
 * |        |          |0: Default OSC12M (OSC12M_T055_00) as system HIRC
 * |        |          |1: Backup OSC12M (OSC12M_T055_01) as system HIRC
 * @var SYS_T::HXTTCTL
 * Offset: 0x190  HXT Test Mode Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |SCHTEST   |HXT Schmitt Trigger Test Mode Enable (Write Protect)
 * |        |          |0: HXT Schmitt Trigger Mode Disable
 * |        |          |1: HXT Schmitt Trigger Mode Enable
 * |        |          |When this bit set to 1, the ??? (CR30 TM)
 * @var SYS_T::ACMPTCTL
 * Offset: 0x194  ACMP Test Mode Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var SYS_T::USBTCTL
 * Offset: 0x198  USB Test Chip Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |USB20PHY_CHIP_EN|USB20PHY CHIP Enable Control (Write Protect)
 * |        |          |0: USB20PHY CHIP Disable
 * |        |          |1: USB20PHY CHIP Enable 
 * |[1]     |USB20PHY_OFF|USB PHY Disable Control (Write Protect)
 * |        |          |0: USB PHY Enable
 * |        |          |1: USB PHY Disable
 * @var SYS_T::BLOPTION
 * Offset: 0x1C0  Boot Loader Option Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var SYS_T::ETMCTL
 * Offset: 0x1F0  ETM Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 */
    __I  uint32_t PDID;                  /*!< [0x0000] Part Device Identification Number Register                       */
    __IO uint32_t RSTSTS;                /*!< [0x0004] System Reset Status Register                                     */
    __IO uint32_t IPRST0;                /*!< [0x0008] Peripheral  Reset Control Register 0                             */
    __IO uint32_t IPRST1;                /*!< [0x000c] Peripheral Reset Control Register 1                              */
    __IO uint32_t IPRST2;                /*!< [0x0010] Peripheral Reset Control Register 2                              */
    __IO uint32_t ALTCTL;                /*!< [0x0014] Miscellaneous Control Register                                   */
    __IO uint32_t BODCTL;                /*!< [0x0018] Brown-Out Detector Control Register                              */
    __IO uint32_t IVSCTL;                /*!< [0x001c] Internal Voltage Source Control Register                         */
    __I  uint32_t RESERVE0[1];
    __IO uint32_t PORCTL;                /*!< [0x0024] Power-On-Reset Controller Register                               */
    __IO uint32_t VREFCTL;               /*!< [0x0028] VREF Control Register                                            */
    __IO uint32_t USBPHY;                /*!< [0x002c] USB PHY Control Register                                         */
    __IO uint32_t GPA_MFPL;              /*!< [0x0030] GPIOA Low Byte Multiple Function Control Register                */
    __IO uint32_t GPA_MFPH;              /*!< [0x0034] GPIOA High Byte Multiple Function Control Register               */
    __IO uint32_t GPB_MFPL;              /*!< [0x0038] GPIOB Low Byte Multiple Function Control Register                */
    __IO uint32_t GPB_MFPH;              /*!< [0x003c] GPIOB High Byte Multiple Function Control Register               */
    __IO uint32_t GPC_MFPL;              /*!< [0x0040] GPIOC Low Byte Multiple Function Control Register                */
    __IO uint32_t GPC_MFPH;              /*!< [0x0044] GPIOC High Byte Multiple Function Control Register               */
    __IO uint32_t GPD_MFPL;              /*!< [0x0048] GPIOD Low Byte Multiple Function Control Register                */
    __IO uint32_t GPD_MFPH;              /*!< [0x004c] GPIOD High Byte Multiple Function Control Register               */
    __IO uint32_t RESERVE1[28];
    __IO uint32_t SRAM_INTCTL;           /*!< [0x00c0] System SRAM Interrupt Enable Control Register                    */
    __IO uint32_t SRAM_STATUS;           /*!< [0x00c4] System SRAM Parity Error Status Register                         */
    __I  uint32_t SRAM_ERRADDR;          /*!< [0x00c8] System SRAM Parity Check Error Address Register                  */
    __I  uint32_t RESERVE2[1];
    __IO uint32_t SRAM_BISTCTL;          /*!< [0x00d0] System SRAM BIST Test Control Register                           */
    __I  uint32_t SRAM_BISTSTS;          /*!< [0x00d4] System SRAM BIST Test Status Register                            */
    __IO uint32_t SRAM_PARITY;           /*!< [0x00d8] System SRAM Parity Test Control Register (Only for Testing)      */
    __I  uint32_t RESERVE3[5];
    __IO uint32_t IRCTCTL;               /*!< [0x00f0] HIRC Trim Control Register                                       */
    __IO uint32_t IRCTIEN;               /*!< [0x00f4] HIRC Trim Interrupt Enable Register                              */
    __IO uint32_t IRCTISTS;              /*!< [0x00f8] HIRC Trim Interrupt Status Register                              */
    __I  uint32_t RESERVE4[1];
    __O  uint32_t REGLCTL;               /*!< [0x0100] Register Lock Control Register                                   */
    __I  uint32_t RESERVE5[3];
    __IO uint32_t RCADJ;                 /*!< [0x0110] HIRC Trim Value Register                                         */
    __I  uint32_t TSOFFSET;              /*!< [0x0114] Temperature sensor offset Register                               */
    __IO uint32_t HIRC_TC;							 /*   [0x0118] HIRC TC, added by OhadR */
		__I  uint32_t RESERVE6[1];
    __IO uint32_t LDOTRIM;               /*!< [0x0120] LDO Trim Code Register                                           */
    __I  uint32_t RESERVE7[2];
		__IO uint32_t RLDOTRIM;							 /*  [0x012C] LIRC LDO Trim, added by OhadR */
    __IO uint32_t LDOLVT;                /*!< [0x0130] Main LDO Low Voltage Trim Code Register                          */
    __IO uint32_t LDOHVT;                /*!< [0x0134] Main LDO High Voltage Trim Code Register                         */
    __IO uint32_t LIRCT;                 /*!< [0x0138] Low Speed Internal Oscillator Trim Code Register                 */
    __I  uint32_t RESERVE8[11];
    __I  uint32_t LDOEAT;                /*!< [0x0168] LDO Error Amplifier Trim Code Register                           */
    __I  uint32_t LDOMDSL;               /*!< [0x016c] LDO Mode Select Register                                         */
    __I  uint32_t RESERVE9[4];
    __IO uint32_t TCHIPCTL;              /*!< [0x0180] Test Chip Control Register                                       */
    __IO uint32_t SRAMRMC;               /*!< [0x0184] SRAM Read Margin Control Register                                */
    __IO uint32_t HIRCTCTL;              /*!< [0x0188] HIRC Test Mode Control Register                                  */
    __IO uint32_t HIRC2TCTL;             /*!< [0x018c] HIRC2 Test Mode Control Register                                 */
    __IO uint32_t HXTTCTL;               /*!< [0x0190] HXT Test Mode Control Register                                   */
    __IO uint32_t ACMPTCTL;              /*!< [0x0194] ACMP Test Mode Control Register                                  */
    __IO uint32_t USBTCTL;               /*!< [0x0198] USB Test Chip Control Register                                   */
    __I  uint32_t RESERVE10[9];
    __IO uint32_t BLOPTION;              /*!< [0x01c0] Boot Loader Option Register                                      */
    __I  uint32_t RESERVE11[11];
    __IO uint32_t ETMCTL;                /*!< [0x01f0] ETM Control Register                                             */

} SYS_T;

/**
    @addtogroup SYS_CONST SYS Bit Field Definition
    Constant Definitions for SYS Controller
@{ */

#define SYS_PDID_PDID_Pos                (0)                                               /*!< SYS_T::PDID: PDID Position             */
#define SYS_PDID_PDID_Msk                (0xfffffffful << SYS_PDID_PDID_Pos)               /*!< SYS_T::PDID: PDID Mask                 */

#define SYS_RSTSTS_PORF_Pos              (0)                                               /*!< SYS_T::RSTSTS: PORF Position           */
#define SYS_RSTSTS_PORF_Msk              (0x1ul << SYS_RSTSTS_PORF_Pos)                    /*!< SYS_T::RSTSTS: PORF Mask               */

#define SYS_RSTSTS_PINRF_Pos             (1)                                               /*!< SYS_T::RSTSTS: PINRF Position          */
#define SYS_RSTSTS_PINRF_Msk             (0x1ul << SYS_RSTSTS_PINRF_Pos)                   /*!< SYS_T::RSTSTS: PINRF Mask              */

#define SYS_RSTSTS_WDTRF_Pos             (2)                                               /*!< SYS_T::RSTSTS: WDTRF Position          */
#define SYS_RSTSTS_WDTRF_Msk             (0x1ul << SYS_RSTSTS_WDTRF_Pos)                   /*!< SYS_T::RSTSTS: WDTRF Mask              */

#define SYS_RSTSTS_LVRF_Pos              (3)                                               /*!< SYS_T::RSTSTS: LVRF Position           */
#define SYS_RSTSTS_LVRF_Msk              (0x1ul << SYS_RSTSTS_LVRF_Pos)                    /*!< SYS_T::RSTSTS: LVRF Mask               */

#define SYS_RSTSTS_BODRF_Pos             (4)                                               /*!< SYS_T::RSTSTS: BODRF Position          */
#define SYS_RSTSTS_BODRF_Msk             (0x1ul << SYS_RSTSTS_BODRF_Pos)                   /*!< SYS_T::RSTSTS: BODRF Mask              */

#define SYS_RSTSTS_SYSRF_Pos             (5)                                               /*!< SYS_T::RSTSTS: SYSRF Position          */
#define SYS_RSTSTS_SYSRF_Msk             (0x1ul << SYS_RSTSTS_SYSRF_Pos)                   /*!< SYS_T::RSTSTS: SYSRF Mask              */

#define SYS_RSTSTS_CPURF_Pos             (7)                                               /*!< SYS_T::RSTSTS: CPURF Position          */
#define SYS_RSTSTS_CPURF_Msk             (0x1ul << SYS_RSTSTS_CPURF_Pos)                   /*!< SYS_T::RSTSTS: CPURF Mask              */

#define SYS_RSTSTS_CPULKRF_Pos           (8)                                               /*!< SYS_T::RSTSTS: CPULKRF Position        */
#define SYS_RSTSTS_CPULKRF_Msk           (0x1ul << SYS_RSTSTS_CPULKRF_Pos)                 /*!< SYS_T::RSTSTS: CPULKRF Mask            */

#define SYS_IPRST0_CHIPRST_Pos           (0)                                               /*!< SYS_T::IPRST0: CHIPRST Position        */
#define SYS_IPRST0_CHIPRST_Msk           (0x1ul << SYS_IPRST0_CHIPRST_Pos)                 /*!< SYS_T::IPRST0: CHIPRST Mask            */

#define SYS_IPRST0_CPURST_Pos            (1)                                               /*!< SYS_T::IPRST0: CPURST Position         */
#define SYS_IPRST0_CPURST_Msk            (0x1ul << SYS_IPRST0_CPURST_Pos)                  /*!< SYS_T::IPRST0: CPURST Mask             */

#define SYS_IPRST0_PDMARST_Pos           (2)                                               /*!< SYS_T::IPRST0: PDMARST Position        */
#define SYS_IPRST0_PDMARST_Msk           (0x1ul << SYS_IPRST0_PDMARST_Pos)                 /*!< SYS_T::IPRST0: PDMARST Mask            */

#define SYS_IPRST0_CRCRST_Pos            (7)                                               /*!< SYS_T::IPRST0: CRCRST Position         */
#define SYS_IPRST0_CRCRST_Msk            (0x1ul << SYS_IPRST0_CRCRST_Pos)                  /*!< SYS_T::IPRST0: CRCRST Mask             */

#define SYS_IPRST1_GPIORST_Pos           (1)                                               /*!< SYS_T::IPRST1: GPIORST Position        */
#define SYS_IPRST1_GPIORST_Msk           (0x1ul << SYS_IPRST1_GPIORST_Pos)                 /*!< SYS_T::IPRST1: GPIORST Mask            */

#define SYS_IPRST1_TMR0RST_Pos           (2)                                               /*!< SYS_T::IPRST1: TMR0RST Position        */
#define SYS_IPRST1_TMR0RST_Msk           (0x1ul << SYS_IPRST1_TMR0RST_Pos)                 /*!< SYS_T::IPRST1: TMR0RST Mask            */

#define SYS_IPRST1_TMR1RST_Pos           (3)                                               /*!< SYS_T::IPRST1: TMR1RST Position        */
#define SYS_IPRST1_TMR1RST_Msk           (0x1ul << SYS_IPRST1_TMR1RST_Pos)                 /*!< SYS_T::IPRST1: TMR1RST Mask            */

#define SYS_IPRST1_TMR2RST_Pos           (4)                                               /*!< SYS_T::IPRST1: TMR2RST Position        */
#define SYS_IPRST1_TMR2RST_Msk           (0x1ul << SYS_IPRST1_TMR2RST_Pos)                 /*!< SYS_T::IPRST1: TMR2RST Mask            */

#define SYS_IPRST1_TMR3RST_Pos           (5)                                               /*!< SYS_T::IPRST1: TMR3RST Position        */
#define SYS_IPRST1_TMR3RST_Msk           (0x1ul << SYS_IPRST1_TMR3RST_Pos)                 /*!< SYS_T::IPRST1: TMR3RST Mask            */

#define SYS_IPRST1_I2C0RST_Pos           (8)                                               /*!< SYS_T::IPRST1: I2C0RST Position        */
#define SYS_IPRST1_I2C0RST_Msk           (0x1ul << SYS_IPRST1_I2C0RST_Pos)                 /*!< SYS_T::IPRST1: I2C0RST Mask            */

#define SYS_IPRST1_I2C1RST_Pos           (9)                                               /*!< SYS_T::IPRST1: I2C1RST Position        */
#define SYS_IPRST1_I2C1RST_Msk           (0x1ul << SYS_IPRST1_I2C1RST_Pos)                 /*!< SYS_T::IPRST1: I2C1RST Mask            */

#define SYS_IPRST1_SPI0RST_Pos           (12)                                              /*!< SYS_T::IPRST1: SPI0RST Position        */
#define SYS_IPRST1_SPI0RST_Msk           (0x1ul << SYS_IPRST1_SPI0RST_Pos)                 /*!< SYS_T::IPRST1: SPI0RST Mask            */

#define SYS_IPRST1_SPI1RST_Pos           (13)                                              /*!< SYS_T::IPRST1: SPI1RST Position        */
#define SYS_IPRST1_SPI1RST_Msk           (0x1ul << SYS_IPRST1_SPI1RST_Pos)                 /*!< SYS_T::IPRST1: SPI1RST Mask            */

#define SYS_IPRST1_SPI2RST_Pos           (14)                                              /*!< SYS_T::IPRST1: SPI2RST Position        */
#define SYS_IPRST1_SPI2RST_Msk           (0x1ul << SYS_IPRST1_SPI2RST_Pos)                 /*!< SYS_T::IPRST1: SPI2RST Mask            */

#define SYS_IPRST1_DMICRST_Pos           (15)                                              /*!< SYS_T::IPRST1: DMICRST Position       */
#define SYS_IPRST1_DMICRST_Msk           (0x1ul << SYS_IPRST1_DMICRST_Pos)                 /*!< SYS_T::IPRST1: DMICRST Mask           */

#define SYS_IPRST1_UART0RST_Pos          (16)                                              /*!< SYS_T::IPRST1: UART0RST Position       */
#define SYS_IPRST1_UART0RST_Msk          (0x1ul << SYS_IPRST1_UART0RST_Pos)                /*!< SYS_T::IPRST1: UART0RST Mask           */

#define SYS_IPRST1_USBDRST_Pos           (27)                                              /*!< SYS_T::IPRST1: USBDRST Position        */
#define SYS_IPRST1_USBDRST_Msk           (0x1ul << SYS_IPRST1_USBDRST_Pos)                 /*!< SYS_T::IPRST1: USBDRST Mask            */

#define SYS_IPRST1_EADCRST_Pos           (28)                                              /*!< SYS_T::IPRST1: EADCRST Position        */
#define SYS_IPRST1_EADCRST_Msk           (0x1ul << SYS_IPRST1_EADCRST_Pos)                 /*!< SYS_T::IPRST1: EADCRST Mask            */

#define SYS_IPRST1_I2S0RST_Pos           (29)                                              /*!< SYS_T::IPRST1: I2S0RST Position        */
#define SYS_IPRST1_I2S0RST_Msk           (0x1ul << SYS_IPRST1_I2S0RST_Pos)                 /*!< SYS_T::IPRST1: I2S0RST Mask            */

#define SYS_IPRST2_DPWMRST_Pos           (6)                                               /*!< SYS_T::IPRST2: DPWMRST Position        */
#define SYS_IPRST2_DPWMRST_Msk           (0x1ul << SYS_IPRST2_DPWMRST_Pos)                 /*!< SYS_T::IPRST2: DPWMRST Mask            */

#define SYS_IPRST2_PWM0RST_Pos           (16)                                              /*!< SYS_T::IPRST2: PWM0RST Position        */
#define SYS_IPRST2_PWM0RST_Msk           (0x1ul << SYS_IPRST2_PWM0RST_Pos)                 /*!< SYS_T::IPRST2: PWM0RST Mask            */




#define SYS_ALTCTL_MISC_Pos              (0)                                               /*!< SYS_T::ALTCTL: MISC Position           */
#define SYS_ALTCTL_MISC_Msk              (0xfffffful << SYS_ALTCTL_MISC_Pos)               /*!< SYS_T::ALTCTL: MISC Mask               */

#define SYS_BODCTL_BODEN_Pos             (0)                                               /*!< SYS_T::BODCTL: BODEN Position          */
#define SYS_BODCTL_BODEN_Msk             (0x1ul << SYS_BODCTL_BODEN_Pos)                   /*!< SYS_T::BODCTL: BODEN Mask              */

#define SYS_BODCTL_BODRSTEN_Pos          (3)                                               /*!< SYS_T::BODCTL: BODRSTEN Position       */
#define SYS_BODCTL_BODRSTEN_Msk          (0x1ul << SYS_BODCTL_BODRSTEN_Pos)                /*!< SYS_T::BODCTL: BODRSTEN Mask           */

#define SYS_BODCTL_BODIF_Pos             (4)                                               /*!< SYS_T::BODCTL: BODIF Position          */
#define SYS_BODCTL_BODIF_Msk             (0x1ul << SYS_BODCTL_BODIF_Pos)                   /*!< SYS_T::BODCTL: BODIF Mask              */

#define SYS_BODCTL_BODLPM_Pos            (5)                                               /*!< SYS_T::BODCTL: BODLPM Position         */
#define SYS_BODCTL_BODLPM_Msk            (0x1ul << SYS_BODCTL_BODLPM_Pos)                  /*!< SYS_T::BODCTL: BODLPM Mask             */

#define SYS_BODCTL_BODOUT_Pos            (6)                                               /*!< SYS_T::BODCTL: BODOUT Position         */
#define SYS_BODCTL_BODOUT_Msk            (0x1ul << SYS_BODCTL_BODOUT_Pos)                  /*!< SYS_T::BODCTL: BODOUT Mask             */

#define SYS_BODCTL_LVREN_Pos             (7)                                               /*!< SYS_T::BODCTL: LVREN Position          */
#define SYS_BODCTL_LVREN_Msk             (0x1ul << SYS_BODCTL_LVREN_Pos)                   /*!< SYS_T::BODCTL: LVREN Mask              */

#define SYS_BODCTL_BODDGSEL_Pos          (8)                                               /*!< SYS_T::BODCTL: BODDGSEL Position       */
#define SYS_BODCTL_BODDGSEL_Msk          (0x7ul << SYS_BODCTL_BODDGSEL_Pos)                /*!< SYS_T::BODCTL: BODDGSEL Mask           */

#define SYS_BODCTL_LVRDGSEL_Pos          (12)                                              /*!< SYS_T::BODCTL: LVRDGSEL Position       */
#define SYS_BODCTL_LVRDGSEL_Msk          (0x7ul << SYS_BODCTL_LVRDGSEL_Pos)                /*!< SYS_T::BODCTL: LVRDGSEL Mask           */

#define SYS_BODCTL_BODVL_Pos             (16)                                              /*!< SYS_T::BODCTL: BODVL Position          */
#define SYS_BODCTL_BODVL_Msk             (0x7ul << SYS_BODCTL_BODVL_Pos)                   /*!< SYS_T::BODCTL: BODVL Mask              */

#define SYS_IVSCTL_VTEMPEN_Pos           (0)                                               /*!< SYS_T::IVSCTL: VTEMPEN Position        */
#define SYS_IVSCTL_VTEMPEN_Msk           (0x1ul << SYS_IVSCTL_VTEMPEN_Pos)                 /*!< SYS_T::IVSCTL: VTEMPEN Mask            */

#define SYS_PORCTL_POROFF_Pos            (0)                                               /*!< SYS_T::PORCTL: POROFF Position         */
#define SYS_PORCTL_POROFF_Msk            (0xfffful << SYS_PORCTL_POROFF_Pos)               /*!< SYS_T::PORCTL: POROFF Mask             */

#define SYS_VREFCTL_VREFCTL_Pos          (0)                                               /*!< SYS_T::VREFCTL: VREFCTL Position       */
#define SYS_VREFCTL_VREFCTL_Msk          (0x1ful << SYS_VREFCTL_VREFCTL_Pos)               /*!< SYS_T::VREFCTL: VREFCTL Mask           */

#define SYS_USBPHY_USBROLE_Pos           (0)                                               /*!< SYS_T::USBPHY: USBROLE Position        */
#define SYS_USBPHY_USBROLE_Msk           (0x3ul << SYS_USBPHY_USBROLE_Pos)                 /*!< SYS_T::USBPHY: USBROLE Mask            */

#define SYS_USBPHY_SBO_Pos               (2)                                               /*!< SYS_T::USBPHY: SBO Position            */
#define SYS_USBPHY_SBO_Msk               (0x1ul << SYS_USBPHY_SBO_Pos)                     /*!< SYS_T::USBPHY: SBO Mask                */

#define SYS_USBPHY_USB_PHY_EN_Pos        (8)                                               /*!< SYS_T::USBPHY: USB_PHY_EN Position     */
#define SYS_USBPHY_USB_PHY_EN_Msk        (0x1ul << SYS_USBPHY_USB_PHY_EN_Pos)              /*!< SYS_T::USBPHY: USB_PHY_EN Mask         */

#define SYS_USBPHY_VBUSPULLON_Pos        (23)                                              /*!< SYS_T::USBPHY: VBUSPULLON Position     */
#define SYS_USBPHY_VBUSPULLON_Msk        (0x1ul << SYS_USBPHY_VBUSPULLON_Pos)              /*!< SYS_T::USBPHY: VBUSPULLON Mask         */

#define SYS_GPA_MFPL_PA0MFP_Pos          (0)                                               /*!< SYS_T::GPA_MFPL: PA0MFP Position       */
#define SYS_GPA_MFPL_PA0MFP_Msk          (0xful << SYS_GPA_MFPL_PA0MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA0MFP Mask           */

#define SYS_GPA_MFPL_PA1MFP_Pos          (4)                                               /*!< SYS_T::GPA_MFPL: PA1MFP Position       */
#define SYS_GPA_MFPL_PA1MFP_Msk          (0xful << SYS_GPA_MFPL_PA1MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA1MFP Mask           */

#define SYS_GPA_MFPL_PA2MFP_Pos          (8)                                               /*!< SYS_T::GPA_MFPL: PA2MFP Position       */
#define SYS_GPA_MFPL_PA2MFP_Msk          (0xful << SYS_GPA_MFPL_PA2MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA2MFP Mask           */

#define SYS_GPA_MFPL_PA3MFP_Pos          (12)                                              /*!< SYS_T::GPA_MFPL: PA3MFP Position       */
#define SYS_GPA_MFPL_PA3MFP_Msk          (0xful << SYS_GPA_MFPL_PA3MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA3MFP Mask           */

#define SYS_GPA_MFPL_PA4MFP_Pos          (16)                                              /*!< SYS_T::GPA_MFPL: PA4MFP Position       */
#define SYS_GPA_MFPL_PA4MFP_Msk          (0xful << SYS_GPA_MFPL_PA4MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA4MFP Mask           */

#define SYS_GPA_MFPL_PA5MFP_Pos          (20)                                              /*!< SYS_T::GPA_MFPL: PA5MFP Position       */
#define SYS_GPA_MFPL_PA5MFP_Msk          (0xful << SYS_GPA_MFPL_PA5MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA5MFP Mask           */

#define SYS_GPA_MFPL_PA6MFP_Pos          (24)                                              /*!< SYS_T::GPA_MFPL: PA6MFP Position       */
#define SYS_GPA_MFPL_PA6MFP_Msk          (0xful << SYS_GPA_MFPL_PA6MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA6MFP Mask           */

#define SYS_GPA_MFPL_PA7MFP_Pos          (28)                                              /*!< SYS_T::GPA_MFPL: PA7MFP Position       */
#define SYS_GPA_MFPL_PA7MFP_Msk          (0xful << SYS_GPA_MFPL_PA7MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA7MFP Mask           */

#define SYS_GPA_MFPH_PA8MFP_Pos          (0)                                               /*!< SYS_T::GPA_MFPH: PA8MFP Position       */
#define SYS_GPA_MFPH_PA8MFP_Msk          (0xful << SYS_GPA_MFPH_PA8MFP_Pos)                /*!< SYS_T::GPA_MFPH: PA8MFP Mask           */

#define SYS_GPA_MFPH_PA9MFP_Pos          (4)                                               /*!< SYS_T::GPA_MFPH: PA9MFP Position       */
#define SYS_GPA_MFPH_PA9MFP_Msk          (0xful << SYS_GPA_MFPH_PA9MFP_Pos)                /*!< SYS_T::GPA_MFPH: PA9MFP Mask           */

#define SYS_GPA_MFPH_PA10MFP_Pos         (8)                                               /*!< SYS_T::GPA_MFPH: PA10MFP Position      */
#define SYS_GPA_MFPH_PA10MFP_Msk         (0xful << SYS_GPA_MFPH_PA10MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA10MFP Mask          */

#define SYS_GPA_MFPH_PA11MFP_Pos         (12)                                              /*!< SYS_T::GPA_MFPH: PA11MFP Position      */
#define SYS_GPA_MFPH_PA11MFP_Msk         (0xful << SYS_GPA_MFPH_PA11MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA11MFP Mask          */

#define SYS_GPA_MFPH_PA12MFP_Pos         (16)                                              /*!< SYS_T::GPA_MFPH: PA12MFP Position      */
#define SYS_GPA_MFPH_PA12MFP_Msk         (0xful << SYS_GPA_MFPH_PA12MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA12MFP Mask          */

#define SYS_GPA_MFPH_PA13MFP_Pos         (20)                                              /*!< SYS_T::GPA_MFPH: PA13MFP Position      */
#define SYS_GPA_MFPH_PA13MFP_Msk         (0xful << SYS_GPA_MFPH_PA13MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA13MFP Mask          */

#define SYS_GPA_MFPH_PA14MFP_Pos         (24)                                              /*!< SYS_T::GPA_MFPH: PA14MFP Position      */
#define SYS_GPA_MFPH_PA14MFP_Msk         (0xful << SYS_GPA_MFPH_PA14MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA14MFP Mask          */

#define SYS_GPA_MFPH_PA15MFP_Pos         (28)                                              /*!< SYS_T::GPA_MFPH: PA15MFP Position      */
#define SYS_GPA_MFPH_PA15MFP_Msk         (0xful << SYS_GPA_MFPH_PA15MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA15MFP Mask          */

#define SYS_GPB_MFPL_PB0MFP_Pos          (0)                                               /*!< SYS_T::GPB_MFPL: PB0MFP Position       */
#define SYS_GPB_MFPL_PB0MFP_Msk          (0xful << SYS_GPB_MFPL_PB0MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB0MFP Mask           */

#define SYS_GPB_MFPL_PB1MFP_Pos          (4)                                               /*!< SYS_T::GPB_MFPL: PB1MFP Position       */
#define SYS_GPB_MFPL_PB1MFP_Msk          (0xful << SYS_GPB_MFPL_PB1MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB1MFP Mask           */

#define SYS_GPB_MFPL_PB2MFP_Pos          (8)                                               /*!< SYS_T::GPB_MFPL: PB2MFP Position       */
#define SYS_GPB_MFPL_PB2MFP_Msk          (0xful << SYS_GPB_MFPL_PB2MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB2MFP Mask           */

#define SYS_GPB_MFPL_PB3MFP_Pos          (12)                                              /*!< SYS_T::GPB_MFPL: PB3MFP Position       */
#define SYS_GPB_MFPL_PB3MFP_Msk          (0xful << SYS_GPB_MFPL_PB3MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB3MFP Mask           */

#define SYS_GPB_MFPL_PB4MFP_Pos          (16)                                              /*!< SYS_T::GPB_MFPL: PB4MFP Position       */
#define SYS_GPB_MFPL_PB4MFP_Msk          (0xful << SYS_GPB_MFPL_PB4MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB4MFP Mask           */

#define SYS_GPB_MFPL_PB5MFP_Pos          (20)                                              /*!< SYS_T::GPB_MFPL: PB5MFP Position       */
#define SYS_GPB_MFPL_PB5MFP_Msk          (0xful << SYS_GPB_MFPL_PB5MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB5MFP Mask           */

#define SYS_GPB_MFPL_PB6MFP_Pos          (24)                                              /*!< SYS_T::GPB_MFPL: PB6MFP Position       */
#define SYS_GPB_MFPL_PB6MFP_Msk          (0xful << SYS_GPB_MFPL_PB6MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB6MFP Mask           */

#define SYS_GPB_MFPL_PB7MFP_Pos          (28)                                              /*!< SYS_T::GPB_MFPL: PB7MFP Position       */
#define SYS_GPB_MFPL_PB7MFP_Msk          (0xful << SYS_GPB_MFPL_PB7MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB7MFP Mask           */

#define SYS_GPB_MFPH_PB8MFP_Pos          (0)                                               /*!< SYS_T::GPB_MFPH: PB8MFP Position       */
#define SYS_GPB_MFPH_PB8MFP_Msk          (0xful << SYS_GPB_MFPH_PB8MFP_Pos)                /*!< SYS_T::GPB_MFPH: PB8MFP Mask           */

#define SYS_GPB_MFPH_PB9MFP_Pos          (4)                                               /*!< SYS_T::GPB_MFPH: PB9MFP Position       */
#define SYS_GPB_MFPH_PB9MFP_Msk          (0xful << SYS_GPB_MFPH_PB9MFP_Pos)                /*!< SYS_T::GPB_MFPH: PB9MFP Mask           */

#define SYS_GPB_MFPH_PB10MFP_Pos         (8)                                               /*!< SYS_T::GPB_MFPH: PB10MFP Position      */
#define SYS_GPB_MFPH_PB10MFP_Msk         (0xful << SYS_GPB_MFPH_PB10MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB10MFP Mask          */

#define SYS_GPB_MFPH_PB11MFP_Pos         (12)                                              /*!< SYS_T::GPB_MFPH: PB11MFP Position      */
#define SYS_GPB_MFPH_PB11MFP_Msk         (0xful << SYS_GPB_MFPH_PB11MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB11MFP Mask          */

#define SYS_GPB_MFPH_PB12MFP_Pos         (16)                                              /*!< SYS_T::GPB_MFPH: PB12MFP Position      */
#define SYS_GPB_MFPH_PB12MFP_Msk         (0xful << SYS_GPB_MFPH_PB12MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB12MFP Mask          */

#define SYS_GPB_MFPH_PB13MFP_Pos         (20)                                              /*!< SYS_T::GPB_MFPH: PB13MFP Position      */
#define SYS_GPB_MFPH_PB13MFP_Msk         (0xful << SYS_GPB_MFPH_PB13MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB13MFP Mask          */

#define SYS_GPB_MFPH_PB14MFP_Pos         (24)                                              /*!< SYS_T::GPB_MFPH: PB14MFP Position      */
#define SYS_GPB_MFPH_PB14MFP_Msk         (0xful << SYS_GPB_MFPH_PB14MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB14MFP Mask          */

#define SYS_GPB_MFPH_PB15MFP_Pos         (28)                                              /*!< SYS_T::GPB_MFPH: PB15MFP Position      */
#define SYS_GPB_MFPH_PB15MFP_Msk         (0xful << SYS_GPB_MFPH_PB15MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB15MFP Mask          */

#define SYS_GPC_MFPL_PC0MFP_Pos          (0)                                               /*!< SYS_T::GPC_MFPL: PC0MFP Position       */
#define SYS_GPC_MFPL_PC0MFP_Msk          (0xful << SYS_GPC_MFPL_PC0MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC0MFP Mask           */

#define SYS_GPC_MFPL_PC1MFP_Pos          (4)                                               /*!< SYS_T::GPC_MFPL: PC1MFP Position       */
#define SYS_GPC_MFPL_PC1MFP_Msk          (0xful << SYS_GPC_MFPL_PC1MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC1MFP Mask           */

#define SYS_GPC_MFPL_PC2MFP_Pos          (8)                                               /*!< SYS_T::GPC_MFPL: PC2MFP Position       */
#define SYS_GPC_MFPL_PC2MFP_Msk          (0xful << SYS_GPC_MFPL_PC2MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC2MFP Mask           */

#define SYS_GPC_MFPL_PC3MFP_Pos          (12)                                              /*!< SYS_T::GPC_MFPL: PC3MFP Position       */
#define SYS_GPC_MFPL_PC3MFP_Msk          (0xful << SYS_GPC_MFPL_PC3MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC3MFP Mask           */

#define SYS_GPC_MFPL_PC4MFP_Pos          (16)                                              /*!< SYS_T::GPC_MFPL: PC4MFP Position       */
#define SYS_GPC_MFPL_PC4MFP_Msk          (0xful << SYS_GPC_MFPL_PC4MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC4MFP Mask           */

#define SYS_GPC_MFPL_PC5MFP_Pos          (20)                                              /*!< SYS_T::GPC_MFPL: PC5MFP Position       */
#define SYS_GPC_MFPL_PC5MFP_Msk          (0xful << SYS_GPC_MFPL_PC5MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC5MFP Mask           */

#define SYS_GPC_MFPL_PC6MFP_Pos          (24)                                              /*!< SYS_T::GPC_MFPL: PC6MFP Position       */
#define SYS_GPC_MFPL_PC6MFP_Msk          (0xful << SYS_GPC_MFPL_PC6MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC6MFP Mask           */

#define SYS_GPC_MFPL_PC7MFP_Pos          (28)                                              /*!< SYS_T::GPC_MFPL: PC7MFP Position       */
#define SYS_GPC_MFPL_PC7MFP_Msk          (0xful << SYS_GPC_MFPL_PC7MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC7MFP Mask           */

#define SYS_GPC_MFPH_PC8MFP_Pos          (0)                                               /*!< SYS_T::GPC_MFPH: PC8MFP Position       */
#define SYS_GPC_MFPH_PC8MFP_Msk          (0xful << SYS_GPC_MFPH_PC8MFP_Pos)                /*!< SYS_T::GPC_MFPH: PC8MFP Mask           */

#define SYS_GPC_MFPH_PC9MFP_Pos          (4)                                               /*!< SYS_T::GPC_MFPH: PC9MFP Position       */
#define SYS_GPC_MFPH_PC9MFP_Msk          (0xful << SYS_GPC_MFPH_PC9MFP_Pos)                /*!< SYS_T::GPC_MFPH: PC9MFP Mask           */

#define SYS_GPC_MFPH_PC10MFP_Pos         (8)                                               /*!< SYS_T::GPC_MFPH: PC10MFP Position      */
#define SYS_GPC_MFPH_PC10MFP_Msk         (0xful << SYS_GPC_MFPH_PC10MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC10MFP Mask          */

#define SYS_GPC_MFPH_PC11MFP_Pos         (12)                                              /*!< SYS_T::GPC_MFPH: PC11MFP Position      */
#define SYS_GPC_MFPH_PC11MFP_Msk         (0xful << SYS_GPC_MFPH_PC11MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC11MFP Mask          */

#define SYS_GPC_MFPH_PC12MFP_Pos         (16)                                              /*!< SYS_T::GPC_MFPH: PC12MFP Position      */
#define SYS_GPC_MFPH_PC12MFP_Msk         (0xful << SYS_GPC_MFPH_PC12MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC12MFP Mask          */

#define SYS_GPC_MFPH_PC13MFP_Pos         (20)                                              /*!< SYS_T::GPC_MFPH: PC13MFP Position      */
#define SYS_GPC_MFPH_PC13MFP_Msk         (0xful << SYS_GPC_MFPH_PC13MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC13MFP Mask          */

#define SYS_GPC_MFPH_PC14MFP_Pos         (24)                                              /*!< SYS_T::GPC_MFPH: PC14MFP Position      */
#define SYS_GPC_MFPH_PC14MFP_Msk         (0xful << SYS_GPC_MFPH_PC14MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC14MFP Mask          */

#define SYS_GPC_MFPH_PC15MFP_Pos         (28)                                              /*!< SYS_T::GPC_MFPH: PC15MFP Position      */
#define SYS_GPC_MFPH_PC15MFP_Msk         (0xful << SYS_GPC_MFPH_PC15MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC15MFP Mask          */

#define SYS_GPD_MFPL_PD0MFP_Pos          (0)                                               /*!< SYS_T::GPD_MFPL: PD0MFP Position       */
#define SYS_GPD_MFPL_PD0MFP_Msk          (0xful << SYS_GPD_MFPL_PD0MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD0MFP Mask           */

#define SYS_GPD_MFPL_PD1MFP_Pos          (4)                                               /*!< SYS_T::GPD_MFPL: PD1MFP Position       */
#define SYS_GPD_MFPL_PD1MFP_Msk          (0xful << SYS_GPD_MFPL_PD1MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD1MFP Mask           */

#define SYS_GPD_MFPL_PD2MFP_Pos          (8)                                               /*!< SYS_T::GPD_MFPL: PD2MFP Position       */
#define SYS_GPD_MFPL_PD2MFP_Msk          (0xful << SYS_GPD_MFPL_PD2MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD2MFP Mask           */

#define SYS_GPD_MFPL_PD3MFP_Pos          (12)                                              /*!< SYS_T::GPD_MFPL: PD3MFP Position       */
#define SYS_GPD_MFPL_PD3MFP_Msk          (0xful << SYS_GPD_MFPL_PD3MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD3MFP Mask           */

#define SYS_GPD_MFPL_PD4MFP_Pos          (16)                                              /*!< SYS_T::GPD_MFPL: PD4MFP Position       */
#define SYS_GPD_MFPL_PD4MFP_Msk          (0xful << SYS_GPD_MFPL_PD4MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD4MFP Mask           */

#define SYS_GPD_MFPL_PD5MFP_Pos          (20)                                              /*!< SYS_T::GPD_MFPL: PD5MFP Position       */
#define SYS_GPD_MFPL_PD5MFP_Msk          (0xful << SYS_GPD_MFPL_PD5MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD5MFP Mask           */

#define SYS_GPD_MFPL_PD6MFP_Pos          (24)                                              /*!< SYS_T::GPD_MFPL: PD6MFP Position       */
#define SYS_GPD_MFPL_PD6MFP_Msk          (0xful << SYS_GPD_MFPL_PD6MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD6MFP Mask           */

#define SYS_GPD_MFPL_PD7MFP_Pos          (28)                                              /*!< SYS_T::GPD_MFPL: PD7MFP Position       */
#define SYS_GPD_MFPL_PD7MFP_Msk          (0xful << SYS_GPD_MFPL_PD7MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD7MFP Mask           */

#define SYS_GPD_MFPH_PD8MFP_Pos          (0)                                               /*!< SYS_T::GPD_MFPH: PD8MFP Position       */
#define SYS_GPD_MFPH_PD8MFP_Msk          (0xful << SYS_GPD_MFPH_PD8MFP_Pos)                /*!< SYS_T::GPD_MFPH: PD8MFP Mask           */

#define SYS_GPD_MFPH_PD9MFP_Pos          (4)                                               /*!< SYS_T::GPD_MFPH: PD9MFP Position       */
#define SYS_GPD_MFPH_PD9MFP_Msk          (0xful << SYS_GPD_MFPH_PD9MFP_Pos)                /*!< SYS_T::GPD_MFPH: PD9MFP Mask           */

#define SYS_GPD_MFPH_PD10MFP_Pos         (8)                                               /*!< SYS_T::GPD_MFPH: PD10MFP Position      */
#define SYS_GPD_MFPH_PD10MFP_Msk         (0xful << SYS_GPD_MFPH_PD10MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD10MFP Mask          */

#define SYS_GPD_MFPH_PD11MFP_Pos         (12)                                              /*!< SYS_T::GPD_MFPH: PD11MFP Position      */
#define SYS_GPD_MFPH_PD11MFP_Msk         (0xful << SYS_GPD_MFPH_PD11MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD11MFP Mask          */

#define SYS_GPD_MFPH_PD12MFP_Pos         (16)                                              /*!< SYS_T::GPD_MFPH: PD12MFP Position      */
#define SYS_GPD_MFPH_PD12MFP_Msk         (0xful << SYS_GPD_MFPH_PD12MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD12MFP Mask          */

#define SYS_GPD_MFPH_PD13MFP_Pos         (20)                                              /*!< SYS_T::GPD_MFPH: PD13MFP Position      */
#define SYS_GPD_MFPH_PD13MFP_Msk         (0xful << SYS_GPD_MFPH_PD13MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD13MFP Mask          */

#define SYS_GPD_MFPH_PD14MFP_Pos         (24)                                              /*!< SYS_T::GPD_MFPH: PD14MFP Position      */
#define SYS_GPD_MFPH_PD14MFP_Msk         (0xful << SYS_GPD_MFPH_PD14MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD14MFP Mask          */

#define SYS_GPD_MFPH_PD15MFP_Pos         (28)                                              /*!< SYS_T::GPD_MFPH: PD15MFP Position      */
#define SYS_GPD_MFPH_PD15MFP_Msk         (0xful << SYS_GPD_MFPH_PD15MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD15MFP Mask          */

#define SYS_SRAM_INTCTL_PERRIEN_Pos      (0)                                               /*!< SYS_T::SRAM_INTCTL: PERRIEN Position   */
#define SYS_SRAM_INTCTL_PERRIEN_Msk      (0x1ul << SYS_SRAM_INTCTL_PERRIEN_Pos)            /*!< SYS_T::SRAM_INTCTL: PERRIEN Mask       */

#define SYS_SRAM_STATUS_PERRIF_Pos       (0)                                               /*!< SYS_T::SRAM_STATUS: PERRIF Position    */
#define SYS_SRAM_STATUS_PERRIF_Msk       (0x1ul << SYS_SRAM_STATUS_PERRIF_Pos)             /*!< SYS_T::SRAM_STATUS: PERRIF Mask        */

#define SYS_SRAM_ERRADDR_ERRADDR_Pos     (0)                                               /*!< SYS_T::SRAM_ERRADDR: ERRADDR Position  */
#define SYS_SRAM_ERRADDR_ERRADDR_Msk     (0xfffffffful << SYS_SRAM_ERRADDR_ERRADDR_Pos)    /*!< SYS_T::SRAM_ERRADDR: ERRADDR Mask      */

#define SYS_SRAM_BISTCTL_SRBIST0_Pos     (0)                                               /*!< SYS_T::SRAM_BISTCTL: SRBIST0 Position  */
#define SYS_SRAM_BISTCTL_SRBIST0_Msk     (0x1ul << SYS_SRAM_BISTCTL_SRBIST0_Pos)           /*!< SYS_T::SRAM_BISTCTL: SRBIST0 Mask      */

#define SYS_SRAM_BISTCTL_SRBIST1_Pos     (1)                                               /*!< SYS_T::SRAM_BISTCTL: SRBIST1 Position  */
#define SYS_SRAM_BISTCTL_SRBIST1_Msk     (0x1ul << SYS_SRAM_BISTCTL_SRBIST1_Pos)           /*!< SYS_T::SRAM_BISTCTL: SRBIST1 Mask      */

#define SYS_SRAM_BISTSTS_SRBISTEF0_Pos   (0)                                               /*!< SYS_T::SRAM_BISTSTS: SRBISTEF0 Position*/
#define SYS_SRAM_BISTSTS_SRBISTEF0_Msk   (0x1ul << SYS_SRAM_BISTSTS_SRBISTEF0_Pos)         /*!< SYS_T::SRAM_BISTSTS: SRBISTEF0 Mask    */

#define SYS_SRAM_BISTSTS_SRBISTEF1_Pos   (1)                                               /*!< SYS_T::SRAM_BISTSTS: SRBISTEF1 Position*/
#define SYS_SRAM_BISTSTS_SRBISTEF1_Msk   (0x1ul << SYS_SRAM_BISTSTS_SRBISTEF1_Pos)         /*!< SYS_T::SRAM_BISTSTS: SRBISTEF1 Mask    */

#define SYS_SRAM_BISTSTS_SRBEND0_Pos     (16)                                              /*!< SYS_T::SRAM_BISTSTS: SRBEND0 Position  */
#define SYS_SRAM_BISTSTS_SRBEND0_Msk     (0x1ul << SYS_SRAM_BISTSTS_SRBEND0_Pos)           /*!< SYS_T::SRAM_BISTSTS: SRBEND0 Mask      */

#define SYS_SRAM_BISTSTS_SRBEND1_Pos     (17)                                              /*!< SYS_T::SRAM_BISTSTS: SRBEND1 Position  */
#define SYS_SRAM_BISTSTS_SRBEND1_Msk     (0x1ul << SYS_SRAM_BISTSTS_SRBEND1_Pos)           /*!< SYS_T::SRAM_BISTSTS: SRBEND1 Mask      */

#define SYS_SRAM_PARITY_PTESTEN_Pos      (0)                                               /*!< SYS_T::SRAM_PARITY: PTESTEN Position   */
#define SYS_SRAM_PARITY_PTESTEN_Msk      (0x1ul << SYS_SRAM_PARITY_PTESTEN_Pos)            /*!< SYS_T::SRAM_PARITY: PTESTEN Mask       */

#define SYS_SRAM_PARITY_PTESTPB_Pos      (4)                                               /*!< SYS_T::SRAM_PARITY: PTESTPB Position   */
#define SYS_SRAM_PARITY_PTESTPB_Msk      (0xful << SYS_SRAM_PARITY_PTESTPB_Pos)            /*!< SYS_T::SRAM_PARITY: PTESTPB Mask       */

#define SYS_IRCTCTL_FREQSEL_Pos          (0)                                               /*!< SYS_T::IRCTCTL: FREQSEL Position       */
#define SYS_IRCTCTL_FREQSEL_Msk          (0x3ul << SYS_IRCTCTL_FREQSEL_Pos)                /*!< SYS_T::IRCTCTL: FREQSEL Mask           */

#define SYS_IRCTCTL_LOOPSEL_Pos          (4)                                               /*!< SYS_T::IRCTCTL: LOOPSEL Position       */
#define SYS_IRCTCTL_LOOPSEL_Msk          (0x3ul << SYS_IRCTCTL_LOOPSEL_Pos)                /*!< SYS_T::IRCTCTL: LOOPSEL Mask           */

#define SYS_IRCTCTL_RETRYCNT_Pos         (6)                                               /*!< SYS_T::IRCTCTL: RETRYCNT Position      */
#define SYS_IRCTCTL_RETRYCNT_Msk         (0x3ul << SYS_IRCTCTL_RETRYCNT_Pos)               /*!< SYS_T::IRCTCTL: RETRYCNT Mask          */

#define SYS_IRCTCTL_CESTOPEN_Pos         (8)                                               /*!< SYS_T::IRCTCTL: CESTOPEN Position      */
#define SYS_IRCTCTL_CESTOPEN_Msk         (0x1ul << SYS_IRCTCTL_CESTOPEN_Pos)               /*!< SYS_T::IRCTCTL: CESTOPEN Mask          */

#define SYS_IRCTCTL_REFCKSEL_Pos         (10)                                              /*!< SYS_T::IRCTCTL: REFCKSEL Position      */
#define SYS_IRCTCTL_REFCKSEL_Msk         (0x1ul << SYS_IRCTCTL_REFCKSEL_Pos)               /*!< SYS_T::IRCTCTL: REFCKSEL Mask          */

#define SYS_IRCTCTL_IGNORE_Pos           (11)                                              /*!< SYS_T::IRCTCTL: IGNORE Position        */
#define SYS_IRCTCTL_IGNORE_Msk           (0x1ul << SYS_IRCTCTL_IGNORE_Pos)                 /*!< SYS_T::IRCTCTL: IGNORE Mask            */

#define SYS_IRCTIEN_TFAILIEN_Pos         (1)                                               /*!< SYS_T::IRCTIEN: TFAILIEN Position      */
#define SYS_IRCTIEN_TFAILIEN_Msk         (0x1ul << SYS_IRCTIEN_TFAILIEN_Pos)               /*!< SYS_T::IRCTIEN: TFAILIEN Mask          */

#define SYS_IRCTIEN_CLKEIEN_Pos          (2)                                               /*!< SYS_T::IRCTIEN: CLKEIEN Position       */
#define SYS_IRCTIEN_CLKEIEN_Msk          (0x1ul << SYS_IRCTIEN_CLKEIEN_Pos)                /*!< SYS_T::IRCTIEN: CLKEIEN Mask           */

#define SYS_IRCTISTS_FREQLOCK_Pos        (0)                                               /*!< SYS_T::IRCTISTS: FREQLOCK Position     */
#define SYS_IRCTISTS_FREQLOCK_Msk        (0x1ul << SYS_IRCTISTS_FREQLOCK_Pos)              /*!< SYS_T::IRCTISTS: FREQLOCK Mask         */

#define SYS_IRCTISTS_TFAILIF_Pos         (1)                                               /*!< SYS_T::IRCTISTS: TFAILIF Position      */
#define SYS_IRCTISTS_TFAILIF_Msk         (0x1ul << SYS_IRCTISTS_TFAILIF_Pos)               /*!< SYS_T::IRCTISTS: TFAILIF Mask          */

#define SYS_IRCTISTS_CLKERRIF_Pos        (2)                                               /*!< SYS_T::IRCTISTS: CLKERRIF Position     */
#define SYS_IRCTISTS_CLKERRIF_Msk        (0x1ul << SYS_IRCTISTS_CLKERRIF_Pos)              /*!< SYS_T::IRCTISTS: CLKERRIF Mask         */

#define SYS_REGLCTL_REGLCTL_Pos          (0)                                               /*!< SYS_T::REGLCTL: REGLCTL Position       */
#define SYS_REGLCTL_REGLCTL_Msk          (0xfful << SYS_REGLCTL_REGLCTL_Pos)               /*!< SYS_T::REGLCTL: REGLCTL Mask           */

#define SYS_RCADJ_RCADJ_Pos              (0)                                               /*!< SYS_T::RCADJ: RCADJ Position           */
#define SYS_RCADJ_RCADJ_Msk              (0x1fful << SYS_RCADJ_RCADJ_Pos)                  /*!< SYS_T::RCADJ: RCADJ Mask               */

#define SYS_TSOFFSET_VTEMP_Pos           (0)                                               /*!< SYS_T::TSOFFSET: VTEMP Position        */
#define SYS_TSOFFSET_VTEMP_Msk           (0xffful << SYS_TSOFFSET_VTEMP_Pos)               /*!< SYS_T::TSOFFSET: VTEMP Mask            */

#define SYS_LDOTRIM_LDOTRIM_Pos          (0)                                               /*!< SYS_T::LDOTRIM: LDOTRIM Position       */
#define SYS_LDOTRIM_LDOTRIM_Msk          (0x3ful << SYS_LDOTRIM_LDOTRIM_Pos)               /*!< SYS_T::LDOTRIM: LDOTRIM Mask           */

#define SYS_RLDOTRIM_RLDOTRIM_Pos         (0)                                               /*!< SYS_T::LDOTRIM: LDOTRIM Position       */
#define SYS_RLDOTRIM_RLDOTRIM_Msk         (0xful << SYS_LDOTRIM_LDOTRIM_Pos)   

#define SYS_LDOLVT_LDOLVTRIM_Pos         (0)                                               /*!< SYS_T::LDOLVT: LDOLVTRIM Position      */
#define SYS_LDOLVT_LDOLVTRIM_Msk         (0x1ful << SYS_LDOLVT_LDOLVTRIM_Pos)              /*!< SYS_T::LDOLVT: LDOLVTRIM Mask          */

#define SYS_LDOHVT_LDOHVTRIM_Pos         (0)                                               /*!< SYS_T::LDOHVT: LDOHVTRIM Position      */
#define SYS_LDOHVT_LDOHVTRIM_Msk         (0x1ful << SYS_LDOHVT_LDOHVTRIM_Pos)              /*!< SYS_T::LDOHVT: LDOHVTRIM Mask          */

#define SYS_LIRCT_LIRCTRIM_Pos           (0)                                               /*!< SYS_T::LIRCT: LIRCTRIM Position        */
#define SYS_LIRCT_LIRCTRIM_Msk           (0x7ul << SYS_LIRCT_LIRCTRIM_Pos)                 /*!< SYS_T::LIRCT: LIRCTRIM Mask            */

#define SYS_LIRCT_LIRCTEN_Pos            (16)                                              /*!< SYS_T::LIRCT: LIRCTEN Position         */
#define SYS_LIRCT_LIRCTEN_Msk            (0x1ul << SYS_LIRCT_LIRCTEN_Pos)                  /*!< SYS_T::LIRCT: LIRCTEN Mask             */

#define SYS_LDOEAT_LDOEAT_Pos            (0)                                               /*!< SYS_T::LDOEAT: LDOEAT Position         */
#define SYS_LDOEAT_LDOEAT_Msk            (0xful << SYS_LDOEAT_LDOEAT_Pos)                  /*!< SYS_T::LDOEAT: LDOEAT Mask             */

#define SYS_LDOEAT_LDO_MODE_Pos          (16)                                              /*!< SYS_T::LDOEAT: LDO_MODE Position       */
#define SYS_LDOEAT_LDO_MODE_Msk          (0x7ul << SYS_LDOEAT_LDO_MODE_Pos)                /*!< SYS_T::LDOEAT: LDO_MODE Mask           */

#define SYS_LDOEAT_SW_LDO_PU_Pos         (24)                                              /*!< SYS_T::LDOEAT: SW_LDO_PU Position      */
#define SYS_LDOEAT_SW_LDO_PU_Msk         (0x1ul << SYS_LDOEAT_SW_LDO_PU_Pos)               /*!< SYS_T::LDOEAT: SW_LDO_PU Mask          */

#define SYS_LDOEAT_SW_LDO_PD_Pos         (25)                                              /*!< SYS_T::LDOEAT: SW_LDO_PD Position      */
#define SYS_LDOEAT_SW_LDO_PD_Msk         (0x1ul << SYS_LDOEAT_SW_LDO_PD_Pos)               /*!< SYS_T::LDOEAT: SW_LDO_PD Mask          */

#define SYS_LDOEAT_LDOSET_BYPASS_Pos     (26)                                              /*!< SYS_T::LDOEAT: LDOSET_BYPASS Position  */
#define SYS_LDOEAT_LDOSET_BYPASS_Msk     (0x1ul << SYS_LDOEAT_LDOSET_BYPASS_Pos)           /*!< SYS_T::LDOEAT: LDOSET_BYPASS Mask      */

#define SYS_LDOMDSL_LDOMD_Pos            (0)                                               /*!< SYS_T::LDOMDSL: LDOMD Position         */
#define SYS_LDOMDSL_LDOMD_Msk            (0xful << SYS_LDOMDSL_LDOMD_Pos)                  /*!< SYS_T::LDOMDSL: LDOMD Mask             */

#define SYS_LDOMDSL_LDOMDTEN_Pos         (7)                                               /*!< SYS_T::LDOMDSL: LDOMDTEN Position      */
#define SYS_LDOMDSL_LDOMDTEN_Msk         (0x1ul << SYS_LDOMDSL_LDOMDTEN_Pos)               /*!< SYS_T::LDOMDSL: LDOMDTEN Mask          */

#define SYS_TCHIPCTL_LIRC2EN_Pos         (0)                                               /*!< SYS_T::TCHIPCTL: LIRC2EN Position      */
#define SYS_TCHIPCTL_LIRC2EN_Msk         (0x1ul << SYS_TCHIPCTL_LIRC2EN_Pos)               /*!< SYS_T::TCHIPCTL: LIRC2EN Mask          */

#define SYS_TCHIPCTL_HVLIRC2EN_Pos       (1)                                               /*!< SYS_T::TCHIPCTL: HVLIRC2EN Position    */
#define SYS_TCHIPCTL_HVLIRC2EN_Msk       (0x1ul << SYS_TCHIPCTL_HVLIRC2EN_Pos)             /*!< SYS_T::TCHIPCTL: HVLIRC2EN Mask        */

#define SYS_TCHIPCTL_RTCLDOEN_Pos        (8)                                               /*!< SYS_T::TCHIPCTL: RTCLDOEN Position     */
#define SYS_TCHIPCTL_RTCLDOEN_Msk        (0x1ul << SYS_TCHIPCTL_RTCLDOEN_Pos)              /*!< SYS_T::TCHIPCTL: RTCLDOEN Mask         */

#define SYS_TCHIPCTL_TEMP12TE_Pos        (16)                                              /*!< SYS_T::TCHIPCTL: TEMP12TE Position     */
#define SYS_TCHIPCTL_TEMP12TE_Msk        (0x1ul << SYS_TCHIPCTL_TEMP12TE_Pos)              /*!< SYS_T::TCHIPCTL: TEMP12TE Mask         */

#define SYS_TCHIPCTL_TEMP33TE_Pos        (17)                                              /*!< SYS_T::TCHIPCTL: TEMP33TE Position     */
#define SYS_TCHIPCTL_TEMP33TE_Msk        (0x1ul << SYS_TCHIPCTL_TEMP33TE_Pos)              /*!< SYS_T::TCHIPCTL: TEMP33TE Mask         */

#define SYS_TCHIPCTL_VBATD2TE_Pos        (18)                                              /*!< SYS_T::TCHIPCTL: VBATD2TE Position     */
#define SYS_TCHIPCTL_VBATD2TE_Msk        (0x1ul << SYS_TCHIPCTL_VBATD2TE_Pos)              /*!< SYS_T::TCHIPCTL: VBATD2TE Mask         */

#define SYS_TCHIPCTL_VBGTE_Pos           (19)                                              /*!< SYS_T::TCHIPCTL: VBGTE Position        */
#define SYS_TCHIPCTL_VBGTE_Msk           (0x1ul << SYS_TCHIPCTL_VBGTE_Pos)                 /*!< SYS_T::TCHIPCTL: VBGTE Mask            */

#define SYS_TCHIPCTL_MBIASTE_Pos         (20)                                              /*!< SYS_T::TCHIPCTL: MBIASTE Position      */
#define SYS_TCHIPCTL_MBIASTE_Msk         (0x1ul << SYS_TCHIPCTL_MBIASTE_Pos)               /*!< SYS_T::TCHIPCTL: MBIASTE Mask          */

#define SYS_SRAMRMC_RM_Pos               (0)                                               /*!< SYS_T::SRAMRMC: RM Position            */
#define SYS_SRAMRMC_RM_Msk               (0xful << SYS_SRAMRMC_RM_Pos)                     /*!< SYS_T::SRAMRMC: RM Mask                */

#define SYS_SRAMRMC_RMEN_Pos             (7)                                               /*!< SYS_T::SRAMRMC: RMEN Position          */
#define SYS_SRAMRMC_RMEN_Msk             (0x1ul << SYS_SRAMRMC_RMEN_Pos)                   /*!< SYS_T::SRAMRMC: RMEN Mask              */

#define SYS_SRAMRMC_RM_P_Pos             (8)                                               /*!< SYS_T::SRAMRMC: RM_P Position          */
#define SYS_SRAMRMC_RM_P_Msk             (0xful << SYS_SRAMRMC_RM_P_Pos)                   /*!< SYS_T::SRAMRMC: RM_P Mask              */

#define SYS_SRAMRMC_RMEN_P_Pos           (15)                                              /*!< SYS_T::SRAMRMC: RMEN_P Position        */
#define SYS_SRAMRMC_RMEN_P_Msk           (0x1ul << SYS_SRAMRMC_RMEN_P_Pos)                 /*!< SYS_T::SRAMRMC: RMEN_P Mask            */

#define SYS_HIRCTCTL_RS_Pos              (0)                                               /*!< SYS_T::HIRCTCTL: RS Position           */
#define SYS_HIRCTCTL_RS_Msk              (0x3ul << SYS_HIRCTCTL_RS_Pos)                    /*!< SYS_T::HIRCTCTL: RS Mask               */

#define SYS_HIRCTCTL_CS_Pos              (4)                                               /*!< SYS_T::HIRCTCTL: CS Position           */
#define SYS_HIRCTCTL_CS_Msk              (0x3ul << SYS_HIRCTCTL_CS_Pos)                    /*!< SYS_T::HIRCTCTL: CS Mask               */

#define SYS_HIRCTCTL_PTC_Pos             (8)                                               /*!< SYS_T::HIRCTCTL: PTC Position          */
#define SYS_HIRCTCTL_PTC_Msk             (0x7ul << SYS_HIRCTCTL_PTC_Pos)                   /*!< SYS_T::HIRCTCTL: PTC Mask              */

#define SYS_HIRCTCTL_NTC_Pos             (12)                                              /*!< SYS_T::HIRCTCTL: NTC Position          */
#define SYS_HIRCTCTL_NTC_Msk             (0x7ul << SYS_HIRCTCTL_NTC_Pos)                   /*!< SYS_T::HIRCTCTL: NTC Mask              */

#define SYS_HIRCTCTL_X2_Pos              (16)                                              /*!< SYS_T::HIRCTCTL: X2 Position           */
#define SYS_HIRCTCTL_X2_Msk              (0x1ul << SYS_HIRCTCTL_X2_Pos)                    /*!< SYS_T::HIRCTCTL: X2 Mask               */

#define SYS_HIRC2TCTL_HIRCBK_EN_Pos      (0)                                               /*!< SYS_T::HIRC2TCTL: HIRCBK_EN Position   */
#define SYS_HIRC2TCTL_HIRCBK_EN_Msk      (0x1ul << SYS_HIRC2TCTL_HIRCBK_EN_Pos)            /*!< SYS_T::HIRC2TCTL: HIRCBK_EN Mask       */

#define SYS_HIRC2TCTL_HIRCBK_GATE_EN_Pos (1)                                               /*!< SYS_T::HIRC2TCTL: HIRCBK_GATE_EN Position*/
#define SYS_HIRC2TCTL_HIRCBK_GATE_EN_Msk (0x1ul << SYS_HIRC2TCTL_HIRCBK_GATE_EN_Pos)       /*!< SYS_T::HIRC2TCTL: HIRCBK_GATE_EN Mask  */

#define SYS_HIRC2TCTL_BGEN_OLDO_Pos      (4)                                               /*!< SYS_T::HIRC2TCTL: BGEN_OLDO Position   */
#define SYS_HIRC2TCTL_BGEN_OLDO_Msk      (0x1ul << SYS_HIRC2TCTL_BGEN_OLDO_Pos)            /*!< SYS_T::HIRC2TCTL: BGEN_OLDO Mask       */

#define SYS_HIRC2TCTL_OLDO_EN_Pos        (5)                                               /*!< SYS_T::HIRC2TCTL: OLDO_EN Position     */
#define SYS_HIRC2TCTL_OLDO_EN_Msk        (0x1ul << SYS_HIRC2TCTL_OLDO_EN_Pos)              /*!< SYS_T::HIRC2TCTL: OLDO_EN Mask         */

#define SYS_HIRC2TCTL_PTC_Pos            (8)                                               /*!< SYS_T::HIRC2TCTL: PTC Position         */
#define SYS_HIRC2TCTL_PTC_Msk            (0x7ul << SYS_HIRC2TCTL_PTC_Pos)                  /*!< SYS_T::HIRC2TCTL: PTC Mask             */

#define SYS_HIRC2TCTL_NTC_Pos            (12)                                              /*!< SYS_T::HIRC2TCTL: NTC Position         */
#define SYS_HIRC2TCTL_NTC_Msk            (0x7ul << SYS_HIRC2TCTL_NTC_Pos)                  /*!< SYS_T::HIRC2TCTL: NTC Mask             */

#define SYS_HIRC2TCTL_RCADJ_Pos          (16)                                              /*!< SYS_T::HIRC2TCTL: RCADJ Position       */
#define SYS_HIRC2TCTL_RCADJ_Msk          (0x1fful << SYS_HIRC2TCTL_RCADJ_Pos)              /*!< SYS_T::HIRC2TCTL: RCADJ Mask           */

#define SYS_HIRC2TCTL_HIRCBKSL_Pos       (31)                                              /*!< SYS_T::HIRC2TCTL: HIRCBKSL Position    */
#define SYS_HIRC2TCTL_HIRCBKSL_Msk       (0x1ul << SYS_HIRC2TCTL_HIRCBKSL_Pos)             /*!< SYS_T::HIRC2TCTL: HIRCBKSL Mask        */

#define SYS_HXTTCTL_SCHTEST_Pos          (0)                                               /*!< SYS_T::HXTTCTL: SCHTEST Position       */
#define SYS_HXTTCTL_SCHTEST_Msk          (0x1ul << SYS_HXTTCTL_SCHTEST_Pos)                /*!< SYS_T::HXTTCTL: SCHTEST Mask           */

#define SYS_USBTCTL_USB20PHY_CHIP_EN_Pos (0)                                               /*!< SYS_T::USBTCTL: USB20PHY_CHIP_EN Position*/
#define SYS_USBTCTL_USB20PHY_CHIP_EN_Msk (0x1ul << SYS_USBTCTL_USB20PHY_CHIP_EN_Pos)       /*!< SYS_T::USBTCTL: USB20PHY_CHIP_EN Mask  */

#define SYS_USBTCTL_USB20PHY_OFF_Pos     (1)                                               /*!< SYS_T::USBTCTL: USB20PHY_OFF Position  */
#define SYS_USBTCTL_USB20PHY_OFF_Msk     (0x1ul << SYS_USBTCTL_USB20PHY_OFF_Pos)           /*!< SYS_T::USBTCTL: USB20PHY_OFF Mask      */

/**@}*/ /* SYS_CONST */
/**@}*/ /* end of SYS register group */


/*---------------------- ?????????????????????????????????????????? -------------------------*/
/**
    @addtogroup TMR01 ??????????????????????????????????????????(TMR01)
    Memory Mapped Structure for TMR01 Controller
@{ */
 
typedef struct
{


/**
 * @var TMR01_T::CTL
 * Offset: 0x00  Timer0 Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[7:0]   |PSC       |Prescale Counter
 * |        |          |Timer input clock or event source is divided by (PSC+1) before it is fed to the timer up counter
 * |        |          |If this field is 0 (PSC = 0), then there is no scaling.
 * |        |          |Note: Update prescale counter value will reset internal 8-bit prescale counter and 24-bit up counter value.[WH1]
 * |        |          |[WH1]Tag92
 * |[19]    |INTRGEN   |Inter-timer Trigger Mode Enable Control
 * |        |          |Setting this bit will enable the inter-timer trigger capture function.
 * |        |          |The Timer0/2 will be in event counter mode and counting with external clock source or event
 * |        |          |Also, Timer1/3 will be in trigger-counting mode of capture function.
 * |        |          |0 = Inter-Timer Trigger Capture mode Disabled.
 * |        |          |1 = Inter-Timer Trigger Capture mode Enabled.
 * |        |          |Note: For Timer1/3, this bit is ignored and the read back value is always 0.[WH1]
 * |        |          |[WH1]Tag91
 * |[20]    |PERIOSEL  |Periodic Mode Behavior Selection Enable Bit
 * |        |          |0 = The behavior selection in periodic mode is Disabled.
 * |        |          |When user updates CMPDAT while timer is running in periodic mode,
 * |        |          |CNT will be reset to default value.
 * |        |          |1 = The behavior selection in periodic mode is Enabled.
 * |        |          |When user update CMPDAT while timer is running in periodic mode, the limitations as bellows list,
 * |        |          |If updated CMPDAT value > CNT, CMPDAT will be updated and CNT keep running continually.
 * |        |          |If updated CMPDAT value = CNT, timer time-out interrupt will be asserted immediately.
 * |        |          |If updated CMPDAT value < CNT, CNT will be reset to default value.[WH1]
 * |        |          |[WH1]Tag90
 * |[21]    |TGLPINSEL |Toggle-output Pin Select
 * |        |          |0 = Toggle mode output to Tx (Timer Event Counter Pin).
 * |        |          |1 = Toggle mode output to Tx_EXT (Timer External Capture Pin).[WH1]
 * |        |          |[WH1]Tag89
 * |[22]    |CAPSRC    |Capture Pin Source Selection
 * |        |          |0 = Capture Function source is from Tx_EXT (x= 0~3) pin.
 * |        |          |1 =RESERVED [AlvinLiao1].[WH2]
 * |        |          |[AlvinLiao1] NEED TO REVEISED
 * |        |          |[WH2]Tag88
 * |[23]    |WKEN      |Wake-up Function Enable Bit
 * |        |          |If this bit is set to 1, while timer interrupt flag TIF (TIMERx_INTSTS[0]) is 1 and INTEN (TIMERx_CTL[29]) is enabled, the timer interrupt signal will generate a wake-up trigger event to CPU.
 * |        |          |0 = Wake-up function Disabled if timer interrupt signal generated.
 * |        |          |1 = Wake-up function Enabled if timer interrupt signal generated.[WH1]
 * |        |          |[WH1]Tag87
 * |[24]    |EXTCNTEN  |Event Counter Mode Enable Bit
 * |        |          |This bit is for external counting pin function enabled.
 * |        |          |0 = Event counter mode Disabled.
 * |        |          |1 = Event counter mode Enabled.
 * |        |          |Note: When timer is used as an event counter, this bit should be set to 1 and select PCLK as timer clock source.[WH1]
 * |        |          |[WH1]Tag86
 * |[25]    |ACTSTS    |Timer Active Status Bit (Read Only)
 * |        |          |This bit indicates the 24-bit up counter status.
 * |        |          |0 = 24-bit up counter is not active.
 * |        |          |1 = 24-bit up counter is active.[WH1]
 * |        |          |[WH1]Tag85
 * |[26]    |RSTCNT    |Timer Counter Reset Bit (Not Release in TRM)
 * |        |          |Setting this bit will reset the 24-bit up counter value CNT (TIMERx_CNT[23:0]) and also force CNTEN (TIMERx_CTL[30]) to 0 if ACTSTS (TIMERx_CTL[25]) is 1.
 * |        |          |0 = No effect.
 * |        |          |1 = Reset internal 8-bit prescale counter, 24-bit up counter value and CNTEN bit.[WH1]
 * |        |          |[WH1]Tag84, not release in TRM
 * |[28:27] |OPMODE    |Timer Counting Mode Select
 * |        |          |00 = The Timer controller is operated in One-shot mode.
 * |        |          |01 = The Timer controller is operated in Periodic mode.
 * |        |          |10 = The Timer controller is operated in Toggle-output mode.
 * |        |          |11 = The Timer controller is operated in Continuous Counting mode.[WH1]
 * |        |          |[WH1]Tag83
 * |[29]    |INTEN     |Timer Interrupt Enable Bit
 * |        |          |0 = Timer time-out interrupt Disabled.
 * |        |          |1 = Timer time-out interrupt Enabled.
 * |        |          |Note: If this bit is enabled, when the timer time-out interrupt flag TIF is set to 1, the timer interrupt signal is generated and inform to CPU.[WH1]
 * |        |          |[WH1]Tag82
 * |[30]    |CNTEN     |Timer Counting Enable Bit
 * |        |          |0 = Stops/Suspends counting.
 * |        |          |1 = Starts counting.
 * |        |          |Note1: In stop status, and then set CNTEN to 1 will enable the 24-bit up counter to keep counting from the last stop counting value.
 * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode OPMODE (TIMER_CTL[28:27] = 00) when the timer time-out interrupt flag TIF (TIMERx_INTSTS[0]) is generated.
 * |        |          |Note3: Set enable/disable this bit needs 2 * TMR_CLK period to become active, user can read ACTSTS (TIMERx_CTL[25]) to check enabe/disable command is completed or not.[WH1]
 * |        |          |[WH1]Tag81
 * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Control (Write Protect)
 * |        |          |0 = ICE debug mode acknowledgement effects TIMER counting.
 * |        |          |TIMER counter will be held while CPU is held by ICE.
 * |        |          |1 = ICE debug mode acknowledgement Disabled.
 * |        |          |TIMER counter will keep going no matter CPU is held by ICE or not.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag80
 * @var TMR01_T::CMP
 * Offset: 0x04  Timer0 Comparator Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[23:0]  |CMPDAT    |Timer Comparator Value
 * |        |          |CMPDAT is a 24-bit compared value register
 * |        |          |When the internal 24-bit up counter value is equal to CMPDAT value, the TIF (TIMERx_INTSTS[0] Timer Interrupt Flag) will set to 1.
 * |        |          |Time-out period = (Period of timer clock input) * (8-bit PSC + 1) * (24-bit CMPDAT).
 * |        |          |Note1: Never write 0x0 or 0x1 in CMPDAT field, or the core will run into unknown state.
 * |        |          |Note2: When timer is operating at continuous counting mode, the 24-bit up counter will keep counting continuously even if user writes a new value into CMPDAT field
 * |        |          |But if timer is operating at other modes, the 24-bit up counter will restart counting from 0 and using newest CMPDAT value to be the timer compared value while user writes a new value into CMPDAT field.[WH1]
 * |        |          |[WH1]Tag93
 * @var TMR01_T::INTSTS
 * Offset: 0x08  Timer0 Interrupt Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |TIF       |Timer Interrupt Flag
 * |        |          |This bit indicates the interrupt flag status of Timer while 24-bit timer up counter CNT (TIMERx_CNT[23:0]) value reaches to CMPDAT (TIMERx_CMP[23:0]) value.
 * |        |          |0 = No effect.
 * |        |          |1 = CNT value matches the CMPDAT value.
 * |        |          |Note: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag95
 * |[1]     |TWKF      |Timer Wake-up Flag
 * |        |          |This bit indicates the interrupt wake-up flag status of timer.
 * |        |          |0 = Timer does not cause CPU wake-up.
 * |        |          |1 = CPU wake-up from Idle or Power-down mode if timer time-out interrupt signal generated.
 * |        |          |Note: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag94
 * @var TMR01_T::CNT
 * Offset: 0x0C  Timer0 Data Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[23:0]  |CNT       |Timer Data Register
 * |        |          |Read operation.
 * |        |          |Read this register to get CNT value. For example:
 * |        |          |If EXTCNTEN (TIMERx_CTL[24] ) is 0, user can read CNT value for getting current 24-bit counter value.
 * |        |          |If EXTCNTEN (TIMERx_CTL[24] ) is 1, user can read CNT value for getting current 24-bit event input counter value.
 * |        |          |Write operation.
 * |        |          |Writing any value to this register will reset current CNT value to 0 and reload internal 8-bit prescale counter.[WH1]
 * |        |          |[WH1]Tag97
 * |[31]    |RSTACT    |Timer Data Register Reset Active (Read Only)
 * |        |          |This bit indicates if the counter reset operation active.
 * |        |          |When user writes this CNT register, timer starts to reset its internal 24-bit timer up-counter to 0 and reload 8-bit pre-scale counter
 * |        |          |At the same time, timer set this flag to 1 to indicate the counter reset operation is in progress
 * |        |          |Once the counter reset operation done, timer clear this bit to 0 automatically.
 * |        |          |0 = Reset operation is done.
 * |        |          |1 = Reset operation triggered by writing TIMERx_CNT is in progress.
 * |        |          |Note: This bit is read only.[WH1]
 * |        |          |[WH1]Tag96
 * @var TMR01_T::CAP
 * Offset: 0x10  Timer0 Capture Data Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[23:0]  |CAPDAT    |Timer Capture Data Register (Read Only)
 * |        |          |When CAPEN (TIMERx_EXTCTL[3]) bit is set, CAPFUNCS (TIMERx_EXTCTL[4]) bit is 0, and a transition on Tx_EXT pin matched the CAPEDGE (TIMERx_EXTCTL[14:12]) setting, CAPIF (TIMERx_EINTSTS[0]) will set to 1 and the current timer counter value CNT (TIMERx_CNT[23:0]) will be auto-loaded into this CAPDAT field.[WH1]
 * |        |          |[WH1]Tag98
 * @var TMR01_T::EXTCTL
 * Offset: 0x14  Timer0 External Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CNTPHASE  |Timer External Count Phase
 * |        |          |This bit indicates the detection phase of external counting pin Tx (x= 0~3).
 * |        |          |0 = A falling edge of external counting pin will be counted.
 * |        |          |1 = A rising edge of external counting pin will be counted.[WH1]
 * |        |          |[WH1]Tag107
 * |[2:1]   |SCAPEDGE  |SBZ
 * |[3]     |CAPEN     |Timer External Capture Pin Enable Bit
 * |        |          |This bit enables the Tx_EXT capture pin input function.
 * |        |          |0 =Tx_EXT (x= 0~3) pin Disabled.
 * |        |          |1 =Tx_EXT (x= 0~3) pin Enabled.[WH1]
 * |        |          |[WH1]Tag106
 * |[4]     |CAPFUNCS  |Capture Function Selection
 * |        |          |0 = External Capture Mode Enabled.
 * |        |          |1 = External Reset Mode Enabled.
 * |        |          |Note1: When CAPFUNCS is 0, transition on Tx_EXT (x= 0~3) pin is using to save current 24-bit timer counter value (CNT value) to CAPDAT field.
 * |        |          |Note2: When CAPFUNCS is 1, transition on Tx_EXT (x= 0~3) pin is using to save current 24-bit timer counter value (CNT value) to CAPDAT field then CNT value will be reset immediately.[WH1]
 * |        |          |[WH1]Tag105
 * |[5]     |CAPIEN    |Timer External Capture Interrupt Enable Bit
 * |        |          |0 = Tx_EXT (x= 0~3) pin detection Interrupt Disabled.
 * |        |          |1 = Tx_EXT (x= 0~3) pin detection Interrupt Enabled.
 * |        |          |Note: CAPIEN is used to enable timer external interrupt
 * |        |          |If CAPIEN enabled, timer will rise an interrupt when CAPIF (TIMERx_EINTSTS[0]) is 1.
 * |        |          |For example, while CAPIEN = 1, CAPEN = 1, and CAPEDGE = 00, a 1 to 0 transition on the Tx_EXT pin will cause the CAPIF to be set then the interrupt signal is generated and sent to NVIC to inform CPU.[WH1]
 * |        |          |[WH1]Tag104
 * |[6]     |CAPDBEN   |Timer External Capture Pin De-bounce Enable Bit
 * |        |          |0 = Tx_EXT (x= 0~3) pin de-bounce Disabled.
 * |        |          |1 = Tx_EXT (x= 0~3) pin de-bounce Enabled.
 * |        |          |Note: If this bit is enabled, the edge detection of Tx_EXT pin output is detected with de-bounce circuit.[WH1]
 * |        |          |[WH1]Tag103
 * |[7]     |CNTDBEN   |Timer Counter Pin De-bounce Enable Bit
 * |        |          |0 = Tx (x= 0~3) pin de-bounce Disabled.
 * |        |          |1 = Tx (x= 0~3) pin de-bounce Enabled.
 * |        |          |Note: If this bit is enabled, the edge detection of Tx pin is detected with de-bounce circuit.[WH1]
 * |        |          |[WH1]Tag102
 * |[14:12] |CAPEDGE   |Timer External Capture Pin Edge Detect
 * |        |          |When first capture event is generated, the CNT (TIMERx_CNT[23:0]) will be reset to 0 and first CAPDAT (TIMERx_CAP[23:0]) should be to 0.
 * |        |          |000 = Capture event occurred when detect falling edge transfer on Tx_EXT (x= 0~3) pin.
 * |        |          |001 = Capture event occurred when detect rising edge transfer on Tx_EXT (x= 0~3) pin.
 * |        |          |010 = Capture event occurred when detect both falling and rising edge transfer on Tx_EXT (x= 0~3) pin, and first capture event occurred at falling edge transfer.
 * |        |          |011 = Capture event occurred when detect both rising and falling edge transfer on Tx_EXT (x= 0~3) pin, and first capture event occurred at rising edge transfer.
 * |        |          |110 = First capture event occurred at falling edge, follows capture events are at rising edge transfer on Tx_EXT (x= 0~3) pin.
 * |        |          |111 = First capture event occurred at rising edge, follows capture events are at falling edge transfer on Tx_EXT (x= 0~3) pin.
 * |        |          |100, 101 = Reserved.[WH1]
 * |        |          |[WH1]Tag100
 * |[16]    |ECNTSSEL  |Event Counter Source Selection to Trigger Event Counter Function
 * |        |          |0 = Event Counter input source is from Tx (x= 0~3) pin.
 * |        |          |1 = Reserved Event Counter input source is from USB internal SOF output signal.[WH1]
 * |        |          |[WH1]Tag99
 * @var TMR01_T::EINTSTS
 * Offset: 0x18  Timer0 External Interrupt Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CAPIF     |Timer External Capture Interrupt Flag
 * |        |          |This bit indicates the timer external capture interrupt flag status.
 * |        |          |0 = Tx_EXT (x= 0~3) pin interrupt did not occur.
 * |        |          |1 = Tx_EXT (x= 0~3) pin interrupt occurred.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2: When CAPEN (TIMERx_EXTCTL[3]) bit is set, CAPFUNCS (TIMERx_EXTCTL[4]) bit is 0, and a transition on Tx_EXT (x= 0~3) pin matched the CAPEDGE (TIMERx_EXTCTL[2:1]) setting, this bit will set to 1 by hardware.
 * |        |          |Note3: There is a new incoming capture event detected before CPU clearing the CAPIF status
 * |        |          |If the above condition occurred, the Timer will keep register TIMERx_CAP unchanged and drop the new capture value.[WH1]
 * |        |          |[WH1]Tag108
 * @var TMR01_T::TRGCTL
 * Offset: 0x1C  Timer0 Trigger Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |TRGSSEL   |Trigger Source Select Bit
 * |        |          |This bit is used to select internal trigger source is form timer time-out interrupt signal or capture interrupt signal.
 * |        |          |0 = Time-out interrupt signal is used to internal trigger PWM, PDMA, and ADC.
 * |        |          |1 = Capture interrupt signal is used to internal trigger PWM, PDMA, and ADC.[WH1]
 * |        |          |[WH1]Tag113
 * |[1]     |TRGPWM    |Trigger PWM Enable Bit
 * |        |          |If this bit is set to 1, each timer time-out event or capture event can be as PWM counter clock source.
 * |        |          |0 = Timer interrupt trigger PWM Disabled.
 * |        |          |1 = Timer interrupt trigger PWM Enabled.
 * |        |          |Note: If TRGSSEL (TIMERx_TRGCTL[0]) = 0, time-out interrupt signal as PWM counter clock source.
 * |        |          |If TRGSSEL (TIMERx_TRGCTL[0]) = 1, capture interrupt signal as PWM counter clock source.[WH1]
 * |        |          |[WH1]Tag112
 * |[2]     |TRGADC    |Trigger ADC Enable Bit
 * |        |          |If this bit is set to 1, each timer time-out event or capture event can be triggered ADC conversion.
 * |        |          |0 = Timer interrupt trigger ADC Disabled.
 * |        |          |1 = Timer interrupt trigger ADC Enabled.
 * |        |          |Note: If TRGSSEL (TIMERx_TRGCTL[0]) = 0, time-out interrupt signal will trigger ADC conversion.
 * |        |          |If TRGSSEL (TIMERx_TRGCTL[0]) = 1, capture interrupt signal will trigger ADC conversion.[WH1]
 * |        |          |[WH1]Tag111
 * |[4]     |TRGPDMA   |Trigger PDMA Enable Bit
 * |        |          |If this bit is set to 1, each timer time-out event or capture event can be triggered PDMA transfer.
 * |        |          |0 = Timer interrupt trigger PDMA Disabled.
 * |        |          |1 = Timer interrupt trigger PDMA Enabled.
 * |        |          |Note: If TRGSSEL (TIMERx_TRGCTL[0]) = 0, time-out interrupt signal will trigger PDMA transfer.
 * |        |          |If TRGSSEL (TIMERx_TRGCTL[0]) = 1, capture interrupt signal will trigger PDMA transfer.[WH1]
 * |        |          |[WH1]Tag109
 * @var TMR01_T::ALTCTL
 * Offset: 0x20  Timer0 Alternative Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |FUNCSEL   |Function Selection
 * |        |          |0 = Timer controller is used as timer function.
 * |        |          |1 = Timer controller is used as PWM function.
 * |        |          |Note: When timer is used as PWM, the clock source of time controller will be forced to PCLKx automatically.[WH1]
 * |        |          |[WH1]Tag114
 * @var TMR01_T::PWMCTL
 * Offset: 0x40  Timer0 PWM Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CNTEN     |PWM Counter Enable Bit
 * |        |          |0 = PWM counter and clock prescale Stop Running.
 * |        |          |1 = PWM counter and clock prescale Start Running.[WH1]
 * |        |          |[WH1]Tag122
 * |[2:1]   |CNTTYPE   |PWM Counter Behavior Type
 * |        |          |00 = Up count type.
 * |        |          |01 = Down count type.
 * |        |          |10 = Up-down count type.
 * |        |          |11 = Reserved.[WH1]
 * |        |          |[WH1]Tag121
 * |[3]     |CNTMODE   |PWM Counter Mode
 * |        |          |0 = Auto-reload mode.
 * |        |          |1 = One-shot mode.[WH1]
 * |        |          |[WH1]Tag120
 * |[8]     |CTRLD     |Center Re-load
 * |        |          |In up-down count type, PERIOD will load to PBUF when current PWM period is completed always and CMP will load to CMPBUF at the center point of current period.[WH1]
 * |        |          |[WH1]Tag119
 * |[9]     |IMMLDEN   |Immediately Load Enable Bit
 * |        |          |0 = PERIOD will load to PBUF when current PWM period is completed no matter CTRLD is enabled/disabled
 * |        |          |If CTRLD is disabled, CMP will load to CMPBUF when current PWM period is completed; if CTRLD is enabled in up-down count type, CMP will load to CMPBUF at the center point of current period.
 * |        |          |1 = PERIOD/CMP will load to PBUF/CMPBUF immediately when user update PERIOD/CMP.
 * |        |          |Note: If IMMLDEN is enabled, CTRLD will be invalid.[WH1]
 * |        |          |[WH1]Tag118
 * |[16]    |OUTMODE   |PWM Output Mode
 * |        |          |This bit controls the output mode of corresponding PWM channel.
 * |        |          |0 = PWM independent mode.
 * |        |          |1 = PWM complementary mode.[WH1]
 * |        |          |[WH1]Tag117
 * |[30]    |DBGHALT   |ICE Debug Mode Counter Halt (Write Protect)
 * |        |          |If debug mode counter halt is enabled, PWM counter will keep current value until exit ICE debug mode.
 * |        |          |0 = ICE debug mode counter halt disable.
 * |        |          |1 = ICE debug mode counter halt enable.
 * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag116
 * |[31]    |DBGTRIOFF |ICE Debug Mode Acknowledge Disable Bit (Write Protect)
 * |        |          |0 = ICE debug mode acknowledgement effects PWM output.
 * |        |          |PWM output pin will be forced as tri-state while ICE debug mode acknowledged.
 * |        |          |1 = ICE debug mode acknowledgement disabled.
 * |        |          |PWM output pin will keep output no matter ICE debug mode acknowledged or not.
 * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag115
 * @var TMR01_T::PWMCLKSRC
 * Offset: 0x44  Timer0 PWM Counter Clock Source Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[2:0]   |CLKSRC    |PWM Counter Clock Source Select
 * |        |          |The PWM counter clock source can be selected from TMRx_CLK or internal timer time-out or capture event.
 * |        |          |000 = TMRx_CLK.
 * |        |          |001 = Internal TIMER0 time-out or capture event.
 * |        |          |010 = Internal TIMER1 time-out or capture event.
 * |        |          |011 = Internal TIMER2 time-out or capture event.
 * |        |          |100 = Internal TIMER3 time-out or capture event.
 * |        |          |Others = Reserved.
 * |        |          |Note: If TIMER0 PWM function is enabled, the PWM counter clock source can be selected from TMR0_CLK, TIMER1 interrupt events, TIMER2 interrupt events, or TIMER3 interrupt events.[WH1]
 * |        |          |[WH1]Tag123
 * @var TMR01_T::PWMCLKPSC
 * Offset: 0x48  Timer0 PWM Counter Clock Pre-scale Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-scale
 * |        |          |The active clock of PWM counter is decided by counter clock prescale and divided by (CLKPSC + 1)
 * |        |          |If CLKPSC is 0, then there is no scaling in PWM counter clock source.[WH1]
 * |        |          |[WH1]Tag124
 * @var TMR01_T::PWMCNTCLR
 * Offset: 0x4C  Timer0 PWM Clear Counter Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CNTCLR    |Clear PWM Counter Control Bit
 * |        |          |It is automatically cleared by hardware.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear 16-bit PWM counter to 0x10000 in up and up-down count type and reset counter value to PERIOD in down count type.[WH1]
 * |        |          |[WH1]Tag125
 * @var TMR01_T::PWMPERIOD
 * Offset: 0x50  Timer0 PWM Period Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PERIOD    |PWM Period Register
 * |        |          |In up count type: PWM counter counts from 0 to PERIOD, and restarts from 0.
 * |        |          |In down count type: PWM counter counts from PERIOD to 0, and restarts from PERIOD.
 * |        |          |In up-down count type: PWM counter counts from 0 to PERIOD, then decrements to 0 and repeats again.
 * |        |          |In up and down count type:
 * |        |          |PWM period time = (PERIOD + 1) * (CLKPSC + 1) * TMRx_PWMCLK.
 * |        |          |In up-down count type:
 * |        |          |PWM period time = 2 * PERIOD * (CLKPSC+ 1) * TMRx_PWMCLK.
 * |        |          |Note: User should take care DIRF (TIMERx_PWMCNT[16]) bit in up/down/up-down count type to monitor current counter direction in each count type.[WH1]
 * |        |          |[WH1]Tag126
 * @var TMR01_T::PWMCMPDAT
 * Offset: 0x54  Timer0 PWM Comparator Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CMP       |PWM Comparator Register
 * |        |          |PWM CMP is used to compare with PWM CNT to generate PWM output waveform, interrupt events and trigger ADC to start convert.[WH1]
 * |        |          |[WH1]Tag127
 * @var TMR01_T::PWMDTCTL
 * Offset: 0x58  Timer0 PWM Dead-Time Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[11:0]  |DTCNT     |Dead-time Counter (Write Protect)
 * |        |          |The dead-time can be calculated from the following two formulas:
 * |        |          |Dead-time = (DTCNT[11:0] + 1) * TMRx_PWMCLK, if DTCKSEL is 0.
 * |        |          |Dead-time = (DTCNT[11:0] + 1) * TMRx_PWMCLK * (CLKPSC + 1), if DTCKSEL is 1.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag130
 * |[16]    |DTEN      |Enable Dead-time Insertion for PWMx_CH0 and PWMx_CH1 (Write Protect)
 * |        |          |Dead-time insertion function is only active when PWM complementary mode is enabled
 * |        |          |If dead- time insertion is inactive, the outputs of PWMx_CH0 and PWMx_CH1 are complementary without any delay.
 * |        |          |0 = Dead-time insertion Disabled on the pin pair.
 * |        |          |1 = Dead-time insertion Enabled on the pin pair.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag129
 * |[24]    |DTCKSEL   |Dead-time Clock Select (Write Protect)
 * |        |          |0 = Dead-time clock source from TMRx_PWMCLK without counter clock prescale.
 * |        |          |1 = Dead-time clock source from TMRx_PWMCLK with counter clock prescale.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag128
 * @var TMR01_T::PWMCNT
 * Offset: 0x5C  Timer0 PWM Counter Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CNT       |PWM Counter Value Register (Read Only)
 * |        |          |User can monitor CNT to know the current counter value in 16-bit period counter.[WH1]
 * |        |          |[WH1]Tag132
 * |[16]    |DIRF      |PWM Counter Direction Indicator Flag (Read Only)
 * |        |          |0 = Counter is active in down count.
 * |        |          |1 = Counter is active up count.[WH1]
 * |        |          |[WH1]Tag131
 * @var TMR01_T::PWMMSKEN
 * Offset: 0x60  Timer0 PWM Output Mask Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |MSKEN0    |PWMx_CH0 Output Mask Enable Bit
 * |        |          |The PWMx_CH0 output signal will be masked when this bit is enabled
 * |        |          |The PWMx_CH0 will output MSKDAT0 (TIMER_PWMMSK[0]) data.
 * |        |          |0 = PWMx_CH0 output signal is non-masked.
 * |        |          |1 = PWMx_CH0 output signal is masked and output MSKDAT0 data.[WH1]
 * |        |          |[WH1]Tag133
 * |[1]     |MSKEN1    |PWMx_CH1 Output Mask Enable Bit
 * |        |          |The PWMx_CH1 output signal will be masked when this bit is enabled
 * |        |          |The PWMx_CH1 will output MSKDAT1 (TIMER_PWMMSK[1]) data.
 * |        |          |0 = PWMx_CH1 output signal is non-masked.
 * |        |          |1 = PWMx_CH1 output signal is masked and output MSKDAT1 data.
 * @var TMR01_T::PWMMSK
 * Offset: 0x64  Timer0 PWM Output Mask Data Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |MSKDAT0   |PWMx_CH0 Output Mask Data Control Bit
 * |        |          |This bit is used to control the output state of PWMx_CH0 pin when PWMx_CH0 output mask function is enabled (MSKEN0 = 1).
 * |        |          |0 = Output logic Low to PWMx_CH0.
 * |        |          |1 = Output logic High to PWMx_CH0.[WH1]
 * |        |          |[WH1]Tag134
 * |[1]     |MSKDAT1   |PWMx_CH1 Output Mask Data Control Bit
 * |        |          |This bit is used to control the output state of PWMx_CH1 pin when PWMx_CH1 output mask function is enabled (MSKEN1 = 1).
 * |        |          |0 = Output logic Low to PWMx_CH1.
 * |        |          |1 = Output logic High to PWMx_CH1.
 * @var TMR01_T::PWMBNF
 * Offset: 0x68  Timer0 PWM Brake Pin Noise Filter Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BRKNFEN   |Brake Pin Noise Filter Enable Bit
 * |        |          |0 = Pin noise filter detect of TM_BRAKEx Disabled.
 * |        |          |1 = Pin noise filter detect of TM_BRAKEx Enabled.[WH1]
 * |        |          |[WH1]Tag139
 * |[3:1]   |BRKNFSEL  |Brake Pin Noise Filter Clock Selection
 * |        |          |000 = Noise filter clock is PCLKx.
 * |        |          |001 = Noise filter clock is PCLKx/2.
 * |        |          |010 = Noise filter clock is PCLKx/4.
 * |        |          |011 = Noise filter clock is PCLKx/8.
 * |        |          |100 = Noise filter clock is PCLKx/16.
 * |        |          |101 = Noise filter clock is PCLKx/32.
 * |        |          |110 = Noise filter clock is PCLKx/64.
 * |        |          |111 = Noise filter clock is PCLKx/128.[WH1]
 * |        |          |[WH1]Tag138
 * |[6:4]   |BRKFCNT   |Brake Pin Noise Filter Count
 * |        |          |The fields is used to control the active noise filter sample time.
 * |        |          |Once noise filter sample time = (Period time of BRKDBCS) * BRKFCNT.[WH1]
 * |        |          |[WH1]Tag137
 * |[7]     |BRKPINV   |Brake Pin Detection Control Bit
 * |        |          |0 = Brake pin event will be detected if TM_BRAKEx pin status transfer from low to high in edge-detect, or pin status is high in level-detect.
 * |        |          |1 = Brake pin event will be detected if TM_BRAKEx pin status transfer from high to low in edge-detect, or pin status is low in level-detect .[WH1]
 * |        |          |[WH1]Tag136
 * |[17:16] |BKPINSRC  |Brake Pin Source Select
 * |        |          |00 = Brake pin source comes from TM_BRAKE0.
 * |        |          |01 = Brake pin source comes from TM_BRAKE1.
 * |        |          |10 = Brake pin source comes from TM_BRAKE2.
 * |        |          |11 = Brake pin source comes from TM_BRAKE3.[WH1]
 * |        |          |[WH1]Tag135
 * @var TMR01_T::PWMFAILBRK
 * Offset: 0x6C  Timer0 PWM System Fail Brake Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CSSBRKEN  |Clock Security System Detection Trigger PWM Brake Function Enable Bit
 * |        |          |0 = Brake Function triggered by clock fail detection Disabled.
 * |        |          |1 = Brake Function triggered by clock fail detection Enabled.[WH1]
 * |        |          |[WH1]Tag143
 * |[1]     |BODBRKEN  |Brown-out Detection Trigger PWM Brake Function Enable Bit
 * |        |          |0 = Brake Function triggered by BOD event Disabled.
 * |        |          |1 = Brake Function triggered by BOD event Enabled.[WH1]
 * |        |          |[WH1]Tag142
 * |[2]     |RAMBRKEN  |SRAM Parity Error Detection Trigger PWM Brake Function Enable Bit
 * |        |          |0 = Brake Function triggered by SRAM parity error detection Disabled.
 * |        |          |1 = Brake Function triggered by SRAM parity error detection Enabled.[WH1]
 * |        |          |[WH1]Tag141
 * |[3]     |CORBRKEN  |Core Lockup Detection Trigger PWM Brake Function Enable Bit
 * |        |          |0 = Brake Function triggered by core lockup event Disabled.
 * |        |          |1 = Brake Function triggered by core lockup event Enabled.[WH1]
 * |        |          |[WH1]Tag140
 * @var TMR01_T::PWMBRKCTL
 * Offset: 0x70  Timer0 PWM Brake Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[4]     |BRKPEEN   |Enable TM_BRAKEx Pin As Edge-detect Brake Source (Write Protect)
 * |        |          |0 = TM_BRAKEx pin event as edge-detect brake source Disabled.
 * |        |          |1 = TM_BRAKEx pin event as edge-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag151
 * |[7]     |SYSEBEN   |Enable System Fail As Edge-detect Brake Source (Write Protect)
 * |        |          |0 = System fail condition as edge-detect brake source Disabled.
 * |        |          |1 = System fail condition as edge-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag150
 * |[12]    |BRKPLEN   |Enable TM_BRAKEx Pin As Level-detect Brake Source (Write Protect)
 * |        |          |0 = TM_BRAKEx pin event as level-detect brake source Disabled.
 * |        |          |1 = TM_BRAKEx pin event as level-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag147
 * |[15]    |SYSLBEN   |Enable System Fail As Level-detect Brake Source (Write Protect)
 * |        |          |0 = System fail condition as level-detect brake source Disabled.
 * |        |          |1 = System fail condition as level-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag146
 * |[17:16] |BRKAEVEN  |PWM Brake Action Select for PWMx_CH0 (Write Protect)
 * |        |          |00 = TIMERx_PWM brake event will not affect PWMx_CH0 output.
 * |        |          |01 = PWMx_CH0 output tri-state when TIMERx_PWM brake event happened.
 * |        |          |10 = PWMx_CH0 output low level when TIMERx_PWM brake event happened.
 * |        |          |11 = PWMx_CH0 output high level when TIMERx_PWM brake event happened.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag145
 * |[19:18] |BRKAODD   |PWM Brake Action Select for PWMx_CH1 (Write Protect)
 * |        |          |00 = TIMERx_PWM brake event will not affect PWMx_CH1 output.
 * |        |          |01 = PWMx_CH1 output tri-state when TIMERx_PWM brake event happened.
 * |        |          |10 = PWMx_CH1 output low level when TIMERx_PWM brake event happened.
 * |        |          |11 = PWMx_CH1 output high level when TIMERx_PWM brake event happened.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag144
 * @var TMR01_T::PWMPOLCTL
 * Offset: 0x74  Timer0 PWM Pin Output Polar Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PINV0     |PWMx_CH0 Output Pin Polar Control Bit
 * |        |          |The bit is used to control polarity state of PWMx_CH0 output pin.
 * |        |          |0 = PWMx_CH0 output pin polar inverse Disabled.
 * |        |          |1 = PWMx_CH0 output pin polar inverse Enabled.[WH1]
 * |        |          |[WH1]Tag154
 * |[1]     |PINV1     |PWMx_CH1 Output Pin Polar Control Bit
 * |        |          |The bit is used to control polarity state of PWMx_CH1 output pin.
 * |        |          |0 = PWMx_CH1 output pin polar inverse Disabled.
 * |        |          |1 = PWMx_CH1 output pin polar inverse Enabled.
 * @var TMR01_T::PWMPOEN
 * Offset: 0x78  Timer0 PWM Pin Output Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |POEN0     |PWMx_CH0 Output Pin Enable Bit
 * |        |          |0 = PWMx_CH0 pin at tri-state mode.
 * |        |          |1 = PWMx_CH0 pin in output mode.[WH1]
 * |        |          |[WH1]Tag155
 * |[1]     |POEN1     |PWMx_CH1 Output Pin Enable Bit
 * |        |          |0 = PWMx_CH1 pin at tri-state mode.
 * |        |          |1 = PWMx_CH1 pin in output mode.
 * @var TMR01_T::PWMSWBRK
 * Offset: 0x7C  Timer0 PWM Software Trigger Brake Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BRKETRG   |Software Trigger Edge-detect Brake Source (Write Only) (Write Protect)
 * |        |          |Write 1 to this bit will trigger PWM edge-detect brake source, then BRKEIF0 and BRKEIF1 will set to 1 automatically in TIMERx_PWMINTSTS1 register.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag156
 * |[8]     |BRKLTRG   |Software Trigger Level-detect Brake Source (Write Only) (Write Protect)
 * |        |          |Write 1 to this bit will trigger PWM level-detect brake source, then BRKLIF0 and BRKLIF1 will set to 1 automatically in TIMERx_PWMINTSTS1 register.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * @var TMR01_T::PWMINTEN0
 * Offset: 0x80  Timer0 PWM Interrupt Enable Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ZIEN      |PWM Zero Point Interrupt Enable Bit
 * |        |          |0 = Zero point interrupt Disabled.
 * |        |          |1 = Zero point interrupt Enabled.[WH1]
 * |        |          |[WH1]Tag160
 * |[1]     |PIEN      |PWM Period Point Interrupt Enable Bit
 * |        |          |0 = Period point interrupt Disabled.
 * |        |          |1 = Period point interrupt Enabled.
 * |        |          |Note: When in up-down count type, period point means the center point of current PWM period.[WH1]
 * |        |          |[WH1]Tag159
 * |[2]     |CMPUIEN   |PWM Compare Up Count Interrupt Enable Bit
 * |        |          |0 = Compare up count interrupt Disabled.
 * |        |          |1 = Compare up count interrupt Enabled.[WH1]
 * |        |          |[WH1]Tag158
 * |[3]     |CMPDIEN   |PWM Compare Down Count Interrupt Enable Bit
 * |        |          |0 = Compare down count interrupt Disabled.
 * |        |          |1 = Compare down count interrupt Enabled.[WH1]
 * |        |          |[WH1]Tag157
 * @var TMR01_T::PWMINTEN1
 * Offset: 0x84  Timer0 PWM Interrupt Enable Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BRKEIEN   |PWM Edge-detect Brake Interrupt Enable (Write Protect)
 * |        |          |0 = PWM edge-detect brake interrupt Disabled.
 * |        |          |1 = PWM edge-detect brake interrupt Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag162
 * |[8]     |BRKLIEN   |PWM Level-detect Brake Interrupt Enable (Write Protect)
 * |        |          |0 = PWM level-detect brake interrupt Disabled.
 * |        |          |1 = PWM level-detect brake interrupt Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag161
 * @var TMR01_T::PWMINTSTS0
 * Offset: 0x88  Timer0 PWM Interrupt Status Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ZIF       |PWM Zero Point Interrupt Flag
 * |        |          |This bit is set by hardware when TIMERx_PWM counter reaches zero.
 * |        |          |Note: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag166
 * |[1]     |PIF       |PWM Period Point Interrupt Flag
 * |        |          |This bit is set by hardware when TIMERx_PWM counter reaches PERIOD.
 * |        |          |Note1: When in up-down count type, PIF flag means the center point flag of current PWM period.
 * |        |          |Note2: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag165
 * |[2]     |CMPUIF    |PWM Compare Up Count Interrupt Flag
 * |        |          |This bit is set by hardware when TIMERx_PWM counter in up count direction and reaches CMP.
 * |        |          |Note1: If CMP equal to PERIOD, there is no CMPUIF flag in up count type and up-down count type.
 * |        |          |Note2: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag164
 * |[3]     |CMPDIF    |PWM Compare Down Count Interrupt Flag
 * |        |          |This bit is set by hardware when TIMERx_PWM counter in down count direction and reaches CMP.
 * |        |          |Note1: If CMP equal to PERIOD, there is no CMPDIF flag in down count type.
 * |        |          |Note2: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag163
 * @var TMR01_T::PWMINTSTS1
 * Offset: 0x8C  Timer0 PWM Interrupt Status Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BRKEIF0   |Edge-detect Brake Interrupt Flag on PWMx_CH0 (Write Protect)
 * |        |          |0 = PWMx_CH0 edge-detect brake event do not happened.
 * |        |          |1 = PWMx_CH0 edge-detect brake event happened.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag170
 * |[1]     |BRKEIF1   |Edge-detect Brake Interrupt Flag PWMx_CH1 (Write Protect)
 * |        |          |0 = PWMx_CH1 edge-detect brake event do not happened.
 * |        |          |1 = PWMx_CH1 edge-detect brake event happened.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2: This register is write protected. Refer to SYS_REGLCTL register.
 * |[8]     |BRKLIF0   |Level-detect Brake Interrupt Flag on PWMx_CH0 (Write Protect)
 * |        |          |0 = PWMx_CH0 level-detect brake event do not happened.
 * |        |          |1 = PWMx_CH0 level-detect brake event happened.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag169
 * |[9]     |BRKLIF1   |Level-detect Brake Interrupt Flag on PWMx_CH1 (Write Protect)
 * |        |          |0 = PWMx_CH1 level-detect brake event do not happened.
 * |        |          |1 = PWMx_CH1 level-detect brake event happened.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2: This register is write protected. Refer to SYS_REGLCTL register.
 * |[16]    |BRKESTS0  |Edge -detect Brake Status of PWMx_CH0 (Read Only)
 * |        |          |0 = PWMx_CH0 edge-detect brake state is released.
 * |        |          |1 = PWMx_CH0 at edge-detect brake state.
 * |        |          |Note: User can set BRKEIF0 1 to clear BRKEIF0 flag and PWMx_CH0 will release brake state when current PWM period finished and resume PWMx_CH0 output waveform start from next full PWM period.[WH1]
 * |        |          |[WH1]Tag168
 * |[17]    |BRKESTS1  |Edge-detect Brake Status of PWMx_CH1 (Read Only)
 * |        |          |0 = PWMx_CH1 edge-detect brake state is released.
 * |        |          |1 = PWMx_CH1 at edge-detect brake state.
 * |        |          |Note: User can set BRKEIF1 1 to clear BRKEIF1 flag and PWMx_CH1 will release brake state when current PWM period finished and resume PWMx_CH1 output waveform start from next full PWM period.
 * |[24]    |BRKLSTS0  |Level-detect Brake Status of PWMx_CH0 (Read Only)
 * |        |          |0 = PWMx_CH0 level-detect brake state is released.
 * |        |          |1 = PWMx_CH0 at level-detect brake state.
 * |        |          |Note: If TIMERx_PWM level-detect brake source has released, both PWMx_CH0 and PWMx_CH1 will release brake state when current PWM period finished and resume PWMx_CH0 and PWMx_CH1 output waveform start from next full PWM period.[WH1]
 * |        |          |[WH1]Tag167
 * |[25]    |BRKLSTS1  |Level-detect Brake Status of PWMx_CH1 (Read Only)
 * |        |          |0 = PWMx_CH1 level-detect brake state is released.
 * |        |          |1 = PWMx_CH1 at level-detect brake state.
 * |        |          |Note: If TIMERx_PWM level-detect brake source has released, both PWMx_CH0 and PWMx_CH1 will release brake state when current PWM period finished and resume PWMx_CH0 and PWMx_CH1 output waveform start from next full PWM period.
 * @var TMR01_T::PWMADCTS
 * Offset: 0x90  Timer0 PWM ADC Trigger Source Select Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[2:0]   |TRGSEL    |PWM Counter Event Source Select to Trigger ADC Conversion
 * |        |          |000 = Trigger ADC conversion at zero point (ZIF).
 * |        |          |001 = Trigger ADC conversion at period point (PIF).
 * |        |          |010 = Trigger ADC conversion at zero or period point (ZIF or PIF).
 * |        |          |011 = Trigger ADC conversion at compare up count point (CMPUIF).
 * |        |          |100 = Trigger ADC conversion at compare down count point (CMPDIF).
 * |        |          |Others = Reserved.[WH1]
 * |        |          |[WH1]Tag172
 * |[7]     |TRGEN     |PWM Counter Event Trigger ADC Conversion Enable Bit
 * |        |          |0 = PWM counter event trigger ADC conversion Disabled.
 * |        |          |1 = PWM counter event trigger ADC conversion Enabled.[WH1]
 * |        |          |[WH1]Tag171
 * @var TMR01_T::PWMSCTL
 * Offset: 0x94  Timer0 PWM Synchronous Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |SYNCMODE  |PWM Synchronous Mode Enable Select
 * |        |          |00 = PWM synchronous function Disabled.
 * |        |          |01 = PWM synchronous counter start function Enabled.
 * |        |          |10 = Reserved.
 * |        |          |11 = PWM synchronous counter clear function Enabled.[WH1]
 * |        |          |[WH1]Tag174
 * |[8]     |SYNCSRC   |PWM Synchronous Counter Start/Clear Source Select
 * |        |          |0 = Counter synchronous start/clear by trigger STRGEN (TIMER0_PWMSTRG[0]).
 * |        |          |1 = Counter synchronous start/clear by trigger STRGEN (TIMER2_PWMSTRG[0]).
 * |        |          |Note1: If TIMER0/1/2/3 PWM counter synchronous source are from TIMER0, TIME0_PWMSCTL[8], TIME1_PWMSCTL[8], TIME2_PWMSCTL[8] and TIME3_PWMSCTL[8] should be 0.
 * |        |          |Note2: If TIMER0/1/ PWM counter synchronous source are from TIMER0, TIME0_PWMSCTL[8] and TIME1_PWMSCTL[8] should be set 0, and TIMER2/3/ PWM counter synchronous source are from TIMER2, TIME2_PWMSCTL[8] and TIME3_PWMSCTL[8] should be set 1.[WH1]
 * |        |          |[WH1]Tag173
 * @var TMR01_T::PWMSTRG
 * Offset: 0x98  Timer0 PWM Synchronous Trigger Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |STRGEN    |PWM Counter Synchronous Trigger Enable Bit (Write Only)
 * |        |          |PMW counter synchronous function is used to make selected PWM channels (include TIMER0/1/2/3 PWM, TIMER0/1 PWM and TIMER2/3 PWM) start counting or clear counter at the same time according to TIMERx_PWMSCTL setting.
 * |        |          |Note: This bit is only available in TIMER0 and TIMER2.[WH1]
 * |        |          |[WH1]Tag175
 * @var TMR01_T::PWMSTATUS
 * Offset: 0x9C  Timer0 PWM Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CNTMAXF   |PWM Counter Equal to 0xFFFF Flag
 * |        |          |0 = Indicates the PWM counter value never reached its maximum value 0xFFFF.
 * |        |          |1 = Indicates the PWM counter value has reached its maximum value.
 * |        |          |Note: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag177
 * |[16]    |ADCTRGF   |Trigger ADC Start Conversion Flag
 * |        |          |0 = PWM counter event trigger ADC start conversion is not occurred.
 * |        |          |1 = PWM counter event trigger ADC start conversion has occurred.
 * |        |          |Note: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag176
 * @var TMR01_T::PWMPBUF
 * Offset: 0xA0  Timer0 PWM Period Buffer Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PBUF      |PWM Period Buffer Register (Read Only)
 * |        |          |Used as PERIOD active register.[WH1]
 * |        |          |[WH1]Tag178
 * @var TMR01_T::PWMCMPBUF
 * Offset: 0xA4  Timer0 PWM Comparator Buffer Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CMPBUF    |PWM Comparator Buffer Register (Read Only)
 * |        |          |Used as CMP active register.[WH1]
 * |        |          |[WH1]Tag179
 * @var TMR01_T::CTL
 * Offset: 0x100  Timer1 Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[7:0]   |PSC       |Prescale Counter
 * |        |          |Timer input clock or event source is divided by (PSC+1) before it is fed to the timer up counter
 * |        |          |If this field is 0 (PSC = 0), then there is no scaling.
 * |        |          |Note: Update prescale counter value will reset internal 8-bit prescale counter and 24-bit up counter value.[WH1]
 * |        |          |[WH1]Tag92
 * |[19]    |INTRGEN   |Inter-timer Trigger Mode Enable Control
 * |        |          |Setting this bit will enable the inter-timer trigger capture function.
 * |        |          |The Timer0/2 will be in event counter mode and counting with external clock source or event
 * |        |          |Also, Timer1/3 will be in trigger-counting mode of capture function.
 * |        |          |0 = Inter-Timer Trigger Capture mode Disabled.
 * |        |          |1 = Inter-Timer Trigger Capture mode Enabled.
 * |        |          |Note: For Timer1/3, this bit is ignored and the read back value is always 0.[WH1]
 * |        |          |[WH1]Tag91
 * |[20]    |PERIOSEL  |Periodic Mode Behavior Selection Enable Bit
 * |        |          |0 = The behavior selection in periodic mode is Disabled.
 * |        |          |When user updates CMPDAT while timer is running in periodic mode,
 * |        |          |CNT will be reset to default value.
 * |        |          |1 = The behavior selection in periodic mode is Enabled.
 * |        |          |When user update CMPDAT while timer is running in periodic mode, the limitations as bellows list,
 * |        |          |If updated CMPDAT value > CNT, CMPDAT will be updated and CNT keep running continually.
 * |        |          |If updated CMPDAT value = CNT, timer time-out interrupt will be asserted immediately.
 * |        |          |If updated CMPDAT value < CNT, CNT will be reset to default value.[WH1]
 * |        |          |[WH1]Tag90
 * |[21]    |TGLPINSEL |Toggle-output Pin Select
 * |        |          |0 = Toggle mode output to Tx (Timer Event Counter Pin).
 * |        |          |1 = Toggle mode output to Tx_EXT (Timer External Capture Pin).[WH1]
 * |        |          |[WH1]Tag89
 * |[22]    |CAPSRC    |Capture Pin Source Selection
 * |        |          |0 = Capture Function source is from Tx_EXT (x= 0~3) pin.
 * |        |          |1 =RESERVED [AlvinLiao1].[WH2]
 * |        |          |[AlvinLiao1] NEED TO REVEISED
 * |        |          |[WH2]Tag88
 * |[23]    |WKEN      |Wake-up Function Enable Bit
 * |        |          |If this bit is set to 1, while timer interrupt flag TIF (TIMERx_INTSTS[0]) is 1 and INTEN (TIMERx_CTL[29]) is enabled, the timer interrupt signal will generate a wake-up trigger event to CPU.
 * |        |          |0 = Wake-up function Disabled if timer interrupt signal generated.
 * |        |          |1 = Wake-up function Enabled if timer interrupt signal generated.[WH1]
 * |        |          |[WH1]Tag87
 * |[24]    |EXTCNTEN  |Event Counter Mode Enable Bit
 * |        |          |This bit is for external counting pin function enabled.
 * |        |          |0 = Event counter mode Disabled.
 * |        |          |1 = Event counter mode Enabled.
 * |        |          |Note: When timer is used as an event counter, this bit should be set to 1 and select PCLK as timer clock source.[WH1]
 * |        |          |[WH1]Tag86
 * |[25]    |ACTSTS    |Timer Active Status Bit (Read Only)
 * |        |          |This bit indicates the 24-bit up counter status.
 * |        |          |0 = 24-bit up counter is not active.
 * |        |          |1 = 24-bit up counter is active.[WH1]
 * |        |          |[WH1]Tag85
 * |[26]    |RSTCNT    |Timer Counter Reset Bit (Not Release in TRM)
 * |        |          |Setting this bit will reset the 24-bit up counter value CNT (TIMERx_CNT[23:0]) and also force CNTEN (TIMERx_CTL[30]) to 0 if ACTSTS (TIMERx_CTL[25]) is 1.
 * |        |          |0 = No effect.
 * |        |          |1 = Reset internal 8-bit prescale counter, 24-bit up counter value and CNTEN bit.[WH1]
 * |        |          |[WH1]Tag84, not release in TRM
 * |[28:27] |OPMODE    |Timer Counting Mode Select
 * |        |          |00 = The Timer controller is operated in One-shot mode.
 * |        |          |01 = The Timer controller is operated in Periodic mode.
 * |        |          |10 = The Timer controller is operated in Toggle-output mode.
 * |        |          |11 = The Timer controller is operated in Continuous Counting mode.[WH1]
 * |        |          |[WH1]Tag83
 * |[29]    |INTEN     |Timer Interrupt Enable Bit
 * |        |          |0 = Timer time-out interrupt Disabled.
 * |        |          |1 = Timer time-out interrupt Enabled.
 * |        |          |Note: If this bit is enabled, when the timer time-out interrupt flag TIF is set to 1, the timer interrupt signal is generated and inform to CPU.[WH1]
 * |        |          |[WH1]Tag82
 * |[30]    |CNTEN     |Timer Counting Enable Bit
 * |        |          |0 = Stops/Suspends counting.
 * |        |          |1 = Starts counting.
 * |        |          |Note1: In stop status, and then set CNTEN to 1 will enable the 24-bit up counter to keep counting from the last stop counting value.
 * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode OPMODE (TIMER_CTL[28:27] = 00) when the timer time-out interrupt flag TIF (TIMERx_INTSTS[0]) is generated.
 * |        |          |Note3: Set enable/disable this bit needs 2 * TMR_CLK period to become active, user can read ACTSTS (TIMERx_CTL[25]) to check enabe/disable command is completed or not.[WH1]
 * |        |          |[WH1]Tag81
 * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Control (Write Protect)
 * |        |          |0 = ICE debug mode acknowledgement effects TIMER counting.
 * |        |          |TIMER counter will be held while CPU is held by ICE.
 * |        |          |1 = ICE debug mode acknowledgement Disabled.
 * |        |          |TIMER counter will keep going no matter CPU is held by ICE or not.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag80
 * @var TMR01_T::CMP
 * Offset: 0x104  Timer1 Comparator Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[23:0]  |CMPDAT    |Timer Comparator Value
 * |        |          |CMPDAT is a 24-bit compared value register
 * |        |          |When the internal 24-bit up counter value is equal to CMPDAT value, the TIF (TIMERx_INTSTS[0] Timer Interrupt Flag) will set to 1.
 * |        |          |Time-out period = (Period of timer clock input) * (8-bit PSC + 1) * (24-bit CMPDAT).
 * |        |          |Note1: Never write 0x0 or 0x1 in CMPDAT field, or the core will run into unknown state.
 * |        |          |Note2: When timer is operating at continuous counting mode, the 24-bit up counter will keep counting continuously even if user writes a new value into CMPDAT field
 * |        |          |But if timer is operating at other modes, the 24-bit up counter will restart counting from 0 and using newest CMPDAT value to be the timer compared value while user writes a new value into CMPDAT field.[WH1]
 * |        |          |[WH1]Tag93
 * @var TMR01_T::INTSTS
 * Offset: 0x108  Timer1 Interrupt Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |TIF       |Timer Interrupt Flag
 * |        |          |This bit indicates the interrupt flag status of Timer while 24-bit timer up counter CNT (TIMERx_CNT[23:0]) value reaches to CMPDAT (TIMERx_CMP[23:0]) value.
 * |        |          |0 = No effect.
 * |        |          |1 = CNT value matches the CMPDAT value.
 * |        |          |Note: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag95
 * |[1]     |TWKF      |Timer Wake-up Flag
 * |        |          |This bit indicates the interrupt wake-up flag status of timer.
 * |        |          |0 = Timer does not cause CPU wake-up.
 * |        |          |1 = CPU wake-up from Idle or Power-down mode if timer time-out interrupt signal generated.
 * |        |          |Note: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag94
 * @var TMR01_T::CNT
 * Offset: 0x10C  Timer1 Data Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[23:0]  |CNT       |Timer Data Register
 * |        |          |Read operation.
 * |        |          |Read this register to get CNT value. For example:
 * |        |          |If EXTCNTEN (TIMERx_CTL[24] ) is 0, user can read CNT value for getting current 24-bit counter value.
 * |        |          |If EXTCNTEN (TIMERx_CTL[24] ) is 1, user can read CNT value for getting current 24-bit event input counter value.
 * |        |          |Write operation.
 * |        |          |Writing any value to this register will reset current CNT value to 0 and reload internal 8-bit prescale counter.[WH1]
 * |        |          |[WH1]Tag97
 * |[31]    |RSTACT    |Timer Data Register Reset Active (Read Only)
 * |        |          |This bit indicates if the counter reset operation active.
 * |        |          |When user writes this CNT register, timer starts to reset its internal 24-bit timer up-counter to 0 and reload 8-bit pre-scale counter
 * |        |          |At the same time, timer set this flag to 1 to indicate the counter reset operation is in progress
 * |        |          |Once the counter reset operation done, timer clear this bit to 0 automatically.
 * |        |          |0 = Reset operation is done.
 * |        |          |1 = Reset operation triggered by writing TIMERx_CNT is in progress.
 * |        |          |Note: This bit is read only.[WH1]
 * |        |          |[WH1]Tag96
 * @var TMR01_T::CAP
 * Offset: 0x110  Timer1 Capture Data Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[23:0]  |CAPDAT    |Timer Capture Data Register (Read Only)
 * |        |          |When CAPEN (TIMERx_EXTCTL[3]) bit is set, CAPFUNCS (TIMERx_EXTCTL[4]) bit is 0, and a transition on Tx_EXT pin matched the CAPEDGE (TIMERx_EXTCTL[14:12]) setting, CAPIF (TIMERx_EINTSTS[0]) will set to 1 and the current timer counter value CNT (TIMERx_CNT[23:0]) will be auto-loaded into this CAPDAT field.[WH1]
 * |        |          |[WH1]Tag98
 * @var TMR01_T::EXTCTL
 * Offset: 0x114  Timer1 External Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CNTPHASE  |Timer External Count Phase
 * |        |          |This bit indicates the detection phase of external counting pin Tx (x= 0~3).
 * |        |          |0 = A falling edge of external counting pin will be counted.
 * |        |          |1 = A rising edge of external counting pin will be counted.[WH1]
 * |        |          |[WH1]Tag107
 * |[2:1]   |SCAPEDGE  |SBZ
 * |[3]     |CAPEN     |Timer External Capture Pin Enable Bit
 * |        |          |This bit enables the Tx_EXT capture pin input function.
 * |        |          |0 =Tx_EXT (x= 0~3) pin Disabled.
 * |        |          |1 =Tx_EXT (x= 0~3) pin Enabled.[WH1]
 * |        |          |[WH1]Tag106
 * |[4]     |CAPFUNCS  |Capture Function Selection
 * |        |          |0 = External Capture Mode Enabled.
 * |        |          |1 = External Reset Mode Enabled.
 * |        |          |Note1: When CAPFUNCS is 0, transition on Tx_EXT (x= 0~3) pin is using to save current 24-bit timer counter value (CNT value) to CAPDAT field.
 * |        |          |Note2: When CAPFUNCS is 1, transition on Tx_EXT (x= 0~3) pin is using to save current 24-bit timer counter value (CNT value) to CAPDAT field then CNT value will be reset immediately.[WH1]
 * |        |          |[WH1]Tag105
 * |[5]     |CAPIEN    |Timer External Capture Interrupt Enable Bit
 * |        |          |0 = Tx_EXT (x= 0~3) pin detection Interrupt Disabled.
 * |        |          |1 = Tx_EXT (x= 0~3) pin detection Interrupt Enabled.
 * |        |          |Note: CAPIEN is used to enable timer external interrupt
 * |        |          |If CAPIEN enabled, timer will rise an interrupt when CAPIF (TIMERx_EINTSTS[0]) is 1.
 * |        |          |For example, while CAPIEN = 1, CAPEN = 1, and CAPEDGE = 00, a 1 to 0 transition on the Tx_EXT pin will cause the CAPIF to be set then the interrupt signal is generated and sent to NVIC to inform CPU.[WH1]
 * |        |          |[WH1]Tag104
 * |[6]     |CAPDBEN   |Timer External Capture Pin De-bounce Enable Bit
 * |        |          |0 = Tx_EXT (x= 0~3) pin de-bounce Disabled.
 * |        |          |1 = Tx_EXT (x= 0~3) pin de-bounce Enabled.
 * |        |          |Note: If this bit is enabled, the edge detection of Tx_EXT pin output is detected with de-bounce circuit.[WH1]
 * |        |          |[WH1]Tag103
 * |[7]     |CNTDBEN   |Timer Counter Pin De-bounce Enable Bit
 * |        |          |0 = Tx (x= 0~3) pin de-bounce Disabled.
 * |        |          |1 = Tx (x= 0~3) pin de-bounce Enabled.
 * |        |          |Note: If this bit is enabled, the edge detection of Tx pin is detected with de-bounce circuit.[WH1]
 * |        |          |[WH1]Tag102
 * |[14:12] |CAPEDGE   |Timer External Capture Pin Edge Detect
 * |        |          |When first capture event is generated, the CNT (TIMERx_CNT[23:0]) will be reset to 0 and first CAPDAT (TIMERx_CAP[23:0]) should be to 0.
 * |        |          |000 = Capture event occurred when detect falling edge transfer on Tx_EXT (x= 0~3) pin.
 * |        |          |001 = Capture event occurred when detect rising edge transfer on Tx_EXT (x= 0~3) pin.
 * |        |          |010 = Capture event occurred when detect both falling and rising edge transfer on Tx_EXT (x= 0~3) pin, and first capture event occurred at falling edge transfer.
 * |        |          |011 = Capture event occurred when detect both rising and falling edge transfer on Tx_EXT (x= 0~3) pin, and first capture event occurred at rising edge transfer.
 * |        |          |110 = First capture event occurred at falling edge, follows capture events are at rising edge transfer on Tx_EXT (x= 0~3) pin.
 * |        |          |111 = First capture event occurred at rising edge, follows capture events are at falling edge transfer on Tx_EXT (x= 0~3) pin.
 * |        |          |100, 101 = Reserved.[WH1]
 * |        |          |[WH1]Tag100
 * |[16]    |ECNTSSEL  |Event Counter Source Selection to Trigger Event Counter Function
 * |        |          |0 = Event Counter input source is from Tx (x= 0~3) pin.
 * |        |          |1 = Reserved Event Counter input source is from USB internal SOF output signal.[WH1]
 * |        |          |[WH1]Tag99
 * @var TMR01_T::EINTSTS
 * Offset: 0x118  Timer1 External Interrupt Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CAPIF     |Timer External Capture Interrupt Flag
 * |        |          |This bit indicates the timer external capture interrupt flag status.
 * |        |          |0 = Tx_EXT (x= 0~3) pin interrupt did not occur.
 * |        |          |1 = Tx_EXT (x= 0~3) pin interrupt occurred.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2: When CAPEN (TIMERx_EXTCTL[3]) bit is set, CAPFUNCS (TIMERx_EXTCTL[4]) bit is 0, and a transition on Tx_EXT (x= 0~3) pin matched the CAPEDGE (TIMERx_EXTCTL[2:1]) setting, this bit will set to 1 by hardware.
 * |        |          |Note3: There is a new incoming capture event detected before CPU clearing the CAPIF status
 * |        |          |If the above condition occurred, the Timer will keep register TIMERx_CAP unchanged and drop the new capture value.[WH1]
 * |        |          |[WH1]Tag108
 * @var TMR01_T::TRGCTL
 * Offset: 0x11C  Timer1 Trigger Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |TRGSSEL   |Trigger Source Select Bit
 * |        |          |This bit is used to select internal trigger source is form timer time-out interrupt signal or capture interrupt signal.
 * |        |          |0 = Time-out interrupt signal is used to internal trigger PWM, PDMA, and ADC.
 * |        |          |1 = Capture interrupt signal is used to internal trigger PWM, PDMA, and ADC.[WH1]
 * |        |          |[WH1]Tag113
 * |[1]     |TRGPWM    |Trigger PWM Enable Bit
 * |        |          |If this bit is set to 1, each timer time-out event or capture event can be as PWM counter clock source.
 * |        |          |0 = Timer interrupt trigger PWM Disabled.
 * |        |          |1 = Timer interrupt trigger PWM Enabled.
 * |        |          |Note: If TRGSSEL (TIMERx_TRGCTL[0]) = 0, time-out interrupt signal as PWM counter clock source.
 * |        |          |If TRGSSEL (TIMERx_TRGCTL[0]) = 1, capture interrupt signal as PWM counter clock source.[WH1]
 * |        |          |[WH1]Tag112
 * |[2]     |TRGADC    |Trigger ADC Enable Bit
 * |        |          |If this bit is set to 1, each timer time-out event or capture event can be triggered ADC conversion.
 * |        |          |0 = Timer interrupt trigger ADC Disabled.
 * |        |          |1 = Timer interrupt trigger ADC Enabled.
 * |        |          |Note: If TRGSSEL (TIMERx_TRGCTL[0]) = 0, time-out interrupt signal will trigger ADC conversion.
 * |        |          |If TRGSSEL (TIMERx_TRGCTL[0]) = 1, capture interrupt signal will trigger ADC conversion.[WH1]
 * |        |          |[WH1]Tag111
 * |[4]     |TRGPDMA   |Trigger PDMA Enable Bit
 * |        |          |If this bit is set to 1, each timer time-out event or capture event can be triggered PDMA transfer.
 * |        |          |0 = Timer interrupt trigger PDMA Disabled.
 * |        |          |1 = Timer interrupt trigger PDMA Enabled.
 * |        |          |Note: If TRGSSEL (TIMERx_TRGCTL[0]) = 0, time-out interrupt signal will trigger PDMA transfer.
 * |        |          |If TRGSSEL (TIMERx_TRGCTL[0]) = 1, capture interrupt signal will trigger PDMA transfer.[WH1]
 * |        |          |[WH1]Tag109
 * @var TMR01_T::ALTCTL
 * Offset: 0x120  Timer1 Alternative Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |FUNCSEL   |Function Selection
 * |        |          |0 = Timer controller is used as timer function.
 * |        |          |1 = Timer controller is used as PWM function.
 * |        |          |Note: When timer is used as PWM, the clock source of time controller will be forced to PCLKx automatically.[WH1]
 * |        |          |[WH1]Tag114
 * @var TMR01_T::PWMCTL
 * Offset: 0x140  Timer1 PWM Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CNTEN     |PWM Counter Enable Bit
 * |        |          |0 = PWM counter and clock prescale Stop Running.
 * |        |          |1 = PWM counter and clock prescale Start Running.[WH1]
 * |        |          |[WH1]Tag122
 * |[2:1]   |CNTTYPE   |PWM Counter Behavior Type
 * |        |          |00 = Up count type.
 * |        |          |01 = Down count type.
 * |        |          |10 = Up-down count type.
 * |        |          |11 = Reserved.[WH1]
 * |        |          |[WH1]Tag121
 * |[3]     |CNTMODE   |PWM Counter Mode
 * |        |          |0 = Auto-reload mode.
 * |        |          |1 = One-shot mode.[WH1]
 * |        |          |[WH1]Tag120
 * |[8]     |CTRLD     |Center Re-load
 * |        |          |In up-down count type, PERIOD will load to PBUF when current PWM period is completed always and CMP will load to CMPBUF at the center point of current period.[WH1]
 * |        |          |[WH1]Tag119
 * |[9]     |IMMLDEN   |Immediately Load Enable Bit
 * |        |          |0 = PERIOD will load to PBUF when current PWM period is completed no matter CTRLD is enabled/disabled
 * |        |          |If CTRLD is disabled, CMP will load to CMPBUF when current PWM period is completed; if CTRLD is enabled in up-down count type, CMP will load to CMPBUF at the center point of current period.
 * |        |          |1 = PERIOD/CMP will load to PBUF/CMPBUF immediately when user update PERIOD/CMP.
 * |        |          |Note: If IMMLDEN is enabled, CTRLD will be invalid.[WH1]
 * |        |          |[WH1]Tag118
 * |[16]    |OUTMODE   |PWM Output Mode
 * |        |          |This bit controls the output mode of corresponding PWM channel.
 * |        |          |0 = PWM independent mode.
 * |        |          |1 = PWM complementary mode.[WH1]
 * |        |          |[WH1]Tag117
 * |[30]    |DBGHALT   |ICE Debug Mode Counter Halt (Write Protect)
 * |        |          |If debug mode counter halt is enabled, PWM counter will keep current value until exit ICE debug mode.
 * |        |          |0 = ICE debug mode counter halt disable.
 * |        |          |1 = ICE debug mode counter halt enable.
 * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag116
 * |[31]    |DBGTRIOFF |ICE Debug Mode Acknowledge Disable Bit (Write Protect)
 * |        |          |0 = ICE debug mode acknowledgement effects PWM output.
 * |        |          |PWM output pin will be forced as tri-state while ICE debug mode acknowledged.
 * |        |          |1 = ICE debug mode acknowledgement disabled.
 * |        |          |PWM output pin will keep output no matter ICE debug mode acknowledged or not.
 * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag115
 * @var TMR01_T::PWMCLKSRC
 * Offset: 0x144  Timer1 PWM Counter Clock Source Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[2:0]   |CLKSRC    |PWM Counter Clock Source Select
 * |        |          |The PWM counter clock source can be selected from TMRx_CLK or internal timer time-out or capture event.
 * |        |          |000 = TMRx_CLK.
 * |        |          |001 = Internal TIMER0 time-out or capture event.
 * |        |          |010 = Internal TIMER1 time-out or capture event.
 * |        |          |011 = Internal TIMER2 time-out or capture event.
 * |        |          |100 = Internal TIMER3 time-out or capture event.
 * |        |          |Others = Reserved.
 * |        |          |Note: If TIMER0 PWM function is enabled, the PWM counter clock source can be selected from TMR0_CLK, TIMER1 interrupt events, TIMER2 interrupt events, or TIMER3 interrupt events.[WH1]
 * |        |          |[WH1]Tag123
 * @var TMR01_T::PWMCLKPSC
 * Offset: 0x148  Timer1 PWM Counter Clock Pre-scale Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-scale
 * |        |          |The active clock of PWM counter is decided by counter clock prescale and divided by (CLKPSC + 1)
 * |        |          |If CLKPSC is 0, then there is no scaling in PWM counter clock source.[WH1]
 * |        |          |[WH1]Tag124
 * @var TMR01_T::PWMCNTCLR
 * Offset: 0x14C  Timer1 PWM Clear Counter Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CNTCLR    |Clear PWM Counter Control Bit
 * |        |          |It is automatically cleared by hardware.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear 16-bit PWM counter to 0x10000 in up and up-down count type and reset counter value to PERIOD in down count type.[WH1]
 * |        |          |[WH1]Tag125
 * @var TMR01_T::PWMPERIOD
 * Offset: 0x150  Timer1 PWM Period Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PERIOD    |PWM Period Register
 * |        |          |In up count type: PWM counter counts from 0 to PERIOD, and restarts from 0.
 * |        |          |In down count type: PWM counter counts from PERIOD to 0, and restarts from PERIOD.
 * |        |          |In up-down count type: PWM counter counts from 0 to PERIOD, then decrements to 0 and repeats again.
 * |        |          |In up and down count type:
 * |        |          |PWM period time = (PERIOD + 1) * (CLKPSC + 1) * TMRx_PWMCLK.
 * |        |          |In up-down count type:
 * |        |          |PWM period time = 2 * PERIOD * (CLKPSC+ 1) * TMRx_PWMCLK.
 * |        |          |Note: User should take care DIRF (TIMERx_PWMCNT[16]) bit in up/down/up-down count type to monitor current counter direction in each count type.[WH1]
 * |        |          |[WH1]Tag126
 * @var TMR01_T::PWMCMPDAT
 * Offset: 0x154  Timer1 PWM Comparator Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CMP       |PWM Comparator Register
 * |        |          |PWM CMP is used to compare with PWM CNT to generate PWM output waveform, interrupt events and trigger ADC to start convert.[WH1]
 * |        |          |[WH1]Tag127
 * @var TMR01_T::PWMDTCTL
 * Offset: 0x158  Timer1 PWM Dead-Time Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[11:0]  |DTCNT     |Dead-time Counter (Write Protect)
 * |        |          |The dead-time can be calculated from the following two formulas:
 * |        |          |Dead-time = (DTCNT[11:0] + 1) * TMRx_PWMCLK, if DTCKSEL is 0.
 * |        |          |Dead-time = (DTCNT[11:0] + 1) * TMRx_PWMCLK * (CLKPSC + 1), if DTCKSEL is 1.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag130
 * |[16]    |DTEN      |Enable Dead-time Insertion for PWMx_CH0 and PWMx_CH1 (Write Protect)
 * |        |          |Dead-time insertion function is only active when PWM complementary mode is enabled
 * |        |          |If dead- time insertion is inactive, the outputs of PWMx_CH0 and PWMx_CH1 are complementary without any delay.
 * |        |          |0 = Dead-time insertion Disabled on the pin pair.
 * |        |          |1 = Dead-time insertion Enabled on the pin pair.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag129
 * |[24]    |DTCKSEL   |Dead-time Clock Select (Write Protect)
 * |        |          |0 = Dead-time clock source from TMRx_PWMCLK without counter clock prescale.
 * |        |          |1 = Dead-time clock source from TMRx_PWMCLK with counter clock prescale.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag128
 * @var TMR01_T::PWMCNT
 * Offset: 0x15C  Timer1 PWM Counter Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CNT       |PWM Counter Value Register (Read Only)
 * |        |          |User can monitor CNT to know the current counter value in 16-bit period counter.[WH1]
 * |        |          |[WH1]Tag132
 * |[16]    |DIRF      |PWM Counter Direction Indicator Flag (Read Only)
 * |        |          |0 = Counter is active in down count.
 * |        |          |1 = Counter is active up count.[WH1]
 * |        |          |[WH1]Tag131
 * @var TMR01_T::PWMMSKEN
 * Offset: 0x160  Timer1 PWM Output Mask Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |MSKEN0    |PWMx_CH0 Output Mask Enable Bit
 * |        |          |The PWMx_CH0 output signal will be masked when this bit is enabled
 * |        |          |The PWMx_CH0 will output MSKDAT0 (TIMER_PWMMSK[0]) data.
 * |        |          |0 = PWMx_CH0 output signal is non-masked.
 * |        |          |1 = PWMx_CH0 output signal is masked and output MSKDAT0 data.[WH1]
 * |        |          |[WH1]Tag133
 * |[1]     |MSKEN1    |PWMx_CH1 Output Mask Enable Bit
 * |        |          |The PWMx_CH1 output signal will be masked when this bit is enabled
 * |        |          |The PWMx_CH1 will output MSKDAT1 (TIMER_PWMMSK[1]) data.
 * |        |          |0 = PWMx_CH1 output signal is non-masked.
 * |        |          |1 = PWMx_CH1 output signal is masked and output MSKDAT1 data.
 * @var TMR01_T::PWMMSK
 * Offset: 0x164  Timer1 PWM Output Mask Data Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |MSKDAT0   |PWMx_CH0 Output Mask Data Control Bit
 * |        |          |This bit is used to control the output state of PWMx_CH0 pin when PWMx_CH0 output mask function is enabled (MSKEN0 = 1).
 * |        |          |0 = Output logic Low to PWMx_CH0.
 * |        |          |1 = Output logic High to PWMx_CH0.[WH1]
 * |        |          |[WH1]Tag134
 * |[1]     |MSKDAT1   |PWMx_CH1 Output Mask Data Control Bit
 * |        |          |This bit is used to control the output state of PWMx_CH1 pin when PWMx_CH1 output mask function is enabled (MSKEN1 = 1).
 * |        |          |0 = Output logic Low to PWMx_CH1.
 * |        |          |1 = Output logic High to PWMx_CH1.
 * @var TMR01_T::PWMBNF
 * Offset: 0x168  Timer1 PWM Brake Pin Noise Filter Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BRKNFEN   |Brake Pin Noise Filter Enable Bit
 * |        |          |0 = Pin noise filter detect of TM_BRAKEx Disabled.
 * |        |          |1 = Pin noise filter detect of TM_BRAKEx Enabled.[WH1]
 * |        |          |[WH1]Tag139
 * |[3:1]   |BRKNFSEL  |Brake Pin Noise Filter Clock Selection
 * |        |          |000 = Noise filter clock is PCLKx.
 * |        |          |001 = Noise filter clock is PCLKx/2.
 * |        |          |010 = Noise filter clock is PCLKx/4.
 * |        |          |011 = Noise filter clock is PCLKx/8.
 * |        |          |100 = Noise filter clock is PCLKx/16.
 * |        |          |101 = Noise filter clock is PCLKx/32.
 * |        |          |110 = Noise filter clock is PCLKx/64.
 * |        |          |111 = Noise filter clock is PCLKx/128.[WH1]
 * |        |          |[WH1]Tag138
 * |[6:4]   |BRKFCNT   |Brake Pin Noise Filter Count
 * |        |          |The fields is used to control the active noise filter sample time.
 * |        |          |Once noise filter sample time = (Period time of BRKDBCS) * BRKFCNT.[WH1]
 * |        |          |[WH1]Tag137
 * |[7]     |BRKPINV   |Brake Pin Detection Control Bit
 * |        |          |0 = Brake pin event will be detected if TM_BRAKEx pin status transfer from low to high in edge-detect, or pin status is high in level-detect.
 * |        |          |1 = Brake pin event will be detected if TM_BRAKEx pin status transfer from high to low in edge-detect, or pin status is low in level-detect .[WH1]
 * |        |          |[WH1]Tag136
 * |[17:16] |BKPINSRC  |Brake Pin Source Select
 * |        |          |00 = Brake pin source comes from TM_BRAKE0.
 * |        |          |01 = Brake pin source comes from TM_BRAKE1.
 * |        |          |10 = Brake pin source comes from TM_BRAKE2.
 * |        |          |11 = Brake pin source comes from TM_BRAKE3.[WH1]
 * |        |          |[WH1]Tag135
 * @var TMR01_T::PWMFAILBRK
 * Offset: 0x16C  Timer1 PWM System Fail Brake Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CSSBRKEN  |Clock Security System Detection Trigger PWM Brake Function Enable Bit
 * |        |          |0 = Brake Function triggered by clock fail detection Disabled.
 * |        |          |1 = Brake Function triggered by clock fail detection Enabled.[WH1]
 * |        |          |[WH1]Tag143
 * |[1]     |BODBRKEN  |Brown-out Detection Trigger PWM Brake Function Enable Bit
 * |        |          |0 = Brake Function triggered by BOD event Disabled.
 * |        |          |1 = Brake Function triggered by BOD event Enabled.[WH1]
 * |        |          |[WH1]Tag142
 * |[2]     |RAMBRKEN  |SRAM Parity Error Detection Trigger PWM Brake Function Enable Bit
 * |        |          |0 = Brake Function triggered by SRAM parity error detection Disabled.
 * |        |          |1 = Brake Function triggered by SRAM parity error detection Enabled.[WH1]
 * |        |          |[WH1]Tag141
 * |[3]     |CORBRKEN  |Core Lockup Detection Trigger PWM Brake Function Enable Bit
 * |        |          |0 = Brake Function triggered by core lockup event Disabled.
 * |        |          |1 = Brake Function triggered by core lockup event Enabled.[WH1]
 * |        |          |[WH1]Tag140
 * @var TMR01_T::PWMBRKCTL
 * Offset: 0x170  Timer1 PWM Brake Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[4]     |BRKPEEN   |Enable TM_BRAKEx Pin As Edge-detect Brake Source (Write Protect)
 * |        |          |0 = TM_BRAKEx pin event as edge-detect brake source Disabled.
 * |        |          |1 = TM_BRAKEx pin event as edge-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag151
 * |[7]     |SYSEBEN   |Enable System Fail As Edge-detect Brake Source (Write Protect)
 * |        |          |0 = System fail condition as edge-detect brake source Disabled.
 * |        |          |1 = System fail condition as edge-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag150
 * |[12]    |BRKPLEN   |Enable TM_BRAKEx Pin As Level-detect Brake Source (Write Protect)
 * |        |          |0 = TM_BRAKEx pin event as level-detect brake source Disabled.
 * |        |          |1 = TM_BRAKEx pin event as level-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag147
 * |[15]    |SYSLBEN   |Enable System Fail As Level-detect Brake Source (Write Protect)
 * |        |          |0 = System fail condition as level-detect brake source Disabled.
 * |        |          |1 = System fail condition as level-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag146
 * |[17:16] |BRKAEVEN  |PWM Brake Action Select for PWMx_CH0 (Write Protect)
 * |        |          |00 = TIMERx_PWM brake event will not affect PWMx_CH0 output.
 * |        |          |01 = PWMx_CH0 output tri-state when TIMERx_PWM brake event happened.
 * |        |          |10 = PWMx_CH0 output low level when TIMERx_PWM brake event happened.
 * |        |          |11 = PWMx_CH0 output high level when TIMERx_PWM brake event happened.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag145
 * |[19:18] |BRKAODD   |PWM Brake Action Select for PWMx_CH1 (Write Protect)
 * |        |          |00 = TIMERx_PWM brake event will not affect PWMx_CH1 output.
 * |        |          |01 = PWMx_CH1 output tri-state when TIMERx_PWM brake event happened.
 * |        |          |10 = PWMx_CH1 output low level when TIMERx_PWM brake event happened.
 * |        |          |11 = PWMx_CH1 output high level when TIMERx_PWM brake event happened.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag144
 * @var TMR01_T::PWMPOLCTL
 * Offset: 0x174  Timer1 PWM Pin Output Polar Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PINV0     |PWMx_CH0 Output Pin Polar Control Bit
 * |        |          |The bit is used to control polarity state of PWMx_CH0 output pin.
 * |        |          |0 = PWMx_CH0 output pin polar inverse Disabled.
 * |        |          |1 = PWMx_CH0 output pin polar inverse Enabled.[WH1]
 * |        |          |[WH1]Tag154
 * |[1]     |PINV1     |PWMx_CH1 Output Pin Polar Control Bit
 * |        |          |The bit is used to control polarity state of PWMx_CH1 output pin.
 * |        |          |0 = PWMx_CH1 output pin polar inverse Disabled.
 * |        |          |1 = PWMx_CH1 output pin polar inverse Enabled.
 * @var TMR01_T::PWMPOEN
 * Offset: 0x178  Timer1 PWM Pin Output Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |POEN0     |PWMx_CH0 Output Pin Enable Bit
 * |        |          |0 = PWMx_CH0 pin at tri-state mode.
 * |        |          |1 = PWMx_CH0 pin in output mode.[WH1]
 * |        |          |[WH1]Tag155
 * |[1]     |POEN1     |PWMx_CH1 Output Pin Enable Bit
 * |        |          |0 = PWMx_CH1 pin at tri-state mode.
 * |        |          |1 = PWMx_CH1 pin in output mode.
 * @var TMR01_T::PWMSWBRK
 * Offset: 0x17C  Timer1 PWM Software Trigger Brake Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BRKETRG   |Software Trigger Edge-detect Brake Source (Write Only) (Write Protect)
 * |        |          |Write 1 to this bit will trigger PWM edge-detect brake source, then BRKEIF0 and BRKEIF1 will set to 1 automatically in TIMERx_PWMINTSTS1 register.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag156
 * |[8]     |BRKLTRG   |Software Trigger Level-detect Brake Source (Write Only) (Write Protect)
 * |        |          |Write 1 to this bit will trigger PWM level-detect brake source, then BRKLIF0 and BRKLIF1 will set to 1 automatically in TIMERx_PWMINTSTS1 register.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * @var TMR01_T::PWMINTEN0
 * Offset: 0x180  Timer1 PWM Interrupt Enable Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ZIEN      |PWM Zero Point Interrupt Enable Bit
 * |        |          |0 = Zero point interrupt Disabled.
 * |        |          |1 = Zero point interrupt Enabled.[WH1]
 * |        |          |[WH1]Tag160
 * |[1]     |PIEN      |PWM Period Point Interrupt Enable Bit
 * |        |          |0 = Period point interrupt Disabled.
 * |        |          |1 = Period point interrupt Enabled.
 * |        |          |Note: When in up-down count type, period point means the center point of current PWM period.[WH1]
 * |        |          |[WH1]Tag159
 * |[2]     |CMPUIEN   |PWM Compare Up Count Interrupt Enable Bit
 * |        |          |0 = Compare up count interrupt Disabled.
 * |        |          |1 = Compare up count interrupt Enabled.[WH1]
 * |        |          |[WH1]Tag158
 * |[3]     |CMPDIEN   |PWM Compare Down Count Interrupt Enable Bit
 * |        |          |0 = Compare down count interrupt Disabled.
 * |        |          |1 = Compare down count interrupt Enabled.[WH1]
 * |        |          |[WH1]Tag157
 * @var TMR01_T::PWMINTEN1
 * Offset: 0x184  Timer1 PWM Interrupt Enable Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BRKEIEN   |PWM Edge-detect Brake Interrupt Enable (Write Protect)
 * |        |          |0 = PWM edge-detect brake interrupt Disabled.
 * |        |          |1 = PWM edge-detect brake interrupt Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag162
 * |[8]     |BRKLIEN   |PWM Level-detect Brake Interrupt Enable (Write Protect)
 * |        |          |0 = PWM level-detect brake interrupt Disabled.
 * |        |          |1 = PWM level-detect brake interrupt Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag161
 * @var TMR01_T::PWMINTSTS0
 * Offset: 0x188  Timer1 PWM Interrupt Status Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ZIF       |PWM Zero Point Interrupt Flag
 * |        |          |This bit is set by hardware when TIMERx_PWM counter reaches zero.
 * |        |          |Note: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag166
 * |[1]     |PIF       |PWM Period Point Interrupt Flag
 * |        |          |This bit is set by hardware when TIMERx_PWM counter reaches PERIOD.
 * |        |          |Note1: When in up-down count type, PIF flag means the center point flag of current PWM period.
 * |        |          |Note2: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag165
 * |[2]     |CMPUIF    |PWM Compare Up Count Interrupt Flag
 * |        |          |This bit is set by hardware when TIMERx_PWM counter in up count direction and reaches CMP.
 * |        |          |Note1: If CMP equal to PERIOD, there is no CMPUIF flag in up count type and up-down count type.
 * |        |          |Note2: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag164
 * |[3]     |CMPDIF    |PWM Compare Down Count Interrupt Flag
 * |        |          |This bit is set by hardware when TIMERx_PWM counter in down count direction and reaches CMP.
 * |        |          |Note1: If CMP equal to PERIOD, there is no CMPDIF flag in down count type.
 * |        |          |Note2: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag163
 * @var TMR01_T::PWMINTSTS1
 * Offset: 0x18C  Timer1 PWM Interrupt Status Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BRKEIF0   |Edge-detect Brake Interrupt Flag on PWMx_CH0 (Write Protect)
 * |        |          |0 = PWMx_CH0 edge-detect brake event do not happened.
 * |        |          |1 = PWMx_CH0 edge-detect brake event happened.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag170
 * |[1]     |BRKEIF1   |Edge-detect Brake Interrupt Flag PWMx_CH1 (Write Protect)
 * |        |          |0 = PWMx_CH1 edge-detect brake event do not happened.
 * |        |          |1 = PWMx_CH1 edge-detect brake event happened.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2: This register is write protected. Refer to SYS_REGLCTL register.
 * |[8]     |BRKLIF0   |Level-detect Brake Interrupt Flag on PWMx_CH0 (Write Protect)
 * |        |          |0 = PWMx_CH0 level-detect brake event do not happened.
 * |        |          |1 = PWMx_CH0 level-detect brake event happened.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag169
 * |[9]     |BRKLIF1   |Level-detect Brake Interrupt Flag on PWMx_CH1 (Write Protect)
 * |        |          |0 = PWMx_CH1 level-detect brake event do not happened.
 * |        |          |1 = PWMx_CH1 level-detect brake event happened.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2: This register is write protected. Refer to SYS_REGLCTL register.
 * |[16]    |BRKESTS0  |Edge -detect Brake Status of PWMx_CH0 (Read Only)
 * |        |          |0 = PWMx_CH0 edge-detect brake state is released.
 * |        |          |1 = PWMx_CH0 at edge-detect brake state.
 * |        |          |Note: User can set BRKEIF0 1 to clear BRKEIF0 flag and PWMx_CH0 will release brake state when current PWM period finished and resume PWMx_CH0 output waveform start from next full PWM period.[WH1]
 * |        |          |[WH1]Tag168
 * |[17]    |BRKESTS1  |Edge-detect Brake Status of PWMx_CH1 (Read Only)
 * |        |          |0 = PWMx_CH1 edge-detect brake state is released.
 * |        |          |1 = PWMx_CH1 at edge-detect brake state.
 * |        |          |Note: User can set BRKEIF1 1 to clear BRKEIF1 flag and PWMx_CH1 will release brake state when current PWM period finished and resume PWMx_CH1 output waveform start from next full PWM period.
 * |[24]    |BRKLSTS0  |Level-detect Brake Status of PWMx_CH0 (Read Only)
 * |        |          |0 = PWMx_CH0 level-detect brake state is released.
 * |        |          |1 = PWMx_CH0 at level-detect brake state.
 * |        |          |Note: If TIMERx_PWM level-detect brake source has released, both PWMx_CH0 and PWMx_CH1 will release brake state when current PWM period finished and resume PWMx_CH0 and PWMx_CH1 output waveform start from next full PWM period.[WH1]
 * |        |          |[WH1]Tag167
 * |[25]    |BRKLSTS1  |Level-detect Brake Status of PWMx_CH1 (Read Only)
 * |        |          |0 = PWMx_CH1 level-detect brake state is released.
 * |        |          |1 = PWMx_CH1 at level-detect brake state.
 * |        |          |Note: If TIMERx_PWM level-detect brake source has released, both PWMx_CH0 and PWMx_CH1 will release brake state when current PWM period finished and resume PWMx_CH0 and PWMx_CH1 output waveform start from next full PWM period.
 * @var TMR01_T::PWMADCTS
 * Offset: 0x190  Timer1 PWM ADC Trigger Source Select Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[2:0]   |TRGSEL    |PWM Counter Event Source Select to Trigger ADC Conversion
 * |        |          |000 = Trigger ADC conversion at zero point (ZIF).
 * |        |          |001 = Trigger ADC conversion at period point (PIF).
 * |        |          |010 = Trigger ADC conversion at zero or period point (ZIF or PIF).
 * |        |          |011 = Trigger ADC conversion at compare up count point (CMPUIF).
 * |        |          |100 = Trigger ADC conversion at compare down count point (CMPDIF).
 * |        |          |Others = Reserved.[WH1]
 * |        |          |[WH1]Tag172
 * |[7]     |TRGEN     |PWM Counter Event Trigger ADC Conversion Enable Bit
 * |        |          |0 = PWM counter event trigger ADC conversion Disabled.
 * |        |          |1 = PWM counter event trigger ADC conversion Enabled.[WH1]
 * |        |          |[WH1]Tag171
 * @var TMR01_T::PWMSCTL
 * Offset: 0x194  Timer1 PWM Synchronous Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |SYNCMODE  |PWM Synchronous Mode Enable Select
 * |        |          |00 = PWM synchronous function Disabled.
 * |        |          |01 = PWM synchronous counter start function Enabled.
 * |        |          |10 = Reserved.
 * |        |          |11 = PWM synchronous counter clear function Enabled.[WH1]
 * |        |          |[WH1]Tag174
 * |[8]     |SYNCSRC   |PWM Synchronous Counter Start/Clear Source Select
 * |        |          |0 = Counter synchronous start/clear by trigger STRGEN (TIMER0_PWMSTRG[0]).
 * |        |          |1 = Counter synchronous start/clear by trigger STRGEN (TIMER2_PWMSTRG[0]).
 * |        |          |Note1: If TIMER0/1/2/3 PWM counter synchronous source are from TIMER0, TIME0_PWMSCTL[8], TIME1_PWMSCTL[8], TIME2_PWMSCTL[8] and TIME3_PWMSCTL[8] should be 0.
 * |        |          |Note2: If TIMER0/1/ PWM counter synchronous source are from TIMER0, TIME0_PWMSCTL[8] and TIME1_PWMSCTL[8] should be set 0, and TIMER2/3/ PWM counter synchronous source are from TIMER2, TIME2_PWMSCTL[8] and TIME3_PWMSCTL[8] should be set 1.[WH1]
 * |        |          |[WH1]Tag173
 * @var TMR01_T::PWMSSTRG
 * Offset: 0x198  Timer1 PWM Synchronous Start Trigger Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var TMR01_T::PWMSTATUS
 * Offset: 0x19C  Timer1 PWM Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CNTMAXF   |PWM Counter Equal to 0xFFFF Flag
 * |        |          |0 = Indicates the PWM counter value never reached its maximum value 0xFFFF.
 * |        |          |1 = Indicates the PWM counter value has reached its maximum value.
 * |        |          |Note: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag177
 * |[16]    |ADCTRGF   |Trigger ADC Start Conversion Flag
 * |        |          |0 = PWM counter event trigger ADC start conversion is not occurred.
 * |        |          |1 = PWM counter event trigger ADC start conversion has occurred.
 * |        |          |Note: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag176
 * @var TMR01_T::PWMPBUF
 * Offset: 0x1A0  Timer1 PWM Period Buffer Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PBUF      |PWM Period Buffer Register (Read Only)
 * |        |          |Used as PERIOD active register.[WH1]
 * |        |          |[WH1]Tag178
 * @var TMR01_T::PWMCMPBUF
 * Offset: 0x1A4  Timer1 PWM Comparator Buffer Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CMPBUF    |PWM Comparator Buffer Register (Read Only)
 * |        |          |Used as CMP active register.[WH1]
 * |        |          |[WH1]Tag179
 * @var TMR01_T::VERSION
 * Offset: 0xFFC  Timer RTL Design Version Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |MINOR     |Timer RTL Design Minor Version
 * |        |          |Minor version number is dependent on ECO version control.[WH1]
 * |        |          |[WH1]Tag180
 * |[23:16] |SUB       |Timer RTL Design Sub Version Number
 * |        |          |Major version number is correlated to product line.
 * |[31:24] |MAJOR     |Timer RTL Design Major Version Number
 * |        |          |Major version number is correlated to product line.
 */
    __IO uint32_t CTL;                   /*!< [0x0000] Timer0 Control Register                                          */
    __IO uint32_t CMP;                   /*!< [0x0004] Timer0 Comparator Register                                       */
    __IO uint32_t INTSTS;                /*!< [0x0008] Timer0 Interrupt Status Register                                 */
    __IO uint32_t CNT;                   /*!< [0x000c] Timer0 Data Register                                             */
    __I  uint32_t CAP;                   /*!< [0x0010] Timer0 Capture Data Register                                     */
    __IO uint32_t EXTCTL;                /*!< [0x0014] Timer0 External Control Register                                 */
    __IO uint32_t EINTSTS;               /*!< [0x0018] Timer0 External Interrupt Status Register                        */
    __IO uint32_t TRGCTL;                /*!< [0x001c] Timer0 Trigger Control Register                                  */
    __IO uint32_t ALTCTL;                /*!< [0x0020] Timer0 Alternative Control Register                              */
    __I  uint32_t RESERVE0[7];
    __IO uint32_t PWMCTL;                /*!< [0x0040] Timer0 PWM Control Register                                      */
    __IO uint32_t PWMCLKSRC;             /*!< [0x0044] Timer0 PWM Counter Clock Source Register                         */
    __IO uint32_t PWMCLKPSC;             /*!< [0x0048] Timer0 PWM Counter Clock Pre-scale Register                      */
    __IO uint32_t PWMCNTCLR;             /*!< [0x004c] Timer0 PWM Clear Counter Register                                */
    __IO uint32_t PWMPERIOD;             /*!< [0x0050] Timer0 PWM Period Register                                       */
    __IO uint32_t PWMCMPDAT;             /*!< [0x0054] Timer0 PWM Comparator Register                                   */
    __IO uint32_t PWMDTCTL;              /*!< [0x0058] Timer0 PWM Dead-Time Control Register                            */
    __I  uint32_t PWMCNT;                /*!< [0x005c] Timer0 PWM Counter Register                                      */
    __IO uint32_t PWMMSKEN;              /*!< [0x0060] Timer0 PWM Output Mask Enable Register                           */
    __IO uint32_t PWMMSK;                /*!< [0x0064] Timer0 PWM Output Mask Data Control Register                     */
    __IO uint32_t PWMBNF;                /*!< [0x0068] Timer0 PWM Brake Pin Noise Filter Register                       */
    __IO uint32_t PWMFAILBRK;            /*!< [0x006c] Timer0 PWM System Fail Brake Control Register                    */
    __IO uint32_t PWMBRKCTL;             /*!< [0x0070] Timer0 PWM Brake Control Register                                */
    __IO uint32_t PWMPOLCTL;             /*!< [0x0074] Timer0 PWM Pin Output Polar Control Register                     */
    __IO uint32_t PWMPOEN;               /*!< [0x0078] Timer0 PWM Pin Output Enable Register                            */
    __O  uint32_t PWMSWBRK;              /*!< [0x007c] Timer0 PWM Software Trigger Brake Control Register               */
    __IO uint32_t PWMINTEN0;             /*!< [0x0080] Timer0 PWM Interrupt Enable Register 0                           */
    __IO uint32_t PWMINTEN1;             /*!< [0x0084] Timer0 PWM Interrupt Enable Register 1                           */
    __IO uint32_t PWMINTSTS0;            /*!< [0x0088] Timer0 PWM Interrupt Status Register 0                           */
    __IO uint32_t PWMINTSTS1;            /*!< [0x008c] Timer0 PWM Interrupt Status Register 1                           */
    __IO uint32_t PWMADCTS;              /*!< [0x0090] Timer0 PWM ADC Trigger Source Select Register                    */
    __IO uint32_t PWMSCTL;               /*!< [0x0094] Timer0 PWM Synchronous Control Register                          */
    __O  uint32_t PWMSTRG;               /*!< [0x0098] Timer0 PWM Synchronous Trigger Register                          */
    __IO uint32_t PWMSTATUS;             /*!< [0x009c] Timer0 PWM Status Register                                       */
    __I  uint32_t PWMPBUF;               /*!< [0x00a0] Timer0 PWM Period Buffer Register                                */
    __I  uint32_t PWMCMPBUF;             /*!< [0x00a4] Timer0 PWM Comparator Buffer Register                            */

} TMR01_T;

/**
    @addtogroup TMR01_CONST TMR01 Bit Field Definition
    Constant Definitions for TMR01 Controller
@{ */

#define TMR01_CTL_PSC_Pos                (0)                                               /*!< TMR01_T::CTL: PSC Position             */
#define TMR01_CTL_PSC_Msk                (0xfful << TMR01_CTL_PSC_Pos)                     /*!< TMR01_T::CTL: PSC Mask                 */

#define TMR01_CTL_INTRGEN_Pos            (19)                                              /*!< TMR01_T::CTL: INTRGEN Position         */
#define TMR01_CTL_INTRGEN_Msk            (0x1ul << TMR01_CTL_INTRGEN_Pos)                  /*!< TMR01_T::CTL: INTRGEN Mask             */

#define TMR01_CTL_PERIOSEL_Pos           (20)                                              /*!< TMR01_T::CTL: PERIOSEL Position        */
#define TMR01_CTL_PERIOSEL_Msk           (0x1ul << TMR01_CTL_PERIOSEL_Pos)                 /*!< TMR01_T::CTL: PERIOSEL Mask            */

#define TMR01_CTL_TGLPINSEL_Pos          (21)                                              /*!< TMR01_T::CTL: TGLPINSEL Position       */
#define TMR01_CTL_TGLPINSEL_Msk          (0x1ul << TMR01_CTL_TGLPINSEL_Pos)                /*!< TMR01_T::CTL: TGLPINSEL Mask           */

#define TMR01_CTL_CAPSRC_Pos             (22)                                              /*!< TMR01_T::CTL: CAPSRC Position          */
#define TMR01_CTL_CAPSRC_Msk             (0x1ul << TMR01_CTL_CAPSRC_Pos)                   /*!< TMR01_T::CTL: CAPSRC Mask              */

#define TMR01_CTL_WKEN_Pos               (23)                                              /*!< TMR01_T::CTL: WKEN Position            */
#define TMR01_CTL_WKEN_Msk               (0x1ul << TMR01_CTL_WKEN_Pos)                     /*!< TMR01_T::CTL: WKEN Mask                */

#define TMR01_CTL_EXTCNTEN_Pos           (24)                                              /*!< TMR01_T::CTL: EXTCNTEN Position        */
#define TMR01_CTL_EXTCNTEN_Msk           (0x1ul << TMR01_CTL_EXTCNTEN_Pos)                 /*!< TMR01_T::CTL: EXTCNTEN Mask            */

#define TMR01_CTL_ACTSTS_Pos             (25)                                              /*!< TMR01_T::CTL: ACTSTS Position          */
#define TMR01_CTL_ACTSTS_Msk             (0x1ul << TMR01_CTL_ACTSTS_Pos)                   /*!< TMR01_T::CTL: ACTSTS Mask              */

#define TMR01_CTL_RSTCNT_Pos             (26)                                              /*!< TMR01_T::CTL: RSTCNT Position          */
#define TMR01_CTL_RSTCNT_Msk             (0x1ul << TMR01_CTL_RSTCNT_Pos)                   /*!< TMR01_T::CTL: RSTCNT Mask              */

#define TMR01_CTL_OPMODE_Pos             (27)                                              /*!< TMR01_T::CTL: OPMODE Position          */
#define TMR01_CTL_OPMODE_Msk             (0x3ul << TMR01_CTL_OPMODE_Pos)                   /*!< TMR01_T::CTL: OPMODE Mask              */

#define TMR01_CTL_INTEN_Pos              (29)                                              /*!< TMR01_T::CTL: INTEN Position           */
#define TMR01_CTL_INTEN_Msk              (0x1ul << TMR01_CTL_INTEN_Pos)                    /*!< TMR01_T::CTL: INTEN Mask               */

#define TMR01_CTL_CNTEN_Pos              (30)                                              /*!< TMR01_T::CTL: CNTEN Position           */
#define TMR01_CTL_CNTEN_Msk              (0x1ul << TMR01_CTL_CNTEN_Pos)                    /*!< TMR01_T::CTL: CNTEN Mask               */

#define TMR01_CTL_ICEDEBUG_Pos           (31)                                              /*!< TMR01_T::CTL: ICEDEBUG Position        */
#define TMR01_CTL_ICEDEBUG_Msk           (0x1ul << TMR01_CTL_ICEDEBUG_Pos)                 /*!< TMR01_T::CTL: ICEDEBUG Mask            */

#define TMR01_CMP_CMPDAT_Pos             (0)                                               /*!< TMR01_T::CMP: CMPDAT Position          */
#define TMR01_CMP_CMPDAT_Msk             (0xfffffful << TMR01_CMP_CMPDAT_Pos)              /*!< TMR01_T::CMP: CMPDAT Mask              */

#define TMR01_INTSTS_TIF_Pos             (0)                                               /*!< TMR01_T::INTSTS: TIF Position          */
#define TMR01_INTSTS_TIF_Msk             (0x1ul << TMR01_INTSTS_TIF_Pos)                   /*!< TMR01_T::INTSTS: TIF Mask              */

#define TMR01_INTSTS_TWKF_Pos            (1)                                               /*!< TMR01_T::INTSTS: TWKF Position         */
#define TMR01_INTSTS_TWKF_Msk            (0x1ul << TMR01_INTSTS_TWKF_Pos)                  /*!< TMR01_T::INTSTS: TWKF Mask             */

#define TMR01_CNT_CNT_Pos                (0)                                               /*!< TMR01_T::CNT: CNT Position             */
#define TMR01_CNT_CNT_Msk                (0xfffffful << TMR01_CNT_CNT_Pos)                 /*!< TMR01_T::CNT: CNT Mask                 */

#define TMR01_CNT_RSTACT_Pos             (31)                                              /*!< TMR01_T::CNT: RSTACT Position          */
#define TMR01_CNT_RSTACT_Msk             (0x1ul << TMR01_CNT_RSTACT_Pos)                   /*!< TMR01_T::CNT: RSTACT Mask              */

#define TMR01_CAP_CAPDAT_Pos             (0)                                               /*!< TMR01_T::CAP: CAPDAT Position          */
#define TMR01_CAP_CAPDAT_Msk             (0xfffffful << TMR01_CAP_CAPDAT_Pos)              /*!< TMR01_T::CAP: CAPDAT Mask              */

#define TMR01_EXTCTL_CNTPHASE_Pos        (0)                                               /*!< TMR01_T::EXTCTL: CNTPHASE Position     */
#define TMR01_EXTCTL_CNTPHASE_Msk        (0x1ul << TMR01_EXTCTL_CNTPHASE_Pos)              /*!< TMR01_T::EXTCTL: CNTPHASE Mask         */

#define TMR01_EXTCTL_SCAPEDGE_Pos        (1)                                               /*!< TMR01_T::EXTCTL: SCAPEDGE Position     */
#define TMR01_EXTCTL_SCAPEDGE_Msk        (0x3ul << TMR01_EXTCTL_SCAPEDGE_Pos)              /*!< TMR01_T::EXTCTL: SCAPEDGE Mask         */

#define TMR01_EXTCTL_CAPEN_Pos           (3)                                               /*!< TMR01_T::EXTCTL: CAPEN Position        */
#define TMR01_EXTCTL_CAPEN_Msk           (0x1ul << TMR01_EXTCTL_CAPEN_Pos)                 /*!< TMR01_T::EXTCTL: CAPEN Mask            */

#define TMR01_EXTCTL_CAPFUNCS_Pos        (4)                                               /*!< TMR01_T::EXTCTL: CAPFUNCS Position     */
#define TMR01_EXTCTL_CAPFUNCS_Msk        (0x1ul << TMR01_EXTCTL_CAPFUNCS_Pos)              /*!< TMR01_T::EXTCTL: CAPFUNCS Mask         */

#define TMR01_EXTCTL_CAPIEN_Pos          (5)                                               /*!< TMR01_T::EXTCTL: CAPIEN Position       */
#define TMR01_EXTCTL_CAPIEN_Msk          (0x1ul << TMR01_EXTCTL_CAPIEN_Pos)                /*!< TMR01_T::EXTCTL: CAPIEN Mask           */

#define TMR01_EXTCTL_CAPDBEN_Pos         (6)                                               /*!< TMR01_T::EXTCTL: CAPDBEN Position      */
#define TMR01_EXTCTL_CAPDBEN_Msk         (0x1ul << TMR01_EXTCTL_CAPDBEN_Pos)               /*!< TMR01_T::EXTCTL: CAPDBEN Mask          */

#define TMR01_EXTCTL_CNTDBEN_Pos         (7)                                               /*!< TMR01_T::EXTCTL: CNTDBEN Position      */
#define TMR01_EXTCTL_CNTDBEN_Msk         (0x1ul << TMR01_EXTCTL_CNTDBEN_Pos)               /*!< TMR01_T::EXTCTL: CNTDBEN Mask          */

#define TMR01_EXTCTL_CAPEDGE_Pos         (12)                                              /*!< TMR01_T::EXTCTL: CAPEDGE Position      */
#define TMR01_EXTCTL_CAPEDGE_Msk         (0x7ul << TMR01_EXTCTL_CAPEDGE_Pos)               /*!< TMR01_T::EXTCTL: CAPEDGE Mask          */

#define TMR01_EXTCTL_ECNTSSEL_Pos        (16)                                              /*!< TMR01_T::EXTCTL: ECNTSSEL Position     */
#define TMR01_EXTCTL_ECNTSSEL_Msk        (0x1ul << TMR01_EXTCTL_ECNTSSEL_Pos)              /*!< TMR01_T::EXTCTL: ECNTSSEL Mask         */

#define TMR01_EINTSTS_CAPIF_Pos          (0)                                               /*!< TMR01_T::EINTSTS: CAPIF Position       */
#define TMR01_EINTSTS_CAPIF_Msk          (0x1ul << TMR01_EINTSTS_CAPIF_Pos)                /*!< TMR01_T::EINTSTS: CAPIF Mask           */

#define TMR01_TRGCTL_TRGSSEL_Pos         (0)                                               /*!< TMR01_T::TRGCTL: TRGSSEL Position      */
#define TMR01_TRGCTL_TRGSSEL_Msk         (0x1ul << TMR01_TRGCTL_TRGSSEL_Pos)               /*!< TMR01_T::TRGCTL: TRGSSEL Mask          */

#define TMR01_TRGCTL_TRGPWM_Pos          (1)                                               /*!< TMR01_T::TRGCTL: TRGPWM Position       */
#define TMR01_TRGCTL_TRGPWM_Msk          (0x1ul << TMR01_TRGCTL_TRGPWM_Pos)                /*!< TMR01_T::TRGCTL: TRGPWM Mask           */

#define TMR01_TRGCTL_TRGADC_Pos          (2)                                               /*!< TMR01_T::TRGCTL: TRGADC Position       */
#define TMR01_TRGCTL_TRGADC_Msk          (0x1ul << TMR01_TRGCTL_TRGADC_Pos)                /*!< TMR01_T::TRGCTL: TRGADC Mask           */

#define TMR01_TRGCTL_TRGPDMA_Pos         (4)                                               /*!< TMR01_T::TRGCTL: TRGPDMA Position      */
#define TMR01_TRGCTL_TRGPDMA_Msk         (0x1ul << TMR01_TRGCTL_TRGPDMA_Pos)               /*!< TMR01_T::TRGCTL: TRGPDMA Mask          */

#define TMR01_ALTCTL_FUNCSEL_Pos         (0)                                               /*!< TMR01_T::ALTCTL: FUNCSEL Position      */
#define TMR01_ALTCTL_FUNCSEL_Msk         (0x1ul << TMR01_ALTCTL_FUNCSEL_Pos)               /*!< TMR01_T::ALTCTL: FUNCSEL Mask          */

#define TMR01_PWMCTL_CNTEN_Pos           (0)                                               /*!< TMR01_T::PWMCTL: CNTEN Position        */
#define TMR01_PWMCTL_CNTEN_Msk           (0x1ul << TMR01_PWMCTL_CNTEN_Pos)                 /*!< TMR01_T::PWMCTL: CNTEN Mask            */

#define TMR01_PWMCTL_CNTTYPE_Pos         (1)                                               /*!< TMR01_T::PWMCTL: CNTTYPE Position      */
#define TMR01_PWMCTL_CNTTYPE_Msk         (0x3ul << TMR01_PWMCTL_CNTTYPE_Pos)               /*!< TMR01_T::PWMCTL: CNTTYPE Mask          */

#define TMR01_PWMCTL_CNTMODE_Pos         (3)                                               /*!< TMR01_T::PWMCTL: CNTMODE Position      */
#define TMR01_PWMCTL_CNTMODE_Msk         (0x1ul << TMR01_PWMCTL_CNTMODE_Pos)               /*!< TMR01_T::PWMCTL: CNTMODE Mask          */

#define TMR01_PWMCTL_CTRLD_Pos           (8)                                               /*!< TMR01_T::PWMCTL: CTRLD Position        */
#define TMR01_PWMCTL_CTRLD_Msk           (0x1ul << TMR01_PWMCTL_CTRLD_Pos)                 /*!< TMR01_T::PWMCTL: CTRLD Mask            */

#define TMR01_PWMCTL_IMMLDEN_Pos         (9)                                               /*!< TMR01_T::PWMCTL: IMMLDEN Position      */
#define TMR01_PWMCTL_IMMLDEN_Msk         (0x1ul << TMR01_PWMCTL_IMMLDEN_Pos)               /*!< TMR01_T::PWMCTL: IMMLDEN Mask          */

#define TMR01_PWMCTL_OUTMODE_Pos         (16)                                              /*!< TMR01_T::PWMCTL: OUTMODE Position      */
#define TMR01_PWMCTL_OUTMODE_Msk         (0x1ul << TMR01_PWMCTL_OUTMODE_Pos)               /*!< TMR01_T::PWMCTL: OUTMODE Mask          */

#define TMR01_PWMCTL_DBGHALT_Pos         (30)                                              /*!< TMR01_T::PWMCTL: DBGHALT Position      */
#define TMR01_PWMCTL_DBGHALT_Msk         (0x1ul << TMR01_PWMCTL_DBGHALT_Pos)               /*!< TMR01_T::PWMCTL: DBGHALT Mask          */

#define TMR01_PWMCTL_DBGTRIOFF_Pos       (31)                                              /*!< TMR01_T::PWMCTL: DBGTRIOFF Position    */
#define TMR01_PWMCTL_DBGTRIOFF_Msk       (0x1ul << TMR01_PWMCTL_DBGTRIOFF_Pos)             /*!< TMR01_T::PWMCTL: DBGTRIOFF Mask        */

#define TMR01_PWMCLKSRC_CLKSRC_Pos       (0)                                               /*!< TMR01_T::PWMCLKSRC: CLKSRC Position    */
#define TMR01_PWMCLKSRC_CLKSRC_Msk       (0x7ul << TMR01_PWMCLKSRC_CLKSRC_Pos)             /*!< TMR01_T::PWMCLKSRC: CLKSRC Mask        */

#define TMR01_PWMCLKPSC_CLKPSC_Pos       (0)                                               /*!< TMR01_T::PWMCLKPSC: CLKPSC Position    */
#define TMR01_PWMCLKPSC_CLKPSC_Msk       (0xffful << TMR01_PWMCLKPSC_CLKPSC_Pos)           /*!< TMR01_T::PWMCLKPSC: CLKPSC Mask        */

#define TMR01_PWMCNTCLR_CNTCLR_Pos       (0)                                               /*!< TMR01_T::PWMCNTCLR: CNTCLR Position    */
#define TMR01_PWMCNTCLR_CNTCLR_Msk       (0x1ul << TMR01_PWMCNTCLR_CNTCLR_Pos)             /*!< TMR01_T::PWMCNTCLR: CNTCLR Mask        */

#define TMR01_PWMPERIOD_PERIOD_Pos       (0)                                               /*!< TMR01_T::PWMPERIOD: PERIOD Position    */
#define TMR01_PWMPERIOD_PERIOD_Msk       (0xfffful << TMR01_PWMPERIOD_PERIOD_Pos)          /*!< TMR01_T::PWMPERIOD: PERIOD Mask        */

#define TMR01_PWMCMPDAT_CMP_Pos          (0)                                               /*!< TMR01_T::PWMCMPDAT: CMP Position       */
#define TMR01_PWMCMPDAT_CMP_Msk          (0xfffful << TMR01_PWMCMPDAT_CMP_Pos)             /*!< TMR01_T::PWMCMPDAT: CMP Mask           */

#define TMR01_PWMDTCTL_DTCNT_Pos         (0)                                               /*!< TMR01_T::PWMDTCTL: DTCNT Position      */
#define TMR01_PWMDTCTL_DTCNT_Msk         (0xffful << TMR01_PWMDTCTL_DTCNT_Pos)             /*!< TMR01_T::PWMDTCTL: DTCNT Mask          */

#define TMR01_PWMDTCTL_DTEN_Pos          (16)                                              /*!< TMR01_T::PWMDTCTL: DTEN Position       */
#define TMR01_PWMDTCTL_DTEN_Msk          (0x1ul << TMR01_PWMDTCTL_DTEN_Pos)                /*!< TMR01_T::PWMDTCTL: DTEN Mask           */

#define TMR01_PWMDTCTL_DTCKSEL_Pos       (24)                                              /*!< TMR01_T::PWMDTCTL: DTCKSEL Position    */
#define TMR01_PWMDTCTL_DTCKSEL_Msk       (0x1ul << TMR01_PWMDTCTL_DTCKSEL_Pos)             /*!< TMR01_T::PWMDTCTL: DTCKSEL Mask        */

#define TMR01_PWMCNT_CNT_Pos             (0)                                               /*!< TMR01_T::PWMCNT: CNT Position          */
#define TMR01_PWMCNT_CNT_Msk             (0xfffful << TMR01_PWMCNT_CNT_Pos)                /*!< TMR01_T::PWMCNT: CNT Mask              */

#define TMR01_PWMCNT_DIRF_Pos            (16)                                              /*!< TMR01_T::PWMCNT: DIRF Position         */
#define TMR01_PWMCNT_DIRF_Msk            (0x1ul << TMR01_PWMCNT_DIRF_Pos)                  /*!< TMR01_T::PWMCNT: DIRF Mask             */

#define TMR01_PWMMSKEN_MSKEN0_Pos        (0)                                               /*!< TMR01_T::PWMMSKEN: MSKEN0 Position     */
#define TMR01_PWMMSKEN_MSKEN0_Msk        (0x1ul << TMR01_PWMMSKEN_MSKEN0_Pos)              /*!< TMR01_T::PWMMSKEN: MSKEN0 Mask         */

#define TMR01_PWMMSKEN_MSKEN1_Pos        (1)                                               /*!< TMR01_T::PWMMSKEN: MSKEN1 Position     */
#define TMR01_PWMMSKEN_MSKEN1_Msk        (0x1ul << TMR01_PWMMSKEN_MSKEN1_Pos)              /*!< TMR01_T::PWMMSKEN: MSKEN1 Mask         */

#define TMR01_PWMMSK_MSKDAT0_Pos         (0)                                               /*!< TMR01_T::PWMMSK: MSKDAT0 Position      */
#define TMR01_PWMMSK_MSKDAT0_Msk         (0x1ul << TMR01_PWMMSK_MSKDAT0_Pos)               /*!< TMR01_T::PWMMSK: MSKDAT0 Mask          */

#define TMR01_PWMMSK_MSKDAT1_Pos         (1)                                               /*!< TMR01_T::PWMMSK: MSKDAT1 Position      */
#define TMR01_PWMMSK_MSKDAT1_Msk         (0x1ul << TMR01_PWMMSK_MSKDAT1_Pos)               /*!< TMR01_T::PWMMSK: MSKDAT1 Mask          */

#define TMR01_PWMBNF_BRKNFEN_Pos         (0)                                               /*!< TMR01_T::PWMBNF: BRKNFEN Position      */
#define TMR01_PWMBNF_BRKNFEN_Msk         (0x1ul << TMR01_PWMBNF_BRKNFEN_Pos)               /*!< TMR01_T::PWMBNF: BRKNFEN Mask          */

#define TMR01_PWMBNF_BRKNFSEL_Pos        (1)                                               /*!< TMR01_T::PWMBNF: BRKNFSEL Position     */
#define TMR01_PWMBNF_BRKNFSEL_Msk        (0x7ul << TMR01_PWMBNF_BRKNFSEL_Pos)              /*!< TMR01_T::PWMBNF: BRKNFSEL Mask         */

#define TMR01_PWMBNF_BRKFCNT_Pos         (4)                                               /*!< TMR01_T::PWMBNF: BRKFCNT Position      */
#define TMR01_PWMBNF_BRKFCNT_Msk         (0x7ul << TMR01_PWMBNF_BRKFCNT_Pos)               /*!< TMR01_T::PWMBNF: BRKFCNT Mask          */

#define TMR01_PWMBNF_BRKPINV_Pos         (7)                                               /*!< TMR01_T::PWMBNF: BRKPINV Position      */
#define TMR01_PWMBNF_BRKPINV_Msk         (0x1ul << TMR01_PWMBNF_BRKPINV_Pos)               /*!< TMR01_T::PWMBNF: BRKPINV Mask          */

#define TMR01_PWMBNF_BKPINSRC_Pos        (16)                                              /*!< TMR01_T::PWMBNF: BKPINSRC Position     */
#define TMR01_PWMBNF_BKPINSRC_Msk        (0x3ul << TMR01_PWMBNF_BKPINSRC_Pos)              /*!< TMR01_T::PWMBNF: BKPINSRC Mask         */

#define TMR01_PWMFAILBRK_CSSBRKEN_Pos    (0)                                               /*!< TMR01_T::PWMFAILBRK: CSSBRKEN Position */
#define TMR01_PWMFAILBRK_CSSBRKEN_Msk    (0x1ul << TMR01_PWMFAILBRK_CSSBRKEN_Pos)          /*!< TMR01_T::PWMFAILBRK: CSSBRKEN Mask     */

#define TMR01_PWMFAILBRK_BODBRKEN_Pos    (1)                                               /*!< TMR01_T::PWMFAILBRK: BODBRKEN Position */
#define TMR01_PWMFAILBRK_BODBRKEN_Msk    (0x1ul << TMR01_PWMFAILBRK_BODBRKEN_Pos)          /*!< TMR01_T::PWMFAILBRK: BODBRKEN Mask     */

#define TMR01_PWMFAILBRK_RAMBRKEN_Pos    (2)                                               /*!< TMR01_T::PWMFAILBRK: RAMBRKEN Position */
#define TMR01_PWMFAILBRK_RAMBRKEN_Msk    (0x1ul << TMR01_PWMFAILBRK_RAMBRKEN_Pos)          /*!< TMR01_T::PWMFAILBRK: RAMBRKEN Mask     */

#define TMR01_PWMFAILBRK_CORBRKEN_Pos    (3)                                               /*!< TMR01_T::PWMFAILBRK: CORBRKEN Position */
#define TMR01_PWMFAILBRK_CORBRKEN_Msk    (0x1ul << TMR01_PWMFAILBRK_CORBRKEN_Pos)          /*!< TMR01_T::PWMFAILBRK: CORBRKEN Mask     */

#define TMR01_PWMBRKCTL_BRKPEEN_Pos      (4)                                               /*!< TMR01_T::PWMBRKCTL: BRKPEEN Position   */
#define TMR01_PWMBRKCTL_BRKPEEN_Msk      (0x1ul << TMR01_PWMBRKCTL_BRKPEEN_Pos)            /*!< TMR01_T::PWMBRKCTL: BRKPEEN Mask       */

#define TMR01_PWMBRKCTL_SYSEBEN_Pos      (7)                                               /*!< TMR01_T::PWMBRKCTL: SYSEBEN Position   */
#define TMR01_PWMBRKCTL_SYSEBEN_Msk      (0x1ul << TMR01_PWMBRKCTL_SYSEBEN_Pos)            /*!< TMR01_T::PWMBRKCTL: SYSEBEN Mask       */

#define TMR01_PWMBRKCTL_BRKPLEN_Pos      (12)                                              /*!< TMR01_T::PWMBRKCTL: BRKPLEN Position   */
#define TMR01_PWMBRKCTL_BRKPLEN_Msk      (0x1ul << TMR01_PWMBRKCTL_BRKPLEN_Pos)            /*!< TMR01_T::PWMBRKCTL: BRKPLEN Mask       */

#define TMR01_PWMBRKCTL_SYSLBEN_Pos      (15)                                              /*!< TMR01_T::PWMBRKCTL: SYSLBEN Position   */
#define TMR01_PWMBRKCTL_SYSLBEN_Msk      (0x1ul << TMR01_PWMBRKCTL_SYSLBEN_Pos)            /*!< TMR01_T::PWMBRKCTL: SYSLBEN Mask       */

#define TMR01_PWMBRKCTL_BRKAEVEN_Pos     (16)                                              /*!< TMR01_T::PWMBRKCTL: BRKAEVEN Position  */
#define TMR01_PWMBRKCTL_BRKAEVEN_Msk     (0x3ul << TMR01_PWMBRKCTL_BRKAEVEN_Pos)           /*!< TMR01_T::PWMBRKCTL: BRKAEVEN Mask      */

#define TMR01_PWMBRKCTL_BRKAODD_Pos      (18)                                              /*!< TMR01_T::PWMBRKCTL: BRKAODD Position   */
#define TMR01_PWMBRKCTL_BRKAODD_Msk      (0x3ul << TMR01_PWMBRKCTL_BRKAODD_Pos)            /*!< TMR01_T::PWMBRKCTL: BRKAODD Mask       */

#define TMR01_PWMPOLCTL_PINV0_Pos        (0)                                               /*!< TMR01_T::PWMPOLCTL: PINV0 Position     */
#define TMR01_PWMPOLCTL_PINV0_Msk        (0x1ul << TMR01_PWMPOLCTL_PINV0_Pos)              /*!< TMR01_T::PWMPOLCTL: PINV0 Mask         */

#define TMR01_PWMPOLCTL_PINV1_Pos        (1)                                               /*!< TMR01_T::PWMPOLCTL: PINV1 Position     */
#define TMR01_PWMPOLCTL_PINV1_Msk        (0x1ul << TMR01_PWMPOLCTL_PINV1_Pos)              /*!< TMR01_T::PWMPOLCTL: PINV1 Mask         */

#define TMR01_PWMPOEN_POEN0_Pos          (0)                                               /*!< TMR01_T::PWMPOEN: POEN0 Position       */
#define TMR01_PWMPOEN_POEN0_Msk          (0x1ul << TMR01_PWMPOEN_POEN0_Pos)                /*!< TMR01_T::PWMPOEN: POEN0 Mask           */

#define TMR01_PWMPOEN_POEN1_Pos          (1)                                               /*!< TMR01_T::PWMPOEN: POEN1 Position       */
#define TMR01_PWMPOEN_POEN1_Msk          (0x1ul << TMR01_PWMPOEN_POEN1_Pos)                /*!< TMR01_T::PWMPOEN: POEN1 Mask           */

#define TMR01_PWMSWBRK_BRKETRG_Pos       (0)                                               /*!< TMR01_T::PWMSWBRK: BRKETRG Position    */
#define TMR01_PWMSWBRK_BRKETRG_Msk       (0x1ul << TMR01_PWMSWBRK_BRKETRG_Pos)             /*!< TMR01_T::PWMSWBRK: BRKETRG Mask        */

#define TMR01_PWMSWBRK_BRKLTRG_Pos       (8)                                               /*!< TMR01_T::PWMSWBRK: BRKLTRG Position    */
#define TMR01_PWMSWBRK_BRKLTRG_Msk       (0x1ul << TMR01_PWMSWBRK_BRKLTRG_Pos)             /*!< TMR01_T::PWMSWBRK: BRKLTRG Mask        */

#define TMR01_PWMINTEN0_ZIEN_Pos         (0)                                               /*!< TMR01_T::PWMINTEN0: ZIEN Position      */
#define TMR01_PWMINTEN0_ZIEN_Msk         (0x1ul << TMR01_PWMINTEN0_ZIEN_Pos)               /*!< TMR01_T::PWMINTEN0: ZIEN Mask          */

#define TMR01_PWMINTEN0_PIEN_Pos         (1)                                               /*!< TMR01_T::PWMINTEN0: PIEN Position      */
#define TMR01_PWMINTEN0_PIEN_Msk         (0x1ul << TMR01_PWMINTEN0_PIEN_Pos)               /*!< TMR01_T::PWMINTEN0: PIEN Mask          */

#define TMR01_PWMINTEN0_CMPUIEN_Pos      (2)                                               /*!< TMR01_T::PWMINTEN0: CMPUIEN Position   */
#define TMR01_PWMINTEN0_CMPUIEN_Msk      (0x1ul << TMR01_PWMINTEN0_CMPUIEN_Pos)            /*!< TMR01_T::PWMINTEN0: CMPUIEN Mask       */

#define TMR01_PWMINTEN0_CMPDIEN_Pos      (3)                                               /*!< TMR01_T::PWMINTEN0: CMPDIEN Position   */
#define TMR01_PWMINTEN0_CMPDIEN_Msk      (0x1ul << TMR01_PWMINTEN0_CMPDIEN_Pos)            /*!< TMR01_T::PWMINTEN0: CMPDIEN Mask       */

#define TMR01_PWMINTEN1_BRKEIEN_Pos      (0)                                               /*!< TMR01_T::PWMINTEN1: BRKEIEN Position   */
#define TMR01_PWMINTEN1_BRKEIEN_Msk      (0x1ul << TMR01_PWMINTEN1_BRKEIEN_Pos)            /*!< TMR01_T::PWMINTEN1: BRKEIEN Mask       */

#define TMR01_PWMINTEN1_BRKLIEN_Pos      (8)                                               /*!< TMR01_T::PWMINTEN1: BRKLIEN Position   */
#define TMR01_PWMINTEN1_BRKLIEN_Msk      (0x1ul << TMR01_PWMINTEN1_BRKLIEN_Pos)            /*!< TMR01_T::PWMINTEN1: BRKLIEN Mask       */

#define TMR01_PWMINTSTS0_ZIF_Pos         (0)                                               /*!< TMR01_T::PWMINTSTS0: ZIF Position      */
#define TMR01_PWMINTSTS0_ZIF_Msk         (0x1ul << TMR01_PWMINTSTS0_ZIF_Pos)               /*!< TMR01_T::PWMINTSTS0: ZIF Mask          */

#define TMR01_PWMINTSTS0_PIF_Pos         (1)                                               /*!< TMR01_T::PWMINTSTS0: PIF Position      */
#define TMR01_PWMINTSTS0_PIF_Msk         (0x1ul << TMR01_PWMINTSTS0_PIF_Pos)               /*!< TMR01_T::PWMINTSTS0: PIF Mask          */

#define TMR01_PWMINTSTS0_CMPUIF_Pos      (2)                                               /*!< TMR01_T::PWMINTSTS0: CMPUIF Position   */
#define TMR01_PWMINTSTS0_CMPUIF_Msk      (0x1ul << TMR01_PWMINTSTS0_CMPUIF_Pos)            /*!< TMR01_T::PWMINTSTS0: CMPUIF Mask       */

#define TMR01_PWMINTSTS0_CMPDIF_Pos      (3)                                               /*!< TMR01_T::PWMINTSTS0: CMPDIF Position   */
#define TMR01_PWMINTSTS0_CMPDIF_Msk      (0x1ul << TMR01_PWMINTSTS0_CMPDIF_Pos)            /*!< TMR01_T::PWMINTSTS0: CMPDIF Mask       */

#define TMR01_PWMINTSTS1_BRKEIF0_Pos     (0)                                               /*!< TMR01_T::PWMINTSTS1: BRKEIF0 Position  */
#define TMR01_PWMINTSTS1_BRKEIF0_Msk     (0x1ul << TMR01_PWMINTSTS1_BRKEIF0_Pos)           /*!< TMR01_T::PWMINTSTS1: BRKEIF0 Mask      */

#define TMR01_PWMINTSTS1_BRKEIF1_Pos     (1)                                               /*!< TMR01_T::PWMINTSTS1: BRKEIF1 Position  */
#define TMR01_PWMINTSTS1_BRKEIF1_Msk     (0x1ul << TMR01_PWMINTSTS1_BRKEIF1_Pos)           /*!< TMR01_T::PWMINTSTS1: BRKEIF1 Mask      */

#define TMR01_PWMINTSTS1_BRKLIF0_Pos     (8)                                               /*!< TMR01_T::PWMINTSTS1: BRKLIF0 Position  */
#define TMR01_PWMINTSTS1_BRKLIF0_Msk     (0x1ul << TMR01_PWMINTSTS1_BRKLIF0_Pos)           /*!< TMR01_T::PWMINTSTS1: BRKLIF0 Mask      */

#define TMR01_PWMINTSTS1_BRKLIF1_Pos     (9)                                               /*!< TMR01_T::PWMINTSTS1: BRKLIF1 Position  */
#define TMR01_PWMINTSTS1_BRKLIF1_Msk     (0x1ul << TMR01_PWMINTSTS1_BRKLIF1_Pos)           /*!< TMR01_T::PWMINTSTS1: BRKLIF1 Mask      */

#define TMR01_PWMINTSTS1_BRKESTS0_Pos    (16)                                              /*!< TMR01_T::PWMINTSTS1: BRKESTS0 Position */
#define TMR01_PWMINTSTS1_BRKESTS0_Msk    (0x1ul << TMR01_PWMINTSTS1_BRKESTS0_Pos)          /*!< TMR01_T::PWMINTSTS1: BRKESTS0 Mask     */

#define TMR01_PWMINTSTS1_BRKESTS1_Pos    (17)                                              /*!< TMR01_T::PWMINTSTS1: BRKESTS1 Position */
#define TMR01_PWMINTSTS1_BRKESTS1_Msk    (0x1ul << TMR01_PWMINTSTS1_BRKESTS1_Pos)          /*!< TMR01_T::PWMINTSTS1: BRKESTS1 Mask     */

#define TMR01_PWMINTSTS1_BRKLSTS0_Pos    (24)                                              /*!< TMR01_T::PWMINTSTS1: BRKLSTS0 Position */
#define TMR01_PWMINTSTS1_BRKLSTS0_Msk    (0x1ul << TMR01_PWMINTSTS1_BRKLSTS0_Pos)          /*!< TMR01_T::PWMINTSTS1: BRKLSTS0 Mask     */

#define TMR01_PWMINTSTS1_BRKLSTS1_Pos    (25)                                              /*!< TMR01_T::PWMINTSTS1: BRKLSTS1 Position */
#define TMR01_PWMINTSTS1_BRKLSTS1_Msk    (0x1ul << TMR01_PWMINTSTS1_BRKLSTS1_Pos)          /*!< TMR01_T::PWMINTSTS1: BRKLSTS1 Mask     */

#define TMR01_PWMADCTS_TRGSEL_Pos        (0)                                               /*!< TMR01_T::PWMADCTS: TRGSEL Position     */
#define TMR01_PWMADCTS_TRGSEL_Msk        (0x7ul << TMR01_PWMADCTS_TRGSEL_Pos)              /*!< TMR01_T::PWMADCTS: TRGSEL Mask         */

#define TMR01_PWMADCTS_TRGEN_Pos         (7)                                               /*!< TMR01_T::PWMADCTS: TRGEN Position      */
#define TMR01_PWMADCTS_TRGEN_Msk         (0x1ul << TMR01_PWMADCTS_TRGEN_Pos)               /*!< TMR01_T::PWMADCTS: TRGEN Mask          */

#define TMR01_PWMSCTL_SYNCMODE_Pos       (0)                                               /*!< TMR01_T::PWMSCTL: SYNCMODE Position    */
#define TMR01_PWMSCTL_SYNCMODE_Msk       (0x3ul << TMR01_PWMSCTL_SYNCMODE_Pos)             /*!< TMR01_T::PWMSCTL: SYNCMODE Mask        */

#define TMR01_PWMSCTL_SYNCSRC_Pos        (8)                                               /*!< TMR01_T::PWMSCTL: SYNCSRC Position     */
#define TMR01_PWMSCTL_SYNCSRC_Msk        (0x1ul << TMR01_PWMSCTL_SYNCSRC_Pos)              /*!< TMR01_T::PWMSCTL: SYNCSRC Mask         */

#define TMR01_PWMSTRG_STRGEN_Pos         (0)                                               /*!< TMR01_T::PWMSTRG: STRGEN Position      */
#define TMR01_PWMSTRG_STRGEN_Msk         (0x1ul << TMR01_PWMSTRG_STRGEN_Pos)               /*!< TMR01_T::PWMSTRG: STRGEN Mask          */

#define TMR01_PWMSTATUS_CNTMAXF_Pos      (0)                                               /*!< TMR01_T::PWMSTATUS: CNTMAXF Position   */
#define TMR01_PWMSTATUS_CNTMAXF_Msk      (0x1ul << TMR01_PWMSTATUS_CNTMAXF_Pos)            /*!< TMR01_T::PWMSTATUS: CNTMAXF Mask       */

#define TMR01_PWMSTATUS_ADCTRGF_Pos      (16)                                              /*!< TMR01_T::PWMSTATUS: ADCTRGF Position   */
#define TMR01_PWMSTATUS_ADCTRGF_Msk      (0x1ul << TMR01_PWMSTATUS_ADCTRGF_Pos)            /*!< TMR01_T::PWMSTATUS: ADCTRGF Mask       */

#define TMR01_PWMPBUF_PBUF_Pos           (0)                                               /*!< TMR01_T::PWMPBUF: PBUF Position        */
#define TMR01_PWMPBUF_PBUF_Msk           (0xfffful << TMR01_PWMPBUF_PBUF_Pos)              /*!< TMR01_T::PWMPBUF: PBUF Mask            */

#define TMR01_PWMCMPBUF_CMPBUF_Pos       (0)                                               /*!< TMR01_T::PWMCMPBUF: CMPBUF Position    */
#define TMR01_PWMCMPBUF_CMPBUF_Msk       (0xfffful << TMR01_PWMCMPBUF_CMPBUF_Pos)          /*!< TMR01_T::PWMCMPBUF: CMPBUF Mask        */

#define TMR01_CTL_PSC_Pos                (0)                                               /*!< TMR01_T::CTL: PSC Position             */
#define TMR01_CTL_PSC_Msk                (0xfful << TMR01_CTL_PSC_Pos)                     /*!< TMR01_T::CTL: PSC Mask                 */

#define TMR01_CTL_INTRGEN_Pos            (19)                                              /*!< TMR01_T::CTL: INTRGEN Position         */
#define TMR01_CTL_INTRGEN_Msk            (0x1ul << TMR01_CTL_INTRGEN_Pos)                  /*!< TMR01_T::CTL: INTRGEN Mask             */

#define TMR01_CTL_PERIOSEL_Pos           (20)                                              /*!< TMR01_T::CTL: PERIOSEL Position        */
#define TMR01_CTL_PERIOSEL_Msk           (0x1ul << TMR01_CTL_PERIOSEL_Pos)                 /*!< TMR01_T::CTL: PERIOSEL Mask            */

#define TMR01_CTL_TGLPINSEL_Pos          (21)                                              /*!< TMR01_T::CTL: TGLPINSEL Position       */
#define TMR01_CTL_TGLPINSEL_Msk          (0x1ul << TMR01_CTL_TGLPINSEL_Pos)                /*!< TMR01_T::CTL: TGLPINSEL Mask           */

#define TMR01_CTL_CAPSRC_Pos             (22)                                              /*!< TMR01_T::CTL: CAPSRC Position          */
#define TMR01_CTL_CAPSRC_Msk             (0x1ul << TMR01_CTL_CAPSRC_Pos)                   /*!< TMR01_T::CTL: CAPSRC Mask              */

#define TMR01_CTL_WKEN_Pos               (23)                                              /*!< TMR01_T::CTL: WKEN Position            */
#define TMR01_CTL_WKEN_Msk               (0x1ul << TMR01_CTL_WKEN_Pos)                     /*!< TMR01_T::CTL: WKEN Mask                */

#define TMR01_CTL_EXTCNTEN_Pos           (24)                                              /*!< TMR01_T::CTL: EXTCNTEN Position        */
#define TMR01_CTL_EXTCNTEN_Msk           (0x1ul << TMR01_CTL_EXTCNTEN_Pos)                 /*!< TMR01_T::CTL: EXTCNTEN Mask            */

#define TMR01_CTL_ACTSTS_Pos             (25)                                              /*!< TMR01_T::CTL: ACTSTS Position          */
#define TMR01_CTL_ACTSTS_Msk             (0x1ul << TMR01_CTL_ACTSTS_Pos)                   /*!< TMR01_T::CTL: ACTSTS Mask              */

#define TMR01_CTL_RSTCNT_Pos             (26)                                              /*!< TMR01_T::CTL: RSTCNT Position          */
#define TMR01_CTL_RSTCNT_Msk             (0x1ul << TMR01_CTL_RSTCNT_Pos)                   /*!< TMR01_T::CTL: RSTCNT Mask              */

#define TMR01_CTL_OPMODE_Pos             (27)                                              /*!< TMR01_T::CTL: OPMODE Position          */
#define TMR01_CTL_OPMODE_Msk             (0x3ul << TMR01_CTL_OPMODE_Pos)                   /*!< TMR01_T::CTL: OPMODE Mask              */

#define TMR01_CTL_INTEN_Pos              (29)                                              /*!< TMR01_T::CTL: INTEN Position           */
#define TMR01_CTL_INTEN_Msk              (0x1ul << TMR01_CTL_INTEN_Pos)                    /*!< TMR01_T::CTL: INTEN Mask               */

#define TMR01_CTL_CNTEN_Pos              (30)                                              /*!< TMR01_T::CTL: CNTEN Position           */
#define TMR01_CTL_CNTEN_Msk              (0x1ul << TMR01_CTL_CNTEN_Pos)                    /*!< TMR01_T::CTL: CNTEN Mask               */

#define TMR01_CTL_ICEDEBUG_Pos           (31)                                              /*!< TMR01_T::CTL: ICEDEBUG Position        */
#define TMR01_CTL_ICEDEBUG_Msk           (0x1ul << TMR01_CTL_ICEDEBUG_Pos)                 /*!< TMR01_T::CTL: ICEDEBUG Mask            */

#define TMR01_CMP_CMPDAT_Pos             (0)                                               /*!< TMR01_T::CMP: CMPDAT Position          */
#define TMR01_CMP_CMPDAT_Msk             (0xfffffful << TMR01_CMP_CMPDAT_Pos)              /*!< TMR01_T::CMP: CMPDAT Mask              */

#define TMR01_INTSTS_TIF_Pos             (0)                                               /*!< TMR01_T::INTSTS: TIF Position          */
#define TMR01_INTSTS_TIF_Msk             (0x1ul << TMR01_INTSTS_TIF_Pos)                   /*!< TMR01_T::INTSTS: TIF Mask              */

#define TMR01_INTSTS_TWKF_Pos            (1)                                               /*!< TMR01_T::INTSTS: TWKF Position         */
#define TMR01_INTSTS_TWKF_Msk            (0x1ul << TMR01_INTSTS_TWKF_Pos)                  /*!< TMR01_T::INTSTS: TWKF Mask             */

#define TMR01_CNT_CNT_Pos                (0)                                               /*!< TMR01_T::CNT: CNT Position             */
#define TMR01_CNT_CNT_Msk                (0xfffffful << TMR01_CNT_CNT_Pos)                 /*!< TMR01_T::CNT: CNT Mask                 */

#define TMR01_CNT_RSTACT_Pos             (31)                                              /*!< TMR01_T::CNT: RSTACT Position          */
#define TMR01_CNT_RSTACT_Msk             (0x1ul << TMR01_CNT_RSTACT_Pos)                   /*!< TMR01_T::CNT: RSTACT Mask              */

#define TMR01_CAP_CAPDAT_Pos             (0)                                               /*!< TMR01_T::CAP: CAPDAT Position          */
#define TMR01_CAP_CAPDAT_Msk             (0xfffffful << TMR01_CAP_CAPDAT_Pos)              /*!< TMR01_T::CAP: CAPDAT Mask              */

#define TMR01_EXTCTL_CNTPHASE_Pos        (0)                                               /*!< TMR01_T::EXTCTL: CNTPHASE Position     */
#define TMR01_EXTCTL_CNTPHASE_Msk        (0x1ul << TMR01_EXTCTL_CNTPHASE_Pos)              /*!< TMR01_T::EXTCTL: CNTPHASE Mask         */

#define TMR01_EXTCTL_SCAPEDGE_Pos        (1)                                               /*!< TMR01_T::EXTCTL: SCAPEDGE Position     */
#define TMR01_EXTCTL_SCAPEDGE_Msk        (0x3ul << TMR01_EXTCTL_SCAPEDGE_Pos)              /*!< TMR01_T::EXTCTL: SCAPEDGE Mask         */

#define TMR01_EXTCTL_CAPEN_Pos           (3)                                               /*!< TMR01_T::EXTCTL: CAPEN Position        */
#define TMR01_EXTCTL_CAPEN_Msk           (0x1ul << TMR01_EXTCTL_CAPEN_Pos)                 /*!< TMR01_T::EXTCTL: CAPEN Mask            */

#define TMR01_EXTCTL_CAPFUNCS_Pos        (4)                                               /*!< TMR01_T::EXTCTL: CAPFUNCS Position     */
#define TMR01_EXTCTL_CAPFUNCS_Msk        (0x1ul << TMR01_EXTCTL_CAPFUNCS_Pos)              /*!< TMR01_T::EXTCTL: CAPFUNCS Mask         */

#define TMR01_EXTCTL_CAPIEN_Pos          (5)                                               /*!< TMR01_T::EXTCTL: CAPIEN Position       */
#define TMR01_EXTCTL_CAPIEN_Msk          (0x1ul << TMR01_EXTCTL_CAPIEN_Pos)                /*!< TMR01_T::EXTCTL: CAPIEN Mask           */

#define TMR01_EXTCTL_CAPDBEN_Pos         (6)                                               /*!< TMR01_T::EXTCTL: CAPDBEN Position      */
#define TMR01_EXTCTL_CAPDBEN_Msk         (0x1ul << TMR01_EXTCTL_CAPDBEN_Pos)               /*!< TMR01_T::EXTCTL: CAPDBEN Mask          */

#define TMR01_EXTCTL_CNTDBEN_Pos         (7)                                               /*!< TMR01_T::EXTCTL: CNTDBEN Position      */
#define TMR01_EXTCTL_CNTDBEN_Msk         (0x1ul << TMR01_EXTCTL_CNTDBEN_Pos)               /*!< TMR01_T::EXTCTL: CNTDBEN Mask          */

#define TMR01_EXTCTL_CAPEDGE_Pos         (12)                                              /*!< TMR01_T::EXTCTL: CAPEDGE Position      */
#define TMR01_EXTCTL_CAPEDGE_Msk         (0x7ul << TMR01_EXTCTL_CAPEDGE_Pos)               /*!< TMR01_T::EXTCTL: CAPEDGE Mask          */

#define TMR01_EXTCTL_ECNTSSEL_Pos        (16)                                              /*!< TMR01_T::EXTCTL: ECNTSSEL Position     */
#define TMR01_EXTCTL_ECNTSSEL_Msk        (0x1ul << TMR01_EXTCTL_ECNTSSEL_Pos)              /*!< TMR01_T::EXTCTL: ECNTSSEL Mask         */

#define TMR01_EINTSTS_CAPIF_Pos          (0)                                               /*!< TMR01_T::EINTSTS: CAPIF Position       */
#define TMR01_EINTSTS_CAPIF_Msk          (0x1ul << TMR01_EINTSTS_CAPIF_Pos)                /*!< TMR01_T::EINTSTS: CAPIF Mask           */

#define TMR01_TRGCTL_TRGSSEL_Pos         (0)                                               /*!< TMR01_T::TRGCTL: TRGSSEL Position      */
#define TMR01_TRGCTL_TRGSSEL_Msk         (0x1ul << TMR01_TRGCTL_TRGSSEL_Pos)               /*!< TMR01_T::TRGCTL: TRGSSEL Mask          */

#define TMR01_TRGCTL_TRGPWM_Pos          (1)                                               /*!< TMR01_T::TRGCTL: TRGPWM Position       */
#define TMR01_TRGCTL_TRGPWM_Msk          (0x1ul << TMR01_TRGCTL_TRGPWM_Pos)                /*!< TMR01_T::TRGCTL: TRGPWM Mask           */

#define TMR01_TRGCTL_TRGADC_Pos          (2)                                               /*!< TMR01_T::TRGCTL: TRGADC Position       */
#define TMR01_TRGCTL_TRGADC_Msk          (0x1ul << TMR01_TRGCTL_TRGADC_Pos)                /*!< TMR01_T::TRGCTL: TRGADC Mask           */

#define TMR01_TRGCTL_TRGPDMA_Pos         (4)                                               /*!< TMR01_T::TRGCTL: TRGPDMA Position      */
#define TMR01_TRGCTL_TRGPDMA_Msk         (0x1ul << TMR01_TRGCTL_TRGPDMA_Pos)               /*!< TMR01_T::TRGCTL: TRGPDMA Mask          */

#define TMR01_ALTCTL_FUNCSEL_Pos         (0)                                               /*!< TMR01_T::ALTCTL: FUNCSEL Position      */
#define TMR01_ALTCTL_FUNCSEL_Msk         (0x1ul << TMR01_ALTCTL_FUNCSEL_Pos)               /*!< TMR01_T::ALTCTL: FUNCSEL Mask          */

#define TMR01_PWMCTL_CNTEN_Pos           (0)                                               /*!< TMR01_T::PWMCTL: CNTEN Position        */
#define TMR01_PWMCTL_CNTEN_Msk           (0x1ul << TMR01_PWMCTL_CNTEN_Pos)                 /*!< TMR01_T::PWMCTL: CNTEN Mask            */

#define TMR01_PWMCTL_CNTTYPE_Pos         (1)                                               /*!< TMR01_T::PWMCTL: CNTTYPE Position      */
#define TMR01_PWMCTL_CNTTYPE_Msk         (0x3ul << TMR01_PWMCTL_CNTTYPE_Pos)               /*!< TMR01_T::PWMCTL: CNTTYPE Mask          */

#define TMR01_PWMCTL_CNTMODE_Pos         (3)                                               /*!< TMR01_T::PWMCTL: CNTMODE Position      */
#define TMR01_PWMCTL_CNTMODE_Msk         (0x1ul << TMR01_PWMCTL_CNTMODE_Pos)               /*!< TMR01_T::PWMCTL: CNTMODE Mask          */

#define TMR01_PWMCTL_CTRLD_Pos           (8)                                               /*!< TMR01_T::PWMCTL: CTRLD Position        */
#define TMR01_PWMCTL_CTRLD_Msk           (0x1ul << TMR01_PWMCTL_CTRLD_Pos)                 /*!< TMR01_T::PWMCTL: CTRLD Mask            */

#define TMR01_PWMCTL_IMMLDEN_Pos         (9)                                               /*!< TMR01_T::PWMCTL: IMMLDEN Position      */
#define TMR01_PWMCTL_IMMLDEN_Msk         (0x1ul << TMR01_PWMCTL_IMMLDEN_Pos)               /*!< TMR01_T::PWMCTL: IMMLDEN Mask          */

#define TMR01_PWMCTL_OUTMODE_Pos         (16)                                              /*!< TMR01_T::PWMCTL: OUTMODE Position      */
#define TMR01_PWMCTL_OUTMODE_Msk         (0x1ul << TMR01_PWMCTL_OUTMODE_Pos)               /*!< TMR01_T::PWMCTL: OUTMODE Mask          */

#define TMR01_PWMCTL_DBGHALT_Pos         (30)                                              /*!< TMR01_T::PWMCTL: DBGHALT Position      */
#define TMR01_PWMCTL_DBGHALT_Msk         (0x1ul << TMR01_PWMCTL_DBGHALT_Pos)               /*!< TMR01_T::PWMCTL: DBGHALT Mask          */

#define TMR01_PWMCTL_DBGTRIOFF_Pos       (31)                                              /*!< TMR01_T::PWMCTL: DBGTRIOFF Position    */
#define TMR01_PWMCTL_DBGTRIOFF_Msk       (0x1ul << TMR01_PWMCTL_DBGTRIOFF_Pos)             /*!< TMR01_T::PWMCTL: DBGTRIOFF Mask        */

#define TMR01_PWMCLKSRC_CLKSRC_Pos       (0)                                               /*!< TMR01_T::PWMCLKSRC: CLKSRC Position    */
#define TMR01_PWMCLKSRC_CLKSRC_Msk       (0x7ul << TMR01_PWMCLKSRC_CLKSRC_Pos)             /*!< TMR01_T::PWMCLKSRC: CLKSRC Mask        */

#define TMR01_PWMCLKPSC_CLKPSC_Pos       (0)                                               /*!< TMR01_T::PWMCLKPSC: CLKPSC Position    */
#define TMR01_PWMCLKPSC_CLKPSC_Msk       (0xffful << TMR01_PWMCLKPSC_CLKPSC_Pos)           /*!< TMR01_T::PWMCLKPSC: CLKPSC Mask        */

#define TMR01_PWMCNTCLR_CNTCLR_Pos       (0)                                               /*!< TMR01_T::PWMCNTCLR: CNTCLR Position    */
#define TMR01_PWMCNTCLR_CNTCLR_Msk       (0x1ul << TMR01_PWMCNTCLR_CNTCLR_Pos)             /*!< TMR01_T::PWMCNTCLR: CNTCLR Mask        */

#define TMR01_PWMPERIOD_PERIOD_Pos       (0)                                               /*!< TMR01_T::PWMPERIOD: PERIOD Position    */
#define TMR01_PWMPERIOD_PERIOD_Msk       (0xfffful << TMR01_PWMPERIOD_PERIOD_Pos)          /*!< TMR01_T::PWMPERIOD: PERIOD Mask        */

#define TMR01_PWMCMPDAT_CMP_Pos          (0)                                               /*!< TMR01_T::PWMCMPDAT: CMP Position       */
#define TMR01_PWMCMPDAT_CMP_Msk          (0xfffful << TMR01_PWMCMPDAT_CMP_Pos)             /*!< TMR01_T::PWMCMPDAT: CMP Mask           */

#define TMR01_PWMDTCTL_DTCNT_Pos         (0)                                               /*!< TMR01_T::PWMDTCTL: DTCNT Position      */
#define TMR01_PWMDTCTL_DTCNT_Msk         (0xffful << TMR01_PWMDTCTL_DTCNT_Pos)             /*!< TMR01_T::PWMDTCTL: DTCNT Mask          */

#define TMR01_PWMDTCTL_DTEN_Pos          (16)                                              /*!< TMR01_T::PWMDTCTL: DTEN Position       */
#define TMR01_PWMDTCTL_DTEN_Msk          (0x1ul << TMR01_PWMDTCTL_DTEN_Pos)                /*!< TMR01_T::PWMDTCTL: DTEN Mask           */

#define TMR01_PWMDTCTL_DTCKSEL_Pos       (24)                                              /*!< TMR01_T::PWMDTCTL: DTCKSEL Position    */
#define TMR01_PWMDTCTL_DTCKSEL_Msk       (0x1ul << TMR01_PWMDTCTL_DTCKSEL_Pos)             /*!< TMR01_T::PWMDTCTL: DTCKSEL Mask        */

#define TMR01_PWMCNT_CNT_Pos             (0)                                               /*!< TMR01_T::PWMCNT: CNT Position          */
#define TMR01_PWMCNT_CNT_Msk             (0xfffful << TMR01_PWMCNT_CNT_Pos)                /*!< TMR01_T::PWMCNT: CNT Mask              */

#define TMR01_PWMCNT_DIRF_Pos            (16)                                              /*!< TMR01_T::PWMCNT: DIRF Position         */
#define TMR01_PWMCNT_DIRF_Msk            (0x1ul << TMR01_PWMCNT_DIRF_Pos)                  /*!< TMR01_T::PWMCNT: DIRF Mask             */

#define TMR01_PWMMSKEN_MSKEN0_Pos        (0)                                               /*!< TMR01_T::PWMMSKEN: MSKEN0 Position     */
#define TMR01_PWMMSKEN_MSKEN0_Msk        (0x1ul << TMR01_PWMMSKEN_MSKEN0_Pos)              /*!< TMR01_T::PWMMSKEN: MSKEN0 Mask         */

#define TMR01_PWMMSKEN_MSKEN1_Pos        (1)                                               /*!< TMR01_T::PWMMSKEN: MSKEN1 Position     */
#define TMR01_PWMMSKEN_MSKEN1_Msk        (0x1ul << TMR01_PWMMSKEN_MSKEN1_Pos)              /*!< TMR01_T::PWMMSKEN: MSKEN1 Mask         */

#define TMR01_PWMMSK_MSKDAT0_Pos         (0)                                               /*!< TMR01_T::PWMMSK: MSKDAT0 Position      */
#define TMR01_PWMMSK_MSKDAT0_Msk         (0x1ul << TMR01_PWMMSK_MSKDAT0_Pos)               /*!< TMR01_T::PWMMSK: MSKDAT0 Mask          */

#define TMR01_PWMMSK_MSKDAT1_Pos         (1)                                               /*!< TMR01_T::PWMMSK: MSKDAT1 Position      */
#define TMR01_PWMMSK_MSKDAT1_Msk         (0x1ul << TMR01_PWMMSK_MSKDAT1_Pos)               /*!< TMR01_T::PWMMSK: MSKDAT1 Mask          */

#define TMR01_PWMBNF_BRKNFEN_Pos         (0)                                               /*!< TMR01_T::PWMBNF: BRKNFEN Position      */
#define TMR01_PWMBNF_BRKNFEN_Msk         (0x1ul << TMR01_PWMBNF_BRKNFEN_Pos)               /*!< TMR01_T::PWMBNF: BRKNFEN Mask          */

#define TMR01_PWMBNF_BRKNFSEL_Pos        (1)                                               /*!< TMR01_T::PWMBNF: BRKNFSEL Position     */
#define TMR01_PWMBNF_BRKNFSEL_Msk        (0x7ul << TMR01_PWMBNF_BRKNFSEL_Pos)              /*!< TMR01_T::PWMBNF: BRKNFSEL Mask         */

#define TMR01_PWMBNF_BRKFCNT_Pos         (4)                                               /*!< TMR01_T::PWMBNF: BRKFCNT Position      */
#define TMR01_PWMBNF_BRKFCNT_Msk         (0x7ul << TMR01_PWMBNF_BRKFCNT_Pos)               /*!< TMR01_T::PWMBNF: BRKFCNT Mask          */

#define TMR01_PWMBNF_BRKPINV_Pos         (7)                                               /*!< TMR01_T::PWMBNF: BRKPINV Position      */
#define TMR01_PWMBNF_BRKPINV_Msk         (0x1ul << TMR01_PWMBNF_BRKPINV_Pos)               /*!< TMR01_T::PWMBNF: BRKPINV Mask          */

#define TMR01_PWMBNF_BKPINSRC_Pos        (16)                                              /*!< TMR01_T::PWMBNF: BKPINSRC Position     */
#define TMR01_PWMBNF_BKPINSRC_Msk        (0x3ul << TMR01_PWMBNF_BKPINSRC_Pos)              /*!< TMR01_T::PWMBNF: BKPINSRC Mask         */

#define TMR01_PWMFAILBRK_CSSBRKEN_Pos    (0)                                               /*!< TMR01_T::PWMFAILBRK: CSSBRKEN Position */
#define TMR01_PWMFAILBRK_CSSBRKEN_Msk    (0x1ul << TMR01_PWMFAILBRK_CSSBRKEN_Pos)          /*!< TMR01_T::PWMFAILBRK: CSSBRKEN Mask     */

#define TMR01_PWMFAILBRK_BODBRKEN_Pos    (1)                                               /*!< TMR01_T::PWMFAILBRK: BODBRKEN Position */
#define TMR01_PWMFAILBRK_BODBRKEN_Msk    (0x1ul << TMR01_PWMFAILBRK_BODBRKEN_Pos)          /*!< TMR01_T::PWMFAILBRK: BODBRKEN Mask     */

#define TMR01_PWMFAILBRK_RAMBRKEN_Pos    (2)                                               /*!< TMR01_T::PWMFAILBRK: RAMBRKEN Position */
#define TMR01_PWMFAILBRK_RAMBRKEN_Msk    (0x1ul << TMR01_PWMFAILBRK_RAMBRKEN_Pos)          /*!< TMR01_T::PWMFAILBRK: RAMBRKEN Mask     */

#define TMR01_PWMFAILBRK_CORBRKEN_Pos    (3)                                               /*!< TMR01_T::PWMFAILBRK: CORBRKEN Position */
#define TMR01_PWMFAILBRK_CORBRKEN_Msk    (0x1ul << TMR01_PWMFAILBRK_CORBRKEN_Pos)          /*!< TMR01_T::PWMFAILBRK: CORBRKEN Mask     */

#define TMR01_PWMBRKCTL_BRKPEEN_Pos      (4)                                               /*!< TMR01_T::PWMBRKCTL: BRKPEEN Position   */
#define TMR01_PWMBRKCTL_BRKPEEN_Msk      (0x1ul << TMR01_PWMBRKCTL_BRKPEEN_Pos)            /*!< TMR01_T::PWMBRKCTL: BRKPEEN Mask       */

#define TMR01_PWMBRKCTL_SYSEBEN_Pos      (7)                                               /*!< TMR01_T::PWMBRKCTL: SYSEBEN Position   */
#define TMR01_PWMBRKCTL_SYSEBEN_Msk      (0x1ul << TMR01_PWMBRKCTL_SYSEBEN_Pos)            /*!< TMR01_T::PWMBRKCTL: SYSEBEN Mask       */

#define TMR01_PWMBRKCTL_BRKPLEN_Pos      (12)                                              /*!< TMR01_T::PWMBRKCTL: BRKPLEN Position   */
#define TMR01_PWMBRKCTL_BRKPLEN_Msk      (0x1ul << TMR01_PWMBRKCTL_BRKPLEN_Pos)            /*!< TMR01_T::PWMBRKCTL: BRKPLEN Mask       */

#define TMR01_PWMBRKCTL_SYSLBEN_Pos      (15)                                              /*!< TMR01_T::PWMBRKCTL: SYSLBEN Position   */
#define TMR01_PWMBRKCTL_SYSLBEN_Msk      (0x1ul << TMR01_PWMBRKCTL_SYSLBEN_Pos)            /*!< TMR01_T::PWMBRKCTL: SYSLBEN Mask       */

#define TMR01_PWMBRKCTL_BRKAEVEN_Pos     (16)                                              /*!< TMR01_T::PWMBRKCTL: BRKAEVEN Position  */
#define TMR01_PWMBRKCTL_BRKAEVEN_Msk     (0x3ul << TMR01_PWMBRKCTL_BRKAEVEN_Pos)           /*!< TMR01_T::PWMBRKCTL: BRKAEVEN Mask      */

#define TMR01_PWMBRKCTL_BRKAODD_Pos      (18)                                              /*!< TMR01_T::PWMBRKCTL: BRKAODD Position   */
#define TMR01_PWMBRKCTL_BRKAODD_Msk      (0x3ul << TMR01_PWMBRKCTL_BRKAODD_Pos)            /*!< TMR01_T::PWMBRKCTL: BRKAODD Mask       */

#define TMR01_PWMPOLCTL_PINV0_Pos        (0)                                               /*!< TMR01_T::PWMPOLCTL: PINV0 Position     */
#define TMR01_PWMPOLCTL_PINV0_Msk        (0x1ul << TMR01_PWMPOLCTL_PINV0_Pos)              /*!< TMR01_T::PWMPOLCTL: PINV0 Mask         */

#define TMR01_PWMPOLCTL_PINV1_Pos        (1)                                               /*!< TMR01_T::PWMPOLCTL: PINV1 Position     */
#define TMR01_PWMPOLCTL_PINV1_Msk        (0x1ul << TMR01_PWMPOLCTL_PINV1_Pos)              /*!< TMR01_T::PWMPOLCTL: PINV1 Mask         */

#define TMR01_PWMPOEN_POEN0_Pos          (0)                                               /*!< TMR01_T::PWMPOEN: POEN0 Position       */
#define TMR01_PWMPOEN_POEN0_Msk          (0x1ul << TMR01_PWMPOEN_POEN0_Pos)                /*!< TMR01_T::PWMPOEN: POEN0 Mask           */

#define TMR01_PWMPOEN_POEN1_Pos          (1)                                               /*!< TMR01_T::PWMPOEN: POEN1 Position       */
#define TMR01_PWMPOEN_POEN1_Msk          (0x1ul << TMR01_PWMPOEN_POEN1_Pos)                /*!< TMR01_T::PWMPOEN: POEN1 Mask           */

#define TMR01_PWMSWBRK_BRKETRG_Pos       (0)                                               /*!< TMR01_T::PWMSWBRK: BRKETRG Position    */
#define TMR01_PWMSWBRK_BRKETRG_Msk       (0x1ul << TMR01_PWMSWBRK_BRKETRG_Pos)             /*!< TMR01_T::PWMSWBRK: BRKETRG Mask        */

#define TMR01_PWMSWBRK_BRKLTRG_Pos       (8)                                               /*!< TMR01_T::PWMSWBRK: BRKLTRG Position    */
#define TMR01_PWMSWBRK_BRKLTRG_Msk       (0x1ul << TMR01_PWMSWBRK_BRKLTRG_Pos)             /*!< TMR01_T::PWMSWBRK: BRKLTRG Mask        */

#define TMR01_PWMINTEN0_ZIEN_Pos         (0)                                               /*!< TMR01_T::PWMINTEN0: ZIEN Position      */
#define TMR01_PWMINTEN0_ZIEN_Msk         (0x1ul << TMR01_PWMINTEN0_ZIEN_Pos)               /*!< TMR01_T::PWMINTEN0: ZIEN Mask          */

#define TMR01_PWMINTEN0_PIEN_Pos         (1)                                               /*!< TMR01_T::PWMINTEN0: PIEN Position      */
#define TMR01_PWMINTEN0_PIEN_Msk         (0x1ul << TMR01_PWMINTEN0_PIEN_Pos)               /*!< TMR01_T::PWMINTEN0: PIEN Mask          */

#define TMR01_PWMINTEN0_CMPUIEN_Pos      (2)                                               /*!< TMR01_T::PWMINTEN0: CMPUIEN Position   */
#define TMR01_PWMINTEN0_CMPUIEN_Msk      (0x1ul << TMR01_PWMINTEN0_CMPUIEN_Pos)            /*!< TMR01_T::PWMINTEN0: CMPUIEN Mask       */

#define TMR01_PWMINTEN0_CMPDIEN_Pos      (3)                                               /*!< TMR01_T::PWMINTEN0: CMPDIEN Position   */
#define TMR01_PWMINTEN0_CMPDIEN_Msk      (0x1ul << TMR01_PWMINTEN0_CMPDIEN_Pos)            /*!< TMR01_T::PWMINTEN0: CMPDIEN Mask       */

#define TMR01_PWMINTEN1_BRKEIEN_Pos      (0)                                               /*!< TMR01_T::PWMINTEN1: BRKEIEN Position   */
#define TMR01_PWMINTEN1_BRKEIEN_Msk      (0x1ul << TMR01_PWMINTEN1_BRKEIEN_Pos)            /*!< TMR01_T::PWMINTEN1: BRKEIEN Mask       */

#define TMR01_PWMINTEN1_BRKLIEN_Pos      (8)                                               /*!< TMR01_T::PWMINTEN1: BRKLIEN Position   */
#define TMR01_PWMINTEN1_BRKLIEN_Msk      (0x1ul << TMR01_PWMINTEN1_BRKLIEN_Pos)            /*!< TMR01_T::PWMINTEN1: BRKLIEN Mask       */

#define TMR01_PWMINTSTS0_ZIF_Pos         (0)                                               /*!< TMR01_T::PWMINTSTS0: ZIF Position      */
#define TMR01_PWMINTSTS0_ZIF_Msk         (0x1ul << TMR01_PWMINTSTS0_ZIF_Pos)               /*!< TMR01_T::PWMINTSTS0: ZIF Mask          */

#define TMR01_PWMINTSTS0_PIF_Pos         (1)                                               /*!< TMR01_T::PWMINTSTS0: PIF Position      */
#define TMR01_PWMINTSTS0_PIF_Msk         (0x1ul << TMR01_PWMINTSTS0_PIF_Pos)               /*!< TMR01_T::PWMINTSTS0: PIF Mask          */

#define TMR01_PWMINTSTS0_CMPUIF_Pos      (2)                                               /*!< TMR01_T::PWMINTSTS0: CMPUIF Position   */
#define TMR01_PWMINTSTS0_CMPUIF_Msk      (0x1ul << TMR01_PWMINTSTS0_CMPUIF_Pos)            /*!< TMR01_T::PWMINTSTS0: CMPUIF Mask       */

#define TMR01_PWMINTSTS0_CMPDIF_Pos      (3)                                               /*!< TMR01_T::PWMINTSTS0: CMPDIF Position   */
#define TMR01_PWMINTSTS0_CMPDIF_Msk      (0x1ul << TMR01_PWMINTSTS0_CMPDIF_Pos)            /*!< TMR01_T::PWMINTSTS0: CMPDIF Mask       */

#define TMR01_PWMINTSTS1_BRKEIF0_Pos     (0)                                               /*!< TMR01_T::PWMINTSTS1: BRKEIF0 Position  */
#define TMR01_PWMINTSTS1_BRKEIF0_Msk     (0x1ul << TMR01_PWMINTSTS1_BRKEIF0_Pos)           /*!< TMR01_T::PWMINTSTS1: BRKEIF0 Mask      */

#define TMR01_PWMINTSTS1_BRKEIF1_Pos     (1)                                               /*!< TMR01_T::PWMINTSTS1: BRKEIF1 Position  */
#define TMR01_PWMINTSTS1_BRKEIF1_Msk     (0x1ul << TMR01_PWMINTSTS1_BRKEIF1_Pos)           /*!< TMR01_T::PWMINTSTS1: BRKEIF1 Mask      */

#define TMR01_PWMINTSTS1_BRKLIF0_Pos     (8)                                               /*!< TMR01_T::PWMINTSTS1: BRKLIF0 Position  */
#define TMR01_PWMINTSTS1_BRKLIF0_Msk     (0x1ul << TMR01_PWMINTSTS1_BRKLIF0_Pos)           /*!< TMR01_T::PWMINTSTS1: BRKLIF0 Mask      */

#define TMR01_PWMINTSTS1_BRKLIF1_Pos     (9)                                               /*!< TMR01_T::PWMINTSTS1: BRKLIF1 Position  */
#define TMR01_PWMINTSTS1_BRKLIF1_Msk     (0x1ul << TMR01_PWMINTSTS1_BRKLIF1_Pos)           /*!< TMR01_T::PWMINTSTS1: BRKLIF1 Mask      */

#define TMR01_PWMINTSTS1_BRKESTS0_Pos    (16)                                              /*!< TMR01_T::PWMINTSTS1: BRKESTS0 Position */
#define TMR01_PWMINTSTS1_BRKESTS0_Msk    (0x1ul << TMR01_PWMINTSTS1_BRKESTS0_Pos)          /*!< TMR01_T::PWMINTSTS1: BRKESTS0 Mask     */

#define TMR01_PWMINTSTS1_BRKESTS1_Pos    (17)                                              /*!< TMR01_T::PWMINTSTS1: BRKESTS1 Position */
#define TMR01_PWMINTSTS1_BRKESTS1_Msk    (0x1ul << TMR01_PWMINTSTS1_BRKESTS1_Pos)          /*!< TMR01_T::PWMINTSTS1: BRKESTS1 Mask     */

#define TMR01_PWMINTSTS1_BRKLSTS0_Pos    (24)                                              /*!< TMR01_T::PWMINTSTS1: BRKLSTS0 Position */
#define TMR01_PWMINTSTS1_BRKLSTS0_Msk    (0x1ul << TMR01_PWMINTSTS1_BRKLSTS0_Pos)          /*!< TMR01_T::PWMINTSTS1: BRKLSTS0 Mask     */

#define TMR01_PWMINTSTS1_BRKLSTS1_Pos    (25)                                              /*!< TMR01_T::PWMINTSTS1: BRKLSTS1 Position */
#define TMR01_PWMINTSTS1_BRKLSTS1_Msk    (0x1ul << TMR01_PWMINTSTS1_BRKLSTS1_Pos)          /*!< TMR01_T::PWMINTSTS1: BRKLSTS1 Mask     */

#define TMR01_PWMADCTS_TRGSEL_Pos        (0)                                               /*!< TMR01_T::PWMADCTS: TRGSEL Position     */
#define TMR01_PWMADCTS_TRGSEL_Msk        (0x7ul << TMR01_PWMADCTS_TRGSEL_Pos)              /*!< TMR01_T::PWMADCTS: TRGSEL Mask         */

#define TMR01_PWMADCTS_TRGEN_Pos         (7)                                               /*!< TMR01_T::PWMADCTS: TRGEN Position      */
#define TMR01_PWMADCTS_TRGEN_Msk         (0x1ul << TMR01_PWMADCTS_TRGEN_Pos)               /*!< TMR01_T::PWMADCTS: TRGEN Mask          */

#define TMR01_PWMSCTL_SYNCMODE_Pos       (0)                                               /*!< TMR01_T::PWMSCTL: SYNCMODE Position    */
#define TMR01_PWMSCTL_SYNCMODE_Msk       (0x3ul << TMR01_PWMSCTL_SYNCMODE_Pos)             /*!< TMR01_T::PWMSCTL: SYNCMODE Mask        */

#define TMR01_PWMSCTL_SYNCSRC_Pos        (8)                                               /*!< TMR01_T::PWMSCTL: SYNCSRC Position     */
#define TMR01_PWMSCTL_SYNCSRC_Msk        (0x1ul << TMR01_PWMSCTL_SYNCSRC_Pos)              /*!< TMR01_T::PWMSCTL: SYNCSRC Mask         */

#define TMR01_PWMSTATUS_CNTMAXF_Pos      (0)                                               /*!< TMR01_T::PWMSTATUS: CNTMAXF Position   */
#define TMR01_PWMSTATUS_CNTMAXF_Msk      (0x1ul << TMR01_PWMSTATUS_CNTMAXF_Pos)            /*!< TMR01_T::PWMSTATUS: CNTMAXF Mask       */

#define TMR01_PWMSTATUS_ADCTRGF_Pos      (16)                                              /*!< TMR01_T::PWMSTATUS: ADCTRGF Position   */
#define TMR01_PWMSTATUS_ADCTRGF_Msk      (0x1ul << TMR01_PWMSTATUS_ADCTRGF_Pos)            /*!< TMR01_T::PWMSTATUS: ADCTRGF Mask       */

#define TMR01_PWMPBUF_PBUF_Pos           (0)                                               /*!< TMR01_T::PWMPBUF: PBUF Position        */
#define TMR01_PWMPBUF_PBUF_Msk           (0xfffful << TMR01_PWMPBUF_PBUF_Pos)              /*!< TMR01_T::PWMPBUF: PBUF Mask            */

#define TMR01_PWMCMPBUF_CMPBUF_Pos       (0)                                               /*!< TMR01_T::PWMCMPBUF: CMPBUF Position    */
#define TMR01_PWMCMPBUF_CMPBUF_Msk       (0xfffful << TMR01_PWMCMPBUF_CMPBUF_Pos)          /*!< TMR01_T::PWMCMPBUF: CMPBUF Mask        */

#define TMR01_VERSION_MINOR_Pos          (0)                                               /*!< TMR01_T::VERSION: MINOR Position       */
#define TMR01_VERSION_MINOR_Msk          (0xfffful << TMR01_VERSION_MINOR_Pos)             /*!< TMR01_T::VERSION: MINOR Mask           */

#define TMR01_VERSION_SUB_Pos            (16)                                              /*!< TMR01_T::VERSION: SUB Position         */
#define TMR01_VERSION_SUB_Msk            (0xfful << TMR01_VERSION_SUB_Pos)                 /*!< TMR01_T::VERSION: SUB Mask             */

#define TMR01_VERSION_MAJOR_Pos          (24)                                              /*!< TMR01_T::VERSION: MAJOR Position       */
#define TMR01_VERSION_MAJOR_Msk          (0xfful << TMR01_VERSION_MAJOR_Pos)               /*!< TMR01_T::VERSION: MAJOR Mask           */

/**@}*/ /* TMR01_CONST */
/**@}*/ /* end of TMR01 register group */


/*---------------------- ?????????????????????????????????????????? -------------------------*/
/**
    @addtogroup TMR23 ??????????????????????????????????????????(TMR23)
    Memory Mapped Structure for TMR23 Controller
@{ */
 
typedef struct
{


/**
 * @var TMR23_T::CTL
 * Offset: 0x00  Timer2 Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[7:0]   |PSC       |Prescale Counter
 * |        |          |Timer input clock or event source is divided by (PSC+1) before it is fed to the timer up counter
 * |        |          |If this field is 0 (PSC = 0), then there is no scaling.
 * |        |          |Note: Update prescale counter value will reset internal 8-bit prescale counter and 24-bit up counter value.[WH1]
 * |        |          |[WH1]Tag92
 * |[19]    |INTRGEN   |Inter-timer Trigger Mode Enable Control
 * |        |          |Setting this bit will enable the inter-timer trigger capture function.
 * |        |          |The Timer0/2 will be in event counter mode and counting with external clock source or event
 * |        |          |Also, Timer1/3 will be in trigger-counting mode of capture function.
 * |        |          |0 = Inter-Timer Trigger Capture mode Disabled.
 * |        |          |1 = Inter-Timer Trigger Capture mode Enabled.
 * |        |          |Note: For Timer1/3, this bit is ignored and the read back value is always 0.[WH1]
 * |        |          |[WH1]Tag91
 * |[20]    |PERIOSEL  |Periodic Mode Behavior Selection Enable Bit
 * |        |          |0 = The behavior selection in periodic mode is Disabled.
 * |        |          |When user updates CMPDAT while timer is running in periodic mode,
 * |        |          |CNT will be reset to default value.
 * |        |          |1 = The behavior selection in periodic mode is Enabled.
 * |        |          |When user update CMPDAT while timer is running in periodic mode, the limitations as bellows list,
 * |        |          |If updated CMPDAT value > CNT, CMPDAT will be updated and CNT keep running continually.
 * |        |          |If updated CMPDAT value = CNT, timer time-out interrupt will be asserted immediately.
 * |        |          |If updated CMPDAT value < CNT, CNT will be reset to default value.[WH1]
 * |        |          |[WH1]Tag90
 * |[21]    |TGLPINSEL |Toggle-output Pin Select
 * |        |          |0 = Toggle mode output to Tx (Timer Event Counter Pin).
 * |        |          |1 = Toggle mode output to Tx_EXT (Timer External Capture Pin).[WH1]
 * |        |          |[WH1]Tag89
 * |[22]    |CAPSRC    |Capture Pin Source Selection
 * |        |          |0 = Capture Function source is from Tx_EXT (x= 0~3) pin.
 * |        |          |1 =RESERVED [AlvinLiao1].[WH2]
 * |        |          |[AlvinLiao1] NEED TO REVEISED
 * |        |          |[WH2]Tag88
 * |[23]    |WKEN      |Wake-up Function Enable Bit
 * |        |          |If this bit is set to 1, while timer interrupt flag TIF (TIMERx_INTSTS[0]) is 1 and INTEN (TIMERx_CTL[29]) is enabled, the timer interrupt signal will generate a wake-up trigger event to CPU.
 * |        |          |0 = Wake-up function Disabled if timer interrupt signal generated.
 * |        |          |1 = Wake-up function Enabled if timer interrupt signal generated.[WH1]
 * |        |          |[WH1]Tag87
 * |[24]    |EXTCNTEN  |Event Counter Mode Enable Bit
 * |        |          |This bit is for external counting pin function enabled.
 * |        |          |0 = Event counter mode Disabled.
 * |        |          |1 = Event counter mode Enabled.
 * |        |          |Note: When timer is used as an event counter, this bit should be set to 1 and select PCLK as timer clock source.[WH1]
 * |        |          |[WH1]Tag86
 * |[25]    |ACTSTS    |Timer Active Status Bit (Read Only)
 * |        |          |This bit indicates the 24-bit up counter status.
 * |        |          |0 = 24-bit up counter is not active.
 * |        |          |1 = 24-bit up counter is active.[WH1]
 * |        |          |[WH1]Tag85
 * |[26]    |RSTCNT    |Timer Counter Reset Bit (Not Release in TRM)
 * |        |          |Setting this bit will reset the 24-bit up counter value CNT (TIMERx_CNT[23:0]) and also force CNTEN (TIMERx_CTL[30]) to 0 if ACTSTS (TIMERx_CTL[25]) is 1.
 * |        |          |0 = No effect.
 * |        |          |1 = Reset internal 8-bit prescale counter, 24-bit up counter value and CNTEN bit.[WH1]
 * |        |          |[WH1]Tag84, not release in TRM
 * |[28:27] |OPMODE    |Timer Counting Mode Select
 * |        |          |00 = The Timer controller is operated in One-shot mode.
 * |        |          |01 = The Timer controller is operated in Periodic mode.
 * |        |          |10 = The Timer controller is operated in Toggle-output mode.
 * |        |          |11 = The Timer controller is operated in Continuous Counting mode.[WH1]
 * |        |          |[WH1]Tag83
 * |[29]    |INTEN     |Timer Interrupt Enable Bit
 * |        |          |0 = Timer time-out interrupt Disabled.
 * |        |          |1 = Timer time-out interrupt Enabled.
 * |        |          |Note: If this bit is enabled, when the timer time-out interrupt flag TIF is set to 1, the timer interrupt signal is generated and inform to CPU.[WH1]
 * |        |          |[WH1]Tag82
 * |[30]    |CNTEN     |Timer Counting Enable Bit
 * |        |          |0 = Stops/Suspends counting.
 * |        |          |1 = Starts counting.
 * |        |          |Note1: In stop status, and then set CNTEN to 1 will enable the 24-bit up counter to keep counting from the last stop counting value.
 * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode OPMODE (TIMER_CTL[28:27] = 00) when the timer time-out interrupt flag TIF (TIMERx_INTSTS[0]) is generated.
 * |        |          |Note3: Set enable/disable this bit needs 2 * TMR_CLK period to become active, user can read ACTSTS (TIMERx_CTL[25]) to check enabe/disable command is completed or not.[WH1]
 * |        |          |[WH1]Tag81
 * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Control (Write Protect)
 * |        |          |0 = ICE debug mode acknowledgement effects TIMER counting.
 * |        |          |TIMER counter will be held while CPU is held by ICE.
 * |        |          |1 = ICE debug mode acknowledgement Disabled.
 * |        |          |TIMER counter will keep going no matter CPU is held by ICE or not.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag80
 * @var TMR23_T::CMP
 * Offset: 0x04  Timer2 Comparator Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[23:0]  |CMPDAT    |Timer Comparator Value
 * |        |          |CMPDAT is a 24-bit compared value register
 * |        |          |When the internal 24-bit up counter value is equal to CMPDAT value, the TIF (TIMERx_INTSTS[0] Timer Interrupt Flag) will set to 1.
 * |        |          |Time-out period = (Period of timer clock input) * (8-bit PSC + 1) * (24-bit CMPDAT).
 * |        |          |Note1: Never write 0x0 or 0x1 in CMPDAT field, or the core will run into unknown state.
 * |        |          |Note2: When timer is operating at continuous counting mode, the 24-bit up counter will keep counting continuously even if user writes a new value into CMPDAT field
 * |        |          |But if timer is operating at other modes, the 24-bit up counter will restart counting from 0 and using newest CMPDAT value to be the timer compared value while user writes a new value into CMPDAT field.[WH1]
 * |        |          |[WH1]Tag93
 * @var TMR23_T::INTSTS
 * Offset: 0x08  Timer2 Interrupt Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |TIF       |Timer Interrupt Flag
 * |        |          |This bit indicates the interrupt flag status of Timer while 24-bit timer up counter CNT (TIMERx_CNT[23:0]) value reaches to CMPDAT (TIMERx_CMP[23:0]) value.
 * |        |          |0 = No effect.
 * |        |          |1 = CNT value matches the CMPDAT value.
 * |        |          |Note: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag95
 * |[1]     |TWKF      |Timer Wake-up Flag
 * |        |          |This bit indicates the interrupt wake-up flag status of timer.
 * |        |          |0 = Timer does not cause CPU wake-up.
 * |        |          |1 = CPU wake-up from Idle or Power-down mode if timer time-out interrupt signal generated.
 * |        |          |Note: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag94
 * @var TMR23_T::CNT
 * Offset: 0x0C  Timer2 Data Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[23:0]  |CNT       |Timer Data Register
 * |        |          |Read operation.
 * |        |          |Read this register to get CNT value. For example:
 * |        |          |If EXTCNTEN (TIMERx_CTL[24] ) is 0, user can read CNT value for getting current 24-bit counter value.
 * |        |          |If EXTCNTEN (TIMERx_CTL[24] ) is 1, user can read CNT value for getting current 24-bit event input counter value.
 * |        |          |Write operation.
 * |        |          |Writing any value to this register will reset current CNT value to 0 and reload internal 8-bit prescale counter.[WH1]
 * |        |          |[WH1]Tag97
 * |[31]    |RSTACT    |Timer Data Register Reset Active (Read Only)
 * |        |          |This bit indicates if the counter reset operation active.
 * |        |          |When user writes this CNT register, timer starts to reset its internal 24-bit timer up-counter to 0 and reload 8-bit pre-scale counter
 * |        |          |At the same time, timer set this flag to 1 to indicate the counter reset operation is in progress
 * |        |          |Once the counter reset operation done, timer clear this bit to 0 automatically.
 * |        |          |0 = Reset operation is done.
 * |        |          |1 = Reset operation triggered by writing TIMERx_CNT is in progress.
 * |        |          |Note: This bit is read only.[WH1]
 * |        |          |[WH1]Tag96
 * @var TMR23_T::CAP
 * Offset: 0x10  Timer2 Capture Data Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[23:0]  |CAPDAT    |Timer Capture Data Register (Read Only)
 * |        |          |When CAPEN (TIMERx_EXTCTL[3]) bit is set, CAPFUNCS (TIMERx_EXTCTL[4]) bit is 0, and a transition on Tx_EXT pin matched the CAPEDGE (TIMERx_EXTCTL[14:12]) setting, CAPIF (TIMERx_EINTSTS[0]) will set to 1 and the current timer counter value CNT (TIMERx_CNT[23:0]) will be auto-loaded into this CAPDAT field.[WH1]
 * |        |          |[WH1]Tag98
 * @var TMR23_T::EXTCTL
 * Offset: 0x14  Timer2 External Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CNTPHASE  |Timer External Count Phase
 * |        |          |This bit indicates the detection phase of external counting pin Tx (x= 0~3).
 * |        |          |0 = A falling edge of external counting pin will be counted.
 * |        |          |1 = A rising edge of external counting pin will be counted.[WH1]
 * |        |          |[WH1]Tag107
 * |[2:1]   |SCAPEDGE  |SBZ
 * |[3]     |CAPEN     |Timer External Capture Pin Enable Bit
 * |        |          |This bit enables the Tx_EXT capture pin input function.
 * |        |          |0 =Tx_EXT (x= 0~3) pin Disabled.
 * |        |          |1 =Tx_EXT (x= 0~3) pin Enabled.[WH1]
 * |        |          |[WH1]Tag106
 * |[4]     |CAPFUNCS  |Capture Function Selection
 * |        |          |0 = External Capture Mode Enabled.
 * |        |          |1 = External Reset Mode Enabled.
 * |        |          |Note1: When CAPFUNCS is 0, transition on Tx_EXT (x= 0~3) pin is using to save current 24-bit timer counter value (CNT value) to CAPDAT field.
 * |        |          |Note2: When CAPFUNCS is 1, transition on Tx_EXT (x= 0~3) pin is using to save current 24-bit timer counter value (CNT value) to CAPDAT field then CNT value will be reset immediately.[WH1]
 * |        |          |[WH1]Tag105
 * |[5]     |CAPIEN    |Timer External Capture Interrupt Enable Bit
 * |        |          |0 = Tx_EXT (x= 0~3) pin detection Interrupt Disabled.
 * |        |          |1 = Tx_EXT (x= 0~3) pin detection Interrupt Enabled.
 * |        |          |Note: CAPIEN is used to enable timer external interrupt
 * |        |          |If CAPIEN enabled, timer will rise an interrupt when CAPIF (TIMERx_EINTSTS[0]) is 1.
 * |        |          |For example, while CAPIEN = 1, CAPEN = 1, and CAPEDGE = 00, a 1 to 0 transition on the Tx_EXT pin will cause the CAPIF to be set then the interrupt signal is generated and sent to NVIC to inform CPU.[WH1]
 * |        |          |[WH1]Tag104
 * |[6]     |CAPDBEN   |Timer External Capture Pin De-bounce Enable Bit
 * |        |          |0 = Tx_EXT (x= 0~3) pin de-bounce Disabled.
 * |        |          |1 = Tx_EXT (x= 0~3) pin de-bounce Enabled.
 * |        |          |Note: If this bit is enabled, the edge detection of Tx_EXT pin output is detected with de-bounce circuit.[WH1]
 * |        |          |[WH1]Tag103
 * |[7]     |CNTDBEN   |Timer Counter Pin De-bounce Enable Bit
 * |        |          |0 = Tx (x= 0~3) pin de-bounce Disabled.
 * |        |          |1 = Tx (x= 0~3) pin de-bounce Enabled.
 * |        |          |Note: If this bit is enabled, the edge detection of Tx pin is detected with de-bounce circuit.[WH1]
 * |        |          |[WH1]Tag102
 * |[14:12] |CAPEDGE   |Timer External Capture Pin Edge Detect
 * |        |          |When first capture event is generated, the CNT (TIMERx_CNT[23:0]) will be reset to 0 and first CAPDAT (TIMERx_CAP[23:0]) should be to 0.
 * |        |          |000 = Capture event occurred when detect falling edge transfer on Tx_EXT (x= 0~3) pin.
 * |        |          |001 = Capture event occurred when detect rising edge transfer on Tx_EXT (x= 0~3) pin.
 * |        |          |010 = Capture event occurred when detect both falling and rising edge transfer on Tx_EXT (x= 0~3) pin, and first capture event occurred at falling edge transfer.
 * |        |          |011 = Capture event occurred when detect both rising and falling edge transfer on Tx_EXT (x= 0~3) pin, and first capture event occurred at rising edge transfer.
 * |        |          |110 = First capture event occurred at falling edge, follows capture events are at rising edge transfer on Tx_EXT (x= 0~3) pin.
 * |        |          |111 = First capture event occurred at rising edge, follows capture events are at falling edge transfer on Tx_EXT (x= 0~3) pin.
 * |        |          |100, 101 = Reserved.[WH1]
 * |        |          |[WH1]Tag100
 * |[16]    |ECNTSSEL  |Event Counter Source Selection to Trigger Event Counter Function
 * |        |          |0 = Event Counter input source is from Tx (x= 0~3) pin.
 * |        |          |1 = Reserved Event Counter input source is from USB internal SOF output signal.[WH1]
 * |        |          |[WH1]Tag99
 * @var TMR23_T::EINTSTS
 * Offset: 0x18  Timer2 External Interrupt Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CAPIF     |Timer External Capture Interrupt Flag
 * |        |          |This bit indicates the timer external capture interrupt flag status.
 * |        |          |0 = Tx_EXT (x= 0~3) pin interrupt did not occur.
 * |        |          |1 = Tx_EXT (x= 0~3) pin interrupt occurred.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2: When CAPEN (TIMERx_EXTCTL[3]) bit is set, CAPFUNCS (TIMERx_EXTCTL[4]) bit is 0, and a transition on Tx_EXT (x= 0~3) pin matched the CAPEDGE (TIMERx_EXTCTL[2:1]) setting, this bit will set to 1 by hardware.
 * |        |          |Note3: There is a new incoming capture event detected before CPU clearing the CAPIF status
 * |        |          |If the above condition occurred, the Timer will keep register TIMERx_CAP unchanged and drop the new capture value.[WH1]
 * |        |          |[WH1]Tag108
 * @var TMR23_T::TRGCTL
 * Offset: 0x1C  Timer2 Trigger Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |TRGSSEL   |Trigger Source Select Bit
 * |        |          |This bit is used to select internal trigger source is form timer time-out interrupt signal or capture interrupt signal.
 * |        |          |0 = Time-out interrupt signal is used to internal trigger PWM, PDMA, and ADC.
 * |        |          |1 = Capture interrupt signal is used to internal trigger PWM, PDMA, and ADC.[WH1]
 * |        |          |[WH1]Tag113
 * |[1]     |TRGPWM    |Trigger PWM Enable Bit
 * |        |          |If this bit is set to 1, each timer time-out event or capture event can be as PWM counter clock source.
 * |        |          |0 = Timer interrupt trigger PWM Disabled.
 * |        |          |1 = Timer interrupt trigger PWM Enabled.
 * |        |          |Note: If TRGSSEL (TIMERx_TRGCTL[0]) = 0, time-out interrupt signal as PWM counter clock source.
 * |        |          |If TRGSSEL (TIMERx_TRGCTL[0]) = 1, capture interrupt signal as PWM counter clock source.[WH1]
 * |        |          |[WH1]Tag112
 * |[2]     |TRGADC    |Trigger ADC Enable Bit
 * |        |          |If this bit is set to 1, each timer time-out event or capture event can be triggered ADC conversion.
 * |        |          |0 = Timer interrupt trigger ADC Disabled.
 * |        |          |1 = Timer interrupt trigger ADC Enabled.
 * |        |          |Note: If TRGSSEL (TIMERx_TRGCTL[0]) = 0, time-out interrupt signal will trigger ADC conversion.
 * |        |          |If TRGSSEL (TIMERx_TRGCTL[0]) = 1, capture interrupt signal will trigger ADC conversion.[WH1]
 * |        |          |[WH1]Tag111
 * |[4]     |TRGPDMA   |Trigger PDMA Enable Bit
 * |        |          |If this bit is set to 1, each timer time-out event or capture event can be triggered PDMA transfer.
 * |        |          |0 = Timer interrupt trigger PDMA Disabled.
 * |        |          |1 = Timer interrupt trigger PDMA Enabled.
 * |        |          |Note: If TRGSSEL (TIMERx_TRGCTL[0]) = 0, time-out interrupt signal will trigger PDMA transfer.
 * |        |          |If TRGSSEL (TIMERx_TRGCTL[0]) = 1, capture interrupt signal will trigger PDMA transfer.[WH1]
 * |        |          |[WH1]Tag109
 * @var TMR23_T::ALTCTL
 * Offset: 0x20  Timer2 Alternative Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |FUNCSEL   |Function Selection
 * |        |          |0 = Timer controller is used as timer function.
 * |        |          |1 = Timer controller is used as PWM function.
 * |        |          |Note: When timer is used as PWM, the clock source of time controller will be forced to PCLKx automatically.[WH1]
 * |        |          |[WH1]Tag114
 * @var TMR23_T::PWMCTL
 * Offset: 0x40  Timer2 PWM Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CNTEN     |PWM Counter Enable Bit
 * |        |          |0 = PWM counter and clock prescale Stop Running.
 * |        |          |1 = PWM counter and clock prescale Start Running.[WH1]
 * |        |          |[WH1]Tag122
 * |[2:1]   |CNTTYPE   |PWM Counter Behavior Type
 * |        |          |00 = Up count type.
 * |        |          |01 = Down count type.
 * |        |          |10 = Up-down count type.
 * |        |          |11 = Reserved.[WH1]
 * |        |          |[WH1]Tag121
 * |[3]     |CNTMODE   |PWM Counter Mode
 * |        |          |0 = Auto-reload mode.
 * |        |          |1 = One-shot mode.[WH1]
 * |        |          |[WH1]Tag120
 * |[8]     |CTRLD     |Center Re-load
 * |        |          |In up-down count type, PERIOD will load to PBUF when current PWM period is completed always and CMP will load to CMPBUF at the center point of current period.[WH1]
 * |        |          |[WH1]Tag119
 * |[9]     |IMMLDEN   |Immediately Load Enable Bit
 * |        |          |0 = PERIOD will load to PBUF when current PWM period is completed no matter CTRLD is enabled/disabled
 * |        |          |If CTRLD is disabled, CMP will load to CMPBUF when current PWM period is completed; if CTRLD is enabled in up-down count type, CMP will load to CMPBUF at the center point of current period.
 * |        |          |1 = PERIOD/CMP will load to PBUF/CMPBUF immediately when user update PERIOD/CMP.
 * |        |          |Note: If IMMLDEN is enabled, CTRLD will be invalid.[WH1]
 * |        |          |[WH1]Tag118
 * |[16]    |OUTMODE   |PWM Output Mode
 * |        |          |This bit controls the output mode of corresponding PWM channel.
 * |        |          |0 = PWM independent mode.
 * |        |          |1 = PWM complementary mode.[WH1]
 * |        |          |[WH1]Tag117
 * |[30]    |DBGHALT   |ICE Debug Mode Counter Halt (Write Protect)
 * |        |          |If debug mode counter halt is enabled, PWM counter will keep current value until exit ICE debug mode.
 * |        |          |0 = ICE debug mode counter halt disable.
 * |        |          |1 = ICE debug mode counter halt enable.
 * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag116
 * |[31]    |DBGTRIOFF |ICE Debug Mode Acknowledge Disable Bit (Write Protect)
 * |        |          |0 = ICE debug mode acknowledgement effects PWM output.
 * |        |          |PWM output pin will be forced as tri-state while ICE debug mode acknowledged.
 * |        |          |1 = ICE debug mode acknowledgement disabled.
 * |        |          |PWM output pin will keep output no matter ICE debug mode acknowledged or not.
 * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag115
 * @var TMR23_T::PWMCLKSRC
 * Offset: 0x44  Timer2 PWM Counter Clock Source Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[2:0]   |CLKSRC    |PWM Counter Clock Source Select
 * |        |          |The PWM counter clock source can be selected from TMRx_CLK or internal timer time-out or capture event.
 * |        |          |000 = TMRx_CLK.
 * |        |          |001 = Internal TIMER0 time-out or capture event.
 * |        |          |010 = Internal TIMER1 time-out or capture event.
 * |        |          |011 = Internal TIMER2 time-out or capture event.
 * |        |          |100 = Internal TIMER3 time-out or capture event.
 * |        |          |Others = Reserved.
 * |        |          |Note: If TIMER0 PWM function is enabled, the PWM counter clock source can be selected from TMR0_CLK, TIMER1 interrupt events, TIMER2 interrupt events, or TIMER3 interrupt events.[WH1]
 * |        |          |[WH1]Tag123
 * @var TMR23_T::PWMCLKPSC
 * Offset: 0x48  Timer2 PWM Counter Clock Pre-scale Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-scale
 * |        |          |The active clock of PWM counter is decided by counter clock prescale and divided by (CLKPSC + 1)
 * |        |          |If CLKPSC is 0, then there is no scaling in PWM counter clock source.[WH1]
 * |        |          |[WH1]Tag124
 * @var TMR23_T::PWMCNTCLR
 * Offset: 0x4C  Timer2 PWM Clear Counter Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CNTCLR    |Clear PWM Counter Control Bit
 * |        |          |It is automatically cleared by hardware.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear 16-bit PWM counter to 0x10000 in up and up-down count type and reset counter value to PERIOD in down count type.[WH1]
 * |        |          |[WH1]Tag125
 * @var TMR23_T::PWMPERIOD
 * Offset: 0x50  Timer2 PWM Period Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PERIOD    |PWM Period Register
 * |        |          |In up count type: PWM counter counts from 0 to PERIOD, and restarts from 0.
 * |        |          |In down count type: PWM counter counts from PERIOD to 0, and restarts from PERIOD.
 * |        |          |In up-down count type: PWM counter counts from 0 to PERIOD, then decrements to 0 and repeats again.
 * |        |          |In up and down count type:
 * |        |          |PWM period time = (PERIOD + 1) * (CLKPSC + 1) * TMRx_PWMCLK.
 * |        |          |In up-down count type:
 * |        |          |PWM period time = 2 * PERIOD * (CLKPSC+ 1) * TMRx_PWMCLK.
 * |        |          |Note: User should take care DIRF (TIMERx_PWMCNT[16]) bit in up/down/up-down count type to monitor current counter direction in each count type.[WH1]
 * |        |          |[WH1]Tag126
 * @var TMR23_T::PWMCMPDAT
 * Offset: 0x54  Timer2 PWM Comparator Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CMP       |PWM Comparator Register
 * |        |          |PWM CMP is used to compare with PWM CNT to generate PWM output waveform, interrupt events and trigger ADC to start convert.[WH1]
 * |        |          |[WH1]Tag127
 * @var TMR23_T::PWMDTCTL
 * Offset: 0x58  Timer2 PWM Dead-Time Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[11:0]  |DTCNT     |Dead-time Counter (Write Protect)
 * |        |          |The dead-time can be calculated from the following two formulas:
 * |        |          |Dead-time = (DTCNT[11:0] + 1) * TMRx_PWMCLK, if DTCKSEL is 0.
 * |        |          |Dead-time = (DTCNT[11:0] + 1) * TMRx_PWMCLK * (CLKPSC + 1), if DTCKSEL is 1.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag130
 * |[16]    |DTEN      |Enable Dead-time Insertion for PWMx_CH0 and PWMx_CH1 (Write Protect)
 * |        |          |Dead-time insertion function is only active when PWM complementary mode is enabled
 * |        |          |If dead- time insertion is inactive, the outputs of PWMx_CH0 and PWMx_CH1 are complementary without any delay.
 * |        |          |0 = Dead-time insertion Disabled on the pin pair.
 * |        |          |1 = Dead-time insertion Enabled on the pin pair.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag129
 * |[24]    |DTCKSEL   |Dead-time Clock Select (Write Protect)
 * |        |          |0 = Dead-time clock source from TMRx_PWMCLK without counter clock prescale.
 * |        |          |1 = Dead-time clock source from TMRx_PWMCLK with counter clock prescale.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag128
 * @var TMR23_T::PWMCNT
 * Offset: 0x5C  Timer2 PWM Counter Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CNT       |PWM Counter Value Register (Read Only)
 * |        |          |User can monitor CNT to know the current counter value in 16-bit period counter.[WH1]
 * |        |          |[WH1]Tag132
 * |[16]    |DIRF      |PWM Counter Direction Indicator Flag (Read Only)
 * |        |          |0 = Counter is active in down count.
 * |        |          |1 = Counter is active up count.[WH1]
 * |        |          |[WH1]Tag131
 * @var TMR23_T::PWMMSKEN
 * Offset: 0x60  Timer2 PWM Output Mask Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |MSKEN0    |PWMx_CH0 Output Mask Enable Bit
 * |        |          |The PWMx_CH0 output signal will be masked when this bit is enabled
 * |        |          |The PWMx_CH0 will output MSKDAT0 (TIMER_PWMMSK[0]) data.
 * |        |          |0 = PWMx_CH0 output signal is non-masked.
 * |        |          |1 = PWMx_CH0 output signal is masked and output MSKDAT0 data.[WH1]
 * |        |          |[WH1]Tag133
 * |[1]     |MSKEN1    |PWMx_CH1 Output Mask Enable Bit
 * |        |          |The PWMx_CH1 output signal will be masked when this bit is enabled
 * |        |          |The PWMx_CH1 will output MSKDAT1 (TIMER_PWMMSK[1]) data.
 * |        |          |0 = PWMx_CH1 output signal is non-masked.
 * |        |          |1 = PWMx_CH1 output signal is masked and output MSKDAT1 data.
 * @var TMR23_T::PWMMSK
 * Offset: 0x64  Timer2 PWM Output Mask Data Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |MSKDAT0   |PWMx_CH0 Output Mask Data Control Bit
 * |        |          |This bit is used to control the output state of PWMx_CH0 pin when PWMx_CH0 output mask function is enabled (MSKEN0 = 1).
 * |        |          |0 = Output logic Low to PWMx_CH0.
 * |        |          |1 = Output logic High to PWMx_CH0.[WH1]
 * |        |          |[WH1]Tag134
 * |[1]     |MSKDAT1   |PWMx_CH1 Output Mask Data Control Bit
 * |        |          |This bit is used to control the output state of PWMx_CH1 pin when PWMx_CH1 output mask function is enabled (MSKEN1 = 1).
 * |        |          |0 = Output logic Low to PWMx_CH1.
 * |        |          |1 = Output logic High to PWMx_CH1.
 * @var TMR23_T::PWMBNF
 * Offset: 0x68  Timer2 PWM Brake Pin Noise Filter Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BRKNFEN   |Brake Pin Noise Filter Enable Bit
 * |        |          |0 = Pin noise filter detect of TM_BRAKEx Disabled.
 * |        |          |1 = Pin noise filter detect of TM_BRAKEx Enabled.[WH1]
 * |        |          |[WH1]Tag139
 * |[3:1]   |BRKNFSEL  |Brake Pin Noise Filter Clock Selection
 * |        |          |000 = Noise filter clock is PCLKx.
 * |        |          |001 = Noise filter clock is PCLKx/2.
 * |        |          |010 = Noise filter clock is PCLKx/4.
 * |        |          |011 = Noise filter clock is PCLKx/8.
 * |        |          |100 = Noise filter clock is PCLKx/16.
 * |        |          |101 = Noise filter clock is PCLKx/32.
 * |        |          |110 = Noise filter clock is PCLKx/64.
 * |        |          |111 = Noise filter clock is PCLKx/128.[WH1]
 * |        |          |[WH1]Tag138
 * |[6:4]   |BRKFCNT   |Brake Pin Noise Filter Count
 * |        |          |The fields is used to control the active noise filter sample time.
 * |        |          |Once noise filter sample time = (Period time of BRKDBCS) * BRKFCNT.[WH1]
 * |        |          |[WH1]Tag137
 * |[7]     |BRKPINV   |Brake Pin Detection Control Bit
 * |        |          |0 = Brake pin event will be detected if TM_BRAKEx pin status transfer from low to high in edge-detect, or pin status is high in level-detect.
 * |        |          |1 = Brake pin event will be detected if TM_BRAKEx pin status transfer from high to low in edge-detect, or pin status is low in level-detect .[WH1]
 * |        |          |[WH1]Tag136
 * |[17:16] |BKPINSRC  |Brake Pin Source Select
 * |        |          |00 = Brake pin source comes from TM_BRAKE0.
 * |        |          |01 = Brake pin source comes from TM_BRAKE1.
 * |        |          |10 = Brake pin source comes from TM_BRAKE2.
 * |        |          |11 = Brake pin source comes from TM_BRAKE3.[WH1]
 * |        |          |[WH1]Tag135
 * @var TMR23_T::PWMFAILBRK
 * Offset: 0x6C  Timer2 PWM System Fail Brake Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CSSBRKEN  |Clock Security System Detection Trigger PWM Brake Function Enable Bit
 * |        |          |0 = Brake Function triggered by clock fail detection Disabled.
 * |        |          |1 = Brake Function triggered by clock fail detection Enabled.[WH1]
 * |        |          |[WH1]Tag143
 * |[1]     |BODBRKEN  |Brown-out Detection Trigger PWM Brake Function Enable Bit
 * |        |          |0 = Brake Function triggered by BOD event Disabled.
 * |        |          |1 = Brake Function triggered by BOD event Enabled.[WH1]
 * |        |          |[WH1]Tag142
 * |[2]     |RAMBRKEN  |SRAM Parity Error Detection Trigger PWM Brake Function Enable Bit
 * |        |          |0 = Brake Function triggered by SRAM parity error detection Disabled.
 * |        |          |1 = Brake Function triggered by SRAM parity error detection Enabled.[WH1]
 * |        |          |[WH1]Tag141
 * |[3]     |CORBRKEN  |Core Lockup Detection Trigger PWM Brake Function Enable Bit
 * |        |          |0 = Brake Function triggered by core lockup event Disabled.
 * |        |          |1 = Brake Function triggered by core lockup event Enabled.[WH1]
 * |        |          |[WH1]Tag140
 * @var TMR23_T::PWMBRKCTL
 * Offset: 0x70  Timer2 PWM Brake Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[4]     |BRKPEEN   |Enable TM_BRAKEx Pin As Edge-detect Brake Source (Write Protect)
 * |        |          |0 = TM_BRAKEx pin event as edge-detect brake source Disabled.
 * |        |          |1 = TM_BRAKEx pin event as edge-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag151
 * |[7]     |SYSEBEN   |Enable System Fail As Edge-detect Brake Source (Write Protect)
 * |        |          |0 = System fail condition as edge-detect brake source Disabled.
 * |        |          |1 = System fail condition as edge-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag150
 * |[12]    |BRKPLEN   |Enable TM_BRAKEx Pin As Level-detect Brake Source (Write Protect)
 * |        |          |0 = TM_BRAKEx pin event as level-detect brake source Disabled.
 * |        |          |1 = TM_BRAKEx pin event as level-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag147
 * |[15]    |SYSLBEN   |Enable System Fail As Level-detect Brake Source (Write Protect)
 * |        |          |0 = System fail condition as level-detect brake source Disabled.
 * |        |          |1 = System fail condition as level-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag146
 * |[17:16] |BRKAEVEN  |PWM Brake Action Select for PWMx_CH0 (Write Protect)
 * |        |          |00 = TIMERx_PWM brake event will not affect PWMx_CH0 output.
 * |        |          |01 = PWMx_CH0 output tri-state when TIMERx_PWM brake event happened.
 * |        |          |10 = PWMx_CH0 output low level when TIMERx_PWM brake event happened.
 * |        |          |11 = PWMx_CH0 output high level when TIMERx_PWM brake event happened.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag145
 * |[19:18] |BRKAODD   |PWM Brake Action Select for PWMx_CH1 (Write Protect)
 * |        |          |00 = TIMERx_PWM brake event will not affect PWMx_CH1 output.
 * |        |          |01 = PWMx_CH1 output tri-state when TIMERx_PWM brake event happened.
 * |        |          |10 = PWMx_CH1 output low level when TIMERx_PWM brake event happened.
 * |        |          |11 = PWMx_CH1 output high level when TIMERx_PWM brake event happened.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag144
 * @var TMR23_T::PWMPOLCTL
 * Offset: 0x74  Timer2 PWM Pin Output Polar Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PINV0     |PWMx_CH0 Output Pin Polar Control Bit
 * |        |          |The bit is used to control polarity state of PWMx_CH0 output pin.
 * |        |          |0 = PWMx_CH0 output pin polar inverse Disabled.
 * |        |          |1 = PWMx_CH0 output pin polar inverse Enabled.[WH1]
 * |        |          |[WH1]Tag154
 * |[1]     |PINV1     |PWMx_CH1 Output Pin Polar Control Bit
 * |        |          |The bit is used to control polarity state of PWMx_CH1 output pin.
 * |        |          |0 = PWMx_CH1 output pin polar inverse Disabled.
 * |        |          |1 = PWMx_CH1 output pin polar inverse Enabled.
 * @var TMR23_T::PWMPOEN
 * Offset: 0x78  Timer2 PWM Pin Output Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |POEN0     |PWMx_CH0 Output Pin Enable Bit
 * |        |          |0 = PWMx_CH0 pin at tri-state mode.
 * |        |          |1 = PWMx_CH0 pin in output mode.[WH1]
 * |        |          |[WH1]Tag155
 * |[1]     |POEN1     |PWMx_CH1 Output Pin Enable Bit
 * |        |          |0 = PWMx_CH1 pin at tri-state mode.
 * |        |          |1 = PWMx_CH1 pin in output mode.
 * @var TMR23_T::PWMSWBRK
 * Offset: 0x7C  Timer2 PWM Software Trigger Brake Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BRKETRG   |Software Trigger Edge-detect Brake Source (Write Only) (Write Protect)
 * |        |          |Write 1 to this bit will trigger PWM edge-detect brake source, then BRKEIF0 and BRKEIF1 will set to 1 automatically in TIMERx_PWMINTSTS1 register.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag156
 * |[8]     |BRKLTRG   |Software Trigger Level-detect Brake Source (Write Only) (Write Protect)
 * |        |          |Write 1 to this bit will trigger PWM level-detect brake source, then BRKLIF0 and BRKLIF1 will set to 1 automatically in TIMERx_PWMINTSTS1 register.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * @var TMR23_T::PWMINTEN0
 * Offset: 0x80  Timer2 PWM Interrupt Enable Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ZIEN      |PWM Zero Point Interrupt Enable Bit
 * |        |          |0 = Zero point interrupt Disabled.
 * |        |          |1 = Zero point interrupt Enabled.[WH1]
 * |        |          |[WH1]Tag160
 * |[1]     |PIEN      |PWM Period Point Interrupt Enable Bit
 * |        |          |0 = Period point interrupt Disabled.
 * |        |          |1 = Period point interrupt Enabled.
 * |        |          |Note: When in up-down count type, period point means the center point of current PWM period.[WH1]
 * |        |          |[WH1]Tag159
 * |[2]     |CMPUIEN   |PWM Compare Up Count Interrupt Enable Bit
 * |        |          |0 = Compare up count interrupt Disabled.
 * |        |          |1 = Compare up count interrupt Enabled.[WH1]
 * |        |          |[WH1]Tag158
 * |[3]     |CMPDIEN   |PWM Compare Down Count Interrupt Enable Bit
 * |        |          |0 = Compare down count interrupt Disabled.
 * |        |          |1 = Compare down count interrupt Enabled.[WH1]
 * |        |          |[WH1]Tag157
 * @var TMR23_T::PWMINTEN1
 * Offset: 0x84  Timer2 PWM Interrupt Enable Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BRKEIEN   |PWM Edge-detect Brake Interrupt Enable (Write Protect)
 * |        |          |0 = PWM edge-detect brake interrupt Disabled.
 * |        |          |1 = PWM edge-detect brake interrupt Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag162
 * |[8]     |BRKLIEN   |PWM Level-detect Brake Interrupt Enable (Write Protect)
 * |        |          |0 = PWM level-detect brake interrupt Disabled.
 * |        |          |1 = PWM level-detect brake interrupt Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag161
 * @var TMR23_T::PWMINTSTS0
 * Offset: 0x88  Timer2 PWM Interrupt Status Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ZIF       |PWM Zero Point Interrupt Flag
 * |        |          |This bit is set by hardware when TIMERx_PWM counter reaches zero.
 * |        |          |Note: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag166
 * |[1]     |PIF       |PWM Period Point Interrupt Flag
 * |        |          |This bit is set by hardware when TIMERx_PWM counter reaches PERIOD.
 * |        |          |Note1: When in up-down count type, PIF flag means the center point flag of current PWM period.
 * |        |          |Note2: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag165
 * |[2]     |CMPUIF    |PWM Compare Up Count Interrupt Flag
 * |        |          |This bit is set by hardware when TIMERx_PWM counter in up count direction and reaches CMP.
 * |        |          |Note1: If CMP equal to PERIOD, there is no CMPUIF flag in up count type and up-down count type.
 * |        |          |Note2: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag164
 * |[3]     |CMPDIF    |PWM Compare Down Count Interrupt Flag
 * |        |          |This bit is set by hardware when TIMERx_PWM counter in down count direction and reaches CMP.
 * |        |          |Note1: If CMP equal to PERIOD, there is no CMPDIF flag in down count type.
 * |        |          |Note2: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag163
 * @var TMR23_T::PWMINTSTS1
 * Offset: 0x8C  Timer2 PWM Interrupt Status Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BRKEIF0   |Edge-detect Brake Interrupt Flag on PWMx_CH0 (Write Protect)
 * |        |          |0 = PWMx_CH0 edge-detect brake event do not happened.
 * |        |          |1 = PWMx_CH0 edge-detect brake event happened.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag170
 * |[1]     |BRKEIF1   |Edge-detect Brake Interrupt Flag PWMx_CH1 (Write Protect)
 * |        |          |0 = PWMx_CH1 edge-detect brake event do not happened.
 * |        |          |1 = PWMx_CH1 edge-detect brake event happened.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2: This register is write protected. Refer to SYS_REGLCTL register.
 * |[8]     |BRKLIF0   |Level-detect Brake Interrupt Flag on PWMx_CH0 (Write Protect)
 * |        |          |0 = PWMx_CH0 level-detect brake event do not happened.
 * |        |          |1 = PWMx_CH0 level-detect brake event happened.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag169
 * |[9]     |BRKLIF1   |Level-detect Brake Interrupt Flag on PWMx_CH1 (Write Protect)
 * |        |          |0 = PWMx_CH1 level-detect brake event do not happened.
 * |        |          |1 = PWMx_CH1 level-detect brake event happened.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2: This register is write protected. Refer to SYS_REGLCTL register.
 * |[16]    |BRKESTS0  |Edge -detect Brake Status of PWMx_CH0 (Read Only)
 * |        |          |0 = PWMx_CH0 edge-detect brake state is released.
 * |        |          |1 = PWMx_CH0 at edge-detect brake state.
 * |        |          |Note: User can set BRKEIF0 1 to clear BRKEIF0 flag and PWMx_CH0 will release brake state when current PWM period finished and resume PWMx_CH0 output waveform start from next full PWM period.[WH1]
 * |        |          |[WH1]Tag168
 * |[17]    |BRKESTS1  |Edge-detect Brake Status of PWMx_CH1 (Read Only)
 * |        |          |0 = PWMx_CH1 edge-detect brake state is released.
 * |        |          |1 = PWMx_CH1 at edge-detect brake state.
 * |        |          |Note: User can set BRKEIF1 1 to clear BRKEIF1 flag and PWMx_CH1 will release brake state when current PWM period finished and resume PWMx_CH1 output waveform start from next full PWM period.
 * |[24]    |BRKLSTS0  |Level-detect Brake Status of PWMx_CH0 (Read Only)
 * |        |          |0 = PWMx_CH0 level-detect brake state is released.
 * |        |          |1 = PWMx_CH0 at level-detect brake state.
 * |        |          |Note: If TIMERx_PWM level-detect brake source has released, both PWMx_CH0 and PWMx_CH1 will release brake state when current PWM period finished and resume PWMx_CH0 and PWMx_CH1 output waveform start from next full PWM period.[WH1]
 * |        |          |[WH1]Tag167
 * |[25]    |BRKLSTS1  |Level-detect Brake Status of PWMx_CH1 (Read Only)
 * |        |          |0 = PWMx_CH1 level-detect brake state is released.
 * |        |          |1 = PWMx_CH1 at level-detect brake state.
 * |        |          |Note: If TIMERx_PWM level-detect brake source has released, both PWMx_CH0 and PWMx_CH1 will release brake state when current PWM period finished and resume PWMx_CH0 and PWMx_CH1 output waveform start from next full PWM period.
 * @var TMR23_T::PWMADCTS
 * Offset: 0x90  Timer2 PWM ADC Trigger Source Select Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[2:0]   |TRGSEL    |PWM Counter Event Source Select to Trigger ADC Conversion
 * |        |          |000 = Trigger ADC conversion at zero point (ZIF).
 * |        |          |001 = Trigger ADC conversion at period point (PIF).
 * |        |          |010 = Trigger ADC conversion at zero or period point (ZIF or PIF).
 * |        |          |011 = Trigger ADC conversion at compare up count point (CMPUIF).
 * |        |          |100 = Trigger ADC conversion at compare down count point (CMPDIF).
 * |        |          |Others = Reserved.[WH1]
 * |        |          |[WH1]Tag172
 * |[7]     |TRGEN     |PWM Counter Event Trigger ADC Conversion Enable Bit
 * |        |          |0 = PWM counter event trigger ADC conversion Disabled.
 * |        |          |1 = PWM counter event trigger ADC conversion Enabled.[WH1]
 * |        |          |[WH1]Tag171
 * @var TMR23_T::PWMSCTL
 * Offset: 0x94  Timer2 PWM Synchronous Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |SYNCMODE  |PWM Synchronous Mode Enable Select
 * |        |          |00 = PWM synchronous function Disabled.
 * |        |          |01 = PWM synchronous counter start function Enabled.
 * |        |          |10 = Reserved.
 * |        |          |11 = PWM synchronous counter clear function Enabled.[WH1]
 * |        |          |[WH1]Tag174
 * |[8]     |SYNCSRC   |PWM Synchronous Counter Start/Clear Source Select
 * |        |          |0 = Counter synchronous start/clear by trigger STRGEN (TIMER0_PWMSTRG[0]).
 * |        |          |1 = Counter synchronous start/clear by trigger STRGEN (TIMER2_PWMSTRG[0]).
 * |        |          |Note1: If TIMER0/1/2/3 PWM counter synchronous source are from TIMER0, TIME0_PWMSCTL[8], TIME1_PWMSCTL[8], TIME2_PWMSCTL[8] and TIME3_PWMSCTL[8] should be 0.
 * |        |          |Note2: If TIMER0/1/ PWM counter synchronous source are from TIMER0, TIME0_PWMSCTL[8] and TIME1_PWMSCTL[8] should be set 0, and TIMER2/3/ PWM counter synchronous source are from TIMER2, TIME2_PWMSCTL[8] and TIME3_PWMSCTL[8] should be set 1.[WH1]
 * |        |          |[WH1]Tag173
 * @var TMR23_T::PWMSTRG
 * Offset: 0x98  Timer2 PWM Synchronous Trigger Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |STRGEN    |PWM Counter Synchronous Trigger Enable Bit (Write Only)
 * |        |          |PMW counter synchronous function is used to make selected PWM channels (include TIMER0/1/2/3 PWM, TIMER0/1 PWM and TIMER2/3 PWM) start counting or clear counter at the same time according to TIMERx_PWMSCTL setting.
 * |        |          |Note: This bit is only available in TIMER0 and TIMER2.[WH1]
 * |        |          |[WH1]Tag175
 * @var TMR23_T::PWMSTATUS
 * Offset: 0x9C  Timer2 PWM Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CNTMAXF   |PWM Counter Equal to 0xFFFF Flag
 * |        |          |0 = Indicates the PWM counter value never reached its maximum value 0xFFFF.
 * |        |          |1 = Indicates the PWM counter value has reached its maximum value.
 * |        |          |Note: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag177
 * |[16]    |ADCTRGF   |Trigger ADC Start Conversion Flag
 * |        |          |0 = PWM counter event trigger ADC start conversion is not occurred.
 * |        |          |1 = PWM counter event trigger ADC start conversion has occurred.
 * |        |          |Note: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag176
 * @var TMR23_T::PWMPBUF
 * Offset: 0xA0  Timer2 PWM Period Buffer Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PBUF      |PWM Period Buffer Register (Read Only)
 * |        |          |Used as PERIOD active register.[WH1]
 * |        |          |[WH1]Tag178
 * @var TMR23_T::PWMCMPBUF
 * Offset: 0xA4  Timer2 PWM Comparator Buffer Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CMPBUF    |PWM Comparator Buffer Register (Read Only)
 * |        |          |Used as CMP active register.[WH1]
 * |        |          |[WH1]Tag179
 * @var TMR23_T::CTL
 * Offset: 0x100  Timer3 Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[7:0]   |PSC       |Prescale Counter
 * |        |          |Timer input clock or event source is divided by (PSC+1) before it is fed to the timer up counter
 * |        |          |If this field is 0 (PSC = 0), then there is no scaling.
 * |        |          |Note: Update prescale counter value will reset internal 8-bit prescale counter and 24-bit up counter value.[WH1]
 * |        |          |[WH1]Tag92
 * |[19]    |INTRGEN   |Inter-timer Trigger Mode Enable Control
 * |        |          |Setting this bit will enable the inter-timer trigger capture function.
 * |        |          |The Timer0/2 will be in event counter mode and counting with external clock source or event
 * |        |          |Also, Timer1/3 will be in trigger-counting mode of capture function.
 * |        |          |0 = Inter-Timer Trigger Capture mode Disabled.
 * |        |          |1 = Inter-Timer Trigger Capture mode Enabled.
 * |        |          |Note: For Timer1/3, this bit is ignored and the read back value is always 0.[WH1]
 * |        |          |[WH1]Tag91
 * |[20]    |PERIOSEL  |Periodic Mode Behavior Selection Enable Bit
 * |        |          |0 = The behavior selection in periodic mode is Disabled.
 * |        |          |When user updates CMPDAT while timer is running in periodic mode,
 * |        |          |CNT will be reset to default value.
 * |        |          |1 = The behavior selection in periodic mode is Enabled.
 * |        |          |When user update CMPDAT while timer is running in periodic mode, the limitations as bellows list,
 * |        |          |If updated CMPDAT value > CNT, CMPDAT will be updated and CNT keep running continually.
 * |        |          |If updated CMPDAT value = CNT, timer time-out interrupt will be asserted immediately.
 * |        |          |If updated CMPDAT value < CNT, CNT will be reset to default value.[WH1]
 * |        |          |[WH1]Tag90
 * |[21]    |TGLPINSEL |Toggle-output Pin Select
 * |        |          |0 = Toggle mode output to Tx (Timer Event Counter Pin).
 * |        |          |1 = Toggle mode output to Tx_EXT (Timer External Capture Pin).[WH1]
 * |        |          |[WH1]Tag89
 * |[22]    |CAPSRC    |Capture Pin Source Selection
 * |        |          |0 = Capture Function source is from Tx_EXT (x= 0~3) pin.
 * |        |          |1 =RESERVED [AlvinLiao1].[WH2]
 * |        |          |[AlvinLiao1] NEED TO REVEISED
 * |        |          |[WH2]Tag88
 * |[23]    |WKEN      |Wake-up Function Enable Bit
 * |        |          |If this bit is set to 1, while timer interrupt flag TIF (TIMERx_INTSTS[0]) is 1 and INTEN (TIMERx_CTL[29]) is enabled, the timer interrupt signal will generate a wake-up trigger event to CPU.
 * |        |          |0 = Wake-up function Disabled if timer interrupt signal generated.
 * |        |          |1 = Wake-up function Enabled if timer interrupt signal generated.[WH1]
 * |        |          |[WH1]Tag87
 * |[24]    |EXTCNTEN  |Event Counter Mode Enable Bit
 * |        |          |This bit is for external counting pin function enabled.
 * |        |          |0 = Event counter mode Disabled.
 * |        |          |1 = Event counter mode Enabled.
 * |        |          |Note: When timer is used as an event counter, this bit should be set to 1 and select PCLK as timer clock source.[WH1]
 * |        |          |[WH1]Tag86
 * |[25]    |ACTSTS    |Timer Active Status Bit (Read Only)
 * |        |          |This bit indicates the 24-bit up counter status.
 * |        |          |0 = 24-bit up counter is not active.
 * |        |          |1 = 24-bit up counter is active.[WH1]
 * |        |          |[WH1]Tag85
 * |[26]    |RSTCNT    |Timer Counter Reset Bit (Not Release in TRM)
 * |        |          |Setting this bit will reset the 24-bit up counter value CNT (TIMERx_CNT[23:0]) and also force CNTEN (TIMERx_CTL[30]) to 0 if ACTSTS (TIMERx_CTL[25]) is 1.
 * |        |          |0 = No effect.
 * |        |          |1 = Reset internal 8-bit prescale counter, 24-bit up counter value and CNTEN bit.[WH1]
 * |        |          |[WH1]Tag84, not release in TRM
 * |[28:27] |OPMODE    |Timer Counting Mode Select
 * |        |          |00 = The Timer controller is operated in One-shot mode.
 * |        |          |01 = The Timer controller is operated in Periodic mode.
 * |        |          |10 = The Timer controller is operated in Toggle-output mode.
 * |        |          |11 = The Timer controller is operated in Continuous Counting mode.[WH1]
 * |        |          |[WH1]Tag83
 * |[29]    |INTEN     |Timer Interrupt Enable Bit
 * |        |          |0 = Timer time-out interrupt Disabled.
 * |        |          |1 = Timer time-out interrupt Enabled.
 * |        |          |Note: If this bit is enabled, when the timer time-out interrupt flag TIF is set to 1, the timer interrupt signal is generated and inform to CPU.[WH1]
 * |        |          |[WH1]Tag82
 * |[30]    |CNTEN     |Timer Counting Enable Bit
 * |        |          |0 = Stops/Suspends counting.
 * |        |          |1 = Starts counting.
 * |        |          |Note1: In stop status, and then set CNTEN to 1 will enable the 24-bit up counter to keep counting from the last stop counting value.
 * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode OPMODE (TIMER_CTL[28:27] = 00) when the timer time-out interrupt flag TIF (TIMERx_INTSTS[0]) is generated.
 * |        |          |Note3: Set enable/disable this bit needs 2 * TMR_CLK period to become active, user can read ACTSTS (TIMERx_CTL[25]) to check enabe/disable command is completed or not.[WH1]
 * |        |          |[WH1]Tag81
 * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Control (Write Protect)
 * |        |          |0 = ICE debug mode acknowledgement effects TIMER counting.
 * |        |          |TIMER counter will be held while CPU is held by ICE.
 * |        |          |1 = ICE debug mode acknowledgement Disabled.
 * |        |          |TIMER counter will keep going no matter CPU is held by ICE or not.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag80
 * @var TMR23_T::CMP
 * Offset: 0x104  Timer3 Comparator Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[23:0]  |CMPDAT    |Timer Comparator Value
 * |        |          |CMPDAT is a 24-bit compared value register
 * |        |          |When the internal 24-bit up counter value is equal to CMPDAT value, the TIF (TIMERx_INTSTS[0] Timer Interrupt Flag) will set to 1.
 * |        |          |Time-out period = (Period of timer clock input) * (8-bit PSC + 1) * (24-bit CMPDAT).
 * |        |          |Note1: Never write 0x0 or 0x1 in CMPDAT field, or the core will run into unknown state.
 * |        |          |Note2: When timer is operating at continuous counting mode, the 24-bit up counter will keep counting continuously even if user writes a new value into CMPDAT field
 * |        |          |But if timer is operating at other modes, the 24-bit up counter will restart counting from 0 and using newest CMPDAT value to be the timer compared value while user writes a new value into CMPDAT field.[WH1]
 * |        |          |[WH1]Tag93
 * @var TMR23_T::INTSTS
 * Offset: 0x108  Timer3 Interrupt Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |TIF       |Timer Interrupt Flag
 * |        |          |This bit indicates the interrupt flag status of Timer while 24-bit timer up counter CNT (TIMERx_CNT[23:0]) value reaches to CMPDAT (TIMERx_CMP[23:0]) value.
 * |        |          |0 = No effect.
 * |        |          |1 = CNT value matches the CMPDAT value.
 * |        |          |Note: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag95
 * |[1]     |TWKF      |Timer Wake-up Flag
 * |        |          |This bit indicates the interrupt wake-up flag status of timer.
 * |        |          |0 = Timer does not cause CPU wake-up.
 * |        |          |1 = CPU wake-up from Idle or Power-down mode if timer time-out interrupt signal generated.
 * |        |          |Note: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag94
 * @var TMR23_T::CNT
 * Offset: 0x10C  Timer3 Data Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[23:0]  |CNT       |Timer Data Register
 * |        |          |Read operation.
 * |        |          |Read this register to get CNT value. For example:
 * |        |          |If EXTCNTEN (TIMERx_CTL[24] ) is 0, user can read CNT value for getting current 24-bit counter value.
 * |        |          |If EXTCNTEN (TIMERx_CTL[24] ) is 1, user can read CNT value for getting current 24-bit event input counter value.
 * |        |          |Write operation.
 * |        |          |Writing any value to this register will reset current CNT value to 0 and reload internal 8-bit prescale counter.[WH1]
 * |        |          |[WH1]Tag97
 * |[31]    |RSTACT    |Timer Data Register Reset Active (Read Only)
 * |        |          |This bit indicates if the counter reset operation active.
 * |        |          |When user writes this CNT register, timer starts to reset its internal 24-bit timer up-counter to 0 and reload 8-bit pre-scale counter
 * |        |          |At the same time, timer set this flag to 1 to indicate the counter reset operation is in progress
 * |        |          |Once the counter reset operation done, timer clear this bit to 0 automatically.
 * |        |          |0 = Reset operation is done.
 * |        |          |1 = Reset operation triggered by writing TIMERx_CNT is in progress.
 * |        |          |Note: This bit is read only.[WH1]
 * |        |          |[WH1]Tag96
 * @var TMR23_T::CAP
 * Offset: 0x110  Timer3 Capture Data Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[23:0]  |CAPDAT    |Timer Capture Data Register (Read Only)
 * |        |          |When CAPEN (TIMERx_EXTCTL[3]) bit is set, CAPFUNCS (TIMERx_EXTCTL[4]) bit is 0, and a transition on Tx_EXT pin matched the CAPEDGE (TIMERx_EXTCTL[14:12]) setting, CAPIF (TIMERx_EINTSTS[0]) will set to 1 and the current timer counter value CNT (TIMERx_CNT[23:0]) will be auto-loaded into this CAPDAT field.[WH1]
 * |        |          |[WH1]Tag98
 * @var TMR23_T::EXTCTL
 * Offset: 0x114  Timer3 External Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CNTPHASE  |Timer External Count Phase
 * |        |          |This bit indicates the detection phase of external counting pin Tx (x= 0~3).
 * |        |          |0 = A falling edge of external counting pin will be counted.
 * |        |          |1 = A rising edge of external counting pin will be counted.[WH1]
 * |        |          |[WH1]Tag107
 * |[2:1]   |SCAPEDGE  |SBZ
 * |[3]     |CAPEN     |Timer External Capture Pin Enable Bit
 * |        |          |This bit enables the Tx_EXT capture pin input function.
 * |        |          |0 =Tx_EXT (x= 0~3) pin Disabled.
 * |        |          |1 =Tx_EXT (x= 0~3) pin Enabled.[WH1]
 * |        |          |[WH1]Tag106
 * |[4]     |CAPFUNCS  |Capture Function Selection
 * |        |          |0 = External Capture Mode Enabled.
 * |        |          |1 = External Reset Mode Enabled.
 * |        |          |Note1: When CAPFUNCS is 0, transition on Tx_EXT (x= 0~3) pin is using to save current 24-bit timer counter value (CNT value) to CAPDAT field.
 * |        |          |Note2: When CAPFUNCS is 1, transition on Tx_EXT (x= 0~3) pin is using to save current 24-bit timer counter value (CNT value) to CAPDAT field then CNT value will be reset immediately.[WH1]
 * |        |          |[WH1]Tag105
 * |[5]     |CAPIEN    |Timer External Capture Interrupt Enable Bit
 * |        |          |0 = Tx_EXT (x= 0~3) pin detection Interrupt Disabled.
 * |        |          |1 = Tx_EXT (x= 0~3) pin detection Interrupt Enabled.
 * |        |          |Note: CAPIEN is used to enable timer external interrupt
 * |        |          |If CAPIEN enabled, timer will rise an interrupt when CAPIF (TIMERx_EINTSTS[0]) is 1.
 * |        |          |For example, while CAPIEN = 1, CAPEN = 1, and CAPEDGE = 00, a 1 to 0 transition on the Tx_EXT pin will cause the CAPIF to be set then the interrupt signal is generated and sent to NVIC to inform CPU.[WH1]
 * |        |          |[WH1]Tag104
 * |[6]     |CAPDBEN   |Timer External Capture Pin De-bounce Enable Bit
 * |        |          |0 = Tx_EXT (x= 0~3) pin de-bounce Disabled.
 * |        |          |1 = Tx_EXT (x= 0~3) pin de-bounce Enabled.
 * |        |          |Note: If this bit is enabled, the edge detection of Tx_EXT pin output is detected with de-bounce circuit.[WH1]
 * |        |          |[WH1]Tag103
 * |[7]     |CNTDBEN   |Timer Counter Pin De-bounce Enable Bit
 * |        |          |0 = Tx (x= 0~3) pin de-bounce Disabled.
 * |        |          |1 = Tx (x= 0~3) pin de-bounce Enabled.
 * |        |          |Note: If this bit is enabled, the edge detection of Tx pin is detected with de-bounce circuit.[WH1]
 * |        |          |[WH1]Tag102
 * |[14:12] |CAPEDGE   |Timer External Capture Pin Edge Detect
 * |        |          |When first capture event is generated, the CNT (TIMERx_CNT[23:0]) will be reset to 0 and first CAPDAT (TIMERx_CAP[23:0]) should be to 0.
 * |        |          |000 = Capture event occurred when detect falling edge transfer on Tx_EXT (x= 0~3) pin.
 * |        |          |001 = Capture event occurred when detect rising edge transfer on Tx_EXT (x= 0~3) pin.
 * |        |          |010 = Capture event occurred when detect both falling and rising edge transfer on Tx_EXT (x= 0~3) pin, and first capture event occurred at falling edge transfer.
 * |        |          |011 = Capture event occurred when detect both rising and falling edge transfer on Tx_EXT (x= 0~3) pin, and first capture event occurred at rising edge transfer.
 * |        |          |110 = First capture event occurred at falling edge, follows capture events are at rising edge transfer on Tx_EXT (x= 0~3) pin.
 * |        |          |111 = First capture event occurred at rising edge, follows capture events are at falling edge transfer on Tx_EXT (x= 0~3) pin.
 * |        |          |100, 101 = Reserved.[WH1]
 * |        |          |[WH1]Tag100
 * |[16]    |ECNTSSEL  |Event Counter Source Selection to Trigger Event Counter Function
 * |        |          |0 = Event Counter input source is from Tx (x= 0~3) pin.
 * |        |          |1 = Reserved Event Counter input source is from USB internal SOF output signal.[WH1]
 * |        |          |[WH1]Tag99
 * @var TMR23_T::EINTSTS
 * Offset: 0x118  Timer3 External Interrupt Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CAPIF     |Timer External Capture Interrupt Flag
 * |        |          |This bit indicates the timer external capture interrupt flag status.
 * |        |          |0 = Tx_EXT (x= 0~3) pin interrupt did not occur.
 * |        |          |1 = Tx_EXT (x= 0~3) pin interrupt occurred.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2: When CAPEN (TIMERx_EXTCTL[3]) bit is set, CAPFUNCS (TIMERx_EXTCTL[4]) bit is 0, and a transition on Tx_EXT (x= 0~3) pin matched the CAPEDGE (TIMERx_EXTCTL[2:1]) setting, this bit will set to 1 by hardware.
 * |        |          |Note3: There is a new incoming capture event detected before CPU clearing the CAPIF status
 * |        |          |If the above condition occurred, the Timer will keep register TIMERx_CAP unchanged and drop the new capture value.[WH1]
 * |        |          |[WH1]Tag108
 * @var TMR23_T::TRGCTL
 * Offset: 0x11C  Timer3 Trigger Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |TRGSSEL   |Trigger Source Select Bit
 * |        |          |This bit is used to select internal trigger source is form timer time-out interrupt signal or capture interrupt signal.
 * |        |          |0 = Time-out interrupt signal is used to internal trigger PWM, PDMA, and ADC.
 * |        |          |1 = Capture interrupt signal is used to internal trigger PWM, PDMA, and ADC.[WH1]
 * |        |          |[WH1]Tag113
 * |[1]     |TRGPWM    |Trigger PWM Enable Bit
 * |        |          |If this bit is set to 1, each timer time-out event or capture event can be as PWM counter clock source.
 * |        |          |0 = Timer interrupt trigger PWM Disabled.
 * |        |          |1 = Timer interrupt trigger PWM Enabled.
 * |        |          |Note: If TRGSSEL (TIMERx_TRGCTL[0]) = 0, time-out interrupt signal as PWM counter clock source.
 * |        |          |If TRGSSEL (TIMERx_TRGCTL[0]) = 1, capture interrupt signal as PWM counter clock source.[WH1]
 * |        |          |[WH1]Tag112
 * |[2]     |TRGADC    |Trigger ADC Enable Bit
 * |        |          |If this bit is set to 1, each timer time-out event or capture event can be triggered ADC conversion.
 * |        |          |0 = Timer interrupt trigger ADC Disabled.
 * |        |          |1 = Timer interrupt trigger ADC Enabled.
 * |        |          |Note: If TRGSSEL (TIMERx_TRGCTL[0]) = 0, time-out interrupt signal will trigger ADC conversion.
 * |        |          |If TRGSSEL (TIMERx_TRGCTL[0]) = 1, capture interrupt signal will trigger ADC conversion.[WH1]
 * |        |          |[WH1]Tag111
 * |[4]     |TRGPDMA   |Trigger PDMA Enable Bit
 * |        |          |If this bit is set to 1, each timer time-out event or capture event can be triggered PDMA transfer.
 * |        |          |0 = Timer interrupt trigger PDMA Disabled.
 * |        |          |1 = Timer interrupt trigger PDMA Enabled.
 * |        |          |Note: If TRGSSEL (TIMERx_TRGCTL[0]) = 0, time-out interrupt signal will trigger PDMA transfer.
 * |        |          |If TRGSSEL (TIMERx_TRGCTL[0]) = 1, capture interrupt signal will trigger PDMA transfer.[WH1]
 * |        |          |[WH1]Tag109
 * @var TMR23_T::ALTCTL
 * Offset: 0x120  Timer3 Alternative Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |FUNCSEL   |Function Selection
 * |        |          |0 = Timer controller is used as timer function.
 * |        |          |1 = Timer controller is used as PWM function.
 * |        |          |Note: When timer is used as PWM, the clock source of time controller will be forced to PCLKx automatically.[WH1]
 * |        |          |[WH1]Tag114
 * @var TMR23_T::PWMCTL
 * Offset: 0x140  Timer3 PWM Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CNTEN     |PWM Counter Enable Bit
 * |        |          |0 = PWM counter and clock prescale Stop Running.
 * |        |          |1 = PWM counter and clock prescale Start Running.[WH1]
 * |        |          |[WH1]Tag122
 * |[2:1]   |CNTTYPE   |PWM Counter Behavior Type
 * |        |          |00 = Up count type.
 * |        |          |01 = Down count type.
 * |        |          |10 = Up-down count type.
 * |        |          |11 = Reserved.[WH1]
 * |        |          |[WH1]Tag121
 * |[3]     |CNTMODE   |PWM Counter Mode
 * |        |          |0 = Auto-reload mode.
 * |        |          |1 = One-shot mode.[WH1]
 * |        |          |[WH1]Tag120
 * |[8]     |CTRLD     |Center Re-load
 * |        |          |In up-down count type, PERIOD will load to PBUF when current PWM period is completed always and CMP will load to CMPBUF at the center point of current period.[WH1]
 * |        |          |[WH1]Tag119
 * |[9]     |IMMLDEN   |Immediately Load Enable Bit
 * |        |          |0 = PERIOD will load to PBUF when current PWM period is completed no matter CTRLD is enabled/disabled
 * |        |          |If CTRLD is disabled, CMP will load to CMPBUF when current PWM period is completed; if CTRLD is enabled in up-down count type, CMP will load to CMPBUF at the center point of current period.
 * |        |          |1 = PERIOD/CMP will load to PBUF/CMPBUF immediately when user update PERIOD/CMP.
 * |        |          |Note: If IMMLDEN is enabled, CTRLD will be invalid.[WH1]
 * |        |          |[WH1]Tag118
 * |[16]    |OUTMODE   |PWM Output Mode
 * |        |          |This bit controls the output mode of corresponding PWM channel.
 * |        |          |0 = PWM independent mode.
 * |        |          |1 = PWM complementary mode.[WH1]
 * |        |          |[WH1]Tag117
 * |[30]    |DBGHALT   |ICE Debug Mode Counter Halt (Write Protect)
 * |        |          |If debug mode counter halt is enabled, PWM counter will keep current value until exit ICE debug mode.
 * |        |          |0 = ICE debug mode counter halt disable.
 * |        |          |1 = ICE debug mode counter halt enable.
 * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag116
 * |[31]    |DBGTRIOFF |ICE Debug Mode Acknowledge Disable Bit (Write Protect)
 * |        |          |0 = ICE debug mode acknowledgement effects PWM output.
 * |        |          |PWM output pin will be forced as tri-state while ICE debug mode acknowledged.
 * |        |          |1 = ICE debug mode acknowledgement disabled.
 * |        |          |PWM output pin will keep output no matter ICE debug mode acknowledged or not.
 * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag115
 * @var TMR23_T::PWMCLKSRC
 * Offset: 0x144  Timer3 PWM Counter Clock Source Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[2:0]   |CLKSRC    |PWM Counter Clock Source Select
 * |        |          |The PWM counter clock source can be selected from TMRx_CLK or internal timer time-out or capture event.
 * |        |          |000 = TMRx_CLK.
 * |        |          |001 = Internal TIMER0 time-out or capture event.
 * |        |          |010 = Internal TIMER1 time-out or capture event.
 * |        |          |011 = Internal TIMER2 time-out or capture event.
 * |        |          |100 = Internal TIMER3 time-out or capture event.
 * |        |          |Others = Reserved.
 * |        |          |Note: If TIMER0 PWM function is enabled, the PWM counter clock source can be selected from TMR0_CLK, TIMER1 interrupt events, TIMER2 interrupt events, or TIMER3 interrupt events.[WH1]
 * |        |          |[WH1]Tag123
 * @var TMR23_T::PWMCLKPSC
 * Offset: 0x148  Timer3 PWM Counter Clock Pre-scale Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-scale
 * |        |          |The active clock of PWM counter is decided by counter clock prescale and divided by (CLKPSC + 1)
 * |        |          |If CLKPSC is 0, then there is no scaling in PWM counter clock source.[WH1]
 * |        |          |[WH1]Tag124
 * @var TMR23_T::PWMCNTCLR
 * Offset: 0x14C  Timer3 PWM Clear Counter Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CNTCLR    |Clear PWM Counter Control Bit
 * |        |          |It is automatically cleared by hardware.
 * |        |          |0 = No effect.
 * |        |          |1 = Clear 16-bit PWM counter to 0x10000 in up and up-down count type and reset counter value to PERIOD in down count type.[WH1]
 * |        |          |[WH1]Tag125
 * @var TMR23_T::PWMPERIOD
 * Offset: 0x150  Timer3 PWM Period Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PERIOD    |PWM Period Register
 * |        |          |In up count type: PWM counter counts from 0 to PERIOD, and restarts from 0.
 * |        |          |In down count type: PWM counter counts from PERIOD to 0, and restarts from PERIOD.
 * |        |          |In up-down count type: PWM counter counts from 0 to PERIOD, then decrements to 0 and repeats again.
 * |        |          |In up and down count type:
 * |        |          |PWM period time = (PERIOD + 1) * (CLKPSC + 1) * TMRx_PWMCLK.
 * |        |          |In up-down count type:
 * |        |          |PWM period time = 2 * PERIOD * (CLKPSC+ 1) * TMRx_PWMCLK.
 * |        |          |Note: User should take care DIRF (TIMERx_PWMCNT[16]) bit in up/down/up-down count type to monitor current counter direction in each count type.[WH1]
 * |        |          |[WH1]Tag126
 * @var TMR23_T::PWMCMPDAT
 * Offset: 0x154  Timer3 PWM Comparator Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CMP       |PWM Comparator Register
 * |        |          |PWM CMP is used to compare with PWM CNT to generate PWM output waveform, interrupt events and trigger ADC to start convert.[WH1]
 * |        |          |[WH1]Tag127
 * @var TMR23_T::PWMDTCTL
 * Offset: 0x158  Timer3 PWM Dead-Time Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[11:0]  |DTCNT     |Dead-time Counter (Write Protect)
 * |        |          |The dead-time can be calculated from the following two formulas:
 * |        |          |Dead-time = (DTCNT[11:0] + 1) * TMRx_PWMCLK, if DTCKSEL is 0.
 * |        |          |Dead-time = (DTCNT[11:0] + 1) * TMRx_PWMCLK * (CLKPSC + 1), if DTCKSEL is 1.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag130
 * |[16]    |DTEN      |Enable Dead-time Insertion for PWMx_CH0 and PWMx_CH1 (Write Protect)
 * |        |          |Dead-time insertion function is only active when PWM complementary mode is enabled
 * |        |          |If dead- time insertion is inactive, the outputs of PWMx_CH0 and PWMx_CH1 are complementary without any delay.
 * |        |          |0 = Dead-time insertion Disabled on the pin pair.
 * |        |          |1 = Dead-time insertion Enabled on the pin pair.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag129
 * |[24]    |DTCKSEL   |Dead-time Clock Select (Write Protect)
 * |        |          |0 = Dead-time clock source from TMRx_PWMCLK without counter clock prescale.
 * |        |          |1 = Dead-time clock source from TMRx_PWMCLK with counter clock prescale.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag128
 * @var TMR23_T::PWMCNT
 * Offset: 0x15C  Timer3 PWM Counter Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CNT       |PWM Counter Value Register (Read Only)
 * |        |          |User can monitor CNT to know the current counter value in 16-bit period counter.[WH1]
 * |        |          |[WH1]Tag132
 * |[16]    |DIRF      |PWM Counter Direction Indicator Flag (Read Only)
 * |        |          |0 = Counter is active in down count.
 * |        |          |1 = Counter is active up count.[WH1]
 * |        |          |[WH1]Tag131
 * @var TMR23_T::PWMMSKEN
 * Offset: 0x160  Timer3 PWM Output Mask Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |MSKEN0    |PWMx_CH0 Output Mask Enable Bit
 * |        |          |The PWMx_CH0 output signal will be masked when this bit is enabled
 * |        |          |The PWMx_CH0 will output MSKDAT0 (TIMER_PWMMSK[0]) data.
 * |        |          |0 = PWMx_CH0 output signal is non-masked.
 * |        |          |1 = PWMx_CH0 output signal is masked and output MSKDAT0 data.[WH1]
 * |        |          |[WH1]Tag133
 * |[1]     |MSKEN1    |PWMx_CH1 Output Mask Enable Bit
 * |        |          |The PWMx_CH1 output signal will be masked when this bit is enabled
 * |        |          |The PWMx_CH1 will output MSKDAT1 (TIMER_PWMMSK[1]) data.
 * |        |          |0 = PWMx_CH1 output signal is non-masked.
 * |        |          |1 = PWMx_CH1 output signal is masked and output MSKDAT1 data.
 * @var TMR23_T::PWMMSK
 * Offset: 0x164  Timer3 PWM Output Mask Data Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |MSKDAT0   |PWMx_CH0 Output Mask Data Control Bit
 * |        |          |This bit is used to control the output state of PWMx_CH0 pin when PWMx_CH0 output mask function is enabled (MSKEN0 = 1).
 * |        |          |0 = Output logic Low to PWMx_CH0.
 * |        |          |1 = Output logic High to PWMx_CH0.[WH1]
 * |        |          |[WH1]Tag134
 * |[1]     |MSKDAT1   |PWMx_CH1 Output Mask Data Control Bit
 * |        |          |This bit is used to control the output state of PWMx_CH1 pin when PWMx_CH1 output mask function is enabled (MSKEN1 = 1).
 * |        |          |0 = Output logic Low to PWMx_CH1.
 * |        |          |1 = Output logic High to PWMx_CH1.
 * @var TMR23_T::PWMBNF
 * Offset: 0x168  Timer3 PWM Brake Pin Noise Filter Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BRKNFEN   |Brake Pin Noise Filter Enable Bit
 * |        |          |0 = Pin noise filter detect of TM_BRAKEx Disabled.
 * |        |          |1 = Pin noise filter detect of TM_BRAKEx Enabled.[WH1]
 * |        |          |[WH1]Tag139
 * |[3:1]   |BRKNFSEL  |Brake Pin Noise Filter Clock Selection
 * |        |          |000 = Noise filter clock is PCLKx.
 * |        |          |001 = Noise filter clock is PCLKx/2.
 * |        |          |010 = Noise filter clock is PCLKx/4.
 * |        |          |011 = Noise filter clock is PCLKx/8.
 * |        |          |100 = Noise filter clock is PCLKx/16.
 * |        |          |101 = Noise filter clock is PCLKx/32.
 * |        |          |110 = Noise filter clock is PCLKx/64.
 * |        |          |111 = Noise filter clock is PCLKx/128.[WH1]
 * |        |          |[WH1]Tag138
 * |[6:4]   |BRKFCNT   |Brake Pin Noise Filter Count
 * |        |          |The fields is used to control the active noise filter sample time.
 * |        |          |Once noise filter sample time = (Period time of BRKDBCS) * BRKFCNT.[WH1]
 * |        |          |[WH1]Tag137
 * |[7]     |BRKPINV   |Brake Pin Detection Control Bit
 * |        |          |0 = Brake pin event will be detected if TM_BRAKEx pin status transfer from low to high in edge-detect, or pin status is high in level-detect.
 * |        |          |1 = Brake pin event will be detected if TM_BRAKEx pin status transfer from high to low in edge-detect, or pin status is low in level-detect .[WH1]
 * |        |          |[WH1]Tag136
 * |[17:16] |BKPINSRC  |Brake Pin Source Select
 * |        |          |00 = Brake pin source comes from TM_BRAKE0.
 * |        |          |01 = Brake pin source comes from TM_BRAKE1.
 * |        |          |10 = Brake pin source comes from TM_BRAKE2.
 * |        |          |11 = Brake pin source comes from TM_BRAKE3.[WH1]
 * |        |          |[WH1]Tag135
 * @var TMR23_T::PWMFAILBRK
 * Offset: 0x16C  Timer3 PWM System Fail Brake Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CSSBRKEN  |Clock Security System Detection Trigger PWM Brake Function Enable Bit
 * |        |          |0 = Brake Function triggered by clock fail detection Disabled.
 * |        |          |1 = Brake Function triggered by clock fail detection Enabled.[WH1]
 * |        |          |[WH1]Tag143
 * |[1]     |BODBRKEN  |Brown-out Detection Trigger PWM Brake Function Enable Bit
 * |        |          |0 = Brake Function triggered by BOD event Disabled.
 * |        |          |1 = Brake Function triggered by BOD event Enabled.[WH1]
 * |        |          |[WH1]Tag142
 * |[2]     |RAMBRKEN  |SRAM Parity Error Detection Trigger PWM Brake Function Enable Bit
 * |        |          |0 = Brake Function triggered by SRAM parity error detection Disabled.
 * |        |          |1 = Brake Function triggered by SRAM parity error detection Enabled.[WH1]
 * |        |          |[WH1]Tag141
 * |[3]     |CORBRKEN  |Core Lockup Detection Trigger PWM Brake Function Enable Bit
 * |        |          |0 = Brake Function triggered by core lockup event Disabled.
 * |        |          |1 = Brake Function triggered by core lockup event Enabled.[WH1]
 * |        |          |[WH1]Tag140
 * @var TMR23_T::PWMBRKCTL
 * Offset: 0x170  Timer3 PWM Brake Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[4]     |BRKPEEN   |Enable TM_BRAKEx Pin As Edge-detect Brake Source (Write Protect)
 * |        |          |0 = TM_BRAKEx pin event as edge-detect brake source Disabled.
 * |        |          |1 = TM_BRAKEx pin event as edge-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag151
 * |[7]     |SYSEBEN   |Enable System Fail As Edge-detect Brake Source (Write Protect)
 * |        |          |0 = System fail condition as edge-detect brake source Disabled.
 * |        |          |1 = System fail condition as edge-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag150
 * |[12]    |BRKPLEN   |Enable TM_BRAKEx Pin As Level-detect Brake Source (Write Protect)
 * |        |          |0 = TM_BRAKEx pin event as level-detect brake source Disabled.
 * |        |          |1 = TM_BRAKEx pin event as level-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag147
 * |[15]    |SYSLBEN   |Enable System Fail As Level-detect Brake Source (Write Protect)
 * |        |          |0 = System fail condition as level-detect brake source Disabled.
 * |        |          |1 = System fail condition as level-detect brake source Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag146
 * |[17:16] |BRKAEVEN  |PWM Brake Action Select for PWMx_CH0 (Write Protect)
 * |        |          |00 = TIMERx_PWM brake event will not affect PWMx_CH0 output.
 * |        |          |01 = PWMx_CH0 output tri-state when TIMERx_PWM brake event happened.
 * |        |          |10 = PWMx_CH0 output low level when TIMERx_PWM brake event happened.
 * |        |          |11 = PWMx_CH0 output high level when TIMERx_PWM brake event happened.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag145
 * |[19:18] |BRKAODD   |PWM Brake Action Select for PWMx_CH1 (Write Protect)
 * |        |          |00 = TIMERx_PWM brake event will not affect PWMx_CH1 output.
 * |        |          |01 = PWMx_CH1 output tri-state when TIMERx_PWM brake event happened.
 * |        |          |10 = PWMx_CH1 output low level when TIMERx_PWM brake event happened.
 * |        |          |11 = PWMx_CH1 output high level when TIMERx_PWM brake event happened.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag144
 * @var TMR23_T::PWMPOLCTL
 * Offset: 0x174  Timer3 PWM Pin Output Polar Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PINV0     |PWMx_CH0 Output Pin Polar Control Bit
 * |        |          |The bit is used to control polarity state of PWMx_CH0 output pin.
 * |        |          |0 = PWMx_CH0 output pin polar inverse Disabled.
 * |        |          |1 = PWMx_CH0 output pin polar inverse Enabled.[WH1]
 * |        |          |[WH1]Tag154
 * |[1]     |PINV1     |PWMx_CH1 Output Pin Polar Control Bit
 * |        |          |The bit is used to control polarity state of PWMx_CH1 output pin.
 * |        |          |0 = PWMx_CH1 output pin polar inverse Disabled.
 * |        |          |1 = PWMx_CH1 output pin polar inverse Enabled.
 * @var TMR23_T::PWMPOEN
 * Offset: 0x178  Timer3 PWM Pin Output Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |POEN0     |PWMx_CH0 Output Pin Enable Bit
 * |        |          |0 = PWMx_CH0 pin at tri-state mode.
 * |        |          |1 = PWMx_CH0 pin in output mode.[WH1]
 * |        |          |[WH1]Tag155
 * |[1]     |POEN1     |PWMx_CH1 Output Pin Enable Bit
 * |        |          |0 = PWMx_CH1 pin at tri-state mode.
 * |        |          |1 = PWMx_CH1 pin in output mode.
 * @var TMR23_T::PWMSWBRK
 * Offset: 0x17C  Timer3 PWM Software Trigger Brake Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BRKETRG   |Software Trigger Edge-detect Brake Source (Write Only) (Write Protect)
 * |        |          |Write 1 to this bit will trigger PWM edge-detect brake source, then BRKEIF0 and BRKEIF1 will set to 1 automatically in TIMERx_PWMINTSTS1 register.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag156
 * |[8]     |BRKLTRG   |Software Trigger Level-detect Brake Source (Write Only) (Write Protect)
 * |        |          |Write 1 to this bit will trigger PWM level-detect brake source, then BRKLIF0 and BRKLIF1 will set to 1 automatically in TIMERx_PWMINTSTS1 register.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
 * @var TMR23_T::PWMINTEN0
 * Offset: 0x180  Timer3 PWM Interrupt Enable Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ZIEN      |PWM Zero Point Interrupt Enable Bit
 * |        |          |0 = Zero point interrupt Disabled.
 * |        |          |1 = Zero point interrupt Enabled.[WH1]
 * |        |          |[WH1]Tag160
 * |[1]     |PIEN      |PWM Period Point Interrupt Enable Bit
 * |        |          |0 = Period point interrupt Disabled.
 * |        |          |1 = Period point interrupt Enabled.
 * |        |          |Note: When in up-down count type, period point means the center point of current PWM period.[WH1]
 * |        |          |[WH1]Tag159
 * |[2]     |CMPUIEN   |PWM Compare Up Count Interrupt Enable Bit
 * |        |          |0 = Compare up count interrupt Disabled.
 * |        |          |1 = Compare up count interrupt Enabled.[WH1]
 * |        |          |[WH1]Tag158
 * |[3]     |CMPDIEN   |PWM Compare Down Count Interrupt Enable Bit
 * |        |          |0 = Compare down count interrupt Disabled.
 * |        |          |1 = Compare down count interrupt Enabled.[WH1]
 * |        |          |[WH1]Tag157
 * @var TMR23_T::PWMINTEN1
 * Offset: 0x184  Timer3 PWM Interrupt Enable Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BRKEIEN   |PWM Edge-detect Brake Interrupt Enable (Write Protect)
 * |        |          |0 = PWM edge-detect brake interrupt Disabled.
 * |        |          |1 = PWM edge-detect brake interrupt Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag162
 * |[8]     |BRKLIEN   |PWM Level-detect Brake Interrupt Enable (Write Protect)
 * |        |          |0 = PWM level-detect brake interrupt Disabled.
 * |        |          |1 = PWM level-detect brake interrupt Enabled.
 * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag161
 * @var TMR23_T::PWMINTSTS0
 * Offset: 0x188  Timer3 PWM Interrupt Status Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ZIF       |PWM Zero Point Interrupt Flag
 * |        |          |This bit is set by hardware when TIMERx_PWM counter reaches zero.
 * |        |          |Note: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag166
 * |[1]     |PIF       |PWM Period Point Interrupt Flag
 * |        |          |This bit is set by hardware when TIMERx_PWM counter reaches PERIOD.
 * |        |          |Note1: When in up-down count type, PIF flag means the center point flag of current PWM period.
 * |        |          |Note2: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag165
 * |[2]     |CMPUIF    |PWM Compare Up Count Interrupt Flag
 * |        |          |This bit is set by hardware when TIMERx_PWM counter in up count direction and reaches CMP.
 * |        |          |Note1: If CMP equal to PERIOD, there is no CMPUIF flag in up count type and up-down count type.
 * |        |          |Note2: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag164
 * |[3]     |CMPDIF    |PWM Compare Down Count Interrupt Flag
 * |        |          |This bit is set by hardware when TIMERx_PWM counter in down count direction and reaches CMP.
 * |        |          |Note1: If CMP equal to PERIOD, there is no CMPDIF flag in down count type.
 * |        |          |Note2: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag163
 * @var TMR23_T::PWMINTSTS1
 * Offset: 0x18C  Timer3 PWM Interrupt Status Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BRKEIF0   |Edge-detect Brake Interrupt Flag on PWMx_CH0 (Write Protect)
 * |        |          |0 = PWMx_CH0 edge-detect brake event do not happened.
 * |        |          |1 = PWMx_CH0 edge-detect brake event happened.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag170
 * |[1]     |BRKEIF1   |Edge-detect Brake Interrupt Flag PWMx_CH1 (Write Protect)
 * |        |          |0 = PWMx_CH1 edge-detect brake event do not happened.
 * |        |          |1 = PWMx_CH1 edge-detect brake event happened.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2: This register is write protected. Refer to SYS_REGLCTL register.
 * |[8]     |BRKLIF0   |Level-detect Brake Interrupt Flag on PWMx_CH0 (Write Protect)
 * |        |          |0 = PWMx_CH0 level-detect brake event do not happened.
 * |        |          |1 = PWMx_CH0 level-detect brake event happened.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2: This register is write protected. Refer to SYS_REGLCTL register.[WH1]
 * |        |          |[WH1]Tag169
 * |[9]     |BRKLIF1   |Level-detect Brake Interrupt Flag on PWMx_CH1 (Write Protect)
 * |        |          |0 = PWMx_CH1 level-detect brake event do not happened.
 * |        |          |1 = PWMx_CH1 level-detect brake event happened.
 * |        |          |Note1: This bit is cleared by writing 1 to it.
 * |        |          |Note2: This register is write protected. Refer to SYS_REGLCTL register.
 * |[16]    |BRKESTS0  |Edge -detect Brake Status of PWMx_CH0 (Read Only)
 * |        |          |0 = PWMx_CH0 edge-detect brake state is released.
 * |        |          |1 = PWMx_CH0 at edge-detect brake state.
 * |        |          |Note: User can set BRKEIF0 1 to clear BRKEIF0 flag and PWMx_CH0 will release brake state when current PWM period finished and resume PWMx_CH0 output waveform start from next full PWM period.[WH1]
 * |        |          |[WH1]Tag168
 * |[17]    |BRKESTS1  |Edge-detect Brake Status of PWMx_CH1 (Read Only)
 * |        |          |0 = PWMx_CH1 edge-detect brake state is released.
 * |        |          |1 = PWMx_CH1 at edge-detect brake state.
 * |        |          |Note: User can set BRKEIF1 1 to clear BRKEIF1 flag and PWMx_CH1 will release brake state when current PWM period finished and resume PWMx_CH1 output waveform start from next full PWM period.
 * |[24]    |BRKLSTS0  |Level-detect Brake Status of PWMx_CH0 (Read Only)
 * |        |          |0 = PWMx_CH0 level-detect brake state is released.
 * |        |          |1 = PWMx_CH0 at level-detect brake state.
 * |        |          |Note: If TIMERx_PWM level-detect brake source has released, both PWMx_CH0 and PWMx_CH1 will release brake state when current PWM period finished and resume PWMx_CH0 and PWMx_CH1 output waveform start from next full PWM period.[WH1]
 * |        |          |[WH1]Tag167
 * |[25]    |BRKLSTS1  |Level-detect Brake Status of PWMx_CH1 (Read Only)
 * |        |          |0 = PWMx_CH1 level-detect brake state is released.
 * |        |          |1 = PWMx_CH1 at level-detect brake state.
 * |        |          |Note: If TIMERx_PWM level-detect brake source has released, both PWMx_CH0 and PWMx_CH1 will release brake state when current PWM period finished and resume PWMx_CH0 and PWMx_CH1 output waveform start from next full PWM period.
 * @var TMR23_T::PWMADCTS
 * Offset: 0x190  Timer3 PWM ADC Trigger Source Select Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[2:0]   |TRGSEL    |PWM Counter Event Source Select to Trigger ADC Conversion
 * |        |          |000 = Trigger ADC conversion at zero point (ZIF).
 * |        |          |001 = Trigger ADC conversion at period point (PIF).
 * |        |          |010 = Trigger ADC conversion at zero or period point (ZIF or PIF).
 * |        |          |011 = Trigger ADC conversion at compare up count point (CMPUIF).
 * |        |          |100 = Trigger ADC conversion at compare down count point (CMPDIF).
 * |        |          |Others = Reserved.[WH1]
 * |        |          |[WH1]Tag172
 * |[7]     |TRGEN     |PWM Counter Event Trigger ADC Conversion Enable Bit
 * |        |          |0 = PWM counter event trigger ADC conversion Disabled.
 * |        |          |1 = PWM counter event trigger ADC conversion Enabled.[WH1]
 * |        |          |[WH1]Tag171
 * @var TMR23_T::PWMSCTL
 * Offset: 0x194  Timer3 PWM Synchronous Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |SYNCMODE  |PWM Synchronous Mode Enable Select
 * |        |          |00 = PWM synchronous function Disabled.
 * |        |          |01 = PWM synchronous counter start function Enabled.
 * |        |          |10 = Reserved.
 * |        |          |11 = PWM synchronous counter clear function Enabled.[WH1]
 * |        |          |[WH1]Tag174
 * |[8]     |SYNCSRC   |PWM Synchronous Counter Start/Clear Source Select
 * |        |          |0 = Counter synchronous start/clear by trigger STRGEN (TIMER0_PWMSTRG[0]).
 * |        |          |1 = Counter synchronous start/clear by trigger STRGEN (TIMER2_PWMSTRG[0]).
 * |        |          |Note1: If TIMER0/1/2/3 PWM counter synchronous source are from TIMER0, TIME0_PWMSCTL[8], TIME1_PWMSCTL[8], TIME2_PWMSCTL[8] and TIME3_PWMSCTL[8] should be 0.
 * |        |          |Note2: If TIMER0/1/ PWM counter synchronous source are from TIMER0, TIME0_PWMSCTL[8] and TIME1_PWMSCTL[8] should be set 0, and TIMER2/3/ PWM counter synchronous source are from TIMER2, TIME2_PWMSCTL[8] and TIME3_PWMSCTL[8] should be set 1.[WH1]
 * |        |          |[WH1]Tag173
 * @var TMR23_T::PWMSSTRG
 * Offset: 0x198  Timer3 PWM Synchronous Start Trigger Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var TMR23_T::PWMSTATUS
 * Offset: 0x19C  Timer3 PWM Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CNTMAXF   |PWM Counter Equal to 0xFFFF Flag
 * |        |          |0 = Indicates the PWM counter value never reached its maximum value 0xFFFF.
 * |        |          |1 = Indicates the PWM counter value has reached its maximum value.
 * |        |          |Note: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag177
 * |[16]    |ADCTRGF   |Trigger ADC Start Conversion Flag
 * |        |          |0 = PWM counter event trigger ADC start conversion is not occurred.
 * |        |          |1 = PWM counter event trigger ADC start conversion has occurred.
 * |        |          |Note: This bit is cleared by writing 1 to it.[WH1]
 * |        |          |[WH1]Tag176
 * @var TMR23_T::PWMPBUF
 * Offset: 0x1A0  Timer3 PWM Period Buffer Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |PBUF      |PWM Period Buffer Register (Read Only)
 * |        |          |Used as PERIOD active register.[WH1]
 * |        |          |[WH1]Tag178
 * @var TMR23_T::PWMCMPBUF
 * Offset: 0x1A4  Timer3 PWM Comparator Buffer Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |CMPBUF    |PWM Comparator Buffer Register (Read Only)
 * |        |          |Used as CMP active register.[WH1]
 * |        |          |[WH1]Tag179
 */
    __IO uint32_t CTL;                   /*!< [0x0000] Timer2 Control Register                                          */
    __IO uint32_t CMP;                   /*!< [0x0004] Timer2 Comparator Register                                       */
    __IO uint32_t INTSTS;                /*!< [0x0008] Timer2 Interrupt Status Register                                 */
    __IO uint32_t CNT;                   /*!< [0x000c] Timer2 Data Register                                             */
    __I  uint32_t CAP;                   /*!< [0x0010] Timer2 Capture Data Register                                     */
    __IO uint32_t EXTCTL;                /*!< [0x0014] Timer2 External Control Register                                 */
    __IO uint32_t EINTSTS;               /*!< [0x0018] Timer2 External Interrupt Status Register                        */
    __IO uint32_t TRGCTL;                /*!< [0x001c] Timer2 Trigger Control Register                                  */
    __IO uint32_t ALTCTL;                /*!< [0x0020] Timer2 Alternative Control Register                              */
    __I  uint32_t RESERVE0[7];
    __IO uint32_t PWMCTL;                /*!< [0x0040] Timer2 PWM Control Register                                      */
    __IO uint32_t PWMCLKSRC;             /*!< [0x0044] Timer2 PWM Counter Clock Source Register                         */
    __IO uint32_t PWMCLKPSC;             /*!< [0x0048] Timer2 PWM Counter Clock Pre-scale Register                      */
    __IO uint32_t PWMCNTCLR;             /*!< [0x004c] Timer2 PWM Clear Counter Register                                */
    __IO uint32_t PWMPERIOD;             /*!< [0x0050] Timer2 PWM Period Register                                       */
    __IO uint32_t PWMCMPDAT;             /*!< [0x0054] Timer2 PWM Comparator Register                                   */
    __IO uint32_t PWMDTCTL;              /*!< [0x0058] Timer2 PWM Dead-Time Control Register                            */
    __I  uint32_t PWMCNT;                /*!< [0x005c] Timer2 PWM Counter Register                                      */
    __IO uint32_t PWMMSKEN;              /*!< [0x0060] Timer2 PWM Output Mask Enable Register                           */
    __IO uint32_t PWMMSK;                /*!< [0x0064] Timer2 PWM Output Mask Data Control Register                     */
    __IO uint32_t PWMBNF;                /*!< [0x0068] Timer2 PWM Brake Pin Noise Filter Register                       */
    __IO uint32_t PWMFAILBRK;            /*!< [0x006c] Timer2 PWM System Fail Brake Control Register                    */
    __IO uint32_t PWMBRKCTL;             /*!< [0x0070] Timer2 PWM Brake Control Register                                */
    __IO uint32_t PWMPOLCTL;             /*!< [0x0074] Timer2 PWM Pin Output Polar Control Register                     */
    __IO uint32_t PWMPOEN;               /*!< [0x0078] Timer2 PWM Pin Output Enable Register                            */
    __O  uint32_t PWMSWBRK;              /*!< [0x007c] Timer2 PWM Software Trigger Brake Control Register               */
    __IO uint32_t PWMINTEN0;             /*!< [0x0080] Timer2 PWM Interrupt Enable Register 0                           */
    __IO uint32_t PWMINTEN1;             /*!< [0x0084] Timer2 PWM Interrupt Enable Register 1                           */
    __IO uint32_t PWMINTSTS0;            /*!< [0x0088] Timer2 PWM Interrupt Status Register 0                           */
    __IO uint32_t PWMINTSTS1;            /*!< [0x008c] Timer2 PWM Interrupt Status Register 1                           */
    __IO uint32_t PWMADCTS;              /*!< [0x0090] Timer2 PWM ADC Trigger Source Select Register                    */
    __IO uint32_t PWMSCTL;               /*!< [0x0094] Timer2 PWM Synchronous Control Register                          */
    __O  uint32_t PWMSTRG;               /*!< [0x0098] Timer2 PWM Synchronous Trigger Register                          */
    __IO uint32_t PWMSTATUS;             /*!< [0x009c] Timer2 PWM Status Register                                       */
    __I  uint32_t PWMPBUF;               /*!< [0x00a0] Timer2 PWM Period Buffer Register                                */
    __I  uint32_t PWMCMPBUF;             /*!< [0x00a4] Timer2 PWM Comparator Buffer Register                            */
    __I  uint32_t RESERVE1[22];


} TMR23_T;

/**
    @addtogroup TMR23_CONST TMR23 Bit Field Definition
    Constant Definitions for TMR23 Controller
@{ */

#define TMR23_CTL_PSC_Pos                (0)                                               /*!< TMR23_T::CTL: PSC Position             */
#define TMR23_CTL_PSC_Msk                (0xfful << TMR23_CTL_PSC_Pos)                     /*!< TMR23_T::CTL: PSC Mask                 */

#define TMR23_CTL_INTRGEN_Pos            (19)                                              /*!< TMR23_T::CTL: INTRGEN Position         */
#define TMR23_CTL_INTRGEN_Msk            (0x1ul << TMR23_CTL_INTRGEN_Pos)                  /*!< TMR23_T::CTL: INTRGEN Mask             */

#define TMR23_CTL_PERIOSEL_Pos           (20)                                              /*!< TMR23_T::CTL: PERIOSEL Position        */
#define TMR23_CTL_PERIOSEL_Msk           (0x1ul << TMR23_CTL_PERIOSEL_Pos)                 /*!< TMR23_T::CTL: PERIOSEL Mask            */

#define TMR23_CTL_TGLPINSEL_Pos          (21)                                              /*!< TMR23_T::CTL: TGLPINSEL Position       */
#define TMR23_CTL_TGLPINSEL_Msk          (0x1ul << TMR23_CTL_TGLPINSEL_Pos)                /*!< TMR23_T::CTL: TGLPINSEL Mask           */

#define TMR23_CTL_CAPSRC_Pos             (22)                                              /*!< TMR23_T::CTL: CAPSRC Position          */
#define TMR23_CTL_CAPSRC_Msk             (0x1ul << TMR23_CTL_CAPSRC_Pos)                   /*!< TMR23_T::CTL: CAPSRC Mask              */

#define TMR23_CTL_WKEN_Pos               (23)                                              /*!< TMR23_T::CTL: WKEN Position            */
#define TMR23_CTL_WKEN_Msk               (0x1ul << TMR23_CTL_WKEN_Pos)                     /*!< TMR23_T::CTL: WKEN Mask                */

#define TMR23_CTL_EXTCNTEN_Pos           (24)                                              /*!< TMR23_T::CTL: EXTCNTEN Position        */
#define TMR23_CTL_EXTCNTEN_Msk           (0x1ul << TMR23_CTL_EXTCNTEN_Pos)                 /*!< TMR23_T::CTL: EXTCNTEN Mask            */

#define TMR23_CTL_ACTSTS_Pos             (25)                                              /*!< TMR23_T::CTL: ACTSTS Position          */
#define TMR23_CTL_ACTSTS_Msk             (0x1ul << TMR23_CTL_ACTSTS_Pos)                   /*!< TMR23_T::CTL: ACTSTS Mask              */

#define TMR23_CTL_RSTCNT_Pos             (26)                                              /*!< TMR23_T::CTL: RSTCNT Position          */
#define TMR23_CTL_RSTCNT_Msk             (0x1ul << TMR23_CTL_RSTCNT_Pos)                   /*!< TMR23_T::CTL: RSTCNT Mask              */

#define TMR23_CTL_OPMODE_Pos             (27)                                              /*!< TMR23_T::CTL: OPMODE Position          */
#define TMR23_CTL_OPMODE_Msk             (0x3ul << TMR23_CTL_OPMODE_Pos)                   /*!< TMR23_T::CTL: OPMODE Mask              */

#define TMR23_CTL_INTEN_Pos              (29)                                              /*!< TMR23_T::CTL: INTEN Position           */
#define TMR23_CTL_INTEN_Msk              (0x1ul << TMR23_CTL_INTEN_Pos)                    /*!< TMR23_T::CTL: INTEN Mask               */

#define TMR23_CTL_CNTEN_Pos              (30)                                              /*!< TMR23_T::CTL: CNTEN Position           */
#define TMR23_CTL_CNTEN_Msk              (0x1ul << TMR23_CTL_CNTEN_Pos)                    /*!< TMR23_T::CTL: CNTEN Mask               */

#define TMR23_CTL_ICEDEBUG_Pos           (31)                                              /*!< TMR23_T::CTL: ICEDEBUG Position        */
#define TMR23_CTL_ICEDEBUG_Msk           (0x1ul << TMR23_CTL_ICEDEBUG_Pos)                 /*!< TMR23_T::CTL: ICEDEBUG Mask            */

#define TMR23_CMP_CMPDAT_Pos             (0)                                               /*!< TMR23_T::CMP: CMPDAT Position          */
#define TMR23_CMP_CMPDAT_Msk             (0xfffffful << TMR23_CMP_CMPDAT_Pos)              /*!< TMR23_T::CMP: CMPDAT Mask              */

#define TMR23_INTSTS_TIF_Pos             (0)                                               /*!< TMR23_T::INTSTS: TIF Position          */
#define TMR23_INTSTS_TIF_Msk             (0x1ul << TMR23_INTSTS_TIF_Pos)                   /*!< TMR23_T::INTSTS: TIF Mask              */

#define TMR23_INTSTS_TWKF_Pos            (1)                                               /*!< TMR23_T::INTSTS: TWKF Position         */
#define TMR23_INTSTS_TWKF_Msk            (0x1ul << TMR23_INTSTS_TWKF_Pos)                  /*!< TMR23_T::INTSTS: TWKF Mask             */

#define TMR23_CNT_CNT_Pos                (0)                                               /*!< TMR23_T::CNT: CNT Position             */
#define TMR23_CNT_CNT_Msk                (0xfffffful << TMR23_CNT_CNT_Pos)                 /*!< TMR23_T::CNT: CNT Mask                 */

#define TMR23_CNT_RSTACT_Pos             (31)                                              /*!< TMR23_T::CNT: RSTACT Position          */
#define TMR23_CNT_RSTACT_Msk             (0x1ul << TMR23_CNT_RSTACT_Pos)                   /*!< TMR23_T::CNT: RSTACT Mask              */

#define TMR23_CAP_CAPDAT_Pos             (0)                                               /*!< TMR23_T::CAP: CAPDAT Position          */
#define TMR23_CAP_CAPDAT_Msk             (0xfffffful << TMR23_CAP_CAPDAT_Pos)              /*!< TMR23_T::CAP: CAPDAT Mask              */

#define TMR23_EXTCTL_CNTPHASE_Pos        (0)                                               /*!< TMR23_T::EXTCTL: CNTPHASE Position     */
#define TMR23_EXTCTL_CNTPHASE_Msk        (0x1ul << TMR23_EXTCTL_CNTPHASE_Pos)              /*!< TMR23_T::EXTCTL: CNTPHASE Mask         */

#define TMR23_EXTCTL_SCAPEDGE_Pos        (1)                                               /*!< TMR23_T::EXTCTL: SCAPEDGE Position     */
#define TMR23_EXTCTL_SCAPEDGE_Msk        (0x3ul << TMR23_EXTCTL_SCAPEDGE_Pos)              /*!< TMR23_T::EXTCTL: SCAPEDGE Mask         */

#define TMR23_EXTCTL_CAPEN_Pos           (3)                                               /*!< TMR23_T::EXTCTL: CAPEN Position        */
#define TMR23_EXTCTL_CAPEN_Msk           (0x1ul << TMR23_EXTCTL_CAPEN_Pos)                 /*!< TMR23_T::EXTCTL: CAPEN Mask            */

#define TMR23_EXTCTL_CAPFUNCS_Pos        (4)                                               /*!< TMR23_T::EXTCTL: CAPFUNCS Position     */
#define TMR23_EXTCTL_CAPFUNCS_Msk        (0x1ul << TMR23_EXTCTL_CAPFUNCS_Pos)              /*!< TMR23_T::EXTCTL: CAPFUNCS Mask         */

#define TMR23_EXTCTL_CAPIEN_Pos          (5)                                               /*!< TMR23_T::EXTCTL: CAPIEN Position       */
#define TMR23_EXTCTL_CAPIEN_Msk          (0x1ul << TMR23_EXTCTL_CAPIEN_Pos)                /*!< TMR23_T::EXTCTL: CAPIEN Mask           */

#define TMR23_EXTCTL_CAPDBEN_Pos         (6)                                               /*!< TMR23_T::EXTCTL: CAPDBEN Position      */
#define TMR23_EXTCTL_CAPDBEN_Msk         (0x1ul << TMR23_EXTCTL_CAPDBEN_Pos)               /*!< TMR23_T::EXTCTL: CAPDBEN Mask          */

#define TMR23_EXTCTL_CNTDBEN_Pos         (7)                                               /*!< TMR23_T::EXTCTL: CNTDBEN Position      */
#define TMR23_EXTCTL_CNTDBEN_Msk         (0x1ul << TMR23_EXTCTL_CNTDBEN_Pos)               /*!< TMR23_T::EXTCTL: CNTDBEN Mask          */

#define TMR23_EXTCTL_CAPEDGE_Pos         (12)                                              /*!< TMR23_T::EXTCTL: CAPEDGE Position      */
#define TMR23_EXTCTL_CAPEDGE_Msk         (0x7ul << TMR23_EXTCTL_CAPEDGE_Pos)               /*!< TMR23_T::EXTCTL: CAPEDGE Mask          */

#define TMR23_EXTCTL_ECNTSSEL_Pos        (16)                                              /*!< TMR23_T::EXTCTL: ECNTSSEL Position     */
#define TMR23_EXTCTL_ECNTSSEL_Msk        (0x1ul << TMR23_EXTCTL_ECNTSSEL_Pos)              /*!< TMR23_T::EXTCTL: ECNTSSEL Mask         */

#define TMR23_EINTSTS_CAPIF_Pos          (0)                                               /*!< TMR23_T::EINTSTS: CAPIF Position       */
#define TMR23_EINTSTS_CAPIF_Msk          (0x1ul << TMR23_EINTSTS_CAPIF_Pos)                /*!< TMR23_T::EINTSTS: CAPIF Mask           */

#define TMR23_TRGCTL_TRGSSEL_Pos         (0)                                               /*!< TMR23_T::TRGCTL: TRGSSEL Position      */
#define TMR23_TRGCTL_TRGSSEL_Msk         (0x1ul << TMR23_TRGCTL_TRGSSEL_Pos)               /*!< TMR23_T::TRGCTL: TRGSSEL Mask          */

#define TMR23_TRGCTL_TRGPWM_Pos          (1)                                               /*!< TMR23_T::TRGCTL: TRGPWM Position       */
#define TMR23_TRGCTL_TRGPWM_Msk          (0x1ul << TMR23_TRGCTL_TRGPWM_Pos)                /*!< TMR23_T::TRGCTL: TRGPWM Mask           */

#define TMR23_TRGCTL_TRGADC_Pos          (2)                                               /*!< TMR23_T::TRGCTL: TRGADC Position       */
#define TMR23_TRGCTL_TRGADC_Msk          (0x1ul << TMR23_TRGCTL_TRGADC_Pos)                /*!< TMR23_T::TRGCTL: TRGADC Mask           */

#define TMR23_TRGCTL_TRGPDMA_Pos         (4)                                               /*!< TMR23_T::TRGCTL: TRGPDMA Position      */
#define TMR23_TRGCTL_TRGPDMA_Msk         (0x1ul << TMR23_TRGCTL_TRGPDMA_Pos)               /*!< TMR23_T::TRGCTL: TRGPDMA Mask          */

#define TMR23_ALTCTL_FUNCSEL_Pos         (0)                                               /*!< TMR23_T::ALTCTL: FUNCSEL Position      */
#define TMR23_ALTCTL_FUNCSEL_Msk         (0x1ul << TMR23_ALTCTL_FUNCSEL_Pos)               /*!< TMR23_T::ALTCTL: FUNCSEL Mask          */

#define TMR23_PWMCTL_CNTEN_Pos           (0)                                               /*!< TMR23_T::PWMCTL: CNTEN Position        */
#define TMR23_PWMCTL_CNTEN_Msk           (0x1ul << TMR23_PWMCTL_CNTEN_Pos)                 /*!< TMR23_T::PWMCTL: CNTEN Mask            */

#define TMR23_PWMCTL_CNTTYPE_Pos         (1)                                               /*!< TMR23_T::PWMCTL: CNTTYPE Position      */
#define TMR23_PWMCTL_CNTTYPE_Msk         (0x3ul << TMR23_PWMCTL_CNTTYPE_Pos)               /*!< TMR23_T::PWMCTL: CNTTYPE Mask          */

#define TMR23_PWMCTL_CNTMODE_Pos         (3)                                               /*!< TMR23_T::PWMCTL: CNTMODE Position      */
#define TMR23_PWMCTL_CNTMODE_Msk         (0x1ul << TMR23_PWMCTL_CNTMODE_Pos)               /*!< TMR23_T::PWMCTL: CNTMODE Mask          */

#define TMR23_PWMCTL_CTRLD_Pos           (8)                                               /*!< TMR23_T::PWMCTL: CTRLD Position        */
#define TMR23_PWMCTL_CTRLD_Msk           (0x1ul << TMR23_PWMCTL_CTRLD_Pos)                 /*!< TMR23_T::PWMCTL: CTRLD Mask            */

#define TMR23_PWMCTL_IMMLDEN_Pos         (9)                                               /*!< TMR23_T::PWMCTL: IMMLDEN Position      */
#define TMR23_PWMCTL_IMMLDEN_Msk         (0x1ul << TMR23_PWMCTL_IMMLDEN_Pos)               /*!< TMR23_T::PWMCTL: IMMLDEN Mask          */

#define TMR23_PWMCTL_OUTMODE_Pos         (16)                                              /*!< TMR23_T::PWMCTL: OUTMODE Position      */
#define TMR23_PWMCTL_OUTMODE_Msk         (0x1ul << TMR23_PWMCTL_OUTMODE_Pos)               /*!< TMR23_T::PWMCTL: OUTMODE Mask          */

#define TMR23_PWMCTL_DBGHALT_Pos         (30)                                              /*!< TMR23_T::PWMCTL: DBGHALT Position      */
#define TMR23_PWMCTL_DBGHALT_Msk         (0x1ul << TMR23_PWMCTL_DBGHALT_Pos)               /*!< TMR23_T::PWMCTL: DBGHALT Mask          */

#define TMR23_PWMCTL_DBGTRIOFF_Pos       (31)                                              /*!< TMR23_T::PWMCTL: DBGTRIOFF Position    */
#define TMR23_PWMCTL_DBGTRIOFF_Msk       (0x1ul << TMR23_PWMCTL_DBGTRIOFF_Pos)             /*!< TMR23_T::PWMCTL: DBGTRIOFF Mask        */

#define TMR23_PWMCLKSRC_CLKSRC_Pos       (0)                                               /*!< TMR23_T::PWMCLKSRC: CLKSRC Position    */
#define TMR23_PWMCLKSRC_CLKSRC_Msk       (0x7ul << TMR23_PWMCLKSRC_CLKSRC_Pos)             /*!< TMR23_T::PWMCLKSRC: CLKSRC Mask        */

#define TMR23_PWMCLKPSC_CLKPSC_Pos       (0)                                               /*!< TMR23_T::PWMCLKPSC: CLKPSC Position    */
#define TMR23_PWMCLKPSC_CLKPSC_Msk       (0xffful << TMR23_PWMCLKPSC_CLKPSC_Pos)           /*!< TMR23_T::PWMCLKPSC: CLKPSC Mask        */

#define TMR23_PWMCNTCLR_CNTCLR_Pos       (0)                                               /*!< TMR23_T::PWMCNTCLR: CNTCLR Position    */
#define TMR23_PWMCNTCLR_CNTCLR_Msk       (0x1ul << TMR23_PWMCNTCLR_CNTCLR_Pos)             /*!< TMR23_T::PWMCNTCLR: CNTCLR Mask        */

#define TMR23_PWMPERIOD_PERIOD_Pos       (0)                                               /*!< TMR23_T::PWMPERIOD: PERIOD Position    */
#define TMR23_PWMPERIOD_PERIOD_Msk       (0xfffful << TMR23_PWMPERIOD_PERIOD_Pos)          /*!< TMR23_T::PWMPERIOD: PERIOD Mask        */

#define TMR23_PWMCMPDAT_CMP_Pos          (0)                                               /*!< TMR23_T::PWMCMPDAT: CMP Position       */
#define TMR23_PWMCMPDAT_CMP_Msk          (0xfffful << TMR23_PWMCMPDAT_CMP_Pos)             /*!< TMR23_T::PWMCMPDAT: CMP Mask           */

#define TMR23_PWMDTCTL_DTCNT_Pos         (0)                                               /*!< TMR23_T::PWMDTCTL: DTCNT Position      */
#define TMR23_PWMDTCTL_DTCNT_Msk         (0xffful << TMR23_PWMDTCTL_DTCNT_Pos)             /*!< TMR23_T::PWMDTCTL: DTCNT Mask          */

#define TMR23_PWMDTCTL_DTEN_Pos          (16)                                              /*!< TMR23_T::PWMDTCTL: DTEN Position       */
#define TMR23_PWMDTCTL_DTEN_Msk          (0x1ul << TMR23_PWMDTCTL_DTEN_Pos)                /*!< TMR23_T::PWMDTCTL: DTEN Mask           */

#define TMR23_PWMDTCTL_DTCKSEL_Pos       (24)                                              /*!< TMR23_T::PWMDTCTL: DTCKSEL Position    */
#define TMR23_PWMDTCTL_DTCKSEL_Msk       (0x1ul << TMR23_PWMDTCTL_DTCKSEL_Pos)             /*!< TMR23_T::PWMDTCTL: DTCKSEL Mask        */

#define TMR23_PWMCNT_CNT_Pos             (0)                                               /*!< TMR23_T::PWMCNT: CNT Position          */
#define TMR23_PWMCNT_CNT_Msk             (0xfffful << TMR23_PWMCNT_CNT_Pos)                /*!< TMR23_T::PWMCNT: CNT Mask              */

#define TMR23_PWMCNT_DIRF_Pos            (16)                                              /*!< TMR23_T::PWMCNT: DIRF Position         */
#define TMR23_PWMCNT_DIRF_Msk            (0x1ul << TMR23_PWMCNT_DIRF_Pos)                  /*!< TMR23_T::PWMCNT: DIRF Mask             */

#define TMR23_PWMMSKEN_MSKEN0_Pos        (0)                                               /*!< TMR23_T::PWMMSKEN: MSKEN0 Position     */
#define TMR23_PWMMSKEN_MSKEN0_Msk        (0x1ul << TMR23_PWMMSKEN_MSKEN0_Pos)              /*!< TMR23_T::PWMMSKEN: MSKEN0 Mask         */

#define TMR23_PWMMSKEN_MSKEN1_Pos        (1)                                               /*!< TMR23_T::PWMMSKEN: MSKEN1 Position     */
#define TMR23_PWMMSKEN_MSKEN1_Msk        (0x1ul << TMR23_PWMMSKEN_MSKEN1_Pos)              /*!< TMR23_T::PWMMSKEN: MSKEN1 Mask         */

#define TMR23_PWMMSK_MSKDAT0_Pos         (0)                                               /*!< TMR23_T::PWMMSK: MSKDAT0 Position      */
#define TMR23_PWMMSK_MSKDAT0_Msk         (0x1ul << TMR23_PWMMSK_MSKDAT0_Pos)               /*!< TMR23_T::PWMMSK: MSKDAT0 Mask          */

#define TMR23_PWMMSK_MSKDAT1_Pos         (1)                                               /*!< TMR23_T::PWMMSK: MSKDAT1 Position      */
#define TMR23_PWMMSK_MSKDAT1_Msk         (0x1ul << TMR23_PWMMSK_MSKDAT1_Pos)               /*!< TMR23_T::PWMMSK: MSKDAT1 Mask          */

#define TMR23_PWMBNF_BRKNFEN_Pos         (0)                                               /*!< TMR23_T::PWMBNF: BRKNFEN Position      */
#define TMR23_PWMBNF_BRKNFEN_Msk         (0x1ul << TMR23_PWMBNF_BRKNFEN_Pos)               /*!< TMR23_T::PWMBNF: BRKNFEN Mask          */

#define TMR23_PWMBNF_BRKNFSEL_Pos        (1)                                               /*!< TMR23_T::PWMBNF: BRKNFSEL Position     */
#define TMR23_PWMBNF_BRKNFSEL_Msk        (0x7ul << TMR23_PWMBNF_BRKNFSEL_Pos)              /*!< TMR23_T::PWMBNF: BRKNFSEL Mask         */

#define TMR23_PWMBNF_BRKFCNT_Pos         (4)                                               /*!< TMR23_T::PWMBNF: BRKFCNT Position      */
#define TMR23_PWMBNF_BRKFCNT_Msk         (0x7ul << TMR23_PWMBNF_BRKFCNT_Pos)               /*!< TMR23_T::PWMBNF: BRKFCNT Mask          */

#define TMR23_PWMBNF_BRKPINV_Pos         (7)                                               /*!< TMR23_T::PWMBNF: BRKPINV Position      */
#define TMR23_PWMBNF_BRKPINV_Msk         (0x1ul << TMR23_PWMBNF_BRKPINV_Pos)               /*!< TMR23_T::PWMBNF: BRKPINV Mask          */

#define TMR23_PWMBNF_BKPINSRC_Pos        (16)                                              /*!< TMR23_T::PWMBNF: BKPINSRC Position     */
#define TMR23_PWMBNF_BKPINSRC_Msk        (0x3ul << TMR23_PWMBNF_BKPINSRC_Pos)              /*!< TMR23_T::PWMBNF: BKPINSRC Mask         */

#define TMR23_PWMFAILBRK_CSSBRKEN_Pos    (0)                                               /*!< TMR23_T::PWMFAILBRK: CSSBRKEN Position */
#define TMR23_PWMFAILBRK_CSSBRKEN_Msk    (0x1ul << TMR23_PWMFAILBRK_CSSBRKEN_Pos)          /*!< TMR23_T::PWMFAILBRK: CSSBRKEN Mask     */

#define TMR23_PWMFAILBRK_BODBRKEN_Pos    (1)                                               /*!< TMR23_T::PWMFAILBRK: BODBRKEN Position */
#define TMR23_PWMFAILBRK_BODBRKEN_Msk    (0x1ul << TMR23_PWMFAILBRK_BODBRKEN_Pos)          /*!< TMR23_T::PWMFAILBRK: BODBRKEN Mask     */

#define TMR23_PWMFAILBRK_RAMBRKEN_Pos    (2)                                               /*!< TMR23_T::PWMFAILBRK: RAMBRKEN Position */
#define TMR23_PWMFAILBRK_RAMBRKEN_Msk    (0x1ul << TMR23_PWMFAILBRK_RAMBRKEN_Pos)          /*!< TMR23_T::PWMFAILBRK: RAMBRKEN Mask     */

#define TMR23_PWMFAILBRK_CORBRKEN_Pos    (3)                                               /*!< TMR23_T::PWMFAILBRK: CORBRKEN Position */
#define TMR23_PWMFAILBRK_CORBRKEN_Msk    (0x1ul << TMR23_PWMFAILBRK_CORBRKEN_Pos)          /*!< TMR23_T::PWMFAILBRK: CORBRKEN Mask     */

#define TMR23_PWMBRKCTL_BRKPEEN_Pos      (4)                                               /*!< TMR23_T::PWMBRKCTL: BRKPEEN Position   */
#define TMR23_PWMBRKCTL_BRKPEEN_Msk      (0x1ul << TMR23_PWMBRKCTL_BRKPEEN_Pos)            /*!< TMR23_T::PWMBRKCTL: BRKPEEN Mask       */

#define TMR23_PWMBRKCTL_SYSEBEN_Pos      (7)                                               /*!< TMR23_T::PWMBRKCTL: SYSEBEN Position   */
#define TMR23_PWMBRKCTL_SYSEBEN_Msk      (0x1ul << TMR23_PWMBRKCTL_SYSEBEN_Pos)            /*!< TMR23_T::PWMBRKCTL: SYSEBEN Mask       */

#define TMR23_PWMBRKCTL_BRKPLEN_Pos      (12)                                              /*!< TMR23_T::PWMBRKCTL: BRKPLEN Position   */
#define TMR23_PWMBRKCTL_BRKPLEN_Msk      (0x1ul << TMR23_PWMBRKCTL_BRKPLEN_Pos)            /*!< TMR23_T::PWMBRKCTL: BRKPLEN Mask       */

#define TMR23_PWMBRKCTL_SYSLBEN_Pos      (15)                                              /*!< TMR23_T::PWMBRKCTL: SYSLBEN Position   */
#define TMR23_PWMBRKCTL_SYSLBEN_Msk      (0x1ul << TMR23_PWMBRKCTL_SYSLBEN_Pos)            /*!< TMR23_T::PWMBRKCTL: SYSLBEN Mask       */

#define TMR23_PWMBRKCTL_BRKAEVEN_Pos     (16)                                              /*!< TMR23_T::PWMBRKCTL: BRKAEVEN Position  */
#define TMR23_PWMBRKCTL_BRKAEVEN_Msk     (0x3ul << TMR23_PWMBRKCTL_BRKAEVEN_Pos)           /*!< TMR23_T::PWMBRKCTL: BRKAEVEN Mask      */

#define TMR23_PWMBRKCTL_BRKAODD_Pos      (18)                                              /*!< TMR23_T::PWMBRKCTL: BRKAODD Position   */
#define TMR23_PWMBRKCTL_BRKAODD_Msk      (0x3ul << TMR23_PWMBRKCTL_BRKAODD_Pos)            /*!< TMR23_T::PWMBRKCTL: BRKAODD Mask       */

#define TMR23_PWMPOLCTL_PINV0_Pos        (0)                                               /*!< TMR23_T::PWMPOLCTL: PINV0 Position     */
#define TMR23_PWMPOLCTL_PINV0_Msk        (0x1ul << TMR23_PWMPOLCTL_PINV0_Pos)              /*!< TMR23_T::PWMPOLCTL: PINV0 Mask         */

#define TMR23_PWMPOLCTL_PINV1_Pos        (1)                                               /*!< TMR23_T::PWMPOLCTL: PINV1 Position     */
#define TMR23_PWMPOLCTL_PINV1_Msk        (0x1ul << TMR23_PWMPOLCTL_PINV1_Pos)              /*!< TMR23_T::PWMPOLCTL: PINV1 Mask         */

#define TMR23_PWMPOEN_POEN0_Pos          (0)                                               /*!< TMR23_T::PWMPOEN: POEN0 Position       */
#define TMR23_PWMPOEN_POEN0_Msk          (0x1ul << TMR23_PWMPOEN_POEN0_Pos)                /*!< TMR23_T::PWMPOEN: POEN0 Mask           */

#define TMR23_PWMPOEN_POEN1_Pos          (1)                                               /*!< TMR23_T::PWMPOEN: POEN1 Position       */
#define TMR23_PWMPOEN_POEN1_Msk          (0x1ul << TMR23_PWMPOEN_POEN1_Pos)                /*!< TMR23_T::PWMPOEN: POEN1 Mask           */

#define TMR23_PWMSWBRK_BRKETRG_Pos       (0)                                               /*!< TMR23_T::PWMSWBRK: BRKETRG Position    */
#define TMR23_PWMSWBRK_BRKETRG_Msk       (0x1ul << TMR23_PWMSWBRK_BRKETRG_Pos)             /*!< TMR23_T::PWMSWBRK: BRKETRG Mask        */

#define TMR23_PWMSWBRK_BRKLTRG_Pos       (8)                                               /*!< TMR23_T::PWMSWBRK: BRKLTRG Position    */
#define TMR23_PWMSWBRK_BRKLTRG_Msk       (0x1ul << TMR23_PWMSWBRK_BRKLTRG_Pos)             /*!< TMR23_T::PWMSWBRK: BRKLTRG Mask        */

#define TMR23_PWMINTEN0_ZIEN_Pos         (0)                                               /*!< TMR23_T::PWMINTEN0: ZIEN Position      */
#define TMR23_PWMINTEN0_ZIEN_Msk         (0x1ul << TMR23_PWMINTEN0_ZIEN_Pos)               /*!< TMR23_T::PWMINTEN0: ZIEN Mask          */

#define TMR23_PWMINTEN0_PIEN_Pos         (1)                                               /*!< TMR23_T::PWMINTEN0: PIEN Position      */
#define TMR23_PWMINTEN0_PIEN_Msk         (0x1ul << TMR23_PWMINTEN0_PIEN_Pos)               /*!< TMR23_T::PWMINTEN0: PIEN Mask          */

#define TMR23_PWMINTEN0_CMPUIEN_Pos      (2)                                               /*!< TMR23_T::PWMINTEN0: CMPUIEN Position   */
#define TMR23_PWMINTEN0_CMPUIEN_Msk      (0x1ul << TMR23_PWMINTEN0_CMPUIEN_Pos)            /*!< TMR23_T::PWMINTEN0: CMPUIEN Mask       */

#define TMR23_PWMINTEN0_CMPDIEN_Pos      (3)                                               /*!< TMR23_T::PWMINTEN0: CMPDIEN Position   */
#define TMR23_PWMINTEN0_CMPDIEN_Msk      (0x1ul << TMR23_PWMINTEN0_CMPDIEN_Pos)            /*!< TMR23_T::PWMINTEN0: CMPDIEN Mask       */

#define TMR23_PWMINTEN1_BRKEIEN_Pos      (0)                                               /*!< TMR23_T::PWMINTEN1: BRKEIEN Position   */
#define TMR23_PWMINTEN1_BRKEIEN_Msk      (0x1ul << TMR23_PWMINTEN1_BRKEIEN_Pos)            /*!< TMR23_T::PWMINTEN1: BRKEIEN Mask       */

#define TMR23_PWMINTEN1_BRKLIEN_Pos      (8)                                               /*!< TMR23_T::PWMINTEN1: BRKLIEN Position   */
#define TMR23_PWMINTEN1_BRKLIEN_Msk      (0x1ul << TMR23_PWMINTEN1_BRKLIEN_Pos)            /*!< TMR23_T::PWMINTEN1: BRKLIEN Mask       */

#define TMR23_PWMINTSTS0_ZIF_Pos         (0)                                               /*!< TMR23_T::PWMINTSTS0: ZIF Position      */
#define TMR23_PWMINTSTS0_ZIF_Msk         (0x1ul << TMR23_PWMINTSTS0_ZIF_Pos)               /*!< TMR23_T::PWMINTSTS0: ZIF Mask          */

#define TMR23_PWMINTSTS0_PIF_Pos         (1)                                               /*!< TMR23_T::PWMINTSTS0: PIF Position      */
#define TMR23_PWMINTSTS0_PIF_Msk         (0x1ul << TMR23_PWMINTSTS0_PIF_Pos)               /*!< TMR23_T::PWMINTSTS0: PIF Mask          */

#define TMR23_PWMINTSTS0_CMPUIF_Pos      (2)                                               /*!< TMR23_T::PWMINTSTS0: CMPUIF Position   */
#define TMR23_PWMINTSTS0_CMPUIF_Msk      (0x1ul << TMR23_PWMINTSTS0_CMPUIF_Pos)            /*!< TMR23_T::PWMINTSTS0: CMPUIF Mask       */

#define TMR23_PWMINTSTS0_CMPDIF_Pos      (3)                                               /*!< TMR23_T::PWMINTSTS0: CMPDIF Position   */
#define TMR23_PWMINTSTS0_CMPDIF_Msk      (0x1ul << TMR23_PWMINTSTS0_CMPDIF_Pos)            /*!< TMR23_T::PWMINTSTS0: CMPDIF Mask       */

#define TMR23_PWMINTSTS1_BRKEIF0_Pos     (0)                                               /*!< TMR23_T::PWMINTSTS1: BRKEIF0 Position  */
#define TMR23_PWMINTSTS1_BRKEIF0_Msk     (0x1ul << TMR23_PWMINTSTS1_BRKEIF0_Pos)           /*!< TMR23_T::PWMINTSTS1: BRKEIF0 Mask      */

#define TMR23_PWMINTSTS1_BRKEIF1_Pos     (1)                                               /*!< TMR23_T::PWMINTSTS1: BRKEIF1 Position  */
#define TMR23_PWMINTSTS1_BRKEIF1_Msk     (0x1ul << TMR23_PWMINTSTS1_BRKEIF1_Pos)           /*!< TMR23_T::PWMINTSTS1: BRKEIF1 Mask      */

#define TMR23_PWMINTSTS1_BRKLIF0_Pos     (8)                                               /*!< TMR23_T::PWMINTSTS1: BRKLIF0 Position  */
#define TMR23_PWMINTSTS1_BRKLIF0_Msk     (0x1ul << TMR23_PWMINTSTS1_BRKLIF0_Pos)           /*!< TMR23_T::PWMINTSTS1: BRKLIF0 Mask      */

#define TMR23_PWMINTSTS1_BRKLIF1_Pos     (9)                                               /*!< TMR23_T::PWMINTSTS1: BRKLIF1 Position  */
#define TMR23_PWMINTSTS1_BRKLIF1_Msk     (0x1ul << TMR23_PWMINTSTS1_BRKLIF1_Pos)           /*!< TMR23_T::PWMINTSTS1: BRKLIF1 Mask      */

#define TMR23_PWMINTSTS1_BRKESTS0_Pos    (16)                                              /*!< TMR23_T::PWMINTSTS1: BRKESTS0 Position */
#define TMR23_PWMINTSTS1_BRKESTS0_Msk    (0x1ul << TMR23_PWMINTSTS1_BRKESTS0_Pos)          /*!< TMR23_T::PWMINTSTS1: BRKESTS0 Mask     */

#define TMR23_PWMINTSTS1_BRKESTS1_Pos    (17)                                              /*!< TMR23_T::PWMINTSTS1: BRKESTS1 Position */
#define TMR23_PWMINTSTS1_BRKESTS1_Msk    (0x1ul << TMR23_PWMINTSTS1_BRKESTS1_Pos)          /*!< TMR23_T::PWMINTSTS1: BRKESTS1 Mask     */

#define TMR23_PWMINTSTS1_BRKLSTS0_Pos    (24)                                              /*!< TMR23_T::PWMINTSTS1: BRKLSTS0 Position */
#define TMR23_PWMINTSTS1_BRKLSTS0_Msk    (0x1ul << TMR23_PWMINTSTS1_BRKLSTS0_Pos)          /*!< TMR23_T::PWMINTSTS1: BRKLSTS0 Mask     */

#define TMR23_PWMINTSTS1_BRKLSTS1_Pos    (25)                                              /*!< TMR23_T::PWMINTSTS1: BRKLSTS1 Position */
#define TMR23_PWMINTSTS1_BRKLSTS1_Msk    (0x1ul << TMR23_PWMINTSTS1_BRKLSTS1_Pos)          /*!< TMR23_T::PWMINTSTS1: BRKLSTS1 Mask     */

#define TMR23_PWMADCTS_TRGSEL_Pos        (0)                                               /*!< TMR23_T::PWMADCTS: TRGSEL Position     */
#define TMR23_PWMADCTS_TRGSEL_Msk        (0x7ul << TMR23_PWMADCTS_TRGSEL_Pos)              /*!< TMR23_T::PWMADCTS: TRGSEL Mask         */

#define TMR23_PWMADCTS_TRGEN_Pos         (7)                                               /*!< TMR23_T::PWMADCTS: TRGEN Position      */
#define TMR23_PWMADCTS_TRGEN_Msk         (0x1ul << TMR23_PWMADCTS_TRGEN_Pos)               /*!< TMR23_T::PWMADCTS: TRGEN Mask          */

#define TMR23_PWMSCTL_SYNCMODE_Pos       (0)                                               /*!< TMR23_T::PWMSCTL: SYNCMODE Position    */
#define TMR23_PWMSCTL_SYNCMODE_Msk       (0x3ul << TMR23_PWMSCTL_SYNCMODE_Pos)             /*!< TMR23_T::PWMSCTL: SYNCMODE Mask        */

#define TMR23_PWMSCTL_SYNCSRC_Pos        (8)                                               /*!< TMR23_T::PWMSCTL: SYNCSRC Position     */
#define TMR23_PWMSCTL_SYNCSRC_Msk        (0x1ul << TMR23_PWMSCTL_SYNCSRC_Pos)              /*!< TMR23_T::PWMSCTL: SYNCSRC Mask         */

#define TMR23_PWMSTRG_STRGEN_Pos         (0)                                               /*!< TMR23_T::PWMSTRG: STRGEN Position      */
#define TMR23_PWMSTRG_STRGEN_Msk         (0x1ul << TMR23_PWMSTRG_STRGEN_Pos)               /*!< TMR23_T::PWMSTRG: STRGEN Mask          */

#define TMR23_PWMSTATUS_CNTMAXF_Pos      (0)                                               /*!< TMR23_T::PWMSTATUS: CNTMAXF Position   */
#define TMR23_PWMSTATUS_CNTMAXF_Msk      (0x1ul << TMR23_PWMSTATUS_CNTMAXF_Pos)            /*!< TMR23_T::PWMSTATUS: CNTMAXF Mask       */

#define TMR23_PWMSTATUS_ADCTRGF_Pos      (16)                                              /*!< TMR23_T::PWMSTATUS: ADCTRGF Position   */
#define TMR23_PWMSTATUS_ADCTRGF_Msk      (0x1ul << TMR23_PWMSTATUS_ADCTRGF_Pos)            /*!< TMR23_T::PWMSTATUS: ADCTRGF Mask       */

#define TMR23_PWMPBUF_PBUF_Pos           (0)                                               /*!< TMR23_T::PWMPBUF: PBUF Position        */
#define TMR23_PWMPBUF_PBUF_Msk           (0xfffful << TMR23_PWMPBUF_PBUF_Pos)              /*!< TMR23_T::PWMPBUF: PBUF Mask            */

#define TMR23_PWMCMPBUF_CMPBUF_Pos       (0)                                               /*!< TMR23_T::PWMCMPBUF: CMPBUF Position    */
#define TMR23_PWMCMPBUF_CMPBUF_Msk       (0xfffful << TMR23_PWMCMPBUF_CMPBUF_Pos)          /*!< TMR23_T::PWMCMPBUF: CMPBUF Mask        */

#define TMR23_CTL_PSC_Pos                (0)                                               /*!< TMR23_T::CTL: PSC Position             */
#define TMR23_CTL_PSC_Msk                (0xfful << TMR23_CTL_PSC_Pos)                     /*!< TMR23_T::CTL: PSC Mask                 */

#define TMR23_CTL_INTRGEN_Pos            (19)                                              /*!< TMR23_T::CTL: INTRGEN Position         */
#define TMR23_CTL_INTRGEN_Msk            (0x1ul << TMR23_CTL_INTRGEN_Pos)                  /*!< TMR23_T::CTL: INTRGEN Mask             */

#define TMR23_CTL_PERIOSEL_Pos           (20)                                              /*!< TMR23_T::CTL: PERIOSEL Position        */
#define TMR23_CTL_PERIOSEL_Msk           (0x1ul << TMR23_CTL_PERIOSEL_Pos)                 /*!< TMR23_T::CTL: PERIOSEL Mask            */

#define TMR23_CTL_TGLPINSEL_Pos          (21)                                              /*!< TMR23_T::CTL: TGLPINSEL Position       */
#define TMR23_CTL_TGLPINSEL_Msk          (0x1ul << TMR23_CTL_TGLPINSEL_Pos)                /*!< TMR23_T::CTL: TGLPINSEL Mask           */

#define TMR23_CTL_CAPSRC_Pos             (22)                                              /*!< TMR23_T::CTL: CAPSRC Position          */
#define TMR23_CTL_CAPSRC_Msk             (0x1ul << TMR23_CTL_CAPSRC_Pos)                   /*!< TMR23_T::CTL: CAPSRC Mask              */

#define TMR23_CTL_WKEN_Pos               (23)                                              /*!< TMR23_T::CTL: WKEN Position            */
#define TMR23_CTL_WKEN_Msk               (0x1ul << TMR23_CTL_WKEN_Pos)                     /*!< TMR23_T::CTL: WKEN Mask                */

#define TMR23_CTL_EXTCNTEN_Pos           (24)                                              /*!< TMR23_T::CTL: EXTCNTEN Position        */
#define TMR23_CTL_EXTCNTEN_Msk           (0x1ul << TMR23_CTL_EXTCNTEN_Pos)                 /*!< TMR23_T::CTL: EXTCNTEN Mask            */

#define TMR23_CTL_ACTSTS_Pos             (25)                                              /*!< TMR23_T::CTL: ACTSTS Position          */
#define TMR23_CTL_ACTSTS_Msk             (0x1ul << TMR23_CTL_ACTSTS_Pos)                   /*!< TMR23_T::CTL: ACTSTS Mask              */

#define TMR23_CTL_RSTCNT_Pos             (26)                                              /*!< TMR23_T::CTL: RSTCNT Position          */
#define TMR23_CTL_RSTCNT_Msk             (0x1ul << TMR23_CTL_RSTCNT_Pos)                   /*!< TMR23_T::CTL: RSTCNT Mask              */

#define TMR23_CTL_OPMODE_Pos             (27)                                              /*!< TMR23_T::CTL: OPMODE Position          */
#define TMR23_CTL_OPMODE_Msk             (0x3ul << TMR23_CTL_OPMODE_Pos)                   /*!< TMR23_T::CTL: OPMODE Mask              */

#define TMR23_CTL_INTEN_Pos              (29)                                              /*!< TMR23_T::CTL: INTEN Position           */
#define TMR23_CTL_INTEN_Msk              (0x1ul << TMR23_CTL_INTEN_Pos)                    /*!< TMR23_T::CTL: INTEN Mask               */

#define TMR23_CTL_CNTEN_Pos              (30)                                              /*!< TMR23_T::CTL: CNTEN Position           */
#define TMR23_CTL_CNTEN_Msk              (0x1ul << TMR23_CTL_CNTEN_Pos)                    /*!< TMR23_T::CTL: CNTEN Mask               */

#define TMR23_CTL_ICEDEBUG_Pos           (31)                                              /*!< TMR23_T::CTL: ICEDEBUG Position        */
#define TMR23_CTL_ICEDEBUG_Msk           (0x1ul << TMR23_CTL_ICEDEBUG_Pos)                 /*!< TMR23_T::CTL: ICEDEBUG Mask            */

#define TMR23_CMP_CMPDAT_Pos             (0)                                               /*!< TMR23_T::CMP: CMPDAT Position          */
#define TMR23_CMP_CMPDAT_Msk             (0xfffffful << TMR23_CMP_CMPDAT_Pos)              /*!< TMR23_T::CMP: CMPDAT Mask              */

#define TMR23_INTSTS_TIF_Pos             (0)                                               /*!< TMR23_T::INTSTS: TIF Position          */
#define TMR23_INTSTS_TIF_Msk             (0x1ul << TMR23_INTSTS_TIF_Pos)                   /*!< TMR23_T::INTSTS: TIF Mask              */

#define TMR23_INTSTS_TWKF_Pos            (1)                                               /*!< TMR23_T::INTSTS: TWKF Position         */
#define TMR23_INTSTS_TWKF_Msk            (0x1ul << TMR23_INTSTS_TWKF_Pos)                  /*!< TMR23_T::INTSTS: TWKF Mask             */

#define TMR23_CNT_CNT_Pos                (0)                                               /*!< TMR23_T::CNT: CNT Position             */
#define TMR23_CNT_CNT_Msk                (0xfffffful << TMR23_CNT_CNT_Pos)                 /*!< TMR23_T::CNT: CNT Mask                 */

#define TMR23_CNT_RSTACT_Pos             (31)                                              /*!< TMR23_T::CNT: RSTACT Position          */
#define TMR23_CNT_RSTACT_Msk             (0x1ul << TMR23_CNT_RSTACT_Pos)                   /*!< TMR23_T::CNT: RSTACT Mask              */

#define TMR23_CAP_CAPDAT_Pos             (0)                                               /*!< TMR23_T::CAP: CAPDAT Position          */
#define TMR23_CAP_CAPDAT_Msk             (0xfffffful << TMR23_CAP_CAPDAT_Pos)              /*!< TMR23_T::CAP: CAPDAT Mask              */

#define TMR23_EXTCTL_CNTPHASE_Pos        (0)                                               /*!< TMR23_T::EXTCTL: CNTPHASE Position     */
#define TMR23_EXTCTL_CNTPHASE_Msk        (0x1ul << TMR23_EXTCTL_CNTPHASE_Pos)              /*!< TMR23_T::EXTCTL: CNTPHASE Mask         */

#define TMR23_EXTCTL_SCAPEDGE_Pos        (1)                                               /*!< TMR23_T::EXTCTL: SCAPEDGE Position     */
#define TMR23_EXTCTL_SCAPEDGE_Msk        (0x3ul << TMR23_EXTCTL_SCAPEDGE_Pos)              /*!< TMR23_T::EXTCTL: SCAPEDGE Mask         */

#define TMR23_EXTCTL_CAPEN_Pos           (3)                                               /*!< TMR23_T::EXTCTL: CAPEN Position        */
#define TMR23_EXTCTL_CAPEN_Msk           (0x1ul << TMR23_EXTCTL_CAPEN_Pos)                 /*!< TMR23_T::EXTCTL: CAPEN Mask            */

#define TMR23_EXTCTL_CAPFUNCS_Pos        (4)                                               /*!< TMR23_T::EXTCTL: CAPFUNCS Position     */
#define TMR23_EXTCTL_CAPFUNCS_Msk        (0x1ul << TMR23_EXTCTL_CAPFUNCS_Pos)              /*!< TMR23_T::EXTCTL: CAPFUNCS Mask         */

#define TMR23_EXTCTL_CAPIEN_Pos          (5)                                               /*!< TMR23_T::EXTCTL: CAPIEN Position       */
#define TMR23_EXTCTL_CAPIEN_Msk          (0x1ul << TMR23_EXTCTL_CAPIEN_Pos)                /*!< TMR23_T::EXTCTL: CAPIEN Mask           */

#define TMR23_EXTCTL_CAPDBEN_Pos         (6)                                               /*!< TMR23_T::EXTCTL: CAPDBEN Position      */
#define TMR23_EXTCTL_CAPDBEN_Msk         (0x1ul << TMR23_EXTCTL_CAPDBEN_Pos)               /*!< TMR23_T::EXTCTL: CAPDBEN Mask          */

#define TMR23_EXTCTL_CNTDBEN_Pos         (7)                                               /*!< TMR23_T::EXTCTL: CNTDBEN Position      */
#define TMR23_EXTCTL_CNTDBEN_Msk         (0x1ul << TMR23_EXTCTL_CNTDBEN_Pos)               /*!< TMR23_T::EXTCTL: CNTDBEN Mask          */

#define TMR23_EXTCTL_CAPEDGE_Pos         (12)                                              /*!< TMR23_T::EXTCTL: CAPEDGE Position      */
#define TMR23_EXTCTL_CAPEDGE_Msk         (0x7ul << TMR23_EXTCTL_CAPEDGE_Pos)               /*!< TMR23_T::EXTCTL: CAPEDGE Mask          */

#define TMR23_EXTCTL_ECNTSSEL_Pos        (16)                                              /*!< TMR23_T::EXTCTL: ECNTSSEL Position     */
#define TMR23_EXTCTL_ECNTSSEL_Msk        (0x1ul << TMR23_EXTCTL_ECNTSSEL_Pos)              /*!< TMR23_T::EXTCTL: ECNTSSEL Mask         */

#define TMR23_EINTSTS_CAPIF_Pos          (0)                                               /*!< TMR23_T::EINTSTS: CAPIF Position       */
#define TMR23_EINTSTS_CAPIF_Msk          (0x1ul << TMR23_EINTSTS_CAPIF_Pos)                /*!< TMR23_T::EINTSTS: CAPIF Mask           */

#define TMR23_TRGCTL_TRGSSEL_Pos         (0)                                               /*!< TMR23_T::TRGCTL: TRGSSEL Position      */
#define TMR23_TRGCTL_TRGSSEL_Msk         (0x1ul << TMR23_TRGCTL_TRGSSEL_Pos)               /*!< TMR23_T::TRGCTL: TRGSSEL Mask          */

#define TMR23_TRGCTL_TRGPWM_Pos          (1)                                               /*!< TMR23_T::TRGCTL: TRGPWM Position       */
#define TMR23_TRGCTL_TRGPWM_Msk          (0x1ul << TMR23_TRGCTL_TRGPWM_Pos)                /*!< TMR23_T::TRGCTL: TRGPWM Mask           */

#define TMR23_TRGCTL_TRGADC_Pos          (2)                                               /*!< TMR23_T::TRGCTL: TRGADC Position       */
#define TMR23_TRGCTL_TRGADC_Msk          (0x1ul << TMR23_TRGCTL_TRGADC_Pos)                /*!< TMR23_T::TRGCTL: TRGADC Mask           */

#define TMR23_TRGCTL_TRGPDMA_Pos         (4)                                               /*!< TMR23_T::TRGCTL: TRGPDMA Position      */
#define TMR23_TRGCTL_TRGPDMA_Msk         (0x1ul << TMR23_TRGCTL_TRGPDMA_Pos)               /*!< TMR23_T::TRGCTL: TRGPDMA Mask          */

#define TMR23_ALTCTL_FUNCSEL_Pos         (0)                                               /*!< TMR23_T::ALTCTL: FUNCSEL Position      */
#define TMR23_ALTCTL_FUNCSEL_Msk         (0x1ul << TMR23_ALTCTL_FUNCSEL_Pos)               /*!< TMR23_T::ALTCTL: FUNCSEL Mask          */

#define TMR23_PWMCTL_CNTEN_Pos           (0)                                               /*!< TMR23_T::PWMCTL: CNTEN Position        */
#define TMR23_PWMCTL_CNTEN_Msk           (0x1ul << TMR23_PWMCTL_CNTEN_Pos)                 /*!< TMR23_T::PWMCTL: CNTEN Mask            */

#define TMR23_PWMCTL_CNTTYPE_Pos         (1)                                               /*!< TMR23_T::PWMCTL: CNTTYPE Position      */
#define TMR23_PWMCTL_CNTTYPE_Msk         (0x3ul << TMR23_PWMCTL_CNTTYPE_Pos)               /*!< TMR23_T::PWMCTL: CNTTYPE Mask          */

#define TMR23_PWMCTL_CNTMODE_Pos         (3)                                               /*!< TMR23_T::PWMCTL: CNTMODE Position      */
#define TMR23_PWMCTL_CNTMODE_Msk         (0x1ul << TMR23_PWMCTL_CNTMODE_Pos)               /*!< TMR23_T::PWMCTL: CNTMODE Mask          */

#define TMR23_PWMCTL_CTRLD_Pos           (8)                                               /*!< TMR23_T::PWMCTL: CTRLD Position        */
#define TMR23_PWMCTL_CTRLD_Msk           (0x1ul << TMR23_PWMCTL_CTRLD_Pos)                 /*!< TMR23_T::PWMCTL: CTRLD Mask            */

#define TMR23_PWMCTL_IMMLDEN_Pos         (9)                                               /*!< TMR23_T::PWMCTL: IMMLDEN Position      */
#define TMR23_PWMCTL_IMMLDEN_Msk         (0x1ul << TMR23_PWMCTL_IMMLDEN_Pos)               /*!< TMR23_T::PWMCTL: IMMLDEN Mask          */

#define TMR23_PWMCTL_OUTMODE_Pos         (16)                                              /*!< TMR23_T::PWMCTL: OUTMODE Position      */
#define TMR23_PWMCTL_OUTMODE_Msk         (0x1ul << TMR23_PWMCTL_OUTMODE_Pos)               /*!< TMR23_T::PWMCTL: OUTMODE Mask          */

#define TMR23_PWMCTL_DBGHALT_Pos         (30)                                              /*!< TMR23_T::PWMCTL: DBGHALT Position      */
#define TMR23_PWMCTL_DBGHALT_Msk         (0x1ul << TMR23_PWMCTL_DBGHALT_Pos)               /*!< TMR23_T::PWMCTL: DBGHALT Mask          */

#define TMR23_PWMCTL_DBGTRIOFF_Pos       (31)                                              /*!< TMR23_T::PWMCTL: DBGTRIOFF Position    */
#define TMR23_PWMCTL_DBGTRIOFF_Msk       (0x1ul << TMR23_PWMCTL_DBGTRIOFF_Pos)             /*!< TMR23_T::PWMCTL: DBGTRIOFF Mask        */

#define TMR23_PWMCLKSRC_CLKSRC_Pos       (0)                                               /*!< TMR23_T::PWMCLKSRC: CLKSRC Position    */
#define TMR23_PWMCLKSRC_CLKSRC_Msk       (0x7ul << TMR23_PWMCLKSRC_CLKSRC_Pos)             /*!< TMR23_T::PWMCLKSRC: CLKSRC Mask        */

#define TMR23_PWMCLKPSC_CLKPSC_Pos       (0)                                               /*!< TMR23_T::PWMCLKPSC: CLKPSC Position    */
#define TMR23_PWMCLKPSC_CLKPSC_Msk       (0xffful << TMR23_PWMCLKPSC_CLKPSC_Pos)           /*!< TMR23_T::PWMCLKPSC: CLKPSC Mask        */

#define TMR23_PWMCNTCLR_CNTCLR_Pos       (0)                                               /*!< TMR23_T::PWMCNTCLR: CNTCLR Position    */
#define TMR23_PWMCNTCLR_CNTCLR_Msk       (0x1ul << TMR23_PWMCNTCLR_CNTCLR_Pos)             /*!< TMR23_T::PWMCNTCLR: CNTCLR Mask        */

#define TMR23_PWMPERIOD_PERIOD_Pos       (0)                                               /*!< TMR23_T::PWMPERIOD: PERIOD Position    */
#define TMR23_PWMPERIOD_PERIOD_Msk       (0xfffful << TMR23_PWMPERIOD_PERIOD_Pos)          /*!< TMR23_T::PWMPERIOD: PERIOD Mask        */

#define TMR23_PWMCMPDAT_CMP_Pos          (0)                                               /*!< TMR23_T::PWMCMPDAT: CMP Position       */
#define TMR23_PWMCMPDAT_CMP_Msk          (0xfffful << TMR23_PWMCMPDAT_CMP_Pos)             /*!< TMR23_T::PWMCMPDAT: CMP Mask           */

#define TMR23_PWMDTCTL_DTCNT_Pos         (0)                                               /*!< TMR23_T::PWMDTCTL: DTCNT Position      */
#define TMR23_PWMDTCTL_DTCNT_Msk         (0xffful << TMR23_PWMDTCTL_DTCNT_Pos)             /*!< TMR23_T::PWMDTCTL: DTCNT Mask          */

#define TMR23_PWMDTCTL_DTEN_Pos          (16)                                              /*!< TMR23_T::PWMDTCTL: DTEN Position       */
#define TMR23_PWMDTCTL_DTEN_Msk          (0x1ul << TMR23_PWMDTCTL_DTEN_Pos)                /*!< TMR23_T::PWMDTCTL: DTEN Mask           */

#define TMR23_PWMDTCTL_DTCKSEL_Pos       (24)                                              /*!< TMR23_T::PWMDTCTL: DTCKSEL Position    */
#define TMR23_PWMDTCTL_DTCKSEL_Msk       (0x1ul << TMR23_PWMDTCTL_DTCKSEL_Pos)             /*!< TMR23_T::PWMDTCTL: DTCKSEL Mask        */

#define TMR23_PWMCNT_CNT_Pos             (0)                                               /*!< TMR23_T::PWMCNT: CNT Position          */
#define TMR23_PWMCNT_CNT_Msk             (0xfffful << TMR23_PWMCNT_CNT_Pos)                /*!< TMR23_T::PWMCNT: CNT Mask              */

#define TMR23_PWMCNT_DIRF_Pos            (16)                                              /*!< TMR23_T::PWMCNT: DIRF Position         */
#define TMR23_PWMCNT_DIRF_Msk            (0x1ul << TMR23_PWMCNT_DIRF_Pos)                  /*!< TMR23_T::PWMCNT: DIRF Mask             */

#define TMR23_PWMMSKEN_MSKEN0_Pos        (0)                                               /*!< TMR23_T::PWMMSKEN: MSKEN0 Position     */
#define TMR23_PWMMSKEN_MSKEN0_Msk        (0x1ul << TMR23_PWMMSKEN_MSKEN0_Pos)              /*!< TMR23_T::PWMMSKEN: MSKEN0 Mask         */

#define TMR23_PWMMSKEN_MSKEN1_Pos        (1)                                               /*!< TMR23_T::PWMMSKEN: MSKEN1 Position     */
#define TMR23_PWMMSKEN_MSKEN1_Msk        (0x1ul << TMR23_PWMMSKEN_MSKEN1_Pos)              /*!< TMR23_T::PWMMSKEN: MSKEN1 Mask         */

#define TMR23_PWMMSK_MSKDAT0_Pos         (0)                                               /*!< TMR23_T::PWMMSK: MSKDAT0 Position      */
#define TMR23_PWMMSK_MSKDAT0_Msk         (0x1ul << TMR23_PWMMSK_MSKDAT0_Pos)               /*!< TMR23_T::PWMMSK: MSKDAT0 Mask          */

#define TMR23_PWMMSK_MSKDAT1_Pos         (1)                                               /*!< TMR23_T::PWMMSK: MSKDAT1 Position      */
#define TMR23_PWMMSK_MSKDAT1_Msk         (0x1ul << TMR23_PWMMSK_MSKDAT1_Pos)               /*!< TMR23_T::PWMMSK: MSKDAT1 Mask          */

#define TMR23_PWMBNF_BRKNFEN_Pos         (0)                                               /*!< TMR23_T::PWMBNF: BRKNFEN Position      */
#define TMR23_PWMBNF_BRKNFEN_Msk         (0x1ul << TMR23_PWMBNF_BRKNFEN_Pos)               /*!< TMR23_T::PWMBNF: BRKNFEN Mask          */

#define TMR23_PWMBNF_BRKNFSEL_Pos        (1)                                               /*!< TMR23_T::PWMBNF: BRKNFSEL Position     */
#define TMR23_PWMBNF_BRKNFSEL_Msk        (0x7ul << TMR23_PWMBNF_BRKNFSEL_Pos)              /*!< TMR23_T::PWMBNF: BRKNFSEL Mask         */

#define TMR23_PWMBNF_BRKFCNT_Pos         (4)                                               /*!< TMR23_T::PWMBNF: BRKFCNT Position      */
#define TMR23_PWMBNF_BRKFCNT_Msk         (0x7ul << TMR23_PWMBNF_BRKFCNT_Pos)               /*!< TMR23_T::PWMBNF: BRKFCNT Mask          */

#define TMR23_PWMBNF_BRKPINV_Pos         (7)                                               /*!< TMR23_T::PWMBNF: BRKPINV Position      */
#define TMR23_PWMBNF_BRKPINV_Msk         (0x1ul << TMR23_PWMBNF_BRKPINV_Pos)               /*!< TMR23_T::PWMBNF: BRKPINV Mask          */

#define TMR23_PWMBNF_BKPINSRC_Pos        (16)                                              /*!< TMR23_T::PWMBNF: BKPINSRC Position     */
#define TMR23_PWMBNF_BKPINSRC_Msk        (0x3ul << TMR23_PWMBNF_BKPINSRC_Pos)              /*!< TMR23_T::PWMBNF: BKPINSRC Mask         */

#define TMR23_PWMFAILBRK_CSSBRKEN_Pos    (0)                                               /*!< TMR23_T::PWMFAILBRK: CSSBRKEN Position */
#define TMR23_PWMFAILBRK_CSSBRKEN_Msk    (0x1ul << TMR23_PWMFAILBRK_CSSBRKEN_Pos)          /*!< TMR23_T::PWMFAILBRK: CSSBRKEN Mask     */

#define TMR23_PWMFAILBRK_BODBRKEN_Pos    (1)                                               /*!< TMR23_T::PWMFAILBRK: BODBRKEN Position */
#define TMR23_PWMFAILBRK_BODBRKEN_Msk    (0x1ul << TMR23_PWMFAILBRK_BODBRKEN_Pos)          /*!< TMR23_T::PWMFAILBRK: BODBRKEN Mask     */

#define TMR23_PWMFAILBRK_RAMBRKEN_Pos    (2)                                               /*!< TMR23_T::PWMFAILBRK: RAMBRKEN Position */
#define TMR23_PWMFAILBRK_RAMBRKEN_Msk    (0x1ul << TMR23_PWMFAILBRK_RAMBRKEN_Pos)          /*!< TMR23_T::PWMFAILBRK: RAMBRKEN Mask     */

#define TMR23_PWMFAILBRK_CORBRKEN_Pos    (3)                                               /*!< TMR23_T::PWMFAILBRK: CORBRKEN Position */
#define TMR23_PWMFAILBRK_CORBRKEN_Msk    (0x1ul << TMR23_PWMFAILBRK_CORBRKEN_Pos)          /*!< TMR23_T::PWMFAILBRK: CORBRKEN Mask     */

#define TMR23_PWMBRKCTL_BRKPEEN_Pos      (4)                                               /*!< TMR23_T::PWMBRKCTL: BRKPEEN Position   */
#define TMR23_PWMBRKCTL_BRKPEEN_Msk      (0x1ul << TMR23_PWMBRKCTL_BRKPEEN_Pos)            /*!< TMR23_T::PWMBRKCTL: BRKPEEN Mask       */

#define TMR23_PWMBRKCTL_SYSEBEN_Pos      (7)                                               /*!< TMR23_T::PWMBRKCTL: SYSEBEN Position   */
#define TMR23_PWMBRKCTL_SYSEBEN_Msk      (0x1ul << TMR23_PWMBRKCTL_SYSEBEN_Pos)            /*!< TMR23_T::PWMBRKCTL: SYSEBEN Mask       */

#define TMR23_PWMBRKCTL_BRKPLEN_Pos      (12)                                              /*!< TMR23_T::PWMBRKCTL: BRKPLEN Position   */
#define TMR23_PWMBRKCTL_BRKPLEN_Msk      (0x1ul << TMR23_PWMBRKCTL_BRKPLEN_Pos)            /*!< TMR23_T::PWMBRKCTL: BRKPLEN Mask       */

#define TMR23_PWMBRKCTL_SYSLBEN_Pos      (15)                                              /*!< TMR23_T::PWMBRKCTL: SYSLBEN Position   */
#define TMR23_PWMBRKCTL_SYSLBEN_Msk      (0x1ul << TMR23_PWMBRKCTL_SYSLBEN_Pos)            /*!< TMR23_T::PWMBRKCTL: SYSLBEN Mask       */

#define TMR23_PWMBRKCTL_BRKAEVEN_Pos     (16)                                              /*!< TMR23_T::PWMBRKCTL: BRKAEVEN Position  */
#define TMR23_PWMBRKCTL_BRKAEVEN_Msk     (0x3ul << TMR23_PWMBRKCTL_BRKAEVEN_Pos)           /*!< TMR23_T::PWMBRKCTL: BRKAEVEN Mask      */

#define TMR23_PWMBRKCTL_BRKAODD_Pos      (18)                                              /*!< TMR23_T::PWMBRKCTL: BRKAODD Position   */
#define TMR23_PWMBRKCTL_BRKAODD_Msk      (0x3ul << TMR23_PWMBRKCTL_BRKAODD_Pos)            /*!< TMR23_T::PWMBRKCTL: BRKAODD Mask       */

#define TMR23_PWMPOLCTL_PINV0_Pos        (0)                                               /*!< TMR23_T::PWMPOLCTL: PINV0 Position     */
#define TMR23_PWMPOLCTL_PINV0_Msk        (0x1ul << TMR23_PWMPOLCTL_PINV0_Pos)              /*!< TMR23_T::PWMPOLCTL: PINV0 Mask         */

#define TMR23_PWMPOLCTL_PINV1_Pos        (1)                                               /*!< TMR23_T::PWMPOLCTL: PINV1 Position     */
#define TMR23_PWMPOLCTL_PINV1_Msk        (0x1ul << TMR23_PWMPOLCTL_PINV1_Pos)              /*!< TMR23_T::PWMPOLCTL: PINV1 Mask         */

#define TMR23_PWMPOEN_POEN0_Pos          (0)                                               /*!< TMR23_T::PWMPOEN: POEN0 Position       */
#define TMR23_PWMPOEN_POEN0_Msk          (0x1ul << TMR23_PWMPOEN_POEN0_Pos)                /*!< TMR23_T::PWMPOEN: POEN0 Mask           */

#define TMR23_PWMPOEN_POEN1_Pos          (1)                                               /*!< TMR23_T::PWMPOEN: POEN1 Position       */
#define TMR23_PWMPOEN_POEN1_Msk          (0x1ul << TMR23_PWMPOEN_POEN1_Pos)                /*!< TMR23_T::PWMPOEN: POEN1 Mask           */

#define TMR23_PWMSWBRK_BRKETRG_Pos       (0)                                               /*!< TMR23_T::PWMSWBRK: BRKETRG Position    */
#define TMR23_PWMSWBRK_BRKETRG_Msk       (0x1ul << TMR23_PWMSWBRK_BRKETRG_Pos)             /*!< TMR23_T::PWMSWBRK: BRKETRG Mask        */

#define TMR23_PWMSWBRK_BRKLTRG_Pos       (8)                                               /*!< TMR23_T::PWMSWBRK: BRKLTRG Position    */
#define TMR23_PWMSWBRK_BRKLTRG_Msk       (0x1ul << TMR23_PWMSWBRK_BRKLTRG_Pos)             /*!< TMR23_T::PWMSWBRK: BRKLTRG Mask        */

#define TMR23_PWMINTEN0_ZIEN_Pos         (0)                                               /*!< TMR23_T::PWMINTEN0: ZIEN Position      */
#define TMR23_PWMINTEN0_ZIEN_Msk         (0x1ul << TMR23_PWMINTEN0_ZIEN_Pos)               /*!< TMR23_T::PWMINTEN0: ZIEN Mask          */

#define TMR23_PWMINTEN0_PIEN_Pos         (1)                                               /*!< TMR23_T::PWMINTEN0: PIEN Position      */
#define TMR23_PWMINTEN0_PIEN_Msk         (0x1ul << TMR23_PWMINTEN0_PIEN_Pos)               /*!< TMR23_T::PWMINTEN0: PIEN Mask          */

#define TMR23_PWMINTEN0_CMPUIEN_Pos      (2)                                               /*!< TMR23_T::PWMINTEN0: CMPUIEN Position   */
#define TMR23_PWMINTEN0_CMPUIEN_Msk      (0x1ul << TMR23_PWMINTEN0_CMPUIEN_Pos)            /*!< TMR23_T::PWMINTEN0: CMPUIEN Mask       */

#define TMR23_PWMINTEN0_CMPDIEN_Pos      (3)                                               /*!< TMR23_T::PWMINTEN0: CMPDIEN Position   */
#define TMR23_PWMINTEN0_CMPDIEN_Msk      (0x1ul << TMR23_PWMINTEN0_CMPDIEN_Pos)            /*!< TMR23_T::PWMINTEN0: CMPDIEN Mask       */

#define TMR23_PWMINTEN1_BRKEIEN_Pos      (0)                                               /*!< TMR23_T::PWMINTEN1: BRKEIEN Position   */
#define TMR23_PWMINTEN1_BRKEIEN_Msk      (0x1ul << TMR23_PWMINTEN1_BRKEIEN_Pos)            /*!< TMR23_T::PWMINTEN1: BRKEIEN Mask       */

#define TMR23_PWMINTEN1_BRKLIEN_Pos      (8)                                               /*!< TMR23_T::PWMINTEN1: BRKLIEN Position   */
#define TMR23_PWMINTEN1_BRKLIEN_Msk      (0x1ul << TMR23_PWMINTEN1_BRKLIEN_Pos)            /*!< TMR23_T::PWMINTEN1: BRKLIEN Mask       */

#define TMR23_PWMINTSTS0_ZIF_Pos         (0)                                               /*!< TMR23_T::PWMINTSTS0: ZIF Position      */
#define TMR23_PWMINTSTS0_ZIF_Msk         (0x1ul << TMR23_PWMINTSTS0_ZIF_Pos)               /*!< TMR23_T::PWMINTSTS0: ZIF Mask          */

#define TMR23_PWMINTSTS0_PIF_Pos         (1)                                               /*!< TMR23_T::PWMINTSTS0: PIF Position      */
#define TMR23_PWMINTSTS0_PIF_Msk         (0x1ul << TMR23_PWMINTSTS0_PIF_Pos)               /*!< TMR23_T::PWMINTSTS0: PIF Mask          */

#define TMR23_PWMINTSTS0_CMPUIF_Pos      (2)                                               /*!< TMR23_T::PWMINTSTS0: CMPUIF Position   */
#define TMR23_PWMINTSTS0_CMPUIF_Msk      (0x1ul << TMR23_PWMINTSTS0_CMPUIF_Pos)            /*!< TMR23_T::PWMINTSTS0: CMPUIF Mask       */

#define TMR23_PWMINTSTS0_CMPDIF_Pos      (3)                                               /*!< TMR23_T::PWMINTSTS0: CMPDIF Position   */
#define TMR23_PWMINTSTS0_CMPDIF_Msk      (0x1ul << TMR23_PWMINTSTS0_CMPDIF_Pos)            /*!< TMR23_T::PWMINTSTS0: CMPDIF Mask       */

#define TMR23_PWMINTSTS1_BRKEIF0_Pos     (0)                                               /*!< TMR23_T::PWMINTSTS1: BRKEIF0 Position  */
#define TMR23_PWMINTSTS1_BRKEIF0_Msk     (0x1ul << TMR23_PWMINTSTS1_BRKEIF0_Pos)           /*!< TMR23_T::PWMINTSTS1: BRKEIF0 Mask      */

#define TMR23_PWMINTSTS1_BRKEIF1_Pos     (1)                                               /*!< TMR23_T::PWMINTSTS1: BRKEIF1 Position  */
#define TMR23_PWMINTSTS1_BRKEIF1_Msk     (0x1ul << TMR23_PWMINTSTS1_BRKEIF1_Pos)           /*!< TMR23_T::PWMINTSTS1: BRKEIF1 Mask      */

#define TMR23_PWMINTSTS1_BRKLIF0_Pos     (8)                                               /*!< TMR23_T::PWMINTSTS1: BRKLIF0 Position  */
#define TMR23_PWMINTSTS1_BRKLIF0_Msk     (0x1ul << TMR23_PWMINTSTS1_BRKLIF0_Pos)           /*!< TMR23_T::PWMINTSTS1: BRKLIF0 Mask      */

#define TMR23_PWMINTSTS1_BRKLIF1_Pos     (9)                                               /*!< TMR23_T::PWMINTSTS1: BRKLIF1 Position  */
#define TMR23_PWMINTSTS1_BRKLIF1_Msk     (0x1ul << TMR23_PWMINTSTS1_BRKLIF1_Pos)           /*!< TMR23_T::PWMINTSTS1: BRKLIF1 Mask      */

#define TMR23_PWMINTSTS1_BRKESTS0_Pos    (16)                                              /*!< TMR23_T::PWMINTSTS1: BRKESTS0 Position */
#define TMR23_PWMINTSTS1_BRKESTS0_Msk    (0x1ul << TMR23_PWMINTSTS1_BRKESTS0_Pos)          /*!< TMR23_T::PWMINTSTS1: BRKESTS0 Mask     */

#define TMR23_PWMINTSTS1_BRKESTS1_Pos    (17)                                              /*!< TMR23_T::PWMINTSTS1: BRKESTS1 Position */
#define TMR23_PWMINTSTS1_BRKESTS1_Msk    (0x1ul << TMR23_PWMINTSTS1_BRKESTS1_Pos)          /*!< TMR23_T::PWMINTSTS1: BRKESTS1 Mask     */

#define TMR23_PWMINTSTS1_BRKLSTS0_Pos    (24)                                              /*!< TMR23_T::PWMINTSTS1: BRKLSTS0 Position */
#define TMR23_PWMINTSTS1_BRKLSTS0_Msk    (0x1ul << TMR23_PWMINTSTS1_BRKLSTS0_Pos)          /*!< TMR23_T::PWMINTSTS1: BRKLSTS0 Mask     */

#define TMR23_PWMINTSTS1_BRKLSTS1_Pos    (25)                                              /*!< TMR23_T::PWMINTSTS1: BRKLSTS1 Position */
#define TMR23_PWMINTSTS1_BRKLSTS1_Msk    (0x1ul << TMR23_PWMINTSTS1_BRKLSTS1_Pos)          /*!< TMR23_T::PWMINTSTS1: BRKLSTS1 Mask     */

#define TMR23_PWMADCTS_TRGSEL_Pos        (0)                                               /*!< TMR23_T::PWMADCTS: TRGSEL Position     */
#define TMR23_PWMADCTS_TRGSEL_Msk        (0x7ul << TMR23_PWMADCTS_TRGSEL_Pos)              /*!< TMR23_T::PWMADCTS: TRGSEL Mask         */

#define TMR23_PWMADCTS_TRGEN_Pos         (7)                                               /*!< TMR23_T::PWMADCTS: TRGEN Position      */
#define TMR23_PWMADCTS_TRGEN_Msk         (0x1ul << TMR23_PWMADCTS_TRGEN_Pos)               /*!< TMR23_T::PWMADCTS: TRGEN Mask          */

#define TMR23_PWMSCTL_SYNCMODE_Pos       (0)                                               /*!< TMR23_T::PWMSCTL: SYNCMODE Position    */
#define TMR23_PWMSCTL_SYNCMODE_Msk       (0x3ul << TMR23_PWMSCTL_SYNCMODE_Pos)             /*!< TMR23_T::PWMSCTL: SYNCMODE Mask        */

#define TMR23_PWMSCTL_SYNCSRC_Pos        (8)                                               /*!< TMR23_T::PWMSCTL: SYNCSRC Position     */
#define TMR23_PWMSCTL_SYNCSRC_Msk        (0x1ul << TMR23_PWMSCTL_SYNCSRC_Pos)              /*!< TMR23_T::PWMSCTL: SYNCSRC Mask         */

#define TMR23_PWMSTATUS_CNTMAXF_Pos      (0)                                               /*!< TMR23_T::PWMSTATUS: CNTMAXF Position   */
#define TMR23_PWMSTATUS_CNTMAXF_Msk      (0x1ul << TMR23_PWMSTATUS_CNTMAXF_Pos)            /*!< TMR23_T::PWMSTATUS: CNTMAXF Mask       */

#define TMR23_PWMSTATUS_ADCTRGF_Pos      (16)                                              /*!< TMR23_T::PWMSTATUS: ADCTRGF Position   */
#define TMR23_PWMSTATUS_ADCTRGF_Msk      (0x1ul << TMR23_PWMSTATUS_ADCTRGF_Pos)            /*!< TMR23_T::PWMSTATUS: ADCTRGF Mask       */

#define TMR23_PWMPBUF_PBUF_Pos           (0)                                               /*!< TMR23_T::PWMPBUF: PBUF Position        */
#define TMR23_PWMPBUF_PBUF_Msk           (0xfffful << TMR23_PWMPBUF_PBUF_Pos)              /*!< TMR23_T::PWMPBUF: PBUF Mask            */

#define TMR23_PWMCMPBUF_CMPBUF_Pos       (0)                                               /*!< TMR23_T::PWMCMPBUF: CMPBUF Position    */
#define TMR23_PWMCMPBUF_CMPBUF_Msk       (0xfffful << TMR23_PWMCMPBUF_CMPBUF_Pos)          /*!< TMR23_T::PWMCMPBUF: CMPBUF Mask        */

/**@}*/ /* TMR23_CONST */
/**@}*/ /* end of TMR23 register group */


/*---------------------- Universal Asynchronous Receiver/Transmitter Controller -------------------------*/
/**
    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller(UART)
    Memory Mapped Structure for UART Controller
@{ */
 
typedef struct
{


/**
 * @var UART_T::DAT
 * Offset: 0x00  UART Receive/Transmit Buffer Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[7:0]   |DAT       |Data Receive/Transmit Buffer
 * |        |          |Write Operation:
 * |        |          |By writing one byte to this register, the data byte will be stored in transmitter FIFO
 * |        |          |The UART controller will send out the data stored in transmitter FIFO top location through the UART0_TXD pin.
 * |        |          |Read Operation:
 * |        |          |By reading this register, the UART controller will return an 8-bit data received from receiver FIFO.
 * |[8]     |PARITY    |Parity Bit Receive/Transmit Buffer
 * |        |          |Write Operation:
 * |        |          |By writing to this bit, the parity bit will be stored in transmitter FIFO
 * |        |          |If PBE (UART_LINE[3]) and PSS (UART_LINE[7]) are set, the UART controller will send out this bit follow the DAT (UART_DAT[7:0]) through the UART0_TXD pin.
 * |        |          |Read Operation:
 * |        |          |If PBE (UART_LINE[3]) and PSS (UART_LINE[7]) are enabled, the parity bit can be read by this bit.
 * |        |          |Note: This bit has effect only when PBE (UART_LINE[3]) and PSS (UART_LINE[7]) are set.
 * @var UART_T::INTEN
 * Offset: 0x04  UART Interrupt Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |RDAIEN    |Receive Data Available Interrupt Enable Bit
 * |        |          |0 = Receive data available interrupt Disabled.
 * |        |          |1 = Receive data available interrupt Enabled.
 * |[1]     |THREIEN   |Transmit Holding Register Empty Interrupt Enable Bit
 * |        |          |0 = Transmit holding register empty interrupt Disabled.
 * |        |          |1 = Transmit holding register empty interrupt Enabled.
 * |[2]     |RLSIEN    |Receive Line Status Interrupt Enable Bit
 * |        |          |0 = Receive Line Status interrupt Disabled.
 * |        |          |1 = Receive Line Status interrupt Enabled.
 * |[3]     |MODEMIEN  |Modem Status Interrupt Enable Bit
 * |        |          |0 = Modem status interrupt Disabled.
 * |        |          |1 = Modem status interrupt Enabled.
 * |[4]     |RXTOIEN   |RX Time-out Interrupt Enable Bit
 * |        |          |0 = RX time-out interrupt Disabled.
 * |        |          |1 = RX time-out interrupt Enabled.
 * |[5]     |BUFERRIEN |Buffer Error Interrupt Enable Bit
 * |        |          |0 = Buffer error interrupt Disabled.
 * |        |          |1 = Buffer error interrupt Enabled.
 * |[6]     |WKIEN     |Wake-up Interrupt Enable Bit
 * |        |          |0 = Wake-up Interrupt Disabled.
 * |        |          |1 = Wake-up Interrupt Enabled.
 * |[8]     |LINIEN    |LIN Bus Interrupt Enable Bit
 * |        |          |0 = LIN bus interrupt Disabled.
 * |        |          |1 = LIN bus interrupt Enabled.
 * |        |          |Note: This bit is used for LIN function mode.
 * |[11]    |TOCNTEN   |Receive Buffer Time-out Counter Enable Bit
 * |        |          |0 = Receive Buffer Time-out counter Disabled.
 * |        |          |1 = Receive Buffer Time-out counter Enabled.
 * |[12]    |ATORTSEN  |nRTS Auto-flow Control Enable Bit
 * |        |          |0 = nRTS auto-flow control Disabled.
 * |        |          |1 = nRTS auto-flow control Enabled.
 * |        |          |Note: When nRTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTSTRGLV (UART_FIFO[19:16]), the UART will de-assert nRTS signal.
 * |[13]    |ATOCTSEN  |nCTS Auto-flow Control Enable Bit
 * |        |          |0 = nCTS auto-flow control Disabled.
 * |        |          |1 = nCTS auto-flow control Enabled.
 * |        |          |Note: When nCTS auto-flow is enabled, the UART will send data to external device if nCTS input assert (UART will not send data to device until nCTS is asserted).
 * |[14]    |TXPDMAEN  |TX PDMA Enable Bit
 * |        |          |This bit can enable or disable TX PDMA service.
 * |        |          |0 = TX PDMA Disabled.
 * |        |          |1 = TX PDMA Enabled.
 * |        |          |Note: If RLSIEN (UART_INTEN[2]) is enabled and HWRLSINT (UART_INTSTS[26]) is set to 1, the RLS (Receive Line Status) Interrupt is caused
 * |        |          |If RLS interrupt is caused by Break Error Flag BIF(UART_FIFOSTS[6]), Frame Error Flag FEF(UART_FIFO[5]) or Parity Error Flag PEF(UART_FIFOSTS[4]) , UART PDMA transmit request operation is stop
 * |        |          |Clear Break Error Flag BIF or Frame Error Flag FEF or Parity Error Flag PEF by writing ...1u201D to corresponding BIF, FEF and PEF to make UART PDMA transmit request operation continue.
 * |[15]    |RXPDMAEN  |RX PDMA Enable Bit
 * |        |          |This bit can enable or disable RX PDMA service.
 * |        |          |0 = RX PDMA Disabled.
 * |        |          |1 = RX PDMA Enabled.
 * |        |          |Note: If RLSIEN (UART_INTEN[2]) is enabled and HWRLSINT (UART_INTSTS[26]) is set to 1, the RLS (Receive Line Status) Interrupt is caused
 * |        |          |If RLS interrupt is caused by Break Error Flag BIF(UART_FIFOSTS[6]), Frame Error Flag FEF(UART_FIFO[5]) or Parity Error Flag PEF(UART_FIFOSTS[4]) , UART PDMA receive request operation is stop
 * |        |          |Clear Break Error Flag BIF or Frame Error Flag FEF or Parity Error Flag PEF by writing ...1u201D to corresponding BIF, FEF and PEF to make UART PDMA receive request operation continue.
 * |[18]    |ABRIEN    |Auto-baud Rate Interrupt Enable Bit
 * |        |          |0 = Auto-baud rate interrupt Disabled.
 * |        |          |1 = Auto-baud rate interrupt Enabled.
 * |[22]    |TXENDIEN  |Transmitter Empty Interrupt Enable Bit
 * |        |          |If TXENDIEN (UART_INTEN[22]) is enabled, the Transmitter Empty interrupt TXENDINT (UART_INTSTS[30]) will be generated when TXENDIF (UART_INTSTS[22]) is set (TX FIFO (UART_DAT) is empty and the STOP bit of the last byte has been transmitted).
 * |        |          |0 = Transmitter empty interrupt Disabled.
 * |        |          |1 = Transmitter empty interrupt Enabled.
 * @var UART_T::FIFO
 * Offset: 0x08  UART FIFO Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1]     |RXRST     |RX Field Software Reset
 * |        |          |When RXRST (UART_FIFO[1]) is set, all the byte in the receiver FIFO and RX internal state machine are cleared.
 * |        |          |0 = No effect.
 * |        |          |1 = Reset the RX internal state machine and pointers.
 * |        |          |Note1: This bit will automatically clear at least 3 UART peripheral clock cycles.
 * |        |          |Note2: Before setting this bit, it should wait for the RXIDLE (UART_FIFOSTS[29]) be set.
 * |[2]     |TXRST     |TX Field Software Reset
 * |        |          |When TXRST (UART_FIFO[2]) is set, all the byte in the transmit FIFO and TX internal state machine are cleared.
 * |        |          |0 = No effect.
 * |        |          |1 = Reset the TX internal state machine and pointers.
 * |        |          |Note1: This bit will automatically clear at least 3 UART peripheral clock cycles.
 * |        |          |Note2: Before setting this bit, it should wait for the TXEMPTYF (UART_FIFOSTS[28]) be set.
 * |[7:4]   |RFITL     |RX FIFO Interrupt Trigger Level
 * |        |          |When the number of bytes in the receive FIFO equals the RFITL, the RDAIF (UART_INTSTS[0]) will be set (if RDAIEN (UART_INTEN [0]) enabled, and an interrupt will be generated).
 * |        |          |0000 = RX FIFO Interrupt Trigger Level is 1 byte.
 * |        |          |0001 = RX FIFO Interrupt Trigger Level is 4 bytes.
 * |        |          |0010 = RX FIFO Interrupt Trigger Level is 8 bytes.
 * |        |          |0011 = RX FIFO Interrupt Trigger Level is 14 bytes.
 * |        |          |Others = Reserved.
 * |[8]     |RXOFF     |Receiver Disable Bit
 * |        |          |The receiver is disabled or not (set 1 to disable receiver).
 * |        |          |0 = Receiver Enabled.
 * |        |          |1 = Receiver Disabled.
 * |        |          |Note: This bit is used for RS-485 Normal Multi-drop mode
 * |        |          |It should be programmed before RS485NMM (UART_ALTCTL [8]) is programmed.
 * |[19:16] |RTSTRGLV  |nRTS Trigger Level for Auto-flow Control Use
 * |        |          |0000 = nRTS Trigger Level is 1 byte.
 * |        |          |0001 = nRTS Trigger Level is 4 bytes.
 * |        |          |0010 = nRTS Trigger Level is 8 bytes.
 * |        |          |0011 = nRTS Trigger Level is 14 bytes.
 * |        |          |Others = Reserved.
 * |        |          |Note: This field is used for auto nRTS flow control.
 * @var UART_T::LINE
 * Offset: 0x0C  UART Line Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |WLS       |Word Length Selection
 * |        |          |This field sets UART word length.
 * |        |          |00 = 5 bits.
 * |        |          |01 = 6 bits.
 * |        |          |10 = 7 bits.
 * |        |          |11 = 8 bits.
 * |[2]     |NSB       |Number of ...STOP Bitu201D
 * |        |          |0 = One ...STOP bitu201D is generated in the transmitted data.
 * |        |          |1 = When select 5-bit word length, 1.5 ...STOP bitu201D is generated in the transmitted data
 * |        |          |When select 6-, 7- and 8-bit word length, 2 ...STOP bitu201D is generated in the transmitted data.
 * |[3]     |PBE       |Parity Bit Enable Bit
 * |        |          |0 = Parity bit generated Disabled.
 * |        |          |1 = Parity bit generated Enabled.
 * |        |          |Note: Parity bit is generated on each outgoing character and is checked on each incoming data.
 * |[4]     |EPE       |Even Parity Enable Bit
 * |        |          |0 = Odd number of logic 1's is transmitted and checked in each word.
 * |        |          |1 = Even number of logic 1's is transmitted and checked in each word.
 * |        |          |Note: This bit has effect only when PBE (UART_LINE[3]) is set.
 * |[5]     |SPE       |Stick Parity Enable Bit
 * |        |          |0 = Stick parity Disabled.
 * |        |          |1 = Stick parity Enabled.
 * |        |          |Note: If PBE (UART_LINE[3]) and EPE (UART_LINE[4]) are logic 1, the parity bit is transmitted and checked as logic 0
 * |        |          |If PBE (UART_LINE[3]) is 1 and EPE (UART_LINE[4]) is 0 then the parity bit is transmitted and checked as 1.
 * |[6]     |BCB       |Break Control Bit
 * |        |          |0 = Break Control Disabled.
 * |        |          |1 = Break Control Enabled.
 * |        |          |Note: When this bit is set to logic 1, the transmitted serial data output (TX) is forced to the Spacing State (logic 0)
 * |        |          |This bit acts only on TX line and has no effect on the transmitter logic.
 * |[7]     |PSS       |Parity Bit Source Selection
 * |        |          |The parity bit can be selected to be generated and checked automatically or by software.
 * |        |          |0 = Parity bit is generated by EPE (UART_LINE[4]) and SPE (UART_LINE[5]) setting and checked automatically.
 * |        |          |1 = Parity bit generated and checked by software.
 * |        |          |Note1: This bit has effect only when PBE (UART_LINE[3]) is set.
 * |        |          |Note2: If PSS is 0, the parity bit is transmitted and checked automatically
 * |        |          |If PSS is 1, the transmitted parity bit value can be determined by writing PARITY (UART_DAT[8]) and the parity bit can be read by reading PARITY (UART_DAT[8]).
 * |[8]     |TXDINV    |TX Data Inverted
 * |        |          |0 = Transmitted data signal inverted Disabled.
 * |        |          |1 = Transmitted data signal inverted Enabled.
 * |        |          |Note1: Before setting this bit, TXRXDIS (UART_FUNCSEL[3]) should be set then waited for TXRXACT (UART_FIFOSTS[31]) is cleared
 * |        |          |When the configuration is done, cleared TXRXDIS (UART_FUNCSEL[3]) to activate UART controller.
 * |        |          |Note2: This bit is valid when FUNCSEL (UART_FUNCSEL[1:0]) is select UART, LIN or RS485 function.
 * |[9]     |RXDINV    |RX Data Inverted
 * |        |          |0 = Received data signal inverted Disabled.
 * |        |          |1 = Received data signal inverted Enabled.
 * |        |          |Note1: Before setting this bit, TXRXDIS (UART_FUNCSEL[3]) should be set then waited for TXRXACT (UART_FIFOSTS[31]) is cleared
 * |        |          |When the configuration is done, cleared TXRXDIS (UART_FUNCSEL[3]) to activate UART controller.
 * |        |          |Note2: This bit is valid when FUNCSEL (UART_FUNCSEL[1:0]) is select UART, LIN or RS485 function.
 * @var UART_T::MODEM
 * Offset: 0x10  UART Modem Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1]     |RTS       |nRTS (Request-to-send) Signal Control
 * |        |          |This bit is direct control internal nRTS signal active or not, and then drive the nRTS pin output with RTSACTLV bit configuration.
 * |        |          |0 = nRTS signal is active.
 * |        |          |1 = nRTS signal is inactive.
 * |        |          |Note1: This nRTS signal control bit is not effective when nRTS auto-flow control is enabled in UART function mode.
 * |        |          |Note2: This nRTS signal control bit is not effective when RS-485 auto direction mode (AUD) is enabled in RS-485 function mode.
 * |[9]     |RTSACTLV  |nRTS Pin Active Level
 * |        |          |This bit defines the active level state of nRTS pin output.
 * |        |          |0 = nRTS pin output is high level active.
 * |        |          |1 = nRTS pin output is low level active. (Default)
 * |        |          |Note1: Refer to Figure 6.12-13 and Figure 6.12-14 for UART function mode.
 * |        |          |Note2: Refer to Figure 6.12-24 and Figure 6.12-25 for RS-485 function mode.
 * |        |          |Note3: Before setting this bit, TXRXDIS (UART_FUNCSEL[3]) should be set then waited for TXRXACT (UART_FIFOSTS[31]) is cleared
 * |        |          |When the configuration is done, cleared TXRXDIS (UART_FUNCSEL[3]) to activate UART controller.
 * |[13]    |RTSSTS    |nRTS Pin Status (Read Only)
 * |        |          |This bit mirror from nRTS pin output of voltage logic status.
 * |        |          |0 = nRTS pin output is low level voltage logic state.
 * |        |          |1 = nRTS pin output is high level voltage logic state.
 * @var UART_T::MODEMSTS
 * Offset: 0x14  UART Modem Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CTSDETF   |Detect nCTS State Change Flag
 * |        |          |This bit is set whenever nCTS input has change state, and it will generate Modem interrupt to CPU when MODEMIEN (UART_INTEN [3]) is set to 1.
 * |        |          |0 = nCTS input has not change state.
 * |        |          |1 = nCTS input has change state.
 * |        |          |Note: This bit can be cleared by writing ...1u201D to it.
 * |[4]     |CTSSTS    |nCTS Pin Status (Read Only)
 * |        |          |This bit mirror from nCTS pin input of voltage logic status.
 * |        |          |0 = nCTS pin input is low level voltage logic state.
 * |        |          |1 = nCTS pin input is high level voltage logic state.
 * |        |          |Note: This bit echoes when UART controller peripheral clock is enabled, and nCTS multi-function port is selected.
 * |[8]     |CTSACTLV  |nCTS Pin Active Level
 * |        |          |This bit defines the active level state of nCTS pin input.
 * |        |          |0 = nCTS pin input is high level active.
 * |        |          |1 = nCTS pin input is low level active. (Default)
 * |        |          |Note: Before setting this bit, TXRXDIS (UART_FUNCSEL[3]) should be set then waited for TXRXACT (UART_FIFOSTS[31]) is cleared
 * |        |          |When the configuration is done, cleared TXRXDIS (UART_FUNCSEL[3]) to activate UART controller.
 * @var UART_T::FIFOSTS
 * Offset: 0x18  UART FIFO Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |RXOVIF    |RX Overflow Error Interrupt Flag
 * |        |          |This bit is set when RX FIFO overflow.
 * |        |          |If the number of bytes of received data is greater than RX_FIFO (UART_DAT) size 16 bytes, this bit will be set.
 * |        |          |0 = RX FIFO is not overflow.
 * |        |          |1 = RX FIFO is overflow.
 * |        |          |Note: This bit can be cleared by writing ...1u201D to it.
 * |[1]     |ABRDIF    |Auto-baud Rate Detect Interrupt Flag
 * |        |          |This bit is set to logic ...1u201D when auto-baud rate detect function is finished.
 * |        |          |0 = Auto-baud rate detect function is not finished.
 * |        |          |1 = Auto-baud rate detect function is finished.
 * |        |          |Note: This bit can be cleared by writing ...1u201D to it. 
 * |[2]     |ABRDTOIF  |Auto-baud Rate Detect Time-out Interrupt Flag
 * |        |          |This bit is set to logic ...1u201D in Auto-baud Rate Detect mode when the baud rate counter is overflow.
 * |        |          |0 = Auto-baud rate counter is underflow.
 * |        |          |1 = Auto-baud rate counter is overflow.
 * |        |          |Note: This bit can be cleared by writing ...1u201D to it. 
 * |[3]     |ADDRDETF  |RS-485 Address Byte Detect Flag
 * |        |          |0 = Receiver detects a data that is not an address bit (bit 9 ='0').
 * |        |          |1 = Receiver detects a data that is an address bit (bit 9 ='1').
 * |        |          |Note1: This field is used for RS-485 function mode and ADDRDEN (UART_ALTCTL[15]) is set to 1 to enable Address detection mode.
 * |        |          |Note2: This bit can be cleared by writing ...1u201D to it.
 * |[4]     |PEF       |Parity Error Flag
 * |        |          |This bit is set to logic 1 whenever the received character does not have a valid ...parity bitu201D.
 * |        |          |0 = No parity error is generated.
 * |        |          |1 = Parity error is generated.
 * |        |          |Note: This bit can be cleared by writing ...1u201D to it. 
 * |[5]     |FEF       |Framing Error Flag
 * |        |          |This bit is set to logic 1 whenever the received character does not have a valid ...stop bitu201D (that is, the stop bit following the last data bit or parity bit is detected as logic 0).
 * |        |          |0 = No framing error is generated.
 * |        |          |1 = Framing error is generated.
 * |        |          |Note: This bit can be cleared by writing ...1u201D to it.
 * |[6]     |BIF       |Break Interrupt Flag
 * |        |          |This bit is set to logic 1 whenever the received data input (RX) is held in the ...spacing stateu201D (logic 0) for longer than a full word transmission time (that is, the total time of ...start bitu201D + data bits + parity + stop bits).
 * |        |          |0 = No Break interrupt is generated.
 * |        |          |1 = Break interrupt is generated.
 * |        |          |Note: This bit can be cleared by writing ...1u201D to it.
 * |[13:8]  |RXPTR     |RX FIFO Pointer (Read Only)
 * |        |          |This field indicates the RX FIFO Buffer Pointer
 * |        |          |When UART receives one byte from external device, RXPTR increases one
 * |        |          |When one byte of RX FIFO is read by CPU, RXPTR decreases one.
 * |        |          |The Maximum value shown in RXPTR is 15
 * |        |          |When the using level of RX FIFO Buffer equal to 16, the RXFULL bit is set to 1 and RXPTR will show 0
 * |        |          |As one byte of RX FIFO is read by CPU, the RXFULL bit is cleared to 0 and RXPTR will show 15
 * |[14]    |RXEMPTY   |Receiver FIFO Empty (Read Only)
 * |        |          |This bit initiate RX FIFO empty or not.
 * |        |          |0 = RX FIFO is not empty.
 * |        |          |1 = RX FIFO is empty.
 * |        |          |Note: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high
 * |        |          |It will be cleared when UART receives any new data.
 * |[15]    |RXFULL    |Receiver FIFO Full (Read Only)
 * |        |          |This bit initiates RX FIFO full or not.
 * |        |          |0 = RX FIFO is not full.
 * |        |          |1 = RX FIFO is full.
 * |        |          |Note: This bit is set when the number of usage in RX FIFO Buffer is equal to 16, otherwise it is cleared by hardware.
 * |[21:16] |TXPTR     |TX FIFO Pointer (Read Only)
 * |        |          |This field indicates the TX FIFO Buffer Pointer
 * |        |          |When CPU writes one byte into UART_DAT, TXPTR increases one
 * |        |          |When one byte of TX FIFO is transferred to Transmitter Shift Register, TXPTR decreases one.
 * |        |          |The Maximum value shown in TXPTR is 15
 * |        |          |When the using level of TX FIFO Buffer equal to 16, the TXFULL bit is set to 1 and TXPTR will show 0
 * |        |          |As one byte of TX FIFO is transferred to Transmitter Shift Register, the TXFULL bit is cleared to 0 and TXPTR will show 15
 * |[22]    |TXEMPTY   |Transmitter FIFO Empty (Read Only)
 * |        |          |This bit indicates TX FIFO empty or not.
 * |        |          |0 = TX FIFO is not empty.
 * |        |          |1 = TX FIFO is empty.
 * |        |          |Note: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high
 * |        |          |It will be cleared when writing data into UART_DAT (TX FIFO not empty).
 * |[23]    |TXFULL    |Transmitter FIFO Full (Read Only)
 * |        |          |This bit indicates TX FIFO full or not.
 * |        |          |0 = TX FIFO is not full.
 * |        |          |1 = TX FIFO is full.
 * |        |          |Note: This bit is set when the number of usage in TX FIFO Buffer is equal to 16, otherwise it is cleared by hardware.
 * |[24]    |TXOVIF    |TX Overflow Error Interrupt Flag
 * |        |          |If TX FIFO (UART_DAT) is full, an additional write to UART_DAT will cause this bit to logic 1.
 * |        |          |0 = TX FIFO is not overflow.
 * |        |          |1 = TX FIFO is overflow.
 * |        |          |Note: This bit can be cleared by writing ...1u201D to it.
 * |[28]    |TXEMPTYF  |Transmitter Empty Flag (Read Only)
 * |        |          |This bit is set by hardware when TX FIFO (UART_DAT) is empty and the STOP bit of the last byte has been transmitted.
 * |        |          |0 = TX FIFO is not empty or the STOP bit of the last byte has been not transmitted.
 * |        |          |1 = TX FIFO is empty and the STOP bit of the last byte has been transmitted.
 * |        |          |Note: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.
 * |[29]    |RXIDLE    |RX Idle Status (Read Only)
 * |        |          |This bit is set by hardware when RX is idle.
 * |        |          |0 = RX is busy.
 * |        |          |1 = RX is idle. (Default)
 * |[31]    |TXRXACT   |TX and RX Active Status (Read Only)
 * |        |          |This bit indicates TX and RX are active or inactive.
 * |        |          |0 = TX and RX are inactive.
 * |        |          |1 = TX and RX are active. (Default)
 * |        |          |Note: When TXRXDIS (UART_FUNCSEL[3]) is set and both TX and RX are in idle state, this bit is cleared
 * |        |          |The UART controller can not transmit or receive data at this moment
 * |        |          |Otherwise this bit is set.
 * @var UART_T::INTSTS
 * Offset: 0x1C  UART Interrupt Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |RDAIF     |Receive Data Available Interrupt Flag
 * |        |          |When the number of bytes in the RX FIFO equals the RFITL then the RDAIF(UART_INTSTS[0]) will be set
 * |        |          |If RDAIEN (UART_INTEN [0]) is enabled, the RDA interrupt will be generated.
 * |        |          |0 = No RDA interrupt flag is generated.
 * |        |          |1 = RDA interrupt flag is generated.
 * |        |          |Note: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UART_FIFO[7:4]).
 * |[1]     |THREIF    |Transmit Holding Register Empty Interrupt Flag
 * |        |          |This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register
 * |        |          |If THREIEN (UART_INTEN[1]) is enabled, the THRE interrupt will be generated.
 * |        |          |0 = No THRE interrupt flag is generated.
 * |        |          |1 = THRE interrupt flag is generated.
 * |        |          |Note: This bit is read only and it will be cleared when writing data into UART_DAT (TX FIFO not empty).
 * |[2]     |RLSIF     |Receive Line Interrupt Flag (Read Only)
 * |        |          |This bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UART_FIFOSTS[6]), FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]), is set)
 * |        |          |If RLSIEN (UART_INTEN [2]) is enabled, the RLS interrupt will be generated.
 * |        |          |0 = No RLS interrupt flag is generated.
 * |        |          |1 = RLS interrupt flag is generated.
 * |        |          |Note1: In RS-485 function mode, this field is set include ...receiver detect and received address byte character (bit9 = '1') bit"
 * |        |          |At the same time, the bit of ADDRDETF (UART_FIFOSTS[3]) is also set.
 * |        |          |Note2: This bit is read only and reset to 0 when all bits of BIF (UART_FIFOSTS[6]), FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) are cleared.
 * |        |          |Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF (UART_FIFOSTS[6]) , FEF(UART_FIFOSTS[5]), PEF(UART_FIFOSTS[4]) and ADDRDETF (UART_FIFOSTS[3]) are cleared.
 * |[3]     |MODEMIF   |MODEM Interrupt Flag (Read Only)
 * |        |          |This bit is set when the nCTS pin has state change (CTSDETF (UART_MODEMSTS[0]) = 1)
 * |        |          |If MODEMIEN (UART_INTEN [3]) is enabled, the Modem interrupt will be generated.
 * |        |          |0 = No Modem interrupt flag is generated.
 * |        |          |1 = Modem interrupt flag is generated.
 * |        |          |Note: This bit is read only and reset to 0 when bit CTSDETF is cleared by a write 1 on CTSDETF(UART_MODEMSTS[0]).
 * |[4]     |RXTOIF    |RX Time-out Interrupt Flag (Read Only)
 * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC (UART_TOUT[7:0])
 * |        |          |If RXTOIEN (UART_INTEN [4]) is enabled, the RX time-out interrupt will be generated.
 * |        |          |0 = No RX time-out interrupt flag is generated.
 * |        |          |1 = RX time-out interrupt flag is generated.
 * |        |          |Note: This bit is read only and user can read UART_DAT (RX is in active) to clear it.
 * |[5]     |BUFERRIF  |Buffer Error Interrupt Flag (Read Only)
 * |        |          |This bit is set when the TX FIFO or RX FIFO overflows (TXOVIF (UART_FIFOSTS[24]) or RXOVIF (UART_FIFOSTS[0]) is set)
 * |        |          |When BUFERRIF (UART_INTSTS[5]) is set, the transfer is not correct
 * |        |          |If BUFERRIEN (UART_INTEN [5]) is enabled, the buffer error interrupt will be generated.
 * |        |          |0 = No buffer error interrupt flag is generated.
 * |        |          |1 = Buffer error interrupt flag is generated.
 * |        |          |Note: This bit is cleared if both of RXOVIF(UART_FIFOSTS[0]) and TXOVIF(UART_FIFOSTS[24]) are cleared to 0 by writing 1 to RXOVIF(UART_FIFOSTS[0]) and TXOVIF(UART_FIFOSTS[24]).
 * |[6]     |WKIF      |UART Wake-up Interrupt Flag (Read Only)
 * |        |          |This bit is set when TOUTWKF (UART_WKSTS[4]), RS485WKF (UART_WKSTS[3]), RFRTWKF (UART_WKSTS[2]), DATWKF (UART_WKSTS[1]) or CTSWKF(UART_WKSTS[0]) is set to 1.
 * |        |          |0 = No UART wake-up interrupt flag is generated.
 * |        |          |1 = UART wake-up interrupt flag is generated.
 * |        |          |Note: This bit is cleared if all of TOUTWKF, RS485WKF, RFRTWKF, DATWKF and CTSWKF are cleared to 0 by writing 1 to the corresponding interrupt flag.
 * |[7]     |LINIF     |LIN Bus Interrupt Flag
 * |        |          |This bit is set when LIN slave header detect (SLVHDETF (UART_LINSTS[0] =1)), LIN break detect (BRKDETF(UART_LINSTS[8]=1)), bit error detect (BITEF(UART_LINSTS[9]=1)), LIN slave ID parity error (SLVIDPEF(UART_LINSTS[2] = 1)) or LIN slave header error detect (SLVHEF (UART_LINSTS[1]))
 * |        |          |If LINIEN (UART_INTEN [8]) is enabled the LIN interrupt will be generated.
 * |        |          |0 = None of SLVHDETF, BRKDETF, BITEF, SLVIDPEF and SLVHEF is generated.
 * |        |          |1 = At least one of SLVHDETF, BRKDETF, BITEF, SLVIDPEF and SLVHEF is generated.
 * |        |          |Note: This bit is cleared when SLVHDETF(UART_LINSTS[0]), BRKDETF(UART_LINSTS[8]), BITEF(UART_LINSTS[9]), SLVIDPEF (UART_LINSTS[2]) and SLVHEF(UART_LINSTS[1]) all are cleared and software writing '1' to LINIF(UART_INTSTS[7]).
 * |[8]     |RDAINT    |Receive Data Available Interrupt Indicator (Read Only)
 * |        |          |This bit is set if RDAIEN (UART_INTEN[0]) and RDAIF (UART_INTSTS[0]) are both set to 1.
 * |        |          |0 = No RDA interrupt is generated.
 * |        |          |1 = RDA interrupt is generated.
 * |[9]     |THREINT   |Transmit Holding Register Empty Interrupt Indicator (Read Only)
 * |        |          |This bit is set if THREIEN (UART_INTEN[1]) and THREIF(UART_INTSTS[1]) are both set to 1.
 * |        |          |0 = No THRE interrupt is generated.
 * |        |          |1 = THRE interrupt is generated.
 * |[10]    |RLSINT    |Receive Line Status Interrupt Indicator (Read Only)
 * |        |          |This bit is set if RLSIEN (UART_INTEN[2]) and RLSIF(UART_INTSTS[2]) are both set to 1.
 * |        |          |0 = No RLS interrupt is generated.
 * |        |          |1 = RLS interrupt is generated.
 * |[11]    |MODEMINT  |MODEM Status Interrupt Indicator (Read Only)
 * |        |          |This bit is set if MODEMIEN(UART_INTEN[3]) and MODEMIF(UART_INTSTS[3]) are both set to 1
 * |        |          |0 = No Modem interrupt is generated.
 * |        |          |1 = Modem interrupt is generated.
 * |[12]    |RXTOINT   |RX Time-out Interrupt Indicator (Read Only)
 * |        |          |This bit is set if RXTOIEN (UART_INTEN[4]) and RXTOIF(UART_INTSTS[4]) are both set to 1.
 * |        |          |0 = No RX time-out interrupt is generated.
 * |        |          |1 = RX time-out interrupt is generated.
 * |[13]    |BUFERRINT |Buffer Error Interrupt Indicator (Read Only)
 * |        |          |This bit is set if BUFERRIEN(UART_INTEN[5]) and BUFERRIF(UART_ INTSTS[5]) are both set to 1.
 * |        |          |0 = No buffer error interrupt is generated.
 * |        |          |1 = Buffer error interrupt is generated.
 * |[14]    |WKINT     |UART Wake-up Interrupt Indicator (Read Only)
 * |        |          |This bit is set if WKIEN (UART_INTEN[6]) and WKIF (UART_INTSTS[6]) are both set to 1.
 * |        |          |0 = No UART wake-up interrupt is generated.
 * |        |          |1 = UART wake-up interrupt is generated.
 * |[15]    |LININT    |LIN Bus Interrupt Indicator (Read Only)
 * |        |          |This bit is set if LINIEN (UART_INTEN[8]) and LINIF(UART_INTSTS[7]) are both set to 1.
 * |        |          |0 = No LIN Bus interrupt is generated.
 * |        |          |1 = The LIN Bus interrupt is generated.
 * |[18]    |HWRLSIF   |PDMA Mode Receive Line Status Flag (Read Only)
 * |        |          |This bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF (UART_FIFOSTS[6]), FEF (UART_FIFOSTS[5]) and PEF (UART_FIFOSTS[4]) is set)
 * |        |          |If RLSIEN (UART_INTEN [2]) is enabled, the RLS interrupt will be generated.
 * |        |          |0 = No RLS interrupt flag is generated in PDMA mode.
 * |        |          |1 = RLS interrupt flag is generated in PDMA mode.
 * |        |          |Note1: In RS-485 function mode, this field include ...receiver detect any address byte received address byte character (bit9 = '1') bit".
 * |        |          |Note2: In UART function mode, this bit is read only and reset to 0 when all bits of BIF(UART_FIFOSTS[6]) , FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) are cleared.
 * |        |          |Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UART_FIFOSTS[6]), FEF(UART_FIFOSTS[5]), PEF(UART_FIFOSTS[4]) and ADDRDETF (UART_FIFOSTS[3]) are cleared
 * |[19]    |HWMODIF   |PDMA Mode MODEM Interrupt Flag (Read Only)
 * |        |          |This bit is set when the nCTS pin has state change (CTSDETF (UART_MODEMSTS [0] =1))
 * |        |          |If MODEMIEN (UART_INTEN [3]) is enabled, the Modem interrupt will be generated.
 * |        |          |0 = No Modem interrupt flag is generated in PDMA mode.
 * |        |          |1 = Modem interrupt flag is generated in PDMA mode.
 * |        |          |Note: This bit is read only and reset to 0 when the bit CTSDETF (UART_MODEMSTS[0]) is cleared by writing 1 on CTSDETF (UART_MODEMSTS [0]).
 * |[20]    |HWTOIF    |PDMA Mode RX Time-out Interrupt Flag (Read Only)
 * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC (UART_TOUT[7:0])
 * |        |          |If RXTOIEN (UART_INTEN [4]) is enabled, the RX time-out interrupt will be generated .
 * |        |          |0 = No RX time-out interrupt flag is generated in PDMA mode.
 * |        |          |1 = RX time-out interrupt flag is generated in PDMA mode.
 * |        |          |Note: This bit is read only and user can read UART_DAT (RX is in active) to clear it.
 * |[21]    |HWBUFEIF  |PDMA Mode Buffer Error Interrupt Flag (Read Only)
 * |        |          |This bit is set when the TX or RX FIFO overflows (TXOVIF (UART_FIFOSTS [24]) or RXOVIF (UART_FIFOSTS[0]) is set)
 * |        |          |When BUFERRIF (UART_INTSTS[5]) is set, the transfer maybe is not correct
 * |        |          |If BUFERRIEN (UART_INTEN [5]) is enabled, the buffer error interrupt will be generated.
 * |        |          |0 = No buffer error interrupt flag is generated in PDMA mode.
 * |        |          |1 = Buffer error interrupt flag is generated in PDMA mode.
 * |        |          |Note: This bit is cleared when both TXOVIF (UART_FIFOSTS[24]]) and RXOVIF (UART_FIFOSTS[0]) are cleared.
 * |[22]    |TXENDIF   |Transmitter Empty Interrupt Flag
 * |        |          |This bit is set when TX FIFO (UART_DAT) is empty and the STOP bit of the last byte has been transmitted (TXEMPTYF (UART_FIFOSTS[28]) is set)
 * |        |          |If TXENDIEN (UART_INTEN[22]) is enabled, the Transmitter Empty interrupt will be generated.
 * |        |          |0 = No transmitter empty interrupt flag is generated.
 * |        |          |1 = Transmitter empty interrupt flag is generated.
 * |        |          |Note: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.
 * |[26]    |HWRLSINT  |PDMA Mode Receive Line Status Interrupt Indicator (Read Only)
 * |        |          |This bit is set if RLSIEN (UART_INTEN[2]) and HWRLSIF(UART_INTSTS[18]) are both set to 1.
 * |        |          |0 = No RLS interrupt is generated in PDMA mode.
 * |        |          |1 = RLS interrupt is generated in PDMA mode.
 * |[27]    |HWMODINT  |PDMA Mode MODEM Status Interrupt Indicator (Read Only)
 * |        |          |This bit is set if MODEMIEN (UART_INTEN[3]) and HWMODIF(UART_INTSTS[19]) are both set to 1.
 * |        |          |0 = No Modem interrupt is generated in PDMA mode.
 * |        |          |1 = Modem interrupt is generated in PDMA mode.
 * |[28]    |HWTOINT   |PDMA Mode RX Time-out Interrupt Indicator (Read Only)
 * |        |          |This bit is set if RXTOIEN (UART_INTEN[4]) and HWTOIF(UART_INTSTS[20]) are both set to 1.
 * |        |          |0 = No RX time-out interrupt is generated in PDMA mode.
 * |        |          |1 = RX time-out interrupt is generated in PDMA mode.
 * |[29]    |HWBUFEINT |PDMA Mode Buffer Error Interrupt Indicator (Read Only)
 * |        |          |This bit is set if BUFERRIEN (UART_INTEN[5]) and HWBUFEIF (UART_INTSTS[21]) are both set to 1.
 * |        |          |0 = No buffer error interrupt is generated in PDMA mode.
 * |        |          |1 = Buffer error interrupt is generated in PDMA mode.
 * |[30]    |TXENDINT  |Transmitter Empty Interrupt Indicator (Read Only)
 * |        |          |This bit is set if TXENDIEN (UART_INTEN[22]) and TXENDIF(UART_INTSTS[22]) are both set to 1.
 * |        |          |0 = No Transmitter Empty interrupt is generated.
 * |        |          |1 = Transmitter Empty interrupt is generated.
 * |[31]    |ABRINT    |Auto-baud Rate Interrupt Indicator (Read Only)
 * |        |          |This bit is set if ABRIEN (UART_INTEN[18]) and ABRIF (UART_ALTCTL[17]) are both set to 1.
 * |        |          |0 = No Auto-baud Rate interrupt is generated.
 * |        |          |1 = The Auto-baud Rate interrupt is generated.
 * @var UART_T::TOUT
 * Offset: 0x20  UART Time-out Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[7:0]   |TOIC      |Time-out Interrupt Comparator
 * |        |          |The time-out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO receives a new data word if time out counter is enabled by setting TOCNTEN (UART_INTEN[11])
 * |        |          |Once the content of time-out counter is equal to that of time-out interrupt comparator (TOIC (UART_TOUT[7:0])), a receiver time-out interrupt (RXTOINT(UART_INTSTS[12])) is generated if RXTOIEN (UART_INTEN [4]) enabled
 * |        |          |A new incoming data word or RX FIFO empty will clear RXTOIF (UART_INTSTS[4])
 * |        |          |In order to avoid receiver time-out interrupt generation immediately during one character is being received, TOIC value should be set between 40 and 255
 * |        |          |So, for example, if TOIC is set with 40, the time-out interrupt is generated after four characters are not received when 1 stop bit and no parity check is set for UART transfer.
 * |[15:8]  |DLY       |TX Delay Time Value
 * |        |          |This field is used to programming the transfer delay time between the last stop bit and next start bit
 * |        |          |The unit is bit time.
 * @var UART_T::BAUD
 * Offset: 0x24  UART Baud Rate Divider Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |BRD       |Baud Rate Divider
 * |        |          |The field indicates the baud rate divider
 * |        |          |This filed is used in baud rate calculation
 * |        |          |The detail description is shown in Table 6.12-4.
 * |[27:24] |EDIVM1    |Extra Divider for BAUD Rate Mode 1
 * |        |          |This field is used for baud rate calculation in mode 1 and has no effect for baud rate calculation in mode 0 and mode 2
 * |        |          |The detail description is shown in Table 6.12-4
 * |[28]    |BAUDM0    |BAUD Rate Mode Selection Bit 0
 * |        |          |This bit is baud rate mode selection bit 0
 * |        |          |UART provides three baud rate calculation modes
 * |        |          |This bit combines with BAUDM1 (UART_BAUD[29]) to select baud rate calculation mode
 * |        |          |The detail description is shown in Table 6.12-4.
 * |[29]    |BAUDM1    |BAUD Rate Mode Selection Bit 1
 * |        |          |This bit is baud rate mode selection bit 1
 * |        |          |UART provides three baud rate calculation modes
 * |        |          |This bit combines with BAUDM0 (UART_BAUD[28]) to select baud rate calculation mode
 * |        |          |The detail description is shown in Table 6.12-4.
 * |        |          |Note: In IrDA mode must be operated in mode 0.
 * @var UART_T::IRDA
 * Offset: 0x28  UART IrDA Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1]     |TXEN      |IrDA Receiver/Transmitter Selection Enable Bit
 * |        |          |0 = IrDA Transmitter Disabled and Receiver Enabled. (Default)
 * |        |          |1 = IrDA Transmitter Enabled and Receiver Disabled.
 * |[5]     |TXINV     |IrDA Inverse Transmitting Output Signal
 * |        |          |0 = None inverse transmitting signal. (Default).
 * |        |          |1 = Inverse transmitting output signal.
 * |        |          |Note1: Before setting this bit, TXRXDIS (UART_FUNCSEL[3]) should be set then waited for TXRXACT (UART_FIFOSTS[31]) is cleared
 * |        |          |When the configuration is done, cleared TXRXDIS (UART_FUNCSEL[3]) to activate UART controller.
 * |        |          |Note2: This bit is valid when FUNCSEL (UART_FUNCSEL[1:0]) is select IrDA function.
 * |[6]     |RXINV     |IrDA Inverse Receive Input Signal
 * |        |          |0 = None inverse receiving input signal.
 * |        |          |1 = Inverse receiving input signal. (Default)
 * |        |          |Note1: Before setting this bit, TXRXDIS (UART_FUNCSEL[3]) should be set then waited for TXRXACT (UART_FIFOSTS[31]) is cleared
 * |        |          |When the configuration is done, cleared TXRXDIS (UART_FUNCSEL[3]) to activate UART controller.
 * |        |          |Note2: This bit is valid when FUNCSEL (UART_FUNCSEL[1:0]) is select IrDA function.
 * @var UART_T::ALTCTL
 * Offset: 0x2C  UART Alternate Control/Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |BRKFL     |UART LIN Break Field Length
 * |        |          |This field indicates a 4-bit LIN TX break field count.
 * |        |          |Note1: This break field length is BRKFL + 1.
 * |        |          |Note2: According to LIN spec, the reset value is 0xC (break field length = 13).
 * |[6]     |LINRXEN   |LIN RX Enable Bit
 * |        |          |0 = LIN RX mode Disabled.
 * |        |          |1 = LIN RX mode Enabled.
 * |[7]     |LINTXEN   |LIN TX Break Mode Enable Bit
 * |        |          |0 = LIN TX Break mode Disabled.
 * |        |          |1 = LIN TX Break mode Enabled.
 * |        |          |Note: When TX break field transfer operation finished, this bit will be cleared automatically.
 * |[8]     |RS485NMM  |RS-485 Normal Multi-drop Operation Mode (NMM)
 * |        |          |0 = RS-485 Normal Multi-drop Operation mode (NMM) Disabled.
 * |        |          |1 = RS-485 Normal Multi-drop Operation mode (NMM) Enabled.
 * |        |          |Note: It cannot be active with RS-485_AAD operation mode.
 * |[9]     |RS485AAD  |RS-485 Auto Address Detection Operation Mode (AAD)
 * |        |          |0 = RS-485 Auto Address Detection Operation mode (AAD) Disabled.
 * |        |          |1 = RS-485 Auto Address Detection Operation mode (AAD) Enabled.
 * |        |          |Note: It cannot be active with RS-485_NMM operation mode.
 * |[10]    |RS485AUD  |RS-485 Auto Direction Function (AUD)
 * |        |          |0 = RS-485 Auto Direction Operation function (AUD) Disabled.
 * |        |          |1 = RS-485 Auto Direction Operation function (AUD) Enabled.
 * |        |          |Note: It can be active with RS-485_AAD or RS-485_NMM operation mode.
 * |[15]    |ADDRDEN   |RS-485 Address Detection Enable Bit
 * |        |          |This bit is used to enable RS-485 Address Detection mode.
 * |        |          |0 = Address detection mode Disabled.
 * |        |          |1 = Address detection mode Enabled.
 * |        |          |Note: This bit is used for RS-485 any operation mode.
 * |[17]    |ABRIF     |Auto-baud Rate Interrupt Flag (Read Only)
 * |        |          |This bit is set when auto-baud rate detection function finished or the auto-baud rate counter was overflow and if ABRIEN(UART_INTEN [18]) is set then the auto-baud rate interrupt will be generated.
 * |        |          |0 = No auto-baud rate interrupt flag is generated.
 * |        |          |1 = Auto-baud rate interrupt flag is generated.
 * |        |          |Note: This bit is read only, but it can be cleared by writing ...1u201D to ABRDTOIF (UART_FIFOSTS[2]) and ABRDIF(UART_FIFOSTS[1])
 * |[18]    |ABRDEN    |Auto-baud Rate Detect Enable Bit
 * |        |          |0 = Auto-baud rate detect function Disabled.
 * |        |          |1 = Auto-baud rate detect function Enabled.
 * |        |          |Note : This bit is cleared automatically after auto-baud detection is finished.
 * |[20:19] |ABRDBITS  |Auto-baud Rate Detect Bit Length
 * |        |          |00 = 1-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x01.
 * |        |          |01 = 2-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x02.
 * |        |          |10 = 4-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x08.
 * |        |          |11 = 8-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x80.
 * |        |          |Note : The calculation of bit number includes the START bit.
 * |[31:24] |ADDRMV    |Address Match Value
 * |        |          |This field contains the RS-485 address match values.
 * |        |          |Note: This field is used for RS-485 auto address detection mode.
 * @var UART_T::FUNCSEL
 * Offset: 0x30  UART Function Select Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |FUNCSEL   |Function Select
 * |        |          |00 = UART function.
 * |        |          |01 = LIN function.
 * |        |          |10 = IrDA function.
 * |        |          |11 = RS-485 function.
 * |[3]     |TXRXDIS   |TX and RX Disable Bit
 * |        |          |Setting this bit can disable TX and RX.
 * |        |          |0 = TX and RX Enabled.
 * |        |          |1 = TX and RX Disabled.
 * |        |          |Note: The TX and RX will not disable immediately when this bit is set
 * |        |          |The TX and RX compelet current task before disable TX and RX
 * |        |          |When TX and RX disable, the TXRXACT (UART_FIFOSTS[31]) is cleared.
 * @var UART_T::LINCTL
 * Offset: 0x34  UART LIN Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |SLVEN     |LIN Slave Mode Enable Bit
 * |        |          |0 = LIN slave mode Disabled.
 * |        |          |1 = LIN slave mode Enabled.
 * |[1]     |SLVHDEN   |LIN Slave Header Detection Enable Bit
 * |        |          |0 = LIN slave header detection Disabled.
 * |        |          |1 = LIN slave header detection Enabled.
 * |        |          |Note1: This bit only valid when in LIN slave mode (SLVEN (UART_LINCTL[0]) = 1).
 * |        |          |Note2: In LIN function mode, when detect header field (break + sync + frame ID), SLVHDETF (UART_LINSTS [0]) flag will be asserted
 * |        |          |If the LINIEN (UART_INTEN[8]) = 1, an interrupt will be generated.
 * |[2]     |SLVAREN   |LIN Slave Automatic Resynchronization Mode Enable Bit
 * |        |          |0 = LIN automatic resynchronization Disabled.
 * |        |          |1 = LIN automatic resynchronization Enabled.
 * |        |          |Note1: This bit only valid when in LIN slave mode (SLVEN (UART_LINCTL[0]) = 1).
 * |        |          |Note2: When operation in Automatic Resynchronization mode, the baud rate setting must be mode2 (BAUDM1 (UART_BAUD [29]) and BAUDM0 (UART_BAUD [28]) must be 1).
 * |        |          |Note3: The control and interactions of this field are explained in 6.12.5.10 (Slave mode with automatic resynchronization).
 * |[3]     |SLVDUEN   |LIN Slave Divider Update Method Enable Bit
 * |        |          |0 = UART_BAUD updated is written by software (if no automatic resynchronization update occurs at the same time).
 * |        |          |1 = UART_BAUD is updated at the next received character
 * |        |          |User must set the bit before checksum reception.
 * |        |          |Note1: This bit only valid when in LIN slave mode (SLVEN (UART_LINCTL[0]) = 1).
 * |        |          |Note2: This bit used for LIN Slave Automatic Resynchronization mode
 * |        |          |(for Non-Automatic Resynchronization mode, this bit should be kept cleared)
 * |        |          |Note3: The control and interactions of this field are explained in 6.12.5.10 (Slave mode with automatic resynchronization).
 * |[4]     |MUTE      |LIN Mute Mode Enable Bit
 * |        |          |0 = LIN mute mode Disabled.
 * |        |          |1 = LIN mute mode Enabled.
 * |        |          |Note: The exit from mute mode condition and each control and interactions of this field are explained in 6.12.5.10 (LIN slave mode).
 * |[8]     |SENDH     |LIN TX Send Header Enable Bit
 * |        |          |The LIN TX header can be ...break fieldu201D or ...break and sync fieldu201D or ...break, sync and frame ID fieldu201D, it is depend on setting HSEL (UART_LINCTL[23:22]).
 * |        |          |0 = Send LIN TX header Disabled.
 * |        |          |1 = Send LIN TX header Enabled.
 * |        |          |Note1: This bit is shadow bit of LINTXEN (UART_ALTCTL [7]); user can read/write it by setting LINTXEN (UART_ALTCTL [7]) or SENDH (UART_LINCTL [8]).
 * |        |          |Note2: When transmitter header field (it may be ...breaku201D or ...break + syncu201D or ...break + sync + frame IDu201D selected by HSEL (UART_LINCTL[23:22]) field) transfer operation finished, this bit will be cleared automatically.
 * |[9]     |IDPEN     |LIN ID Parity Enable Bit
 * |        |          |0 = LIN frame ID parity Disabled.
 * |        |          |1 = LIN frame ID parity Enabled.
 * |        |          |Note1: This bit can be used for LIN master to sending header field (SENDH (UART_LINCTL[8])) = 1 and HSEL (UART_LINCTL[23:22]) = 10 or be used for enable LIN slave received frame ID parity checked.
 * |        |          |Note2: This bit is only used when the operation header transmitter is in HSEL (UART_LINCTL[23:22]) = 10
 * |[10]    |BRKDETEN  |LIN Break Detection Enable Bit
 * |        |          |When detect consecutive dominant greater than 11 bits, and are followed by a delimiter character, the BRKDETF (UART_LINSTS[8]) flag is set at the end of break field
 * |        |          |If the LINIEN (UART_INTEN [8])=1, an interrupt will be generated.
 * |        |          |0 = LIN break detection Disabled .
 * |        |          |1 = LIN break detection Enabled.
 * |[11]    |LINRXOFF  |LIN Receiver Disable Bit
 * |        |          |If the receiver is enabled (LINRXOFF (UART_LINCTL[11] ) = 0), all received byte data will be accepted and stored in the RX FIFO, and if the receiver is disabled (LINRXOFF (UART_LINCTL[11] = 1), all received byte data will be ignore.
 * |        |          |0 = LIN receiver Enabled.
 * |        |          |1 = LIN receiver Disabled.
 * |        |          |Note: This bit is only valid when operating in LIN function mode (FUNCSEL (UART_FUNCSEL[1:0]) = 01).
 * |[12]    |BITERREN  |Bit Error Detect Enable Bit
 * |        |          |0 = Bit error detection function Disabled.
 * |        |          |1 = Bit error detection function Enabled.
 * |        |          |Note: In LIN function mode, when occur bit error, the BITEF (UART_LINSTS[9]) flag will be asserted
 * |        |          |If the LINIEN (UART_INTEN[8]) = 1, an interrupt will be generated.
 * |[19:16] |BRKFL     |LIN Break Field Length
 * |        |          |This field indicates a 4-bit LIN TX break field count.
 * |        |          |Note1: These registers are shadow registers of BRKFL (UART_ALTCTL[3:0]), User can read/write it by setting BRKFL (UART_ALTCTL[3:0]) or BRKFL (UART_LINCTL[19:16]).
 * |        |          |Note2: This break field length is BRKFL + 1.
 * |        |          |Note3: According to LIN spec, the reset value is 12 (break field length = 13).
 * |[21:20] |BSL       |LIN Break/Sync Delimiter Length
 * |        |          |00 = The LIN break/sync delimiter length is 1-bit time.
 * |        |          |01 = The LIN break/sync delimiter length is 2-bit time.
 * |        |          |10 = The LIN break/sync delimiter length is 3-bit time.
 * |        |          |11 = The LIN break/sync delimiter length is 4-bit time.
 * |        |          |Note: This bit used for LIN master to sending header field.
 * |[23:22] |HSEL      |LIN Header Select
 * |        |          |00 = The LIN header includes ...break fieldu201D.
 * |        |          |01 = The LIN header includes ...break fieldu201D and ...sync fieldu201D.
 * |        |          |10 = The LIN header includes ...break fieldu201D, ...sync fieldu201D and ...frame ID fieldu201D.
 * |        |          |11 = Reserved.
 * |        |          |Note: This bit is used to master mode for LIN to send header field (SENDH (UART_LINCTL [8]) = 1) or used to slave to indicates exit from mute mode condition (MUTE (UART_LINCTL[4] = 1).
 * |[31:24] |PID       |LIN PID Bits
 * |        |          |This field contains the LIN frame ID value when in LIN function mode, the frame ID parity can be generated by software or hardware depends on IDPEN (UART_LINCTL[9]) = 1.
 * |        |          |If the parity generated by hardware, user fill ID0~ID5 (PID [29:24] ), hardware will calculate P0 (PID[30]) and P1 (PID[31]), otherwise user must filled frame ID and parity in this field.
 * |        |          |Note1: User can fill any 8-bit value to this field and the bit 24 indicates ID0 (LSB first).
 * |        |          |Note2: This field can be used for LIN master mode or slave mode.
 * @var UART_T::LINSTS
 * Offset: 0x38  UART LIN Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |SLVHDETF  |LIN Slave Header Detection Flag
 * |        |          |This bit is set by hardware when a LIN header is detected in LIN slave mode and be cleared by writing 1 to it.
 * |        |          |0 = LIN header not detected.
 * |        |          |1 = LIN header detected (break + sync + frame ID).
 * |        |          |Note1: This bit can be cleared by writing 1 to it.
 * |        |          |Note2: This bit is only valid when in LIN slave mode (SLVEN (UART_LINCTL [0]) = 1) and enable LIN slave header detection function (SLVHDEN (UART_LINCTL [1])).
 * |        |          |Note3: When enable ID parity check IDPEN (UART_LINCTL [9]), if hardware detect complete header (...break + sync + frame IDu201D), the SLVHDETF will be set whether the frame ID correct or not.
 * |[1]     |SLVHEF    |LIN Slave Header Error Flag
 * |        |          |This bit is set by hardware when a LIN header error is detected in LIN slave mode and be cleared by writing 1 to it
 * |        |          |The header errors include ...break delimiter is too short (less than 0.5 bit time)u201D, ...frame error in sync field or Identifier fieldu201D, ...sync field data is not 0x55 in Non-Automatic Resynchronization modeu201D, ...sync field deviation error with Automatic Resynchronization modeu201D, ...sync field measure time-out with Automatic Resynchronization modeu201D and ...LIN header reception time-outu201D.
 * |        |          |0 = LIN header error not detected.
 * |        |          |1 = LIN header error detected.
 * |        |          |Note1: This bit can be cleared by writing 1 to it.
 * |        |          |Note2: This bit is only valid when UART is operated in LIN slave mode (SLVEN (UART_LINCTL [0]) = 1) and enables LIN slave header detection function (SLVHDEN (UART_LINCTL [1])).
 * |[2]     |SLVIDPEF  |LIN Slave ID Parity Error Flag
 * |        |          |This bit is set by hardware when receipted frame ID parity is not correct.
 * |        |          |0 = No active.
 * |        |          |1 = Receipted frame ID parity is not correct.
 * |        |          |Note1: This bit can be cleared by writing 1 to it.
 * |        |          |Note2: This bit is only valid when in LIN slave mode (SLVEN (UART_LINCTL [0])= 1) and enable LIN frame ID parity check function IDPEN (UART_LINCTL [9]).
 * |[3]     |SLVSYNCF  |LIN Slave Sync Field
 * |        |          |This bit indicates that the LIN sync field is being analyzed in Automatic Resynchronization mode
 * |        |          |When the receiver header have some error been detect, user must reset the internal circuit to re-search new frame header by writing 1 to this bit.
 * |        |          |0 = The current character is not at LIN sync state.
 * |        |          |1 = The current character is at LIN sync state.
 * |        |          |Note1: This bit is only valid when in LIN Slave mode (SLVEN(UART_LINCTL[0]) = 1).
 * |        |          |Note2: This bit can be cleared by writing 1 to it.
 * |        |          |Note3: When writing 1 to it, hardware will reload the initial baud rate and re-search a new frame header.
 * |[8]     |BRKDETF   |LIN Break Detection Flag
 * |        |          |This bit is set by hardware when a break is detected and be cleared by writing 1 to it through software.
 * |        |          |0 = LIN break not detected.
 * |        |          |1 = LIN break detected.
 * |        |          |Note1: This bit can be cleared by writing 1 to it.
 * |        |          |Note2: This bit is only valid when LIN break detection function is enabled (BRKDETEN (UART_LINCTL[10]) =1).
 * |[9]     |BITEF     |Bit Error Detect Status Flag
 * |        |          |At TX transfer state, hardware will monitor the bus state, if the input pin (UART0_RXD) state not equals to the output pin (UART_TXD) state, BITEF (UART_LINSTS[9]) will be set.
 * |        |          |When occur bit error, if the LINIEN (UART_INTEN[8]) = 1, an interrupt will be generated.
 * |        |          |0 = Bit error not detected.
 * |        |          |1 = Bit error detected.
 * |        |          |Note1: This bit can be cleared by writing 1 to it.
 * |        |          |Note2: This bit is only valid when enable bit error detection function (BITERREN (UART_LINCTL [12]) = 1).
 * @var UART_T::BRCOMP
 * Offset: 0x3C  UART Baud Rate Compensation Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:0]   |BRCOMP    |Baud Rate Compensation Patten
 * |        |          |These 9-bits are used to define the relative bit is compensated or not.
 * |        |          |BRCOMP[7:0] is used to define the compensation of UART_DAT[7:0] and BRCOM[8] is used to define the parity bit.
 * |[31]    |BRCOMPDEC |Baud Rate Compensation Decrease
 * |        |          |0 = Positive (increase one module clock) compensation for each compensated bit.
 * |        |          |1 = Negative (decrease one module clock) compensation for each compensated bit.
 * @var UART_T::WKCTL
 * Offset: 0x40  UART Wake-up Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |WKCTSEN   |nCTS Wake-up Enable Bit
 * |        |          |0 = nCTS Wake-up system function Disabled.
 * |        |          |1 = nCTS Wake-up system function Enabled, when the system is in Power-down mode, an external.
 * |        |          |nCTS change will wake-up system from Power-down mode.
 * |[1]     |WKDATEN   |Incoming Data Wake-up Enable Bit
 * |        |          |0 = Incoming data wake-up system function Disabled.
 * |        |          |1 = Incoming data wake-up system function Enabled, when the system is in Power-down mode,.
 * |        |          |incoming data will wake-up system from Power-down mode.
 * |[2]     |WKRFRTEN  |Received Data FIFO Reached Threshold Wake-up Enable Bit
 * |        |          |0 = Received Data FIFO reached threshold wake-up system function Disabled.
 * |        |          |1 = Received Data FIFO reached threshold wake-up system function Enabled, when the system is.
 * |        |          |in Power-down mode, Received Data FIFO reached threshold will wake-up system from
 * |        |          |Power-down mode.
 * |[3]     |WKRS485EN |RS-485 Address Match (AAD Mode) Wake-up Enable Bit
 * |        |          |0 = RS-485 Address Match (AAD mode) wake-up system function Disabled.
 * |        |          |1 = RS-485 Address Match (AAD mode) wake-up system function Enabled, when the system is in.
 * |        |          |Power-down mode, RS-485 Address Match will wake-up system from Power-down mode.
 * |        |          |Note: This bit is used for RS-485 Auto Address Detection (AAD) mode in RS-485 function mode
 * |        |          |and ADDRDEN (UART_ALTCTL[15]) is set to 1.
 * |[4]     |WKTOUTEN  |Received Data FIFO Reached Threshold Time-out Wake-up Enable Bit
 * |        |          |0 = Received Data FIFO reached threshold time-out wake-up system function Disabled.
 * |        |          |1 = Received Data FIFO reached threshold time-out wake-up system function Enabled, when the.
 * |        |          |system is in Power-down mode, Received Data FIFO reached threshold time-out will wake-up
 * |        |          |system from Power-down mode.
 * |        |          |Note: It is suggest the function is enabled when the WKRFRTEN (UART_WKCTL[2]) is set to 1.
 * @var UART_T::WKSTS
 * Offset: 0x44  UART Wake-up Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CTSWKF    |nCTS Wake-up Flag
 * |        |          |This bit is set if chip wake-up from power-down state by nCTS wake-up.
 * |        |          |0 = Chip stays in power-down state.
 * |        |          |1 = Chip wake-up from power-down state by nCTS wake-up.
 * |        |          |Note1: If WKCTSEN (UART_WKCTL[0]) is enabled, the nCTS wake-up cause this bit is set to '1'.
 * |        |          |Note2: This bit can be cleared by writing '1' to it.
 * |[1]     |DATWKF    |Incoming Data Wake-up Flag
 * |        |          |This bit is set if chip wake-up from power-down state by data wake-up.
 * |        |          |0 = Chip stays in power-down state.
 * |        |          |1 = Chip wake-up from power-down state by Incoming Data wake-up.
 * |        |          |Note1: If WKDATEN (UART_WKCTL[1]) is enabled, the Incoming Data wake-up cause this bit is set to '1'.
 * |        |          |Note2: This bit can be cleared by writing '1' to it.
 * |[2]     |RFRTWKF   |Received Data FIFO Reached Threshold Wake-up Flag
 * |        |          |This bit is set if chip wake-up from power-down state by Received Data FIFO reached threshold
 * |        |          |wake-up .
 * |        |          |0 = Chip stays in power-down state.
 * |        |          |1 = Chip wake-up from power-down state by Received Data FIFO Reached Threshold wake-up.
 * |        |          |Note1: If WKRFRTEN (UART_WKCTL[2]) is enabled, the Received Data FIFO Reached Threshold wake-up cause this bit is set to '1'.
 * |        |          |Note2: This bit can be cleared by writing '1' to it.
 * |[3]     |RS485WKF  |RS-485 Address Match (AAD Mode) Wake-up Flag
 * |        |          |This bit is set if chip wake-up from power-down state by RS-485 Address Match (AAD mode).
 * |        |          |0 = Chip stays in power-down state.
 * |        |          |1 = Chip wake-up from power-down state by RS-485 Address Match (AAD mode) wake-up.
 * |        |          |Note1: If WKRS485EN (UART_WKCTL[3]) is enabled, the RS-485 Address Match (AAD mode) wake-up cause this bit is set to '1'.
 * |        |          |Note2: This bit can be cleared by writing '1' to it.
 * |[4]     |TOUTWKF   |Received Data FIFO Threshold Time-out Wake-up Flag
 * |        |          |This bit is set if chip wake-up from power-down state by Received Data FIFO Threshold Time-out
 * |        |          |wake-up.
 * |        |          |0 = Chip stays in power-down state.
 * |        |          |1 = Chip wake-up from power-down state by Received Data FIFO reached threshold time-out.
 * |        |          |wake-up.
 * |        |          |Note1: If WKTOUTEN (UART_WKCTL[4]) is enabled, the Received Data FIFO reached threshold time-out wake-up cause this bit is set to '1'.
 * |        |          |Note2: This bit can be cleared by writing '1' to it.
 * @var UART_T::DWKCOMP
 * Offset: 0x48  UART Imcoming Data Wake-up Compensation Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |STCOMP    |Start Bit Compensation Value
 * |        |          |These bits field indicate how many clock cycle selected by UART0_CLK do the UART controller can get the 1st bit (start bit) when the device is wake-up from power-down mode.
 * |        |          |Note: It is valid only when WKDATEN (UART_WKCTL[1]) is set.
 * @var UART_T::VERSION
 * Offset: 0xFFC  UART Module Version Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |MINOR     |RTL Design MINOR Version Number
 * |        |          |Minor version number is dependent on module's ECO version control.
 * |        |          |0x0000:(Current Minor Version Number)
 * |[23:16] |SUB       |RTL Design SUB Version Number
 * |        |          |Sub version number is correlated to module's key feature.
 * |        |          |0x01:(Current Sub Version Number)
 * |[31:24] |MAJOR     |RTL Design MAJOR Version Number
 * |        |          |Major version number is correlated to Product Line
 * |        |          |0x03:(Current Major Version Number)
 */
    __IO uint32_t DAT;                   /*!< [0x0000] UART Receive/Transmit Buffer Register                            */
    __IO uint32_t INTEN;                 /*!< [0x0004] UART Interrupt Enable Register                                   */
    __IO uint32_t FIFO;                  /*!< [0x0008] UART FIFO Control Register                                       */
    __IO uint32_t LINE;                  /*!< [0x000c] UART Line Control Register                                       */
    __IO uint32_t MODEM;                 /*!< [0x0010] UART Modem Control Register                                      */
    __IO uint32_t MODEMSTS;              /*!< [0x0014] UART Modem Status Register                                       */
    __IO uint32_t FIFOSTS;               /*!< [0x0018] UART FIFO Status Register                                        */
    __IO uint32_t INTSTS;                /*!< [0x001c] UART Interrupt Status Register                                   */
    __IO uint32_t TOUT;                  /*!< [0x0020] UART Time-out Register                                           */
    __IO uint32_t BAUD;                  /*!< [0x0024] UART Baud Rate Divider Register                                  */
    __IO uint32_t IRDA;                  /*!< [0x0028] UART IrDA Control Register                                       */
    __IO uint32_t ALTCTL;                /*!< [0x002c] UART Alternate Control/Status Register                           */
    __IO uint32_t FUNCSEL;               /*!< [0x0030] UART Function Select Register                                    */
    __IO uint32_t LINCTL;                /*!< [0x0034] UART LIN Control Register                                        */
    __IO uint32_t LINSTS;                /*!< [0x0038] UART LIN Status Register                                         */
    __IO uint32_t BRCOMP;                /*!< [0x003c] UART Baud Rate Compensation Register                             */
    __IO uint32_t WKCTL;                 /*!< [0x0040] UART Wake-up Control Register                                    */
    __IO uint32_t WKSTS;                 /*!< [0x0044] UART Wake-up Status Register                                     */
    __IO uint32_t DWKCOMP;               /*!< [0x0048] UART Imcoming Data Wake-up Compensation Register                 */
    __I  uint32_t RESERVE0[1004];
    __I  uint32_t VERSION;               /*!< [0x0ffc] UART Module Version Register                                     */

} UART_T;

/**
    @addtogroup UART_CONST UART Bit Field Definition
    Constant Definitions for UART Controller
@{ */

#define UART_DAT_DAT_Pos                 (0)                                               /*!< UART_T::DAT: DAT Position              */
#define UART_DAT_DAT_Msk                 (0xfful << UART_DAT_DAT_Pos)                      /*!< UART_T::DAT: DAT Mask                  */

#define UART_DAT_PARITY_Pos              (8)                                               /*!< UART_T::DAT: PARITY Position           */
#define UART_DAT_PARITY_Msk              (0x1ul << UART_DAT_PARITY_Pos)                    /*!< UART_T::DAT: PARITY Mask               */

#define UART_INTEN_RDAIEN_Pos            (0)                                               /*!< UART_T::INTEN: RDAIEN Position         */
#define UART_INTEN_RDAIEN_Msk            (0x1ul << UART_INTEN_RDAIEN_Pos)                  /*!< UART_T::INTEN: RDAIEN Mask             */

#define UART_INTEN_THREIEN_Pos           (1)                                               /*!< UART_T::INTEN: THREIEN Position        */
#define UART_INTEN_THREIEN_Msk           (0x1ul << UART_INTEN_THREIEN_Pos)                 /*!< UART_T::INTEN: THREIEN Mask            */

#define UART_INTEN_RLSIEN_Pos            (2)                                               /*!< UART_T::INTEN: RLSIEN Position         */
#define UART_INTEN_RLSIEN_Msk            (0x1ul << UART_INTEN_RLSIEN_Pos)                  /*!< UART_T::INTEN: RLSIEN Mask             */

#define UART_INTEN_MODEMIEN_Pos          (3)                                               /*!< UART_T::INTEN: MODEMIEN Position       */
#define UART_INTEN_MODEMIEN_Msk          (0x1ul << UART_INTEN_MODEMIEN_Pos)                /*!< UART_T::INTEN: MODEMIEN Mask           */

#define UART_INTEN_RXTOIEN_Pos           (4)                                               /*!< UART_T::INTEN: RXTOIEN Position        */
#define UART_INTEN_RXTOIEN_Msk           (0x1ul << UART_INTEN_RXTOIEN_Pos)                 /*!< UART_T::INTEN: RXTOIEN Mask            */

#define UART_INTEN_BUFERRIEN_Pos         (5)                                               /*!< UART_T::INTEN: BUFERRIEN Position      */
#define UART_INTEN_BUFERRIEN_Msk         (0x1ul << UART_INTEN_BUFERRIEN_Pos)               /*!< UART_T::INTEN: BUFERRIEN Mask          */

#define UART_INTEN_WKIEN_Pos             (6)                                               /*!< UART_T::INTEN: WKIEN Position          */
#define UART_INTEN_WKIEN_Msk             (0x1ul << UART_INTEN_WKIEN_Pos)                   /*!< UART_T::INTEN: WKIEN Mask              */

#define UART_INTEN_LINIEN_Pos            (8)                                               /*!< UART_T::INTEN: LINIEN Position         */
#define UART_INTEN_LINIEN_Msk            (0x1ul << UART_INTEN_LINIEN_Pos)                  /*!< UART_T::INTEN: LINIEN Mask             */

#define UART_INTEN_TOCNTEN_Pos           (11)                                              /*!< UART_T::INTEN: TOCNTEN Position        */
#define UART_INTEN_TOCNTEN_Msk           (0x1ul << UART_INTEN_TOCNTEN_Pos)                 /*!< UART_T::INTEN: TOCNTEN Mask            */

#define UART_INTEN_ATORTSEN_Pos          (12)                                              /*!< UART_T::INTEN: ATORTSEN Position       */
#define UART_INTEN_ATORTSEN_Msk          (0x1ul << UART_INTEN_ATORTSEN_Pos)                /*!< UART_T::INTEN: ATORTSEN Mask           */

#define UART_INTEN_ATOCTSEN_Pos          (13)                                              /*!< UART_T::INTEN: ATOCTSEN Position       */
#define UART_INTEN_ATOCTSEN_Msk          (0x1ul << UART_INTEN_ATOCTSEN_Pos)                /*!< UART_T::INTEN: ATOCTSEN Mask           */

#define UART_INTEN_TXPDMAEN_Pos          (14)                                              /*!< UART_T::INTEN: TXPDMAEN Position       */
#define UART_INTEN_TXPDMAEN_Msk          (0x1ul << UART_INTEN_TXPDMAEN_Pos)                /*!< UART_T::INTEN: TXPDMAEN Mask           */

#define UART_INTEN_RXPDMAEN_Pos          (15)                                              /*!< UART_T::INTEN: RXPDMAEN Position       */
#define UART_INTEN_RXPDMAEN_Msk          (0x1ul << UART_INTEN_RXPDMAEN_Pos)                /*!< UART_T::INTEN: RXPDMAEN Mask           */

#define UART_INTEN_ABRIEN_Pos            (18)                                              /*!< UART_T::INTEN: ABRIEN Position         */
#define UART_INTEN_ABRIEN_Msk            (0x1ul << UART_INTEN_ABRIEN_Pos)                  /*!< UART_T::INTEN: ABRIEN Mask             */

#define UART_INTEN_TXENDIEN_Pos          (22)                                              /*!< UART_T::INTEN: TXENDIEN Position       */
#define UART_INTEN_TXENDIEN_Msk          (0x1ul << UART_INTEN_TXENDIEN_Pos)                /*!< UART_T::INTEN: TXENDIEN Mask           */

#define UART_FIFO_RXRST_Pos              (1)                                               /*!< UART_T::FIFO: RXRST Position           */
#define UART_FIFO_RXRST_Msk              (0x1ul << UART_FIFO_RXRST_Pos)                    /*!< UART_T::FIFO: RXRST Mask               */

#define UART_FIFO_TXRST_Pos              (2)                                               /*!< UART_T::FIFO: TXRST Position           */
#define UART_FIFO_TXRST_Msk              (0x1ul << UART_FIFO_TXRST_Pos)                    /*!< UART_T::FIFO: TXRST Mask               */

#define UART_FIFO_RFITL_Pos              (4)                                               /*!< UART_T::FIFO: RFITL Position           */
#define UART_FIFO_RFITL_Msk              (0xful << UART_FIFO_RFITL_Pos)                    /*!< UART_T::FIFO: RFITL Mask               */

#define UART_FIFO_RXOFF_Pos              (8)                                               /*!< UART_T::FIFO: RXOFF Position           */
#define UART_FIFO_RXOFF_Msk              (0x1ul << UART_FIFO_RXOFF_Pos)                    /*!< UART_T::FIFO: RXOFF Mask               */

#define UART_FIFO_RTSTRGLV_Pos           (16)                                              /*!< UART_T::FIFO: RTSTRGLV Position        */
#define UART_FIFO_RTSTRGLV_Msk           (0xful << UART_FIFO_RTSTRGLV_Pos)                 /*!< UART_T::FIFO: RTSTRGLV Mask            */

#define UART_LINE_WLS_Pos                (0)                                               /*!< UART_T::LINE: WLS Position             */
#define UART_LINE_WLS_Msk                (0x3ul << UART_LINE_WLS_Pos)                      /*!< UART_T::LINE: WLS Mask                 */

#define UART_LINE_NSB_Pos                (2)                                               /*!< UART_T::LINE: NSB Position             */
#define UART_LINE_NSB_Msk                (0x1ul << UART_LINE_NSB_Pos)                      /*!< UART_T::LINE: NSB Mask                 */

#define UART_LINE_PBE_Pos                (3)                                               /*!< UART_T::LINE: PBE Position             */
#define UART_LINE_PBE_Msk                (0x1ul << UART_LINE_PBE_Pos)                      /*!< UART_T::LINE: PBE Mask                 */

#define UART_LINE_EPE_Pos                (4)                                               /*!< UART_T::LINE: EPE Position             */
#define UART_LINE_EPE_Msk                (0x1ul << UART_LINE_EPE_Pos)                      /*!< UART_T::LINE: EPE Mask                 */

#define UART_LINE_SPE_Pos                (5)                                               /*!< UART_T::LINE: SPE Position             */
#define UART_LINE_SPE_Msk                (0x1ul << UART_LINE_SPE_Pos)                      /*!< UART_T::LINE: SPE Mask                 */

#define UART_LINE_BCB_Pos                (6)                                               /*!< UART_T::LINE: BCB Position             */
#define UART_LINE_BCB_Msk                (0x1ul << UART_LINE_BCB_Pos)                      /*!< UART_T::LINE: BCB Mask                 */

#define UART_LINE_PSS_Pos                (7)                                               /*!< UART_T::LINE: PSS Position             */
#define UART_LINE_PSS_Msk                (0x1ul << UART_LINE_PSS_Pos)                      /*!< UART_T::LINE: PSS Mask                 */

#define UART_LINE_TXDINV_Pos             (8)                                               /*!< UART_T::LINE: TXDINV Position          */
#define UART_LINE_TXDINV_Msk             (0x1ul << UART_LINE_TXDINV_Pos)                   /*!< UART_T::LINE: TXDINV Mask              */

#define UART_LINE_RXDINV_Pos             (9)                                               /*!< UART_T::LINE: RXDINV Position          */
#define UART_LINE_RXDINV_Msk             (0x1ul << UART_LINE_RXDINV_Pos)                   /*!< UART_T::LINE: RXDINV Mask              */

#define UART_MODEM_RTS_Pos               (1)                                               /*!< UART_T::MODEM: RTS Position            */
#define UART_MODEM_RTS_Msk               (0x1ul << UART_MODEM_RTS_Pos)                     /*!< UART_T::MODEM: RTS Mask                */

#define UART_MODEM_RTSACTLV_Pos          (9)                                               /*!< UART_T::MODEM: RTSACTLV Position       */
#define UART_MODEM_RTSACTLV_Msk          (0x1ul << UART_MODEM_RTSACTLV_Pos)                /*!< UART_T::MODEM: RTSACTLV Mask           */

#define UART_MODEM_RTSSTS_Pos            (13)                                              /*!< UART_T::MODEM: RTSSTS Position         */
#define UART_MODEM_RTSSTS_Msk            (0x1ul << UART_MODEM_RTSSTS_Pos)                  /*!< UART_T::MODEM: RTSSTS Mask             */

#define UART_MODEMSTS_CTSDETF_Pos        (0)                                               /*!< UART_T::MODEMSTS: CTSDETF Position     */
#define UART_MODEMSTS_CTSDETF_Msk        (0x1ul << UART_MODEMSTS_CTSDETF_Pos)              /*!< UART_T::MODEMSTS: CTSDETF Mask         */

#define UART_MODEMSTS_CTSSTS_Pos         (4)                                               /*!< UART_T::MODEMSTS: CTSSTS Position      */
#define UART_MODEMSTS_CTSSTS_Msk         (0x1ul << UART_MODEMSTS_CTSSTS_Pos)               /*!< UART_T::MODEMSTS: CTSSTS Mask          */

#define UART_MODEMSTS_CTSACTLV_Pos       (8)                                               /*!< UART_T::MODEMSTS: CTSACTLV Position    */
#define UART_MODEMSTS_CTSACTLV_Msk       (0x1ul << UART_MODEMSTS_CTSACTLV_Pos)             /*!< UART_T::MODEMSTS: CTSACTLV Mask        */

#define UART_FIFOSTS_RXOVIF_Pos          (0)                                               /*!< UART_T::FIFOSTS: RXOVIF Position       */
#define UART_FIFOSTS_RXOVIF_Msk          (0x1ul << UART_FIFOSTS_RXOVIF_Pos)                /*!< UART_T::FIFOSTS: RXOVIF Mask           */

#define UART_FIFOSTS_ABRDIF_Pos          (1)                                               /*!< UART_T::FIFOSTS: ABRDIF Position       */
#define UART_FIFOSTS_ABRDIF_Msk          (0x1ul << UART_FIFOSTS_ABRDIF_Pos)                /*!< UART_T::FIFOSTS: ABRDIF Mask           */

#define UART_FIFOSTS_ABRDTOIF_Pos        (2)                                               /*!< UART_T::FIFOSTS: ABRDTOIF Position     */
#define UART_FIFOSTS_ABRDTOIF_Msk        (0x1ul << UART_FIFOSTS_ABRDTOIF_Pos)              /*!< UART_T::FIFOSTS: ABRDTOIF Mask         */

#define UART_FIFOSTS_ADDRDETF_Pos        (3)                                               /*!< UART_T::FIFOSTS: ADDRDETF Position     */
#define UART_FIFOSTS_ADDRDETF_Msk        (0x1ul << UART_FIFOSTS_ADDRDETF_Pos)              /*!< UART_T::FIFOSTS: ADDRDETF Mask         */

#define UART_FIFOSTS_PEF_Pos             (4)                                               /*!< UART_T::FIFOSTS: PEF Position          */
#define UART_FIFOSTS_PEF_Msk             (0x1ul << UART_FIFOSTS_PEF_Pos)                   /*!< UART_T::FIFOSTS: PEF Mask              */

#define UART_FIFOSTS_FEF_Pos             (5)                                               /*!< UART_T::FIFOSTS: FEF Position          */
#define UART_FIFOSTS_FEF_Msk             (0x1ul << UART_FIFOSTS_FEF_Pos)                   /*!< UART_T::FIFOSTS: FEF Mask              */

#define UART_FIFOSTS_BIF_Pos             (6)                                               /*!< UART_T::FIFOSTS: BIF Position          */
#define UART_FIFOSTS_BIF_Msk             (0x1ul << UART_FIFOSTS_BIF_Pos)                   /*!< UART_T::FIFOSTS: BIF Mask              */

#define UART_FIFOSTS_RXPTR_Pos           (8)                                               /*!< UART_T::FIFOSTS: RXPTR Position        */
#define UART_FIFOSTS_RXPTR_Msk           (0x3ful << UART_FIFOSTS_RXPTR_Pos)                /*!< UART_T::FIFOSTS: RXPTR Mask            */

#define UART_FIFOSTS_RXEMPTY_Pos         (14)                                              /*!< UART_T::FIFOSTS: RXEMPTY Position      */
#define UART_FIFOSTS_RXEMPTY_Msk         (0x1ul << UART_FIFOSTS_RXEMPTY_Pos)               /*!< UART_T::FIFOSTS: RXEMPTY Mask          */

#define UART_FIFOSTS_RXFULL_Pos          (15)                                              /*!< UART_T::FIFOSTS: RXFULL Position       */
#define UART_FIFOSTS_RXFULL_Msk          (0x1ul << UART_FIFOSTS_RXFULL_Pos)                /*!< UART_T::FIFOSTS: RXFULL Mask           */

#define UART_FIFOSTS_TXPTR_Pos           (16)                                              /*!< UART_T::FIFOSTS: TXPTR Position        */
#define UART_FIFOSTS_TXPTR_Msk           (0x3ful << UART_FIFOSTS_TXPTR_Pos)                /*!< UART_T::FIFOSTS: TXPTR Mask            */

#define UART_FIFOSTS_TXEMPTY_Pos         (22)                                              /*!< UART_T::FIFOSTS: TXEMPTY Position      */
#define UART_FIFOSTS_TXEMPTY_Msk         (0x1ul << UART_FIFOSTS_TXEMPTY_Pos)               /*!< UART_T::FIFOSTS: TXEMPTY Mask          */

#define UART_FIFOSTS_TXFULL_Pos          (23)                                              /*!< UART_T::FIFOSTS: TXFULL Position       */
#define UART_FIFOSTS_TXFULL_Msk          (0x1ul << UART_FIFOSTS_TXFULL_Pos)                /*!< UART_T::FIFOSTS: TXFULL Mask           */

#define UART_FIFOSTS_TXOVIF_Pos          (24)                                              /*!< UART_T::FIFOSTS: TXOVIF Position       */
#define UART_FIFOSTS_TXOVIF_Msk          (0x1ul << UART_FIFOSTS_TXOVIF_Pos)                /*!< UART_T::FIFOSTS: TXOVIF Mask           */

#define UART_FIFOSTS_TXEMPTYF_Pos        (28)                                              /*!< UART_T::FIFOSTS: TXEMPTYF Position     */
#define UART_FIFOSTS_TXEMPTYF_Msk        (0x1ul << UART_FIFOSTS_TXEMPTYF_Pos)              /*!< UART_T::FIFOSTS: TXEMPTYF Mask         */

#define UART_FIFOSTS_RXIDLE_Pos          (29)                                              /*!< UART_T::FIFOSTS: RXIDLE Position       */
#define UART_FIFOSTS_RXIDLE_Msk          (0x1ul << UART_FIFOSTS_RXIDLE_Pos)                /*!< UART_T::FIFOSTS: RXIDLE Mask           */

#define UART_FIFOSTS_TXRXACT_Pos         (31)                                              /*!< UART_T::FIFOSTS: TXRXACT Position      */
#define UART_FIFOSTS_TXRXACT_Msk         (0x1ul << UART_FIFOSTS_TXRXACT_Pos)               /*!< UART_T::FIFOSTS: TXRXACT Mask          */

#define UART_INTSTS_RDAIF_Pos            (0)                                               /*!< UART_T::INTSTS: RDAIF Position         */
#define UART_INTSTS_RDAIF_Msk            (0x1ul << UART_INTSTS_RDAIF_Pos)                  /*!< UART_T::INTSTS: RDAIF Mask             */

#define UART_INTSTS_THREIF_Pos           (1)                                               /*!< UART_T::INTSTS: THREIF Position        */
#define UART_INTSTS_THREIF_Msk           (0x1ul << UART_INTSTS_THREIF_Pos)                 /*!< UART_T::INTSTS: THREIF Mask            */

#define UART_INTSTS_RLSIF_Pos            (2)                                               /*!< UART_T::INTSTS: RLSIF Position         */
#define UART_INTSTS_RLSIF_Msk            (0x1ul << UART_INTSTS_RLSIF_Pos)                  /*!< UART_T::INTSTS: RLSIF Mask             */

#define UART_INTSTS_MODEMIF_Pos          (3)                                               /*!< UART_T::INTSTS: MODEMIF Position       */
#define UART_INTSTS_MODEMIF_Msk          (0x1ul << UART_INTSTS_MODEMIF_Pos)                /*!< UART_T::INTSTS: MODEMIF Mask           */

#define UART_INTSTS_RXTOIF_Pos           (4)                                               /*!< UART_T::INTSTS: RXTOIF Position        */
#define UART_INTSTS_RXTOIF_Msk           (0x1ul << UART_INTSTS_RXTOIF_Pos)                 /*!< UART_T::INTSTS: RXTOIF Mask            */

#define UART_INTSTS_BUFERRIF_Pos         (5)                                               /*!< UART_T::INTSTS: BUFERRIF Position      */
#define UART_INTSTS_BUFERRIF_Msk         (0x1ul << UART_INTSTS_BUFERRIF_Pos)               /*!< UART_T::INTSTS: BUFERRIF Mask          */

#define UART_INTSTS_WKIF_Pos             (6)                                               /*!< UART_T::INTSTS: WKIF Position          */
#define UART_INTSTS_WKIF_Msk             (0x1ul << UART_INTSTS_WKIF_Pos)                   /*!< UART_T::INTSTS: WKIF Mask              */

#define UART_INTSTS_LINIF_Pos            (7)                                               /*!< UART_T::INTSTS: LINIF Position         */
#define UART_INTSTS_LINIF_Msk            (0x1ul << UART_INTSTS_LINIF_Pos)                  /*!< UART_T::INTSTS: LINIF Mask             */

#define UART_INTSTS_RDAINT_Pos           (8)                                               /*!< UART_T::INTSTS: RDAINT Position        */
#define UART_INTSTS_RDAINT_Msk           (0x1ul << UART_INTSTS_RDAINT_Pos)                 /*!< UART_T::INTSTS: RDAINT Mask            */

#define UART_INTSTS_THREINT_Pos          (9)                                               /*!< UART_T::INTSTS: THREINT Position       */
#define UART_INTSTS_THREINT_Msk          (0x1ul << UART_INTSTS_THREINT_Pos)                /*!< UART_T::INTSTS: THREINT Mask           */

#define UART_INTSTS_RLSINT_Pos           (10)                                              /*!< UART_T::INTSTS: RLSINT Position        */
#define UART_INTSTS_RLSINT_Msk           (0x1ul << UART_INTSTS_RLSINT_Pos)                 /*!< UART_T::INTSTS: RLSINT Mask            */

#define UART_INTSTS_MODEMINT_Pos         (11)                                              /*!< UART_T::INTSTS: MODEMINT Position      */
#define UART_INTSTS_MODEMINT_Msk         (0x1ul << UART_INTSTS_MODEMINT_Pos)               /*!< UART_T::INTSTS: MODEMINT Mask          */

#define UART_INTSTS_RXTOINT_Pos          (12)                                              /*!< UART_T::INTSTS: RXTOINT Position       */
#define UART_INTSTS_RXTOINT_Msk          (0x1ul << UART_INTSTS_RXTOINT_Pos)                /*!< UART_T::INTSTS: RXTOINT Mask           */

#define UART_INTSTS_BUFERRINT_Pos        (13)                                              /*!< UART_T::INTSTS: BUFERRINT Position     */
#define UART_INTSTS_BUFERRINT_Msk        (0x1ul << UART_INTSTS_BUFERRINT_Pos)              /*!< UART_T::INTSTS: BUFERRINT Mask         */

#define UART_INTSTS_WKINT_Pos            (14)                                              /*!< UART_T::INTSTS: WKINT Position         */
#define UART_INTSTS_WKINT_Msk            (0x1ul << UART_INTSTS_WKINT_Pos)                  /*!< UART_T::INTSTS: WKINT Mask             */

#define UART_INTSTS_LININT_Pos           (15)                                              /*!< UART_T::INTSTS: LININT Position        */
#define UART_INTSTS_LININT_Msk           (0x1ul << UART_INTSTS_LININT_Pos)                 /*!< UART_T::INTSTS: LININT Mask            */

#define UART_INTSTS_HWRLSIF_Pos          (18)                                              /*!< UART_T::INTSTS: HWRLSIF Position       */
#define UART_INTSTS_HWRLSIF_Msk          (0x1ul << UART_INTSTS_HWRLSIF_Pos)                /*!< UART_T::INTSTS: HWRLSIF Mask           */

#define UART_INTSTS_HWMODIF_Pos          (19)                                              /*!< UART_T::INTSTS: HWMODIF Position       */
#define UART_INTSTS_HWMODIF_Msk          (0x1ul << UART_INTSTS_HWMODIF_Pos)                /*!< UART_T::INTSTS: HWMODIF Mask           */

#define UART_INTSTS_HWTOIF_Pos           (20)                                              /*!< UART_T::INTSTS: HWTOIF Position        */
#define UART_INTSTS_HWTOIF_Msk           (0x1ul << UART_INTSTS_HWTOIF_Pos)                 /*!< UART_T::INTSTS: HWTOIF Mask            */

#define UART_INTSTS_HWBUFEIF_Pos         (21)                                              /*!< UART_T::INTSTS: HWBUFEIF Position      */
#define UART_INTSTS_HWBUFEIF_Msk         (0x1ul << UART_INTSTS_HWBUFEIF_Pos)               /*!< UART_T::INTSTS: HWBUFEIF Mask          */

#define UART_INTSTS_TXENDIF_Pos          (22)                                              /*!< UART_T::INTSTS: TXENDIF Position       */
#define UART_INTSTS_TXENDIF_Msk          (0x1ul << UART_INTSTS_TXENDIF_Pos)                /*!< UART_T::INTSTS: TXENDIF Mask           */

#define UART_INTSTS_HWRLSINT_Pos         (26)                                              /*!< UART_T::INTSTS: HWRLSINT Position      */
#define UART_INTSTS_HWRLSINT_Msk         (0x1ul << UART_INTSTS_HWRLSINT_Pos)               /*!< UART_T::INTSTS: HWRLSINT Mask          */

#define UART_INTSTS_HWMODINT_Pos         (27)                                              /*!< UART_T::INTSTS: HWMODINT Position      */
#define UART_INTSTS_HWMODINT_Msk         (0x1ul << UART_INTSTS_HWMODINT_Pos)               /*!< UART_T::INTSTS: HWMODINT Mask          */

#define UART_INTSTS_HWTOINT_Pos          (28)                                              /*!< UART_T::INTSTS: HWTOINT Position       */
#define UART_INTSTS_HWTOINT_Msk          (0x1ul << UART_INTSTS_HWTOINT_Pos)                /*!< UART_T::INTSTS: HWTOINT Mask           */

#define UART_INTSTS_HWBUFEINT_Pos        (29)                                              /*!< UART_T::INTSTS: HWBUFEINT Position     */
#define UART_INTSTS_HWBUFEINT_Msk        (0x1ul << UART_INTSTS_HWBUFEINT_Pos)              /*!< UART_T::INTSTS: HWBUFEINT Mask         */

#define UART_INTSTS_TXENDINT_Pos         (30)                                              /*!< UART_T::INTSTS: TXENDINT Position      */
#define UART_INTSTS_TXENDINT_Msk         (0x1ul << UART_INTSTS_TXENDINT_Pos)               /*!< UART_T::INTSTS: TXENDINT Mask          */

#define UART_INTSTS_ABRINT_Pos           (31)                                              /*!< UART_T::INTSTS: ABRINT Position        */
#define UART_INTSTS_ABRINT_Msk           (0x1ul << UART_INTSTS_ABRINT_Pos)                 /*!< UART_T::INTSTS: ABRINT Mask            */

#define UART_TOUT_TOIC_Pos               (0)                                               /*!< UART_T::TOUT: TOIC Position            */
#define UART_TOUT_TOIC_Msk               (0xfful << UART_TOUT_TOIC_Pos)                    /*!< UART_T::TOUT: TOIC Mask                */

#define UART_TOUT_DLY_Pos                (8)                                               /*!< UART_T::TOUT: DLY Position             */
#define UART_TOUT_DLY_Msk                (0xfful << UART_TOUT_DLY_Pos)                     /*!< UART_T::TOUT: DLY Mask                 */

#define UART_BAUD_BRD_Pos                (0)                                               /*!< UART_T::BAUD: BRD Position             */
#define UART_BAUD_BRD_Msk                (0xfffful << UART_BAUD_BRD_Pos)                   /*!< UART_T::BAUD: BRD Mask                 */

#define UART_BAUD_EDIVM1_Pos             (24)                                              /*!< UART_T::BAUD: EDIVM1 Position          */
#define UART_BAUD_EDIVM1_Msk             (0xful << UART_BAUD_EDIVM1_Pos)                   /*!< UART_T::BAUD: EDIVM1 Mask              */

#define UART_BAUD_BAUDM0_Pos             (28)                                              /*!< UART_T::BAUD: BAUDM0 Position          */
#define UART_BAUD_BAUDM0_Msk             (0x1ul << UART_BAUD_BAUDM0_Pos)                   /*!< UART_T::BAUD: BAUDM0 Mask              */

#define UART_BAUD_BAUDM1_Pos             (29)                                              /*!< UART_T::BAUD: BAUDM1 Position          */
#define UART_BAUD_BAUDM1_Msk             (0x1ul << UART_BAUD_BAUDM1_Pos)                   /*!< UART_T::BAUD: BAUDM1 Mask              */

#define UART_IRDA_TXEN_Pos               (1)                                               /*!< UART_T::IRDA: TXEN Position            */
#define UART_IRDA_TXEN_Msk               (0x1ul << UART_IRDA_TXEN_Pos)                     /*!< UART_T::IRDA: TXEN Mask                */

#define UART_IRDA_TXINV_Pos              (5)                                               /*!< UART_T::IRDA: TXINV Position           */
#define UART_IRDA_TXINV_Msk              (0x1ul << UART_IRDA_TXINV_Pos)                    /*!< UART_T::IRDA: TXINV Mask               */

#define UART_IRDA_RXINV_Pos              (6)                                               /*!< UART_T::IRDA: RXINV Position           */
#define UART_IRDA_RXINV_Msk              (0x1ul << UART_IRDA_RXINV_Pos)                    /*!< UART_T::IRDA: RXINV Mask               */

#define UART_ALTCTL_BRKFL_Pos            (0)                                               /*!< UART_T::ALTCTL: BRKFL Position         */
#define UART_ALTCTL_BRKFL_Msk            (0xful << UART_ALTCTL_BRKFL_Pos)                  /*!< UART_T::ALTCTL: BRKFL Mask             */

#define UART_ALTCTL_LINRXEN_Pos          (6)                                               /*!< UART_T::ALTCTL: LINRXEN Position       */
#define UART_ALTCTL_LINRXEN_Msk          (0x1ul << UART_ALTCTL_LINRXEN_Pos)                /*!< UART_T::ALTCTL: LINRXEN Mask           */

#define UART_ALTCTL_LINTXEN_Pos          (7)                                               /*!< UART_T::ALTCTL: LINTXEN Position       */
#define UART_ALTCTL_LINTXEN_Msk          (0x1ul << UART_ALTCTL_LINTXEN_Pos)                /*!< UART_T::ALTCTL: LINTXEN Mask           */

#define UART_ALTCTL_RS485NMM_Pos         (8)                                               /*!< UART_T::ALTCTL: RS485NMM Position      */
#define UART_ALTCTL_RS485NMM_Msk         (0x1ul << UART_ALTCTL_RS485NMM_Pos)               /*!< UART_T::ALTCTL: RS485NMM Mask          */

#define UART_ALTCTL_RS485AAD_Pos         (9)                                               /*!< UART_T::ALTCTL: RS485AAD Position      */
#define UART_ALTCTL_RS485AAD_Msk         (0x1ul << UART_ALTCTL_RS485AAD_Pos)               /*!< UART_T::ALTCTL: RS485AAD Mask          */

#define UART_ALTCTL_RS485AUD_Pos         (10)                                              /*!< UART_T::ALTCTL: RS485AUD Position      */
#define UART_ALTCTL_RS485AUD_Msk         (0x1ul << UART_ALTCTL_RS485AUD_Pos)               /*!< UART_T::ALTCTL: RS485AUD Mask          */

#define UART_ALTCTL_ADDRDEN_Pos          (15)                                              /*!< UART_T::ALTCTL: ADDRDEN Position       */
#define UART_ALTCTL_ADDRDEN_Msk          (0x1ul << UART_ALTCTL_ADDRDEN_Pos)                /*!< UART_T::ALTCTL: ADDRDEN Mask           */

#define UART_ALTCTL_ABRIF_Pos            (17)                                              /*!< UART_T::ALTCTL: ABRIF Position         */
#define UART_ALTCTL_ABRIF_Msk            (0x1ul << UART_ALTCTL_ABRIF_Pos)                  /*!< UART_T::ALTCTL: ABRIF Mask             */

#define UART_ALTCTL_ABRDEN_Pos           (18)                                              /*!< UART_T::ALTCTL: ABRDEN Position        */
#define UART_ALTCTL_ABRDEN_Msk           (0x1ul << UART_ALTCTL_ABRDEN_Pos)                 /*!< UART_T::ALTCTL: ABRDEN Mask            */

#define UART_ALTCTL_ABRDBITS_Pos         (19)                                              /*!< UART_T::ALTCTL: ABRDBITS Position      */
#define UART_ALTCTL_ABRDBITS_Msk         (0x3ul << UART_ALTCTL_ABRDBITS_Pos)               /*!< UART_T::ALTCTL: ABRDBITS Mask          */

#define UART_ALTCTL_ADDRMV_Pos           (24)                                              /*!< UART_T::ALTCTL: ADDRMV Position        */
#define UART_ALTCTL_ADDRMV_Msk           (0xfful << UART_ALTCTL_ADDRMV_Pos)                /*!< UART_T::ALTCTL: ADDRMV Mask            */

#define UART_FUNCSEL_FUNCSEL_Pos         (0)                                               /*!< UART_T::FUNCSEL: FUNCSEL Position      */
#define UART_FUNCSEL_FUNCSEL_Msk         (0x3ul << UART_FUNCSEL_FUNCSEL_Pos)               /*!< UART_T::FUNCSEL: FUNCSEL Mask          */

#define UART_FUNCSEL_TXRXDIS_Pos         (3)                                               /*!< UART_T::FUNCSEL: TXRXDIS Position      */
#define UART_FUNCSEL_TXRXDIS_Msk         (0x1ul << UART_FUNCSEL_TXRXDIS_Pos)               /*!< UART_T::FUNCSEL: TXRXDIS Mask          */

#define UART_LINCTL_SLVEN_Pos            (0)                                               /*!< UART_T::LINCTL: SLVEN Position         */
#define UART_LINCTL_SLVEN_Msk            (0x1ul << UART_LINCTL_SLVEN_Pos)                  /*!< UART_T::LINCTL: SLVEN Mask             */

#define UART_LINCTL_SLVHDEN_Pos          (1)                                               /*!< UART_T::LINCTL: SLVHDEN Position       */
#define UART_LINCTL_SLVHDEN_Msk          (0x1ul << UART_LINCTL_SLVHDEN_Pos)                /*!< UART_T::LINCTL: SLVHDEN Mask           */

#define UART_LINCTL_SLVAREN_Pos          (2)                                               /*!< UART_T::LINCTL: SLVAREN Position       */
#define UART_LINCTL_SLVAREN_Msk          (0x1ul << UART_LINCTL_SLVAREN_Pos)                /*!< UART_T::LINCTL: SLVAREN Mask           */

#define UART_LINCTL_SLVDUEN_Pos          (3)                                               /*!< UART_T::LINCTL: SLVDUEN Position       */
#define UART_LINCTL_SLVDUEN_Msk          (0x1ul << UART_LINCTL_SLVDUEN_Pos)                /*!< UART_T::LINCTL: SLVDUEN Mask           */

#define UART_LINCTL_MUTE_Pos             (4)                                               /*!< UART_T::LINCTL: MUTE Position          */
#define UART_LINCTL_MUTE_Msk             (0x1ul << UART_LINCTL_MUTE_Pos)                   /*!< UART_T::LINCTL: MUTE Mask              */

#define UART_LINCTL_SENDH_Pos            (8)                                               /*!< UART_T::LINCTL: SENDH Position         */
#define UART_LINCTL_SENDH_Msk            (0x1ul << UART_LINCTL_SENDH_Pos)                  /*!< UART_T::LINCTL: SENDH Mask             */

#define UART_LINCTL_IDPEN_Pos            (9)                                               /*!< UART_T::LINCTL: IDPEN Position         */
#define UART_LINCTL_IDPEN_Msk            (0x1ul << UART_LINCTL_IDPEN_Pos)                  /*!< UART_T::LINCTL: IDPEN Mask             */

#define UART_LINCTL_BRKDETEN_Pos         (10)                                              /*!< UART_T::LINCTL: BRKDETEN Position      */
#define UART_LINCTL_BRKDETEN_Msk         (0x1ul << UART_LINCTL_BRKDETEN_Pos)               /*!< UART_T::LINCTL: BRKDETEN Mask          */

#define UART_LINCTL_LINRXOFF_Pos         (11)                                              /*!< UART_T::LINCTL: LINRXOFF Position      */
#define UART_LINCTL_LINRXOFF_Msk         (0x1ul << UART_LINCTL_LINRXOFF_Pos)               /*!< UART_T::LINCTL: LINRXOFF Mask          */

#define UART_LINCTL_BITERREN_Pos         (12)                                              /*!< UART_T::LINCTL: BITERREN Position      */
#define UART_LINCTL_BITERREN_Msk         (0x1ul << UART_LINCTL_BITERREN_Pos)               /*!< UART_T::LINCTL: BITERREN Mask          */

#define UART_LINCTL_BRKFL_Pos            (16)                                              /*!< UART_T::LINCTL: BRKFL Position         */
#define UART_LINCTL_BRKFL_Msk            (0xful << UART_LINCTL_BRKFL_Pos)                  /*!< UART_T::LINCTL: BRKFL Mask             */

#define UART_LINCTL_BSL_Pos              (20)                                              /*!< UART_T::LINCTL: BSL Position           */
#define UART_LINCTL_BSL_Msk              (0x3ul << UART_LINCTL_BSL_Pos)                    /*!< UART_T::LINCTL: BSL Mask               */

#define UART_LINCTL_HSEL_Pos             (22)                                              /*!< UART_T::LINCTL: HSEL Position          */
#define UART_LINCTL_HSEL_Msk             (0x3ul << UART_LINCTL_HSEL_Pos)                   /*!< UART_T::LINCTL: HSEL Mask              */

#define UART_LINCTL_PID_Pos              (24)                                              /*!< UART_T::LINCTL: PID Position           */
#define UART_LINCTL_PID_Msk              (0xfful << UART_LINCTL_PID_Pos)                   /*!< UART_T::LINCTL: PID Mask               */

#define UART_LINSTS_SLVHDETF_Pos         (0)                                               /*!< UART_T::LINSTS: SLVHDETF Position      */
#define UART_LINSTS_SLVHDETF_Msk         (0x1ul << UART_LINSTS_SLVHDETF_Pos)               /*!< UART_T::LINSTS: SLVHDETF Mask          */

#define UART_LINSTS_SLVHEF_Pos           (1)                                               /*!< UART_T::LINSTS: SLVHEF Position        */
#define UART_LINSTS_SLVHEF_Msk           (0x1ul << UART_LINSTS_SLVHEF_Pos)                 /*!< UART_T::LINSTS: SLVHEF Mask            */

#define UART_LINSTS_SLVIDPEF_Pos         (2)                                               /*!< UART_T::LINSTS: SLVIDPEF Position      */
#define UART_LINSTS_SLVIDPEF_Msk         (0x1ul << UART_LINSTS_SLVIDPEF_Pos)               /*!< UART_T::LINSTS: SLVIDPEF Mask          */

#define UART_LINSTS_SLVSYNCF_Pos         (3)                                               /*!< UART_T::LINSTS: SLVSYNCF Position      */
#define UART_LINSTS_SLVSYNCF_Msk         (0x1ul << UART_LINSTS_SLVSYNCF_Pos)               /*!< UART_T::LINSTS: SLVSYNCF Mask          */

#define UART_LINSTS_BRKDETF_Pos          (8)                                               /*!< UART_T::LINSTS: BRKDETF Position       */
#define UART_LINSTS_BRKDETF_Msk          (0x1ul << UART_LINSTS_BRKDETF_Pos)                /*!< UART_T::LINSTS: BRKDETF Mask           */

#define UART_LINSTS_BITEF_Pos            (9)                                               /*!< UART_T::LINSTS: BITEF Position         */
#define UART_LINSTS_BITEF_Msk            (0x1ul << UART_LINSTS_BITEF_Pos)                  /*!< UART_T::LINSTS: BITEF Mask             */

#define UART_BRCOMP_BRCOMP_Pos           (0)                                               /*!< UART_T::BRCOMP: BRCOMP Position        */
#define UART_BRCOMP_BRCOMP_Msk           (0x1fful << UART_BRCOMP_BRCOMP_Pos)               /*!< UART_T::BRCOMP: BRCOMP Mask            */

#define UART_BRCOMP_BRCOMPDEC_Pos        (31)                                              /*!< UART_T::BRCOMP: BRCOMPDEC Position     */
#define UART_BRCOMP_BRCOMPDEC_Msk        (0x1ul << UART_BRCOMP_BRCOMPDEC_Pos)              /*!< UART_T::BRCOMP: BRCOMPDEC Mask         */

#define UART_WKCTL_WKCTSEN_Pos           (0)                                               /*!< UART_T::WKCTL: WKCTSEN Position        */
#define UART_WKCTL_WKCTSEN_Msk           (0x1ul << UART_WKCTL_WKCTSEN_Pos)                 /*!< UART_T::WKCTL: WKCTSEN Mask            */

#define UART_WKCTL_WKDATEN_Pos           (1)                                               /*!< UART_T::WKCTL: WKDATEN Position        */
#define UART_WKCTL_WKDATEN_Msk           (0x1ul << UART_WKCTL_WKDATEN_Pos)                 /*!< UART_T::WKCTL: WKDATEN Mask            */

#define UART_WKCTL_WKRFRTEN_Pos          (2)                                               /*!< UART_T::WKCTL: WKRFRTEN Position       */
#define UART_WKCTL_WKRFRTEN_Msk          (0x1ul << UART_WKCTL_WKRFRTEN_Pos)                /*!< UART_T::WKCTL: WKRFRTEN Mask           */

#define UART_WKCTL_WKRS485EN_Pos         (3)                                               /*!< UART_T::WKCTL: WKRS485EN Position      */
#define UART_WKCTL_WKRS485EN_Msk         (0x1ul << UART_WKCTL_WKRS485EN_Pos)               /*!< UART_T::WKCTL: WKRS485EN Mask          */

#define UART_WKCTL_WKTOUTEN_Pos          (4)                                               /*!< UART_T::WKCTL: WKTOUTEN Position       */
#define UART_WKCTL_WKTOUTEN_Msk          (0x1ul << UART_WKCTL_WKTOUTEN_Pos)                /*!< UART_T::WKCTL: WKTOUTEN Mask           */

#define UART_WKSTS_CTSWKF_Pos            (0)                                               /*!< UART_T::WKSTS: CTSWKF Position         */
#define UART_WKSTS_CTSWKF_Msk            (0x1ul << UART_WKSTS_CTSWKF_Pos)                  /*!< UART_T::WKSTS: CTSWKF Mask             */

#define UART_WKSTS_DATWKF_Pos            (1)                                               /*!< UART_T::WKSTS: DATWKF Position         */
#define UART_WKSTS_DATWKF_Msk            (0x1ul << UART_WKSTS_DATWKF_Pos)                  /*!< UART_T::WKSTS: DATWKF Mask             */

#define UART_WKSTS_RFRTWKF_Pos           (2)                                               /*!< UART_T::WKSTS: RFRTWKF Position        */
#define UART_WKSTS_RFRTWKF_Msk           (0x1ul << UART_WKSTS_RFRTWKF_Pos)                 /*!< UART_T::WKSTS: RFRTWKF Mask            */

#define UART_WKSTS_RS485WKF_Pos          (3)                                               /*!< UART_T::WKSTS: RS485WKF Position       */
#define UART_WKSTS_RS485WKF_Msk          (0x1ul << UART_WKSTS_RS485WKF_Pos)                /*!< UART_T::WKSTS: RS485WKF Mask           */

#define UART_WKSTS_TOUTWKF_Pos           (4)                                               /*!< UART_T::WKSTS: TOUTWKF Position        */
#define UART_WKSTS_TOUTWKF_Msk           (0x1ul << UART_WKSTS_TOUTWKF_Pos)                 /*!< UART_T::WKSTS: TOUTWKF Mask            */

#define UART_DWKCOMP_STCOMP_Pos          (0)                                               /*!< UART_T::DWKCOMP: STCOMP Position       */
#define UART_DWKCOMP_STCOMP_Msk          (0xfffful << UART_DWKCOMP_STCOMP_Pos)             /*!< UART_T::DWKCOMP: STCOMP Mask           */

#define UART_VERSION_MINOR_Pos           (0)                                               /*!< UART_T::VERSION: MINOR Position        */
#define UART_VERSION_MINOR_Msk           (0xfffful << UART_VERSION_MINOR_Pos)              /*!< UART_T::VERSION: MINOR Mask            */

#define UART_VERSION_SUB_Pos             (16)                                              /*!< UART_T::VERSION: SUB Position          */
#define UART_VERSION_SUB_Msk             (0xfful << UART_VERSION_SUB_Pos)                  /*!< UART_T::VERSION: SUB Mask              */

#define UART_VERSION_MAJOR_Pos           (24)                                              /*!< UART_T::VERSION: MAJOR Position        */
#define UART_VERSION_MAJOR_Msk           (0xfful << UART_VERSION_MAJOR_Pos)                /*!< UART_T::VERSION: MAJOR Mask            */

/**@}*/ /* UART_CONST */
/**@}*/ /* end of UART register group */


/*---------------------- USB Device Controller -------------------------*/
/**
    @addtogroup USBD USB Device Controller(USBD)
    Memory Mapped Structure for USBD Controller
@{ */
 
typedef struct
{


/**
 * @var USBD_T::INTEN
 * Offset: 0x00  USB Device Interrupt Enable Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BUSIEN    |Bus Event Interrupt Enable Bit
 * |        |          |0 = BUS event interrupt Disabled.
 * |        |          |1 = BUS event interrupt Enabled.
 * |[1]     |USBIEN    |USB Event Interrupt Enable Bit
 * |        |          |0 = USB event interrupt Disabled.
 * |        |          |1 = USB event interrupt Enabled.
 * |[2]     |VBDETIEN  |VBUS Detection Interrupt Enable Bit
 * |        |          |0 = VBUS detection Interrupt Disabled.
 * |        |          |1 = VBUS detection Interrupt Enabled.
 * |[3]     |NEVWKIEN  |USB No-event-wake-up Interrupt Enable Bit
 * |        |          |0 = No-event-wake-up Interrupt Disabled.
 * |        |          |1 = No-event-wake-up Interrupt Enabled.
 * |[8]     |WKEN      |Wake-up Function Enable Bit
 * |        |          |0 = USB wake-up function Disabled.
 * |        |          |1 = USB wake-up function Enabled.
 * |[15]    |INNAKEN   |Active NAK Function and Its Status in IN Token
 * |        |          |0 = When device responds NAK after receiving IN token, IN NAK status will not be updated to USBD_EPSTS0 and USBD_EPSTS1, so that the USB interrupt event will not be asserted.
 * |        |          |1 = IN NAK status will be updated to USBD_EPSTS0 and USBD_EPSTS1 and the USB interrupt event will be asserted, when the device responds NAK after receiving IN token.
 * @var USBD_T::INTSTS
 * Offset: 0x04  USB Device Interrupt Event Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BUSIF     |BUS Interrupt Status
 * |        |          |The BUS event means that there is one of the suspend or the resume function in the bus.
 * |        |          |0 = No BUS event occurred.
 * |        |          |1 = Bus event occurred; check USBD_ATTR[3:0] to know which kind of bus event was occurred, cleared by writing 1 to USBD_INTSTS[0].
 * |[1]     |USBIF     |USB Event Interrupt Status
 * |        |          |The USB event includes the SETUP Token, IN Token, OUT ACK, ISO IN, or ISO OUT events in the bus.
 * |        |          |0 = No USB event occurred.
 * |        |          |1 = USB event occurred, check EPSTS (USBD_EPSTS0 and USBD_EPSTS1) to know which kind of USB event was occurred, cleared by writing 1 to USBD_INTSTS[1] or EPEVT11~0 (USBD_INTSTS[27:16) and SETUP (USBD_INTSTS[31]).
 * |[2]     |VBDETIF   |VBUS Detection Interrupt Status
 * |        |          |0 = There is not attached/detached event in the USB.
 * |        |          |1 = There is attached/detached event in the USB bus and it is cleared by writing 1 to USBD_INTSTS[2].
 * |[3]     |NEVWKIF   |No-event-wake-up Interrupt Status
 * |        |          |0 = NEVWK event does not occur.
 * |        |          |1 = No-event-wake-up event occurred, cleared by writing 1 to USBD_INTSTS[3].
 * |[16]    |EPEVT0    |Endpoint 0's USB Event Status
 * |        |          |0 = No event occurred in endpoint 0.
 * |        |          |1 = USB event occurred on Endpoint 0, check USBD_EPSTS0[3:0] to know which kind of USB event was occurred, cleared by writing 1 to USBD_INTSTS[16] or USBD_INTSTS[1].
 * |[17]    |EPEVT1    |Endpoint 1's USB Event Status
 * |        |          |0 = No event occurred in endpoint 1.
 * |        |          |1 = USB event occurred on Endpoint 1, check USBD_EPSTS0[7:4] to know which kind of USB event was occurred, cleared by writing 1 to USBD_INTSTS[17] or USBD_INTSTS[1].
 * |[18]    |EPEVT2    |Endpoint 2's USB Event Status
 * |        |          |0 = No event occurred in endpoint 2.
 * |        |          |1 = USB event occurred on Endpoint 2, check USBD_EPSTS0[11:8] to know which kind of USB event was occurred, cleared by writing 1 to USBD_INTSTS[18] or USBD_INTSTS[1].
 * |[19]    |EPEVT3    |Endpoint 3's USB Event Status
 * |        |          |0 = No event occurred in endpoint 3.
 * |        |          |1 = USB event occurred on Endpoint 3, check USBD_EPSTS0[15:12] to know which kind of USB event was occurred, cleared by writing 1 to USBD_INTSTS[19] or USBD_INTSTS[1].
 * |[20]    |EPEVT4    |Endpoint 4's USB Event Status
 * |        |          |0 = No event occurred in endpoint 4.
 * |        |          |1 = USB event occurred on Endpoint 4, check USBD_EPSTS0[19:16] to know which kind of USB event was occurred, cleared by writing 1 to USBD_INTSTS[20] or USBD_INTSTS[1].
 * |[21]    |EPEVT5    |Endpoint 5's USB Event Status
 * |        |          |0 = No event occurred in endpoint 5.
 * |        |          |1 = USB event occurred on Endpoint 5, check USBD_EPSTS0[23:20] to know which kind of USB event was occurred, cleared by writing 1 to USBD_INTSTS[21] or USBD_INTSTS[1].
 * |[22]    |EPEVT6    |Endpoint 6's USB Event Status
 * |        |          |0 = No event occurred in endpoint 6.
 * |        |          |1 = USB event occurred on Endpoint 6, check USBD_EPSTS0[27:24] to know which kind of USB event was occurred, cleared by writing 1 to USBD_INTSTS[22] or USBD_INTSTS[1].
 * |[23]    |EPEVT7    |Endpoint 7's USB Event Status
 * |        |          |0 = No event occurred in endpoint 7.
 * |        |          |1 = USB event occurred on Endpoint 7, check USBD_EPSTS0[31:28] to know which kind of USB event was occurred, cleared by writing 1 to USBD_INTSTS[23] or USBD_INTSTS[1].
 * |[24]    |EPEVT8    |Endpoint 8's USB Event Status
 * |        |          |0 = No event occurred in endpoint 8.
 * |        |          |1 = USB event occurred on Endpoint 8, check USBD_EPSTS1[3 :0] to know which kind of USB event was occurred, cleared by writing 1 to USBD_INTSTS[24] or USBD_INTSTS[1].
 * |[25]    |EPEVT9    |Endpoint 9's USB Event Status
 * |        |          |0 = No event occurred in endpoint 9.
 * |        |          |1 = USB event occurred on Endpoint 9, check USBD_EPSTS1[7 :4] to know which kind of USB event was occurred, cleared by writing 1 to USBD_INTSTS[25] or USBD_INTSTS[1].
 * |[26]    |EPEVT10   |Endpoint 10's USB Event Status
 * |        |          |0 = No event occurred in endpoint 10.
 * |        |          |1 = USB event occurred on Endpoint 10, check USBD_EPSTS1[11 :8] to know which kind of USB event was occurred, cleared by writing 1 to USBD_INTSTS[26] or USBD_INTSTS[1].
 * |[27]    |EPEVT11   |Endpoint 11's USB Event Status
 * |        |          |0 = No event occurred in endpoint 11.
 * |        |          |1 = USB event occurred on Endpoint 11, check USBD_EPSTS1[15:12] to know which kind of USB event was occurred, cleared by writing 1 to USBD_INTSTS[27] or USBD_INTSTS[1].
 * |[31]    |SETUP     |Setup Event Status
 * |        |          |0 = No Setup event.
 * |        |          |1 = Setup event occurred, cleared by writing 1 to USBD_INTSTS[31].
 * @var USBD_T::FADDR
 * Offset: 0x08  USB Device Function Address Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[6:0]   |FADDR     |USB Device Function Address
 * @var USBD_T::EPSTS
 * Offset: 0x0C  USB Device Endpoint Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[7]     |OV        |Overrun
 * |        |          |It indicates that the received data is over the maximum payload number or not.
 * |        |          |0 = No overrun.
 * |        |          |1 = Out Data is more than the Max Payload in MXPLD register or the Setup Data is more than 8 Bytes.
 * @var USBD_T::ATTR
 * Offset: 0x10  USB Device Bus Status and Attribution Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |USBRST    |USB Reset Status
 * |        |          |0 = Bus no reset.
 * |        |          |1 = Bus reset when SE0 (single-ended 0) more than 2.5us.
 * |        |          |Note: This bit is read only.
 * |[1]     |SUSPEND   |Suspend Status
 * |        |          |0 = Bus no suspend.
 * |        |          |1 = Bus idle more than 3ms, either cable is plugged off or host is sleeping.
 * |        |          |Note: This bit is read only.
 * |[2]     |RESUME    |Resume Status
 * |        |          |0 = No bus resume.
 * |        |          |1 = Resume from suspend.
 * |        |          |Note: This bit is read only.
 * |[3]     |TOUT      |Time-out Status
 * |        |          |0 = No time-out.
 * |        |          |1 = No Bus response more than 18 bits time.
 * |        |          |Note: This bit is read only.
 * |[4]     |PHYEN     |PHY Transceiver Function Enable Bit
 * |        |          |0 = PHY transceiver function Disabled.
 * |        |          |1 = PHY transceiver function Enabled.
 * |[5]     |RWAKEUP   |Remote Wake-up
 * |        |          |0 = Release the USB bus from K state.
 * |        |          |1 = Force USB bus to K (USB_D+ low, USB_D-: high) state, used for remote wake-up.
 * |[7]     |USBEN     |USB Controller Enable Bit
 * |        |          |0 = USB Controller Disabled.
 * |        |          |1 = USB Controller Enabled.
 * |[8]     |DPPUEN    |Pull-up Resistor on USB_DP Enable Bit
 * |        |          |0 = Pull-up resistor in USB_D+ bus Disabled.
 * |        |          |1 = Pull-up resistor in USB_D+ bus Active.
 * |[10]    |BYTEM     |CPU Access USB SRAM Size Mode Selection
 * |        |          |0 = Word mode: The size of the transfer from CPU to USB SRAM can be Word only.
 * |        |          |1 = Byte mode: The size of the transfer from CPU to USB SRAM can be Byte only.
 * @var USBD_T::VBUSDET
 * Offset: 0x14  USB Device VBUS Detection Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |VBUSDET   |Device VBUS Detection
 * |        |          |0 = Controller is not attached to the USB host.
 * |        |          |1 = Controller is attached to the USB host.
 * @var USBD_T::STBUFSEG
 * Offset: 0x18  SETUP Token Buffer Segmentation Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:3]   |STBUFSEG  |SETUP Token Buffer Segmentation
 * |        |          |It is used to indicate the offset address for the SETUP token with the USB Device SRAM starting address The effective starting address is
 * |        |          |USBD_SRAM address + {STBUFSEG, 3'b000}
 * |        |          |Where the USBD_SRAM address = USBD_BA+0x100h.
 * |        |          |Note: It is used for SETUP token only.
 * @var USBD_T::EPSTS0
 * Offset: 0x20  USB Device Endpoint Status Register 0
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[23:20] |EPSTS5    |Endpoint 5 Status
 * |        |          |These bits are used to indicate the current status of this endpoint
 * |        |          |0000 = In ACK.
 * |        |          |0001 = In NAK.
 * |        |          |0010 = Out Packet Data0 ACK.
 * |        |          |0011 = Setup ACK.
 * |        |          |0110 = Out Packet Data1 ACK.
 * |        |          |0111 = Isochronous transfer end.
 * |[27:24] |EPSTS6    |Endpoint 6 Status
 * |        |          |These bits are used to indicate the current status of this endpoint
 * |        |          |0000 = In ACK.
 * |        |          |0001 = In NAK.
 * |        |          |0010 = Out Packet Data0 ACK.
 * |        |          |0011 = Setup ACK.
 * |        |          |0110 = Out Packet Data1 ACK.
 * |        |          |0111 = Isochronous transfer end.
 * |[31:28] |EPSTS7    |Endpoint 7 Status
 * |        |          |These bits are used to indicate the current status of this endpoint
 * |        |          |0000 = In ACK.
 * |        |          |0001 = In NAK.
 * |        |          |0010 = Out Packet Data0 ACK.
 * |        |          |0011 = Setup ACK.
 * |        |          |0110 = Out Packet Data1 ACK.
 * |        |          |0111 = Isochronous transfer end.
 * @var USBD_T::EPSTS1
 * Offset: 0x24  USB Device Endpoint Status Register 1
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |EPSTS8    |Endpoint 8 Status
 * |        |          |These bits are used to indicate the current status of this endpoint
 * |        |          |0000 = In ACK.
 * |        |          |0001 = In NAK.
 * |        |          |0010 = Out Packet Data0 ACK.
 * |        |          |0011 = Setup ACK.
 * |        |          |0110 = Out Packet Data1 ACK.
 * |        |          |0111 = Isochronous transfer end.
 * |[7:4]   |EPSTS9    |Endpoint 9 Status
 * |        |          |These bits are used to indicate the current status of this endpoint
 * |        |          |0000 = In ACK.
 * |        |          |0001 = In NAK.
 * |        |          |0010 = Out Packet Data0 ACK.
 * |        |          |0011 = Setup ACK.
 * |        |          |0110 = Out Packet Data1 ACK.
 * |        |          |0111 = Isochronous transfer end.
 * |[11:8]  |EPSTS10   |Endpoint 10 Status
 * |        |          |These bits are used to indicate the current status of this endpoint
 * |        |          |0000 = In ACK.
 * |        |          |0001 = In NAK.
 * |        |          |0010 = Out Packet Data0 ACK.
 * |        |          |0011 = Setup ACK.
 * |        |          |0110 = Out Packet Data1 ACK.
 * |        |          |0111 = Isochronous transfer end.
 * |[15:12] |EPSTS11   |Endpoint 11 Status
 * |        |          |These bits are used to indicate the current status of this endpoint
 * |        |          |0000 = In ACK.
 * |        |          |0001 = In NAK.
 * |        |          |0010 = Out Packet Data0 ACK.
 * |        |          |0011 = Setup ACK.
 * |        |          |0110 = Out Packet Data1 ACK.
 * |        |          |0111 = Isochronous transfer end.
 * @var USBD_T::LPMATTR
 * Offset: 0x88  USB LPM Attribution Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |LPMLINKSTS|LPM Link State
 * |        |          |These bits contain the bLinkState received with last ACK LPM Token
 * |[7:4]   |LPMBESL   |LPM Best Effort Service Latency
 * |        |          |These bits contain the BESL value received with last ACK LPM Token
 * |[8]     |LPMRWAKUP |LPM Remote Wakeup
 * |        |          |This bit contains the bRemoteWake value received with last ACK LPM Token 
 * @var USBD_T::FN
 * Offset: 0x8C  USB Frame number Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[10:0]  |FN        |Frame Number
 * |        |          |These bits contain the 11-bits frame number in the last received SOF packet.
 * @var USBD_T::SE0
 * Offset: 0x90  USB Device Drive SE0 Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |SE0       |Drive Single Ended Zero in USB Bus
 * |        |          |The Single Ended Zero (SE0) is when both lines (USB_D+ and USB_D-) are being pulled low.
 * |        |          |0 = Normal operation.
 * |        |          |1 = Force USB PHY transceiver to drive SE0.
 * @var USBD_T::BIST
 * Offset: 0xA0  USB Buffer Self-Test Control
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |BISTEN    |BIST Mode Enable (INTERNAL ONLY)
 * |        |          |0 = BIST is disabled or completed (automatically cleared by BIST controller).
 * |        |          |1 = BIST is enabled begin to perform BIST on selected memory group.
 * |[1]     |FINISH    |BIST Operation Finish (INTERNAL ONLY)
 * |        |          |It indicates the end of the BIST operation.
 * |        |          |0 = When the BIST controller doesn't finish all operation, this bit will keep as low.
 * |        |          |1 = When the BIST controller finishes all operations, this bit will be set as high.
 * |[2]     |BISTFAIL  |BISTFAIL (INTERNAL ONLY)
 * |        |          |The BistFail indicates if the BIST test fails or succeeds.
 * |        |          |0 = If the BistFail is low at the end, the embedded SRAM pass the BIST test, otherwise, it is faulty.
 * |        |          |1 = The BistFail will be high once the BIST detects the error and remains high during the BIST operation.
 * @var USBD_T::PDMA
 * Offset: 0xA4  USB PDMA Control
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PDMARW    |PDMA Read/Write Control Bit
 * |        |          |0 = The PDMA will read data from memory to USB buffer.
 * |        |          |1 = The PDMA will read data from USB buffer to memory.
 * |[1]     |PDMAEN    |PDMA Function Enable Bit
 * |        |          |0 = The PDMA function is not active.
 * |        |          |1 = The PDMA function in USB is active.
 * |        |          |Note: This bit will be automatically cleared after PDMA transfer done.
 * @var USBD_T::TEST
 * Offset: 0xA8  USB Test Control
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |VDDIS     |VBUS Detection De-bounce Disable Bit
 * |        |          |0 = VBUS debounce control enabled .
 * |        |          |1 = VBUS debounce control disabled.
 * @var USBD_T::BUFSEG0
 * Offset: 0x500  Endpoint 0 Buffer Segmentation Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:3]   |BUFSEG    |Endpoint Buffer Segmentation
 * |        |          |It is used to indicate the offset address for each endpoint with the USB SRAM starting address The effective starting address of the endpoint is
 * |        |          |USBD_SRAM address + { BUFSEG, 3'b000}
 * |        |          |Where the USBD_SRAM address = USBD_BA+0x100h.
 * |        |          |Refer to the section 6.17.5.7 for the endpoint SRAM structure and its description.
 * @var USBD_T::MXPLD0
 * Offset: 0x504  Endpoint 0 Maximal Payload Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:0]   |MXPLD     |Maximal Payload
 * |        |          |Define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token)
 * |        |          |It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
 * |        |          |(1) When the register is written by CPU,
 * |        |          |For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready.
 * |        |          |For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
 * |        |          |(2) When the register is read by CPU,
 * |        |          |For IN token, the value of MXPLD is indicated by the data length be transmitted to host
 * |        |          |For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
 * |        |          |Note: Once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.
 * @var USBD_T::CFG0
 * Offset: 0x508  Endpoint 0 Configuration Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |EPNUM     |Endpoint Number
 * |        |          |These bits are used to define the endpoint number of the current endpoint
 * |[4]     |ISOCH     |Isochronous Endpoint
 * |        |          |This bit is used to set the endpoint as Isochronous endpoint, no handshake.
 * |        |          |0 = No Isochronous endpoint.
 * |        |          |1 = Isochronous endpoint.
 * |[6:5]   |STATE     |Endpoint STATE
 * |        |          |00 = Endpoint is Disabled.
 * |        |          |01 = Out endpoint.
 * |        |          |10 = IN endpoint.
 * |        |          |11 = Undefined.
 * |[7]     |DSQSYNC   |Data Sequence Synchronization
 * |        |          |0 = DATA0 PID.
 * |        |          |1 = DATA1 PID.
 * |        |          |Note: It is used to specify the DATA0 or DATA1 PID in the following IN token transaction
 * |        |          |hardware will toggle automatically in IN token base on the bit.
 * |[9]     |CSTALL    |Clear STALL Response
 * |        |          |0 = Disable the device to clear the STALL handshake in setup stage.
 * |        |          |1 = Clear the device to response STALL handshake in setup stage.
 * @var USBD_T::CFGP0
 * Offset: 0x50C  Endpoint 0 Set Stall and Clear In/Out Ready Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CLRRDY    |Clear Ready
 * |        |          |When the USBD_MXPLDx register is set by user, it means that the endpoint is ready to transmit or receive data
 * |        |          |If the user wants to disable this transaction before the transaction start, users can set this bit to 1 to disable it and it is auto clear to 0.
 * |        |          |For IN token, write '1' to clear the IN token had ready to transmit the data to USB.
 * |        |          |For OUT token, write '1' to clear the OUT token had ready to receive the data from USB.
 * |        |          |This bit is write 1 only and is always 0 when it is read back.
 * |[1]     |SSTALL    |Set STALL
 * |        |          |0 = Disable the device to response STALL.
 * |        |          |1 = Set the device to respond STALL automatically.
 * @var USBD_T::BUFSEG1
 * Offset: 0x510  Endpoint 1 Buffer Segmentation Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:3]   |BUFSEG    |Endpoint Buffer Segmentation
 * |        |          |It is used to indicate the offset address for each endpoint with the USB SRAM starting address The effective starting address of the endpoint is
 * |        |          |USBD_SRAM address + { BUFSEG, 3'b000}
 * |        |          |Where the USBD_SRAM address = USBD_BA+0x100h.
 * |        |          |Refer to the section 6.17.5.7 for the endpoint SRAM structure and its description.
 * @var USBD_T::MXPLD1
 * Offset: 0x514  Endpoint 1 Maximal Payload Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:0]   |MXPLD     |Maximal Payload
 * |        |          |Define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token)
 * |        |          |It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
 * |        |          |(1) When the register is written by CPU,
 * |        |          |For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready.
 * |        |          |For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
 * |        |          |(2) When the register is read by CPU,
 * |        |          |For IN token, the value of MXPLD is indicated by the data length be transmitted to host
 * |        |          |For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
 * |        |          |Note: Once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.
 * @var USBD_T::CFG1
 * Offset: 0x518  Endpoint 1 Configuration Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |EPNUM     |Endpoint Number
 * |        |          |These bits are used to define the endpoint number of the current endpoint
 * |[4]     |ISOCH     |Isochronous Endpoint
 * |        |          |This bit is used to set the endpoint as Isochronous endpoint, no handshake.
 * |        |          |0 = No Isochronous endpoint.
 * |        |          |1 = Isochronous endpoint.
 * |[6:5]   |STATE     |Endpoint STATE
 * |        |          |00 = Endpoint is Disabled.
 * |        |          |01 = Out endpoint.
 * |        |          |10 = IN endpoint.
 * |        |          |11 = Undefined.
 * |[7]     |DSQSYNC   |Data Sequence Synchronization
 * |        |          |0 = DATA0 PID.
 * |        |          |1 = DATA1 PID.
 * |        |          |Note: It is used to specify the DATA0 or DATA1 PID in the following IN token transaction
 * |        |          |hardware will toggle automatically in IN token base on the bit.
 * |[9]     |CSTALL    |Clear STALL Response
 * |        |          |0 = Disable the device to clear the STALL handshake in setup stage.
 * |        |          |1 = Clear the device to response STALL handshake in setup stage.
 * @var USBD_T::CFGP1
 * Offset: 0x51C  Endpoint 1 Set Stall and Clear In/Out Ready Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CLRRDY    |Clear Ready
 * |        |          |When the USBD_MXPLDx register is set by user, it means that the endpoint is ready to transmit or receive data
 * |        |          |If the user wants to disable this transaction before the transaction start, users can set this bit to 1 to disable it and it is auto clear to 0.
 * |        |          |For IN token, write '1' to clear the IN token had ready to transmit the data to USB.
 * |        |          |For OUT token, write '1' to clear the OUT token had ready to receive the data from USB.
 * |        |          |This bit is write 1 only and is always 0 when it is read back.
 * |[1]     |SSTALL    |Set STALL
 * |        |          |0 = Disable the device to response STALL.
 * |        |          |1 = Set the device to respond STALL automatically.
 * @var USBD_T::BUFSEG2
 * Offset: 0x520  Endpoint 2 Buffer Segmentation Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:3]   |BUFSEG    |Endpoint Buffer Segmentation
 * |        |          |It is used to indicate the offset address for each endpoint with the USB SRAM starting address The effective starting address of the endpoint is
 * |        |          |USBD_SRAM address + { BUFSEG, 3'b000}
 * |        |          |Where the USBD_SRAM address = USBD_BA+0x100h.
 * |        |          |Refer to the section 6.17.5.7 for the endpoint SRAM structure and its description.
 * @var USBD_T::MXPLD2
 * Offset: 0x524  Endpoint 2 Maximal Payload Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:0]   |MXPLD     |Maximal Payload
 * |        |          |Define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token)
 * |        |          |It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
 * |        |          |(1) When the register is written by CPU,
 * |        |          |For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready.
 * |        |          |For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
 * |        |          |(2) When the register is read by CPU,
 * |        |          |For IN token, the value of MXPLD is indicated by the data length be transmitted to host
 * |        |          |For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
 * |        |          |Note: Once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.
 * @var USBD_T::CFG2
 * Offset: 0x528  Endpoint 2 Configuration Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |EPNUM     |Endpoint Number
 * |        |          |These bits are used to define the endpoint number of the current endpoint
 * |[4]     |ISOCH     |Isochronous Endpoint
 * |        |          |This bit is used to set the endpoint as Isochronous endpoint, no handshake.
 * |        |          |0 = No Isochronous endpoint.
 * |        |          |1 = Isochronous endpoint.
 * |[6:5]   |STATE     |Endpoint STATE
 * |        |          |00 = Endpoint is Disabled.
 * |        |          |01 = Out endpoint.
 * |        |          |10 = IN endpoint.
 * |        |          |11 = Undefined.
 * |[7]     |DSQSYNC   |Data Sequence Synchronization
 * |        |          |0 = DATA0 PID.
 * |        |          |1 = DATA1 PID.
 * |        |          |Note: It is used to specify the DATA0 or DATA1 PID in the following IN token transaction
 * |        |          |hardware will toggle automatically in IN token base on the bit.
 * |[9]     |CSTALL    |Clear STALL Response
 * |        |          |0 = Disable the device to clear the STALL handshake in setup stage.
 * |        |          |1 = Clear the device to response STALL handshake in setup stage.
 * @var USBD_T::CFGP2
 * Offset: 0x52C  Endpoint 2 Set Stall and Clear In/Out Ready Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CLRRDY    |Clear Ready
 * |        |          |When the USBD_MXPLDx register is set by user, it means that the endpoint is ready to transmit or receive data
 * |        |          |If the user wants to disable this transaction before the transaction start, users can set this bit to 1 to disable it and it is auto clear to 0.
 * |        |          |For IN token, write '1' to clear the IN token had ready to transmit the data to USB.
 * |        |          |For OUT token, write '1' to clear the OUT token had ready to receive the data from USB.
 * |        |          |This bit is write 1 only and is always 0 when it is read back.
 * |[1]     |SSTALL    |Set STALL
 * |        |          |0 = Disable the device to response STALL.
 * |        |          |1 = Set the device to respond STALL automatically.
 * @var USBD_T::BUFSEG3
 * Offset: 0x530  Endpoint 3 Buffer Segmentation Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:3]   |BUFSEG    |Endpoint Buffer Segmentation
 * |        |          |It is used to indicate the offset address for each endpoint with the USB SRAM starting address The effective starting address of the endpoint is
 * |        |          |USBD_SRAM address + { BUFSEG, 3'b000}
 * |        |          |Where the USBD_SRAM address = USBD_BA+0x100h.
 * |        |          |Refer to the section 6.17.5.7 for the endpoint SRAM structure and its description.
 * @var USBD_T::MXPLD3
 * Offset: 0x534  Endpoint 3 Maximal Payload Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:0]   |MXPLD     |Maximal Payload
 * |        |          |Define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token)
 * |        |          |It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
 * |        |          |(1) When the register is written by CPU,
 * |        |          |For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready.
 * |        |          |For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
 * |        |          |(2) When the register is read by CPU,
 * |        |          |For IN token, the value of MXPLD is indicated by the data length be transmitted to host
 * |        |          |For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
 * |        |          |Note: Once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.
 * @var USBD_T::CFG3
 * Offset: 0x538  Endpoint 3 Configuration Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |EPNUM     |Endpoint Number
 * |        |          |These bits are used to define the endpoint number of the current endpoint
 * |[4]     |ISOCH     |Isochronous Endpoint
 * |        |          |This bit is used to set the endpoint as Isochronous endpoint, no handshake.
 * |        |          |0 = No Isochronous endpoint.
 * |        |          |1 = Isochronous endpoint.
 * |[6:5]   |STATE     |Endpoint STATE
 * |        |          |00 = Endpoint is Disabled.
 * |        |          |01 = Out endpoint.
 * |        |          |10 = IN endpoint.
 * |        |          |11 = Undefined.
 * |[7]     |DSQSYNC   |Data Sequence Synchronization
 * |        |          |0 = DATA0 PID.
 * |        |          |1 = DATA1 PID.
 * |        |          |Note: It is used to specify the DATA0 or DATA1 PID in the following IN token transaction
 * |        |          |hardware will toggle automatically in IN token base on the bit.
 * |[9]     |CSTALL    |Clear STALL Response
 * |        |          |0 = Disable the device to clear the STALL handshake in setup stage.
 * |        |          |1 = Clear the device to response STALL handshake in setup stage.
 * @var USBD_T::CFGP3
 * Offset: 0x53C  Endpoint 3 Set Stall and Clear In/Out Ready Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CLRRDY    |Clear Ready
 * |        |          |When the USBD_MXPLDx register is set by user, it means that the endpoint is ready to transmit or receive data
 * |        |          |If the user wants to disable this transaction before the transaction start, users can set this bit to 1 to disable it and it is auto clear to 0.
 * |        |          |For IN token, write '1' to clear the IN token had ready to transmit the data to USB.
 * |        |          |For OUT token, write '1' to clear the OUT token had ready to receive the data from USB.
 * |        |          |This bit is write 1 only and is always 0 when it is read back.
 * |[1]     |SSTALL    |Set STALL
 * |        |          |0 = Disable the device to response STALL.
 * |        |          |1 = Set the device to respond STALL automatically.
 * @var USBD_T::BUFSEG4
 * Offset: 0x540  Endpoint 4 Buffer Segmentation Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:3]   |BUFSEG    |Endpoint Buffer Segmentation
 * |        |          |It is used to indicate the offset address for each endpoint with the USB SRAM starting address The effective starting address of the endpoint is
 * |        |          |USBD_SRAM address + { BUFSEG, 3'b000}
 * |        |          |Where the USBD_SRAM address = USBD_BA+0x100h.
 * |        |          |Refer to the section 6.17.5.7 for the endpoint SRAM structure and its description.
 * @var USBD_T::MXPLD4
 * Offset: 0x544  Endpoint 4 Maximal Payload Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:0]   |MXPLD     |Maximal Payload
 * |        |          |Define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token)
 * |        |          |It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
 * |        |          |(1) When the register is written by CPU,
 * |        |          |For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready.
 * |        |          |For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
 * |        |          |(2) When the register is read by CPU,
 * |        |          |For IN token, the value of MXPLD is indicated by the data length be transmitted to host
 * |        |          |For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
 * |        |          |Note: Once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.
 * @var USBD_T::CFG4
 * Offset: 0x548  Endpoint 4 Configuration Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |EPNUM     |Endpoint Number
 * |        |          |These bits are used to define the endpoint number of the current endpoint
 * |[4]     |ISOCH     |Isochronous Endpoint
 * |        |          |This bit is used to set the endpoint as Isochronous endpoint, no handshake.
 * |        |          |0 = No Isochronous endpoint.
 * |        |          |1 = Isochronous endpoint.
 * |[6:5]   |STATE     |Endpoint STATE
 * |        |          |00 = Endpoint is Disabled.
 * |        |          |01 = Out endpoint.
 * |        |          |10 = IN endpoint.
 * |        |          |11 = Undefined.
 * |[7]     |DSQSYNC   |Data Sequence Synchronization
 * |        |          |0 = DATA0 PID.
 * |        |          |1 = DATA1 PID.
 * |        |          |Note: It is used to specify the DATA0 or DATA1 PID in the following IN token transaction
 * |        |          |hardware will toggle automatically in IN token base on the bit.
 * |[9]     |CSTALL    |Clear STALL Response
 * |        |          |0 = Disable the device to clear the STALL handshake in setup stage.
 * |        |          |1 = Clear the device to response STALL handshake in setup stage.
 * @var USBD_T::CFGP4
 * Offset: 0x54C  Endpoint 4 Set Stall and Clear In/Out Ready Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CLRRDY    |Clear Ready
 * |        |          |When the USBD_MXPLDx register is set by user, it means that the endpoint is ready to transmit or receive data
 * |        |          |If the user wants to disable this transaction before the transaction start, users can set this bit to 1 to disable it and it is auto clear to 0.
 * |        |          |For IN token, write '1' to clear the IN token had ready to transmit the data to USB.
 * |        |          |For OUT token, write '1' to clear the OUT token had ready to receive the data from USB.
 * |        |          |This bit is write 1 only and is always 0 when it is read back.
 * |[1]     |SSTALL    |Set STALL
 * |        |          |0 = Disable the device to response STALL.
 * |        |          |1 = Set the device to respond STALL automatically.
 * @var USBD_T::BUFSEG5
 * Offset: 0x550  Endpoint 5 Buffer Segmentation Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:3]   |BUFSEG    |Endpoint Buffer Segmentation
 * |        |          |It is used to indicate the offset address for each endpoint with the USB SRAM starting address The effective starting address of the endpoint is
 * |        |          |USBD_SRAM address + { BUFSEG, 3'b000}
 * |        |          |Where the USBD_SRAM address = USBD_BA+0x100h.
 * |        |          |Refer to the section 6.17.5.7 for the endpoint SRAM structure and its description.
 * @var USBD_T::MXPLD5
 * Offset: 0x554  Endpoint 5 Maximal Payload Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:0]   |MXPLD     |Maximal Payload
 * |        |          |Define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token)
 * |        |          |It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
 * |        |          |(1) When the register is written by CPU,
 * |        |          |For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready.
 * |        |          |For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
 * |        |          |(2) When the register is read by CPU,
 * |        |          |For IN token, the value of MXPLD is indicated by the data length be transmitted to host
 * |        |          |For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
 * |        |          |Note: Once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.
 * @var USBD_T::CFG5
 * Offset: 0x558  Endpoint 5 Configuration Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |EPNUM     |Endpoint Number
 * |        |          |These bits are used to define the endpoint number of the current endpoint
 * |[4]     |ISOCH     |Isochronous Endpoint
 * |        |          |This bit is used to set the endpoint as Isochronous endpoint, no handshake.
 * |        |          |0 = No Isochronous endpoint.
 * |        |          |1 = Isochronous endpoint.
 * |[6:5]   |STATE     |Endpoint STATE
 * |        |          |00 = Endpoint is Disabled.
 * |        |          |01 = Out endpoint.
 * |        |          |10 = IN endpoint.
 * |        |          |11 = Undefined.
 * |[7]     |DSQSYNC   |Data Sequence Synchronization
 * |        |          |0 = DATA0 PID.
 * |        |          |1 = DATA1 PID.
 * |        |          |Note: It is used to specify the DATA0 or DATA1 PID in the following IN token transaction
 * |        |          |hardware will toggle automatically in IN token base on the bit.
 * |[9]     |CSTALL    |Clear STALL Response
 * |        |          |0 = Disable the device to clear the STALL handshake in setup stage.
 * |        |          |1 = Clear the device to response STALL handshake in setup stage.
 * @var USBD_T::CFGP5
 * Offset: 0x55C  Endpoint 5 Set Stall and Clear In/Out Ready Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CLRRDY    |Clear Ready
 * |        |          |When the USBD_MXPLDx register is set by user, it means that the endpoint is ready to transmit or receive data
 * |        |          |If the user wants to disable this transaction before the transaction start, users can set this bit to 1 to disable it and it is auto clear to 0.
 * |        |          |For IN token, write '1' to clear the IN token had ready to transmit the data to USB.
 * |        |          |For OUT token, write '1' to clear the OUT token had ready to receive the data from USB.
 * |        |          |This bit is write 1 only and is always 0 when it is read back.
 * |[1]     |SSTALL    |Set STALL
 * |        |          |0 = Disable the device to response STALL.
 * |        |          |1 = Set the device to respond STALL automatically.
 * @var USBD_T::BUFSEG6
 * Offset: 0x560  Endpoint 6 Buffer Segmentation Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:3]   |BUFSEG    |Endpoint Buffer Segmentation
 * |        |          |It is used to indicate the offset address for each endpoint with the USB SRAM starting address The effective starting address of the endpoint is
 * |        |          |USBD_SRAM address + { BUFSEG, 3'b000}
 * |        |          |Where the USBD_SRAM address = USBD_BA+0x100h.
 * |        |          |Refer to the section 6.17.5.7 for the endpoint SRAM structure and its description.
 * @var USBD_T::MXPLD6
 * Offset: 0x564  Endpoint 6 Maximal Payload Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:0]   |MXPLD     |Maximal Payload
 * |        |          |Define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token)
 * |        |          |It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
 * |        |          |(1) When the register is written by CPU,
 * |        |          |For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready.
 * |        |          |For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
 * |        |          |(2) When the register is read by CPU,
 * |        |          |For IN token, the value of MXPLD is indicated by the data length be transmitted to host
 * |        |          |For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
 * |        |          |Note: Once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.
 * @var USBD_T::CFG6
 * Offset: 0x568  Endpoint 6 Configuration Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |EPNUM     |Endpoint Number
 * |        |          |These bits are used to define the endpoint number of the current endpoint
 * |[4]     |ISOCH     |Isochronous Endpoint
 * |        |          |This bit is used to set the endpoint as Isochronous endpoint, no handshake.
 * |        |          |0 = No Isochronous endpoint.
 * |        |          |1 = Isochronous endpoint.
 * |[6:5]   |STATE     |Endpoint STATE
 * |        |          |00 = Endpoint is Disabled.
 * |        |          |01 = Out endpoint.
 * |        |          |10 = IN endpoint.
 * |        |          |11 = Undefined.
 * |[7]     |DSQSYNC   |Data Sequence Synchronization
 * |        |          |0 = DATA0 PID.
 * |        |          |1 = DATA1 PID.
 * |        |          |Note: It is used to specify the DATA0 or DATA1 PID in the following IN token transaction
 * |        |          |hardware will toggle automatically in IN token base on the bit.
 * |[9]     |CSTALL    |Clear STALL Response
 * |        |          |0 = Disable the device to clear the STALL handshake in setup stage.
 * |        |          |1 = Clear the device to response STALL handshake in setup stage.
 * @var USBD_T::CFGP6
 * Offset: 0x56C  Endpoint 6 Set Stall and Clear In/Out Ready Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CLRRDY    |Clear Ready
 * |        |          |When the USBD_MXPLDx register is set by user, it means that the endpoint is ready to transmit or receive data
 * |        |          |If the user wants to disable this transaction before the transaction start, users can set this bit to 1 to disable it and it is auto clear to 0.
 * |        |          |For IN token, write '1' to clear the IN token had ready to transmit the data to USB.
 * |        |          |For OUT token, write '1' to clear the OUT token had ready to receive the data from USB.
 * |        |          |This bit is write 1 only and is always 0 when it is read back.
 * |[1]     |SSTALL    |Set STALL
 * |        |          |0 = Disable the device to response STALL.
 * |        |          |1 = Set the device to respond STALL automatically.
 * @var USBD_T::BUFSEG7
 * Offset: 0x570  Endpoint 7 Buffer Segmentation Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:3]   |BUFSEG    |Endpoint Buffer Segmentation
 * |        |          |It is used to indicate the offset address for each endpoint with the USB SRAM starting address The effective starting address of the endpoint is
 * |        |          |USBD_SRAM address + { BUFSEG, 3'b000}
 * |        |          |Where the USBD_SRAM address = USBD_BA+0x100h.
 * |        |          |Refer to the section 6.17.5.7 for the endpoint SRAM structure and its description.
 * @var USBD_T::MXPLD7
 * Offset: 0x574  Endpoint 7 Maximal Payload Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:0]   |MXPLD     |Maximal Payload
 * |        |          |Define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token)
 * |        |          |It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
 * |        |          |(1) When the register is written by CPU,
 * |        |          |For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready.
 * |        |          |For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
 * |        |          |(2) When the register is read by CPU,
 * |        |          |For IN token, the value of MXPLD is indicated by the data length be transmitted to host
 * |        |          |For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
 * |        |          |Note: Once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.
 * @var USBD_T::CFG7
 * Offset: 0x578  Endpoint 7 Configuration Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |EPNUM     |Endpoint Number
 * |        |          |These bits are used to define the endpoint number of the current endpoint
 * |[4]     |ISOCH     |Isochronous Endpoint
 * |        |          |This bit is used to set the endpoint as Isochronous endpoint, no handshake.
 * |        |          |0 = No Isochronous endpoint.
 * |        |          |1 = Isochronous endpoint.
 * |[6:5]   |STATE     |Endpoint STATE
 * |        |          |00 = Endpoint is Disabled.
 * |        |          |01 = Out endpoint.
 * |        |          |10 = IN endpoint.
 * |        |          |11 = Undefined.
 * |[7]     |DSQSYNC   |Data Sequence Synchronization
 * |        |          |0 = DATA0 PID.
 * |        |          |1 = DATA1 PID.
 * |        |          |Note: It is used to specify the DATA0 or DATA1 PID in the following IN token transaction
 * |        |          |hardware will toggle automatically in IN token base on the bit.
 * |[9]     |CSTALL    |Clear STALL Response
 * |        |          |0 = Disable the device to clear the STALL handshake in setup stage.
 * |        |          |1 = Clear the device to response STALL handshake in setup stage.
 * @var USBD_T::CFGP7
 * Offset: 0x57C  Endpoint 7 Set Stall and Clear In/Out Ready Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CLRRDY    |Clear Ready
 * |        |          |When the USBD_MXPLDx register is set by user, it means that the endpoint is ready to transmit or receive data
 * |        |          |If the user wants to disable this transaction before the transaction start, users can set this bit to 1 to disable it and it is auto clear to 0.
 * |        |          |For IN token, write '1' to clear the IN token had ready to transmit the data to USB.
 * |        |          |For OUT token, write '1' to clear the OUT token had ready to receive the data from USB.
 * |        |          |This bit is write 1 only and is always 0 when it is read back.
 * |[1]     |SSTALL    |Set STALL
 * |        |          |0 = Disable the device to response STALL.
 * |        |          |1 = Set the device to respond STALL automatically.
 * @var USBD_T::BUFSEG8
 * Offset: 0x580  Endpoint 8 Buffer Segmentation Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:3]   |BUFSEG    |Endpoint Buffer Segmentation
 * |        |          |It is used to indicate the offset address for each endpoint with the USB SRAM starting address The effective starting address of the endpoint is
 * |        |          |USBD_SRAM address + { BUFSEG, 3'b000}
 * |        |          |Where the USBD_SRAM address = USBD_BA+0x100h.
 * |        |          |Refer to the section 6.17.5.7 for the endpoint SRAM structure and its description.
 * @var USBD_T::MXPLD8
 * Offset: 0x584  Endpoint 8 Maximal Payload Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:0]   |MXPLD     |Maximal Payload
 * |        |          |Define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token)
 * |        |          |It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
 * |        |          |(1) When the register is written by CPU,
 * |        |          |For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready.
 * |        |          |For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
 * |        |          |(2) When the register is read by CPU,
 * |        |          |For IN token, the value of MXPLD is indicated by the data length be transmitted to host
 * |        |          |For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
 * |        |          |Note: Once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.
 * @var USBD_T::CFG8
 * Offset: 0x588  Endpoint 8 Configuration Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |EPNUM     |Endpoint Number
 * |        |          |These bits are used to define the endpoint number of the current endpoint
 * |[4]     |ISOCH     |Isochronous Endpoint
 * |        |          |This bit is used to set the endpoint as Isochronous endpoint, no handshake.
 * |        |          |0 = No Isochronous endpoint.
 * |        |          |1 = Isochronous endpoint.
 * |[6:5]   |STATE     |Endpoint STATE
 * |        |          |00 = Endpoint is Disabled.
 * |        |          |01 = Out endpoint.
 * |        |          |10 = IN endpoint.
 * |        |          |11 = Undefined.
 * |[7]     |DSQSYNC   |Data Sequence Synchronization
 * |        |          |0 = DATA0 PID.
 * |        |          |1 = DATA1 PID.
 * |        |          |Note: It is used to specify the DATA0 or DATA1 PID in the following IN token transaction
 * |        |          |hardware will toggle automatically in IN token base on the bit.
 * |[9]     |CSTALL    |Clear STALL Response
 * |        |          |0 = Disable the device to clear the STALL handshake in setup stage.
 * |        |          |1 = Clear the device to response STALL handshake in setup stage.
 * @var USBD_T::CFGP8
 * Offset: 0x58C  Endpoint 8 Set Stall and Clear In/Out Ready Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CLRRDY    |Clear Ready
 * |        |          |When the USBD_MXPLDx register is set by user, it means that the endpoint is ready to transmit or receive data
 * |        |          |If the user wants to disable this transaction before the transaction start, users can set this bit to 1 to disable it and it is auto clear to 0.
 * |        |          |For IN token, write '1' to clear the IN token had ready to transmit the data to USB.
 * |        |          |For OUT token, write '1' to clear the OUT token had ready to receive the data from USB.
 * |        |          |This bit is write 1 only and is always 0 when it is read back.
 * |[1]     |SSTALL    |Set STALL
 * |        |          |0 = Disable the device to response STALL.
 * |        |          |1 = Set the device to respond STALL automatically.
 * @var USBD_T::BUFSEG9
 * Offset: 0x590  Endpoint 9 Buffer Segmentation Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:3]   |BUFSEG    |Endpoint Buffer Segmentation
 * |        |          |It is used to indicate the offset address for each endpoint with the USB SRAM starting address The effective starting address of the endpoint is
 * |        |          |USBD_SRAM address + { BUFSEG, 3'b000}
 * |        |          |Where the USBD_SRAM address = USBD_BA+0x100h.
 * |        |          |Refer to the section 6.17.5.7 for the endpoint SRAM structure and its description.
 * @var USBD_T::MXPLD9
 * Offset: 0x594  Endpoint 9 Maximal Payload Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:0]   |MXPLD     |Maximal Payload
 * |        |          |Define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token)
 * |        |          |It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
 * |        |          |(1) When the register is written by CPU,
 * |        |          |For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready.
 * |        |          |For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
 * |        |          |(2) When the register is read by CPU,
 * |        |          |For IN token, the value of MXPLD is indicated by the data length be transmitted to host
 * |        |          |For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
 * |        |          |Note: Once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.
 * @var USBD_T::CFG9
 * Offset: 0x598  Endpoint 9 Configuration Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |EPNUM     |Endpoint Number
 * |        |          |These bits are used to define the endpoint number of the current endpoint
 * |[4]     |ISOCH     |Isochronous Endpoint
 * |        |          |This bit is used to set the endpoint as Isochronous endpoint, no handshake.
 * |        |          |0 = No Isochronous endpoint.
 * |        |          |1 = Isochronous endpoint.
 * |[6:5]   |STATE     |Endpoint STATE
 * |        |          |00 = Endpoint is Disabled.
 * |        |          |01 = Out endpoint.
 * |        |          |10 = IN endpoint.
 * |        |          |11 = Undefined.
 * |[7]     |DSQSYNC   |Data Sequence Synchronization
 * |        |          |0 = DATA0 PID.
 * |        |          |1 = DATA1 PID.
 * |        |          |Note: It is used to specify the DATA0 or DATA1 PID in the following IN token transaction
 * |        |          |hardware will toggle automatically in IN token base on the bit.
 * |[9]     |CSTALL    |Clear STALL Response
 * |        |          |0 = Disable the device to clear the STALL handshake in setup stage.
 * |        |          |1 = Clear the device to response STALL handshake in setup stage.
 * @var USBD_T::CFGP9
 * Offset: 0x59C  Endpoint 9 Set Stall and Clear In/Out Ready Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CLRRDY    |Clear Ready
 * |        |          |When the USBD_MXPLDx register is set by user, it means that the endpoint is ready to transmit or receive data
 * |        |          |If the user wants to disable this transaction before the transaction start, users can set this bit to 1 to disable it and it is auto clear to 0.
 * |        |          |For IN token, write '1' to clear the IN token had ready to transmit the data to USB.
 * |        |          |For OUT token, write '1' to clear the OUT token had ready to receive the data from USB.
 * |        |          |This bit is write 1 only and is always 0 when it is read back.
 * |[1]     |SSTALL    |Set STALL
 * |        |          |0 = Disable the device to response STALL.
 * |        |          |1 = Set the device to respond STALL automatically.
 * @var USBD_T::BUFSEG10
 * Offset: 0x5A0  Endpoint 10 Buffer Segmentation Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:3]   |BUFSEG    |Endpoint Buffer Segmentation
 * |        |          |It is used to indicate the offset address for each endpoint with the USB SRAM starting address The effective starting address of the endpoint is
 * |        |          |USBD_SRAM address + { BUFSEG, 3'b000}
 * |        |          |Where the USBD_SRAM address = USBD_BA+0x100h.
 * |        |          |Refer to the section 6.17.5.7 for the endpoint SRAM structure and its description.
 * @var USBD_T::MXPLD10
 * Offset: 0x5A4  Endpoint 10 Maximal Payload Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:0]   |MXPLD     |Maximal Payload
 * |        |          |Define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token)
 * |        |          |It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
 * |        |          |(1) When the register is written by CPU,
 * |        |          |For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready.
 * |        |          |For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
 * |        |          |(2) When the register is read by CPU,
 * |        |          |For IN token, the value of MXPLD is indicated by the data length be transmitted to host
 * |        |          |For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
 * |        |          |Note: Once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.
 * @var USBD_T::CFG10
 * Offset: 0x5A8  Endpoint 10 Configuration Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |EPNUM     |Endpoint Number
 * |        |          |These bits are used to define the endpoint number of the current endpoint
 * |[4]     |ISOCH     |Isochronous Endpoint
 * |        |          |This bit is used to set the endpoint as Isochronous endpoint, no handshake.
 * |        |          |0 = No Isochronous endpoint.
 * |        |          |1 = Isochronous endpoint.
 * |[6:5]   |STATE     |Endpoint STATE
 * |        |          |00 = Endpoint is Disabled.
 * |        |          |01 = Out endpoint.
 * |        |          |10 = IN endpoint.
 * |        |          |11 = Undefined.
 * |[7]     |DSQSYNC   |Data Sequence Synchronization
 * |        |          |0 = DATA0 PID.
 * |        |          |1 = DATA1 PID.
 * |        |          |Note: It is used to specify the DATA0 or DATA1 PID in the following IN token transaction
 * |        |          |hardware will toggle automatically in IN token base on the bit.
 * |[9]     |CSTALL    |Clear STALL Response
 * |        |          |0 = Disable the device to clear the STALL handshake in setup stage.
 * |        |          |1 = Clear the device to response STALL handshake in setup stage.
 * @var USBD_T::CFGP10
 * Offset: 0x5AC  Endpoint 10 Set Stall and Clear In/Out Ready Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CLRRDY    |Clear Ready
 * |        |          |When the USBD_MXPLDx register is set by user, it means that the endpoint is ready to transmit or receive data
 * |        |          |If the user wants to disable this transaction before the transaction start, users can set this bit to 1 to disable it and it is auto clear to 0.
 * |        |          |For IN token, write '1' to clear the IN token had ready to transmit the data to USB.
 * |        |          |For OUT token, write '1' to clear the OUT token had ready to receive the data from USB.
 * |        |          |This bit is write 1 only and is always 0 when it is read back.
 * |[1]     |SSTALL    |Set STALL
 * |        |          |0 = Disable the device to response STALL.
 * |        |          |1 = Set the device to respond STALL automatically.
 * @var USBD_T::BUFSEG11
 * Offset: 0x5B0  Endpoint 11 Buffer Segmentation Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:3]   |BUFSEG    |Endpoint Buffer Segmentation
 * |        |          |It is used to indicate the offset address for each endpoint with the USB SRAM starting address The effective starting address of the endpoint is
 * |        |          |USBD_SRAM address + { BUFSEG, 3'b000}
 * |        |          |Where the USBD_SRAM address = USBD_BA+0x100h.
 * |        |          |Refer to the section 6.17.5.7 for the endpoint SRAM structure and its description.
 * @var USBD_T::MXPLD11
 * Offset: 0x5B4  Endpoint 11 Maximal Payload Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[8:0]   |MXPLD     |Maximal Payload
 * |        |          |Define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token)
 * |        |          |It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
 * |        |          |(1) When the register is written by CPU,
 * |        |          |For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready.
 * |        |          |For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
 * |        |          |(2) When the register is read by CPU,
 * |        |          |For IN token, the value of MXPLD is indicated by the data length be transmitted to host
 * |        |          |For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
 * |        |          |Note: Once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.
 * @var USBD_T::CFG11
 * Offset: 0x5B8  Endpoint 11 Configuration Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[3:0]   |EPNUM     |Endpoint Number
 * |        |          |These bits are used to define the endpoint number of the current endpoint
 * |[4]     |ISOCH     |Isochronous Endpoint
 * |        |          |This bit is used to set the endpoint as Isochronous endpoint, no handshake.
 * |        |          |0 = No Isochronous endpoint.
 * |        |          |1 = Isochronous endpoint.
 * |[6:5]   |STATE     |Endpoint STATE
 * |        |          |00 = Endpoint is Disabled.
 * |        |          |01 = Out endpoint.
 * |        |          |10 = IN endpoint.
 * |        |          |11 = Undefined.
 * |[7]     |DSQSYNC   |Data Sequence Synchronization
 * |        |          |0 = DATA0 PID.
 * |        |          |1 = DATA1 PID.
 * |        |          |Note: It is used to specify the DATA0 or DATA1 PID in the following IN token transaction
 * |        |          |hardware will toggle automatically in IN token base on the bit.
 * |[9]     |CSTALL    |Clear STALL Response
 * |        |          |0 = Disable the device to clear the STALL handshake in setup stage.
 * |        |          |1 = Clear the device to response STALL handshake in setup stage.
 * @var USBD_T::CFGP11
 * Offset: 0x5BC  Endpoint 11 Set Stall and Clear In/Out Ready Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |CLRRDY    |Clear Ready
 * |        |          |When the USBD_MXPLDx register is set by user, it means that the endpoint is ready to transmit or receive data
 * |        |          |If the user wants to disable this transaction before the transaction start, users can set this bit to 1 to disable it and it is auto clear to 0.
 * |        |          |For IN token, write '1' to clear the IN token had ready to transmit the data to USB.
 * |        |          |For OUT token, write '1' to clear the OUT token had ready to receive the data from USB.
 * |        |          |This bit is write 1 only and is always 0 when it is read back.
 * |[1]     |SSTALL    |Set STALL
 * |        |          |0 = Disable the device to response STALL.
 * |        |          |1 = Set the device to respond STALL automatically.
 * @var USBD_T::VERSION
 * Offset: 0xFFC  USB Version Number Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[15:0]  |MINOR     |RTL Design MINOR Version Number
 * |        |          |Minor version number is dependent on module's ECO version control.
 * |        |          |0x0000:(Current Minor Version Number)
 * |[23:16] |SUB       |RTL Design SUB Version Number
 * |        |          |Sub version number is correlated to module's key feature.
 * |        |          |0x01:(Current Sub Version Number)
 * |[31:24] |MAJOR     |RTL Design MAJOR Version Number
 * |        |          |Major version number is correlated to Product Line
 * |        |          |0x02:(Current Major Version Number)
 */
    __IO uint32_t INTEN;                 /*!< [0x0000] USB Device Interrupt Enable Register                             */
    __IO uint32_t INTSTS;                /*!< [0x0004] USB Device Interrupt Event Status Register                       */
    __IO uint32_t FADDR;                 /*!< [0x0008] USB Device Function Address Register                             */
    __I  uint32_t EPSTS;                 /*!< [0x000c] USB Device Endpoint Status Register                              */
    __IO uint32_t ATTR;                  /*!< [0x0010] USB Device Bus Status and Attribution Register                   */
    __I  uint32_t VBUSDET;               /*!< [0x0014] USB Device VBUS Detection Register                               */
    __IO uint32_t STBUFSEG;              /*!< [0x0018] SETUP Token Buffer Segmentation Register                         */
    __I  uint32_t RESERVE0[1];
    __I  uint32_t EPSTS0;                /*!< [0x0020] USB Device Endpoint Status Register 0                            */
    __I  uint32_t EPSTS1;                /*!< [0x0024] USB Device Endpoint Status Register 1                            */
    __I  uint32_t RESERVE1[24];
    __I  uint32_t LPMATTR;               /*!< [0x0088] USB LPM Attribution Register                                     */
    __I  uint32_t FN;                    /*!< [0x008c] USB Frame number Register                                        */
    __IO uint32_t SE0;                   /*!< [0x0090] USB Device Drive SE0 Control Register                            */
    __I  uint32_t RESERVE2[3];
    __IO uint32_t BIST;                  /*!< [0x00a0] USB Buffer Self-Test Control                                     */
    __IO uint32_t PDMA;                  /*!< [0x00a4] USB PDMA Control                                                 */
    __IO uint32_t TEST;                  /*!< [0x00a8] USB Test Control                                                 */
    __I  uint32_t RESERVE3[277];
    __IO uint32_t BUFSEG0;               /*!< [0x0500] Endpoint 0 Buffer Segmentation Register                          */
    __IO uint32_t MXPLD0;                /*!< [0x0504] Endpoint 0 Maximal Payload Register                              */
    __IO uint32_t CFG0;                  /*!< [0x0508] Endpoint 0 Configuration Register                                */
    __IO uint32_t CFGP0;                 /*!< [0x050c] Endpoint 0 Set Stall and Clear In/Out Ready Control Register     */
    __IO uint32_t BUFSEG1;               /*!< [0x0510] Endpoint 1 Buffer Segmentation Register                          */
    __IO uint32_t MXPLD1;                /*!< [0x0514] Endpoint 1 Maximal Payload Register                              */
    __IO uint32_t CFG1;                  /*!< [0x0518] Endpoint 1 Configuration Register                                */
    __IO uint32_t CFGP1;                 /*!< [0x051c] Endpoint 1 Set Stall and Clear In/Out Ready Control Register     */
    __IO uint32_t BUFSEG2;               /*!< [0x0520] Endpoint 2 Buffer Segmentation Register                          */
    __IO uint32_t MXPLD2;                /*!< [0x0524] Endpoint 2 Maximal Payload Register                              */
    __IO uint32_t CFG2;                  /*!< [0x0528] Endpoint 2 Configuration Register                                */
    __IO uint32_t CFGP2;                 /*!< [0x052c] Endpoint 2 Set Stall and Clear In/Out Ready Control Register     */
    __IO uint32_t BUFSEG3;               /*!< [0x0530] Endpoint 3 Buffer Segmentation Register                          */
    __IO uint32_t MXPLD3;                /*!< [0x0534] Endpoint 3 Maximal Payload Register                              */
    __IO uint32_t CFG3;                  /*!< [0x0538] Endpoint 3 Configuration Register                                */
    __IO uint32_t CFGP3;                 /*!< [0x053c] Endpoint 3 Set Stall and Clear In/Out Ready Control Register     */
    __IO uint32_t BUFSEG4;               /*!< [0x0540] Endpoint 4 Buffer Segmentation Register                          */
    __IO uint32_t MXPLD4;                /*!< [0x0544] Endpoint 4 Maximal Payload Register                              */
    __IO uint32_t CFG4;                  /*!< [0x0548] Endpoint 4 Configuration Register                                */
    __IO uint32_t CFGP4;                 /*!< [0x054c] Endpoint 4 Set Stall and Clear In/Out Ready Control Register     */
    __IO uint32_t BUFSEG5;               /*!< [0x0550] Endpoint 5 Buffer Segmentation Register                          */
    __IO uint32_t MXPLD5;                /*!< [0x0554] Endpoint 5 Maximal Payload Register                              */
    __IO uint32_t CFG5;                  /*!< [0x0558] Endpoint 5 Configuration Register                                */
    __IO uint32_t CFGP5;                 /*!< [0x055c] Endpoint 5 Set Stall and Clear In/Out Ready Control Register     */
    __IO uint32_t BUFSEG6;               /*!< [0x0560] Endpoint 6 Buffer Segmentation Register                          */
    __IO uint32_t MXPLD6;                /*!< [0x0564] Endpoint 6 Maximal Payload Register                              */
    __IO uint32_t CFG6;                  /*!< [0x0568] Endpoint 6 Configuration Register                                */
    __IO uint32_t CFGP6;                 /*!< [0x056c] Endpoint 6 Set Stall and Clear In/Out Ready Control Register     */
    __IO uint32_t BUFSEG7;               /*!< [0x0570] Endpoint 7 Buffer Segmentation Register                          */
    __IO uint32_t MXPLD7;                /*!< [0x0574] Endpoint 7 Maximal Payload Register                              */
    __IO uint32_t CFG7;                  /*!< [0x0578] Endpoint 7 Configuration Register                                */
    __IO uint32_t CFGP7;                 /*!< [0x057c] Endpoint 7 Set Stall and Clear In/Out Ready Control Register     */
    __IO uint32_t BUFSEG8;               /*!< [0x0580] Endpoint 8 Buffer Segmentation Register                          */
    __IO uint32_t MXPLD8;                /*!< [0x0584] Endpoint 8 Maximal Payload Register                              */
    __IO uint32_t CFG8;                  /*!< [0x0588] Endpoint 8 Configuration Register                                */
    __IO uint32_t CFGP8;                 /*!< [0x058c] Endpoint 8 Set Stall and Clear In/Out Ready Control Register     */
    __IO uint32_t BUFSEG9;               /*!< [0x0590] Endpoint 9 Buffer Segmentation Register                          */
    __IO uint32_t MXPLD9;                /*!< [0x0594] Endpoint 9 Maximal Payload Register                              */
    __IO uint32_t CFG9;                  /*!< [0x0598] Endpoint 9 Configuration Register                                */
    __IO uint32_t CFGP9;                 /*!< [0x059c] Endpoint 9 Set Stall and Clear In/Out Ready Control Register     */
    __IO uint32_t BUFSEG10;              /*!< [0x05a0] Endpoint 10 Buffer Segmentation Register                         */
    __IO uint32_t MXPLD10;               /*!< [0x05a4] Endpoint 10 Maximal Payload Register                             */
    __IO uint32_t CFG10;                 /*!< [0x05a8] Endpoint 10 Configuration Register                               */
    __IO uint32_t CFGP10;                /*!< [0x05ac] Endpoint 10 Set Stall and Clear In/Out Ready Control Register    */
    __IO uint32_t BUFSEG11;              /*!< [0x05b0] Endpoint 11 Buffer Segmentation Register                         */
    __IO uint32_t MXPLD11;               /*!< [0x05b4] Endpoint 11 Maximal Payload Register                             */
    __IO uint32_t CFG11;                 /*!< [0x05b8] Endpoint 11 Configuration Register                               */
    __IO uint32_t CFGP11;                /*!< [0x05bc] Endpoint 11 Set Stall and Clear In/Out Ready Control Register    */
    __I  uint32_t RESERVE4[655];
    __I  uint32_t VERSION;               /*!< [0x0ffc] USB Version Number Register                                      */

} USBD_T;

/**
    @addtogroup USBD_CONST USBD Bit Field Definition
    Constant Definitions for USBD Controller
@{ */

#define USBD_INTEN_BUSIEN_Pos            (0)                                               /*!< USBD_T::INTEN: BUSIEN Position         */
#define USBD_INTEN_BUSIEN_Msk            (0x1ul << USBD_INTEN_BUSIEN_Pos)                  /*!< USBD_T::INTEN: BUSIEN Mask             */

#define USBD_INTEN_USBIEN_Pos            (1)                                               /*!< USBD_T::INTEN: USBIEN Position         */
#define USBD_INTEN_USBIEN_Msk            (0x1ul << USBD_INTEN_USBIEN_Pos)                  /*!< USBD_T::INTEN: USBIEN Mask             */

#define USBD_INTEN_VBDETIEN_Pos          (2)                                               /*!< USBD_T::INTEN: VBDETIEN Position       */
#define USBD_INTEN_VBDETIEN_Msk          (0x1ul << USBD_INTEN_VBDETIEN_Pos)                /*!< USBD_T::INTEN: VBDETIEN Mask           */

#define USBD_INTEN_NEVWKIEN_Pos          (3)                                               /*!< USBD_T::INTEN: NEVWKIEN Position       */
#define USBD_INTEN_NEVWKIEN_Msk          (0x1ul << USBD_INTEN_NEVWKIEN_Pos)                /*!< USBD_T::INTEN: NEVWKIEN Mask           */

#define USBD_INTEN_WKEN_Pos              (8)                                               /*!< USBD_T::INTEN: WKEN Position           */
#define USBD_INTEN_WKEN_Msk              (0x1ul << USBD_INTEN_WKEN_Pos)                    /*!< USBD_T::INTEN: WKEN Mask               */

#define USBD_INTEN_INNAKEN_Pos           (15)                                              /*!< USBD_T::INTEN: INNAKEN Position        */
#define USBD_INTEN_INNAKEN_Msk           (0x1ul << USBD_INTEN_INNAKEN_Pos)                 /*!< USBD_T::INTEN: INNAKEN Mask            */

#define USBD_INTSTS_BUSIF_Pos            (0)                                               /*!< USBD_T::INTSTS: BUSIF Position         */
#define USBD_INTSTS_BUSIF_Msk            (0x1ul << USBD_INTSTS_BUSIF_Pos)                  /*!< USBD_T::INTSTS: BUSIF Mask             */

#define USBD_INTSTS_USBIF_Pos            (1)                                               /*!< USBD_T::INTSTS: USBIF Position         */
#define USBD_INTSTS_USBIF_Msk            (0x1ul << USBD_INTSTS_USBIF_Pos)                  /*!< USBD_T::INTSTS: USBIF Mask             */

#define USBD_INTSTS_VBDETIF_Pos          (2)                                               /*!< USBD_T::INTSTS: VBDETIF Position       */
#define USBD_INTSTS_VBDETIF_Msk          (0x1ul << USBD_INTSTS_VBDETIF_Pos)                /*!< USBD_T::INTSTS: VBDETIF Mask           */

#define USBD_INTSTS_NEVWKIF_Pos          (3)                                               /*!< USBD_T::INTSTS: NEVWKIF Position       */
#define USBD_INTSTS_NEVWKIF_Msk          (0x1ul << USBD_INTSTS_NEVWKIF_Pos)                /*!< USBD_T::INTSTS: NEVWKIF Mask           */

#define USBD_INTSTS_EPEVT0_Pos           (16)                                              /*!< USBD_T::INTSTS: EPEVT0 Position        */
#define USBD_INTSTS_EPEVT0_Msk           (0x1ul << USBD_INTSTS_EPEVT0_Pos)                 /*!< USBD_T::INTSTS: EPEVT0 Mask            */

#define USBD_INTSTS_EPEVT1_Pos           (17)                                              /*!< USBD_T::INTSTS: EPEVT1 Position        */
#define USBD_INTSTS_EPEVT1_Msk           (0x1ul << USBD_INTSTS_EPEVT1_Pos)                 /*!< USBD_T::INTSTS: EPEVT1 Mask            */

#define USBD_INTSTS_EPEVT2_Pos           (18)                                              /*!< USBD_T::INTSTS: EPEVT2 Position        */
#define USBD_INTSTS_EPEVT2_Msk           (0x1ul << USBD_INTSTS_EPEVT2_Pos)                 /*!< USBD_T::INTSTS: EPEVT2 Mask            */

#define USBD_INTSTS_EPEVT3_Pos           (19)                                              /*!< USBD_T::INTSTS: EPEVT3 Position        */
#define USBD_INTSTS_EPEVT3_Msk           (0x1ul << USBD_INTSTS_EPEVT3_Pos)                 /*!< USBD_T::INTSTS: EPEVT3 Mask            */

#define USBD_INTSTS_EPEVT4_Pos           (20)                                              /*!< USBD_T::INTSTS: EPEVT4 Position        */
#define USBD_INTSTS_EPEVT4_Msk           (0x1ul << USBD_INTSTS_EPEVT4_Pos)                 /*!< USBD_T::INTSTS: EPEVT4 Mask            */

#define USBD_INTSTS_EPEVT5_Pos           (21)                                              /*!< USBD_T::INTSTS: EPEVT5 Position        */
#define USBD_INTSTS_EPEVT5_Msk           (0x1ul << USBD_INTSTS_EPEVT5_Pos)                 /*!< USBD_T::INTSTS: EPEVT5 Mask            */

#define USBD_INTSTS_EPEVT6_Pos           (22)                                              /*!< USBD_T::INTSTS: EPEVT6 Position        */
#define USBD_INTSTS_EPEVT6_Msk           (0x1ul << USBD_INTSTS_EPEVT6_Pos)                 /*!< USBD_T::INTSTS: EPEVT6 Mask            */

#define USBD_INTSTS_EPEVT7_Pos           (23)                                              /*!< USBD_T::INTSTS: EPEVT7 Position        */
#define USBD_INTSTS_EPEVT7_Msk           (0x1ul << USBD_INTSTS_EPEVT7_Pos)                 /*!< USBD_T::INTSTS: EPEVT7 Mask            */

#define USBD_INTSTS_EPEVT8_Pos           (24)                                              /*!< USBD_T::INTSTS: EPEVT8 Position        */
#define USBD_INTSTS_EPEVT8_Msk           (0x1ul << USBD_INTSTS_EPEVT8_Pos)                 /*!< USBD_T::INTSTS: EPEVT8 Mask            */

#define USBD_INTSTS_EPEVT9_Pos           (25)                                              /*!< USBD_T::INTSTS: EPEVT9 Position        */
#define USBD_INTSTS_EPEVT9_Msk           (0x1ul << USBD_INTSTS_EPEVT9_Pos)                 /*!< USBD_T::INTSTS: EPEVT9 Mask            */

#define USBD_INTSTS_EPEVT10_Pos          (26)                                              /*!< USBD_T::INTSTS: EPEVT10 Position       */
#define USBD_INTSTS_EPEVT10_Msk          (0x1ul << USBD_INTSTS_EPEVT10_Pos)                /*!< USBD_T::INTSTS: EPEVT10 Mask           */

#define USBD_INTSTS_EPEVT11_Pos          (27)                                              /*!< USBD_T::INTSTS: EPEVT11 Position       */
#define USBD_INTSTS_EPEVT11_Msk          (0x1ul << USBD_INTSTS_EPEVT11_Pos)                /*!< USBD_T::INTSTS: EPEVT11 Mask           */

#define USBD_INTSTS_SETUP_Pos            (31)                                              /*!< USBD_T::INTSTS: SETUP Position         */
#define USBD_INTSTS_SETUP_Msk            (0x1ul << USBD_INTSTS_SETUP_Pos)                  /*!< USBD_T::INTSTS: SETUP Mask             */

#define USBD_FADDR_FADDR_Pos             (0)                                               /*!< USBD_T::FADDR: FADDR Position          */
#define USBD_FADDR_FADDR_Msk             (0x7ful << USBD_FADDR_FADDR_Pos)                  /*!< USBD_T::FADDR: FADDR Mask              */

#define USBD_EPSTS_OV_Pos                (7)                                               /*!< USBD_T::EPSTS: OV Position             */
#define USBD_EPSTS_OV_Msk                (0x1ul << USBD_EPSTS_OV_Pos)                      /*!< USBD_T::EPSTS: OV Mask                 */

#define USBD_ATTR_USBRST_Pos             (0)                                               /*!< USBD_T::ATTR: USBRST Position          */
#define USBD_ATTR_USBRST_Msk             (0x1ul << USBD_ATTR_USBRST_Pos)                   /*!< USBD_T::ATTR: USBRST Mask              */

#define USBD_ATTR_SUSPEND_Pos            (1)                                               /*!< USBD_T::ATTR: SUSPEND Position         */
#define USBD_ATTR_SUSPEND_Msk            (0x1ul << USBD_ATTR_SUSPEND_Pos)                  /*!< USBD_T::ATTR: SUSPEND Mask             */

#define USBD_ATTR_RESUME_Pos             (2)                                               /*!< USBD_T::ATTR: RESUME Position          */
#define USBD_ATTR_RESUME_Msk             (0x1ul << USBD_ATTR_RESUME_Pos)                   /*!< USBD_T::ATTR: RESUME Mask              */

#define USBD_ATTR_TOUT_Pos               (3)                                               /*!< USBD_T::ATTR: TOUT Position            */
#define USBD_ATTR_TOUT_Msk               (0x1ul << USBD_ATTR_TOUT_Pos)                     /*!< USBD_T::ATTR: TOUT Mask                */

#define USBD_ATTR_PHYEN_Pos              (4)                                               /*!< USBD_T::ATTR: PHYEN Position           */
#define USBD_ATTR_PHYEN_Msk              (0x1ul << USBD_ATTR_PHYEN_Pos)                    /*!< USBD_T::ATTR: PHYEN Mask               */

#define USBD_ATTR_RWAKEUP_Pos            (5)                                               /*!< USBD_T::ATTR: RWAKEUP Position         */
#define USBD_ATTR_RWAKEUP_Msk            (0x1ul << USBD_ATTR_RWAKEUP_Pos)                  /*!< USBD_T::ATTR: RWAKEUP Mask             */

#define USBD_ATTR_USBEN_Pos              (7)                                               /*!< USBD_T::ATTR: USBEN Position           */
#define USBD_ATTR_USBEN_Msk              (0x1ul << USBD_ATTR_USBEN_Pos)                    /*!< USBD_T::ATTR: USBEN Mask               */

#define USBD_ATTR_DPPUEN_Pos             (8)                                               /*!< USBD_T::ATTR: DPPUEN Position          */
#define USBD_ATTR_DPPUEN_Msk             (0x1ul << USBD_ATTR_DPPUEN_Pos)                   /*!< USBD_T::ATTR: DPPUEN Mask              */

#define USBD_ATTR_BYTEM_Pos              (10)                                              /*!< USBD_T::ATTR: BYTEM Position           */
#define USBD_ATTR_BYTEM_Msk              (0x1ul << USBD_ATTR_BYTEM_Pos)                    /*!< USBD_T::ATTR: BYTEM Mask               */

#define USBD_VBUSDET_VBUSDET_Pos         (0)                                               /*!< USBD_T::VBUSDET: VBUSDET Position      */
#define USBD_VBUSDET_VBUSDET_Msk         (0x1ul << USBD_VBUSDET_VBUSDET_Pos)               /*!< USBD_T::VBUSDET: VBUSDET Mask          */

#define USBD_STBUFSEG_STBUFSEG_Pos       (3)                                               /*!< USBD_T::STBUFSEG: STBUFSEG Position    */
#define USBD_STBUFSEG_STBUFSEG_Msk       (0x3ful << USBD_STBUFSEG_STBUFSEG_Pos)            /*!< USBD_T::STBUFSEG: STBUFSEG Mask        */

#define USBD_EPSTS0_EPSTS5_Pos           (20)                                              /*!< USBD_T::EPSTS0: EPSTS5 Position        */
#define USBD_EPSTS0_EPSTS5_Msk           (0xful << USBD_EPSTS0_EPSTS5_Pos)                 /*!< USBD_T::EPSTS0: EPSTS5 Mask            */

#define USBD_EPSTS0_EPSTS6_Pos           (24)                                              /*!< USBD_T::EPSTS0: EPSTS6 Position        */
#define USBD_EPSTS0_EPSTS6_Msk           (0xful << USBD_EPSTS0_EPSTS6_Pos)                 /*!< USBD_T::EPSTS0: EPSTS6 Mask            */

#define USBD_EPSTS0_EPSTS7_Pos           (28)                                              /*!< USBD_T::EPSTS0: EPSTS7 Position        */
#define USBD_EPSTS0_EPSTS7_Msk           (0xful << USBD_EPSTS0_EPSTS7_Pos)                 /*!< USBD_T::EPSTS0: EPSTS7 Mask            */

#define USBD_EPSTS1_EPSTS8_Pos           (0)                                               /*!< USBD_T::EPSTS1: EPSTS8 Position        */
#define USBD_EPSTS1_EPSTS8_Msk           (0xful << USBD_EPSTS1_EPSTS8_Pos)                 /*!< USBD_T::EPSTS1: EPSTS8 Mask            */

#define USBD_EPSTS1_EPSTS9_Pos           (4)                                               /*!< USBD_T::EPSTS1: EPSTS9 Position        */
#define USBD_EPSTS1_EPSTS9_Msk           (0xful << USBD_EPSTS1_EPSTS9_Pos)                 /*!< USBD_T::EPSTS1: EPSTS9 Mask            */

#define USBD_EPSTS1_EPSTS10_Pos          (8)                                               /*!< USBD_T::EPSTS1: EPSTS10 Position       */
#define USBD_EPSTS1_EPSTS10_Msk          (0xful << USBD_EPSTS1_EPSTS10_Pos)                /*!< USBD_T::EPSTS1: EPSTS10 Mask           */

#define USBD_EPSTS1_EPSTS11_Pos          (12)                                              /*!< USBD_T::EPSTS1: EPSTS11 Position       */
#define USBD_EPSTS1_EPSTS11_Msk          (0xful << USBD_EPSTS1_EPSTS11_Pos)                /*!< USBD_T::EPSTS1: EPSTS11 Mask           */

#define USBD_LPMATTR_LPMLINKSTS_Pos      (0)                                               /*!< USBD_T::LPMATTR: LPMLINKSTS Position   */
#define USBD_LPMATTR_LPMLINKSTS_Msk      (0xful << USBD_LPMATTR_LPMLINKSTS_Pos)            /*!< USBD_T::LPMATTR: LPMLINKSTS Mask       */

#define USBD_LPMATTR_LPMBESL_Pos         (4)                                               /*!< USBD_T::LPMATTR: LPMBESL Position      */
#define USBD_LPMATTR_LPMBESL_Msk         (0xful << USBD_LPMATTR_LPMBESL_Pos)               /*!< USBD_T::LPMATTR: LPMBESL Mask          */

#define USBD_LPMATTR_LPMRWAKUP_Pos       (8)                                               /*!< USBD_T::LPMATTR: LPMRWAKUP Position    */
#define USBD_LPMATTR_LPMRWAKUP_Msk       (0x1ul << USBD_LPMATTR_LPMRWAKUP_Pos)             /*!< USBD_T::LPMATTR: LPMRWAKUP Mask        */

#define USBD_FN_FN_Pos                   (0)                                               /*!< USBD_T::FN: FN Position                */
#define USBD_FN_FN_Msk                   (0x7fful << USBD_FN_FN_Pos)                       /*!< USBD_T::FN: FN Mask                    */

#define USBD_SE0_SE0_Pos                 (0)                                               /*!< USBD_T::SE0: SE0 Position              */
#define USBD_SE0_SE0_Msk                 (0x1ul << USBD_SE0_SE0_Pos)                       /*!< USBD_T::SE0: SE0 Mask                  */

#define USBD_BIST_BISTEN_Pos             (0)                                               /*!< USBD_T::BIST: BISTEN Position          */
#define USBD_BIST_BISTEN_Msk             (0x1ul << USBD_BIST_BISTEN_Pos)                   /*!< USBD_T::BIST: BISTEN Mask              */

#define USBD_BIST_FINISH_Pos             (1)                                               /*!< USBD_T::BIST: FINISH Position          */
#define USBD_BIST_FINISH_Msk             (0x1ul << USBD_BIST_FINISH_Pos)                   /*!< USBD_T::BIST: FINISH Mask              */

#define USBD_BIST_BISTFAIL_Pos           (2)                                               /*!< USBD_T::BIST: BISTFAIL Position        */
#define USBD_BIST_BISTFAIL_Msk           (0x1ul << USBD_BIST_BISTFAIL_Pos)                 /*!< USBD_T::BIST: BISTFAIL Mask            */

#define USBD_PDMA_PDMARW_Pos             (0)                                               /*!< USBD_T::PDMA: PDMARW Position          */
#define USBD_PDMA_PDMARW_Msk             (0x1ul << USBD_PDMA_PDMARW_Pos)                   /*!< USBD_T::PDMA: PDMARW Mask              */

#define USBD_PDMA_PDMAEN_Pos             (1)                                               /*!< USBD_T::PDMA: PDMAEN Position          */
#define USBD_PDMA_PDMAEN_Msk             (0x1ul << USBD_PDMA_PDMAEN_Pos)                   /*!< USBD_T::PDMA: PDMAEN Mask              */

#define USBD_TEST_VDDIS_Pos              (0)                                               /*!< USBD_T::TEST: VDDIS Position           */
#define USBD_TEST_VDDIS_Msk              (0x1ul << USBD_TEST_VDDIS_Pos)                    /*!< USBD_T::TEST: VDDIS Mask               */

#define USBD_BUFSEG0_BUFSEG_Pos          (3)                                               /*!< USBD_T::BUFSEG0: BUFSEG Position       */
#define USBD_BUFSEG0_BUFSEG_Msk          (0x3ful << USBD_BUFSEG0_BUFSEG_Pos)               /*!< USBD_T::BUFSEG0: BUFSEG Mask           */

#define USBD_MXPLD0_MXPLD_Pos            (0)                                               /*!< USBD_T::MXPLD0: MXPLD Position         */
#define USBD_MXPLD0_MXPLD_Msk            (0x1fful << USBD_MXPLD0_MXPLD_Pos)                /*!< USBD_T::MXPLD0: MXPLD Mask             */

#define USBD_CFG0_EPNUM_Pos              (0)                                               /*!< USBD_T::CFG0: EPNUM Position           */
#define USBD_CFG0_EPNUM_Msk              (0xful << USBD_CFG0_EPNUM_Pos)                    /*!< USBD_T::CFG0: EPNUM Mask               */

#define USBD_CFG0_ISOCH_Pos              (4)                                               /*!< USBD_T::CFG0: ISOCH Position           */
#define USBD_CFG0_ISOCH_Msk              (0x1ul << USBD_CFG0_ISOCH_Pos)                    /*!< USBD_T::CFG0: ISOCH Mask               */

#define USBD_CFG0_STATE_Pos              (5)                                               /*!< USBD_T::CFG0: STATE Position           */
#define USBD_CFG0_STATE_Msk              (0x3ul << USBD_CFG0_STATE_Pos)                    /*!< USBD_T::CFG0: STATE Mask               */

#define USBD_CFG0_DSQSYNC_Pos            (7)                                               /*!< USBD_T::CFG0: DSQSYNC Position         */
#define USBD_CFG0_DSQSYNC_Msk            (0x1ul << USBD_CFG0_DSQSYNC_Pos)                  /*!< USBD_T::CFG0: DSQSYNC Mask             */

#define USBD_CFG0_CSTALL_Pos             (9)                                               /*!< USBD_T::CFG0: CSTALL Position          */
#define USBD_CFG0_CSTALL_Msk             (0x1ul << USBD_CFG0_CSTALL_Pos)                   /*!< USBD_T::CFG0: CSTALL Mask              */

#define USBD_CFGP0_CLRRDY_Pos            (0)                                               /*!< USBD_T::CFGP0: CLRRDY Position         */
#define USBD_CFGP0_CLRRDY_Msk            (0x1ul << USBD_CFGP0_CLRRDY_Pos)                  /*!< USBD_T::CFGP0: CLRRDY Mask             */

#define USBD_CFGP0_SSTALL_Pos            (1)                                               /*!< USBD_T::CFGP0: SSTALL Position         */
#define USBD_CFGP0_SSTALL_Msk            (0x1ul << USBD_CFGP0_SSTALL_Pos)                  /*!< USBD_T::CFGP0: SSTALL Mask             */

#define USBD_BUFSEG1_BUFSEG_Pos          (3)                                               /*!< USBD_T::BUFSEG1: BUFSEG Position       */
#define USBD_BUFSEG1_BUFSEG_Msk          (0x3ful << USBD_BUFSEG1_BUFSEG_Pos)               /*!< USBD_T::BUFSEG1: BUFSEG Mask           */

#define USBD_MXPLD1_MXPLD_Pos            (0)                                               /*!< USBD_T::MXPLD1: MXPLD Position         */
#define USBD_MXPLD1_MXPLD_Msk            (0x1fful << USBD_MXPLD1_MXPLD_Pos)                /*!< USBD_T::MXPLD1: MXPLD Mask             */

#define USBD_CFG1_EPNUM_Pos              (0)                                               /*!< USBD_T::CFG1: EPNUM Position           */
#define USBD_CFG1_EPNUM_Msk              (0xful << USBD_CFG1_EPNUM_Pos)                    /*!< USBD_T::CFG1: EPNUM Mask               */

#define USBD_CFG1_ISOCH_Pos              (4)                                               /*!< USBD_T::CFG1: ISOCH Position           */
#define USBD_CFG1_ISOCH_Msk              (0x1ul << USBD_CFG1_ISOCH_Pos)                    /*!< USBD_T::CFG1: ISOCH Mask               */

#define USBD_CFG1_STATE_Pos              (5)                                               /*!< USBD_T::CFG1: STATE Position           */
#define USBD_CFG1_STATE_Msk              (0x3ul << USBD_CFG1_STATE_Pos)                    /*!< USBD_T::CFG1: STATE Mask               */

#define USBD_CFG1_DSQSYNC_Pos            (7)                                               /*!< USBD_T::CFG1: DSQSYNC Position         */
#define USBD_CFG1_DSQSYNC_Msk            (0x1ul << USBD_CFG1_DSQSYNC_Pos)                  /*!< USBD_T::CFG1: DSQSYNC Mask             */

#define USBD_CFG1_CSTALL_Pos             (9)                                               /*!< USBD_T::CFG1: CSTALL Position          */
#define USBD_CFG1_CSTALL_Msk             (0x1ul << USBD_CFG1_CSTALL_Pos)                   /*!< USBD_T::CFG1: CSTALL Mask              */

#define USBD_CFGP1_CLRRDY_Pos            (0)                                               /*!< USBD_T::CFGP1: CLRRDY Position         */
#define USBD_CFGP1_CLRRDY_Msk            (0x1ul << USBD_CFGP1_CLRRDY_Pos)                  /*!< USBD_T::CFGP1: CLRRDY Mask             */

#define USBD_CFGP1_SSTALL_Pos            (1)                                               /*!< USBD_T::CFGP1: SSTALL Position         */
#define USBD_CFGP1_SSTALL_Msk            (0x1ul << USBD_CFGP1_SSTALL_Pos)                  /*!< USBD_T::CFGP1: SSTALL Mask             */

#define USBD_BUFSEG2_BUFSEG_Pos          (3)                                               /*!< USBD_T::BUFSEG2: BUFSEG Position       */
#define USBD_BUFSEG2_BUFSEG_Msk          (0x3ful << USBD_BUFSEG2_BUFSEG_Pos)               /*!< USBD_T::BUFSEG2: BUFSEG Mask           */

#define USBD_MXPLD2_MXPLD_Pos            (0)                                               /*!< USBD_T::MXPLD2: MXPLD Position         */
#define USBD_MXPLD2_MXPLD_Msk            (0x1fful << USBD_MXPLD2_MXPLD_Pos)                /*!< USBD_T::MXPLD2: MXPLD Mask             */

#define USBD_CFG2_EPNUM_Pos              (0)                                               /*!< USBD_T::CFG2: EPNUM Position           */
#define USBD_CFG2_EPNUM_Msk              (0xful << USBD_CFG2_EPNUM_Pos)                    /*!< USBD_T::CFG2: EPNUM Mask               */

#define USBD_CFG2_ISOCH_Pos              (4)                                               /*!< USBD_T::CFG2: ISOCH Position           */
#define USBD_CFG2_ISOCH_Msk              (0x1ul << USBD_CFG2_ISOCH_Pos)                    /*!< USBD_T::CFG2: ISOCH Mask               */

#define USBD_CFG2_STATE_Pos              (5)                                               /*!< USBD_T::CFG2: STATE Position           */
#define USBD_CFG2_STATE_Msk              (0x3ul << USBD_CFG2_STATE_Pos)                    /*!< USBD_T::CFG2: STATE Mask               */

#define USBD_CFG2_DSQSYNC_Pos            (7)                                               /*!< USBD_T::CFG2: DSQSYNC Position         */
#define USBD_CFG2_DSQSYNC_Msk            (0x1ul << USBD_CFG2_DSQSYNC_Pos)                  /*!< USBD_T::CFG2: DSQSYNC Mask             */

#define USBD_CFG2_CSTALL_Pos             (9)                                               /*!< USBD_T::CFG2: CSTALL Position          */
#define USBD_CFG2_CSTALL_Msk             (0x1ul << USBD_CFG2_CSTALL_Pos)                   /*!< USBD_T::CFG2: CSTALL Mask              */

#define USBD_CFGP2_CLRRDY_Pos            (0)                                               /*!< USBD_T::CFGP2: CLRRDY Position         */
#define USBD_CFGP2_CLRRDY_Msk            (0x1ul << USBD_CFGP2_CLRRDY_Pos)                  /*!< USBD_T::CFGP2: CLRRDY Mask             */

#define USBD_CFGP2_SSTALL_Pos            (1)                                               /*!< USBD_T::CFGP2: SSTALL Position         */
#define USBD_CFGP2_SSTALL_Msk            (0x1ul << USBD_CFGP2_SSTALL_Pos)                  /*!< USBD_T::CFGP2: SSTALL Mask             */

#define USBD_BUFSEG3_BUFSEG_Pos          (3)                                               /*!< USBD_T::BUFSEG3: BUFSEG Position       */
#define USBD_BUFSEG3_BUFSEG_Msk          (0x3ful << USBD_BUFSEG3_BUFSEG_Pos)               /*!< USBD_T::BUFSEG3: BUFSEG Mask           */

#define USBD_MXPLD3_MXPLD_Pos            (0)                                               /*!< USBD_T::MXPLD3: MXPLD Position         */
#define USBD_MXPLD3_MXPLD_Msk            (0x1fful << USBD_MXPLD3_MXPLD_Pos)                /*!< USBD_T::MXPLD3: MXPLD Mask             */

#define USBD_CFG3_EPNUM_Pos              (0)                                               /*!< USBD_T::CFG3: EPNUM Position           */
#define USBD_CFG3_EPNUM_Msk              (0xful << USBD_CFG3_EPNUM_Pos)                    /*!< USBD_T::CFG3: EPNUM Mask               */

#define USBD_CFG3_ISOCH_Pos              (4)                                               /*!< USBD_T::CFG3: ISOCH Position           */
#define USBD_CFG3_ISOCH_Msk              (0x1ul << USBD_CFG3_ISOCH_Pos)                    /*!< USBD_T::CFG3: ISOCH Mask               */

#define USBD_CFG3_STATE_Pos              (5)                                               /*!< USBD_T::CFG3: STATE Position           */
#define USBD_CFG3_STATE_Msk              (0x3ul << USBD_CFG3_STATE_Pos)                    /*!< USBD_T::CFG3: STATE Mask               */

#define USBD_CFG3_DSQSYNC_Pos            (7)                                               /*!< USBD_T::CFG3: DSQSYNC Position         */
#define USBD_CFG3_DSQSYNC_Msk            (0x1ul << USBD_CFG3_DSQSYNC_Pos)                  /*!< USBD_T::CFG3: DSQSYNC Mask             */

#define USBD_CFG3_CSTALL_Pos             (9)                                               /*!< USBD_T::CFG3: CSTALL Position          */
#define USBD_CFG3_CSTALL_Msk             (0x1ul << USBD_CFG3_CSTALL_Pos)                   /*!< USBD_T::CFG3: CSTALL Mask              */

#define USBD_CFGP3_CLRRDY_Pos            (0)                                               /*!< USBD_T::CFGP3: CLRRDY Position         */
#define USBD_CFGP3_CLRRDY_Msk            (0x1ul << USBD_CFGP3_CLRRDY_Pos)                  /*!< USBD_T::CFGP3: CLRRDY Mask             */

#define USBD_CFGP3_SSTALL_Pos            (1)                                               /*!< USBD_T::CFGP3: SSTALL Position         */
#define USBD_CFGP3_SSTALL_Msk            (0x1ul << USBD_CFGP3_SSTALL_Pos)                  /*!< USBD_T::CFGP3: SSTALL Mask             */

#define USBD_BUFSEG4_BUFSEG_Pos          (3)                                               /*!< USBD_T::BUFSEG4: BUFSEG Position       */
#define USBD_BUFSEG4_BUFSEG_Msk          (0x3ful << USBD_BUFSEG4_BUFSEG_Pos)               /*!< USBD_T::BUFSEG4: BUFSEG Mask           */

#define USBD_MXPLD4_MXPLD_Pos            (0)                                               /*!< USBD_T::MXPLD4: MXPLD Position         */
#define USBD_MXPLD4_MXPLD_Msk            (0x1fful << USBD_MXPLD4_MXPLD_Pos)                /*!< USBD_T::MXPLD4: MXPLD Mask             */

#define USBD_CFG4_EPNUM_Pos              (0)                                               /*!< USBD_T::CFG4: EPNUM Position           */
#define USBD_CFG4_EPNUM_Msk              (0xful << USBD_CFG4_EPNUM_Pos)                    /*!< USBD_T::CFG4: EPNUM Mask               */

#define USBD_CFG4_ISOCH_Pos              (4)                                               /*!< USBD_T::CFG4: ISOCH Position           */
#define USBD_CFG4_ISOCH_Msk              (0x1ul << USBD_CFG4_ISOCH_Pos)                    /*!< USBD_T::CFG4: ISOCH Mask               */

#define USBD_CFG4_STATE_Pos              (5)                                               /*!< USBD_T::CFG4: STATE Position           */
#define USBD_CFG4_STATE_Msk              (0x3ul << USBD_CFG4_STATE_Pos)                    /*!< USBD_T::CFG4: STATE Mask               */

#define USBD_CFG4_DSQSYNC_Pos            (7)                                               /*!< USBD_T::CFG4: DSQSYNC Position         */
#define USBD_CFG4_DSQSYNC_Msk            (0x1ul << USBD_CFG4_DSQSYNC_Pos)                  /*!< USBD_T::CFG4: DSQSYNC Mask             */

#define USBD_CFG4_CSTALL_Pos             (9)                                               /*!< USBD_T::CFG4: CSTALL Position          */
#define USBD_CFG4_CSTALL_Msk             (0x1ul << USBD_CFG4_CSTALL_Pos)                   /*!< USBD_T::CFG4: CSTALL Mask              */

#define USBD_CFGP4_CLRRDY_Pos            (0)                                               /*!< USBD_T::CFGP4: CLRRDY Position         */
#define USBD_CFGP4_CLRRDY_Msk            (0x1ul << USBD_CFGP4_CLRRDY_Pos)                  /*!< USBD_T::CFGP4: CLRRDY Mask             */

#define USBD_CFGP4_SSTALL_Pos            (1)                                               /*!< USBD_T::CFGP4: SSTALL Position         */
#define USBD_CFGP4_SSTALL_Msk            (0x1ul << USBD_CFGP4_SSTALL_Pos)                  /*!< USBD_T::CFGP4: SSTALL Mask             */

#define USBD_BUFSEG5_BUFSEG_Pos          (3)                                               /*!< USBD_T::BUFSEG5: BUFSEG Position       */
#define USBD_BUFSEG5_BUFSEG_Msk          (0x3ful << USBD_BUFSEG5_BUFSEG_Pos)               /*!< USBD_T::BUFSEG5: BUFSEG Mask           */

#define USBD_MXPLD5_MXPLD_Pos            (0)                                               /*!< USBD_T::MXPLD5: MXPLD Position         */
#define USBD_MXPLD5_MXPLD_Msk            (0x1fful << USBD_MXPLD5_MXPLD_Pos)                /*!< USBD_T::MXPLD5: MXPLD Mask             */

#define USBD_CFG5_EPNUM_Pos              (0)                                               /*!< USBD_T::CFG5: EPNUM Position           */
#define USBD_CFG5_EPNUM_Msk              (0xful << USBD_CFG5_EPNUM_Pos)                    /*!< USBD_T::CFG5: EPNUM Mask               */

#define USBD_CFG5_ISOCH_Pos              (4)                                               /*!< USBD_T::CFG5: ISOCH Position           */
#define USBD_CFG5_ISOCH_Msk              (0x1ul << USBD_CFG5_ISOCH_Pos)                    /*!< USBD_T::CFG5: ISOCH Mask               */

#define USBD_CFG5_STATE_Pos              (5)                                               /*!< USBD_T::CFG5: STATE Position           */
#define USBD_CFG5_STATE_Msk              (0x3ul << USBD_CFG5_STATE_Pos)                    /*!< USBD_T::CFG5: STATE Mask               */

#define USBD_CFG5_DSQSYNC_Pos            (7)                                               /*!< USBD_T::CFG5: DSQSYNC Position         */
#define USBD_CFG5_DSQSYNC_Msk            (0x1ul << USBD_CFG5_DSQSYNC_Pos)                  /*!< USBD_T::CFG5: DSQSYNC Mask             */

#define USBD_CFG5_CSTALL_Pos             (9)                                               /*!< USBD_T::CFG5: CSTALL Position          */
#define USBD_CFG5_CSTALL_Msk             (0x1ul << USBD_CFG5_CSTALL_Pos)                   /*!< USBD_T::CFG5: CSTALL Mask              */

#define USBD_CFGP5_CLRRDY_Pos            (0)                                               /*!< USBD_T::CFGP5: CLRRDY Position         */
#define USBD_CFGP5_CLRRDY_Msk            (0x1ul << USBD_CFGP5_CLRRDY_Pos)                  /*!< USBD_T::CFGP5: CLRRDY Mask             */

#define USBD_CFGP5_SSTALL_Pos            (1)                                               /*!< USBD_T::CFGP5: SSTALL Position         */
#define USBD_CFGP5_SSTALL_Msk            (0x1ul << USBD_CFGP5_SSTALL_Pos)                  /*!< USBD_T::CFGP5: SSTALL Mask             */

#define USBD_BUFSEG6_BUFSEG_Pos          (3)                                               /*!< USBD_T::BUFSEG6: BUFSEG Position       */
#define USBD_BUFSEG6_BUFSEG_Msk          (0x3ful << USBD_BUFSEG6_BUFSEG_Pos)               /*!< USBD_T::BUFSEG6: BUFSEG Mask           */

#define USBD_MXPLD6_MXPLD_Pos            (0)                                               /*!< USBD_T::MXPLD6: MXPLD Position         */
#define USBD_MXPLD6_MXPLD_Msk            (0x1fful << USBD_MXPLD6_MXPLD_Pos)                /*!< USBD_T::MXPLD6: MXPLD Mask             */

#define USBD_CFG6_EPNUM_Pos              (0)                                               /*!< USBD_T::CFG6: EPNUM Position           */
#define USBD_CFG6_EPNUM_Msk              (0xful << USBD_CFG6_EPNUM_Pos)                    /*!< USBD_T::CFG6: EPNUM Mask               */

#define USBD_CFG6_ISOCH_Pos              (4)                                               /*!< USBD_T::CFG6: ISOCH Position           */
#define USBD_CFG6_ISOCH_Msk              (0x1ul << USBD_CFG6_ISOCH_Pos)                    /*!< USBD_T::CFG6: ISOCH Mask               */

#define USBD_CFG6_STATE_Pos              (5)                                               /*!< USBD_T::CFG6: STATE Position           */
#define USBD_CFG6_STATE_Msk              (0x3ul << USBD_CFG6_STATE_Pos)                    /*!< USBD_T::CFG6: STATE Mask               */

#define USBD_CFG6_DSQSYNC_Pos            (7)                                               /*!< USBD_T::CFG6: DSQSYNC Position         */
#define USBD_CFG6_DSQSYNC_Msk            (0x1ul << USBD_CFG6_DSQSYNC_Pos)                  /*!< USBD_T::CFG6: DSQSYNC Mask             */

#define USBD_CFG6_CSTALL_Pos             (9)                                               /*!< USBD_T::CFG6: CSTALL Position          */
#define USBD_CFG6_CSTALL_Msk             (0x1ul << USBD_CFG6_CSTALL_Pos)                   /*!< USBD_T::CFG6: CSTALL Mask              */

#define USBD_CFGP6_CLRRDY_Pos            (0)                                               /*!< USBD_T::CFGP6: CLRRDY Position         */
#define USBD_CFGP6_CLRRDY_Msk            (0x1ul << USBD_CFGP6_CLRRDY_Pos)                  /*!< USBD_T::CFGP6: CLRRDY Mask             */

#define USBD_CFGP6_SSTALL_Pos            (1)                                               /*!< USBD_T::CFGP6: SSTALL Position         */
#define USBD_CFGP6_SSTALL_Msk            (0x1ul << USBD_CFGP6_SSTALL_Pos)                  /*!< USBD_T::CFGP6: SSTALL Mask             */

#define USBD_BUFSEG7_BUFSEG_Pos          (3)                                               /*!< USBD_T::BUFSEG7: BUFSEG Position       */
#define USBD_BUFSEG7_BUFSEG_Msk          (0x3ful << USBD_BUFSEG7_BUFSEG_Pos)               /*!< USBD_T::BUFSEG7: BUFSEG Mask           */

#define USBD_MXPLD7_MXPLD_Pos            (0)                                               /*!< USBD_T::MXPLD7: MXPLD Position         */
#define USBD_MXPLD7_MXPLD_Msk            (0x1fful << USBD_MXPLD7_MXPLD_Pos)                /*!< USBD_T::MXPLD7: MXPLD Mask             */

#define USBD_CFG7_EPNUM_Pos              (0)                                               /*!< USBD_T::CFG7: EPNUM Position           */
#define USBD_CFG7_EPNUM_Msk              (0xful << USBD_CFG7_EPNUM_Pos)                    /*!< USBD_T::CFG7: EPNUM Mask               */

#define USBD_CFG7_ISOCH_Pos              (4)                                               /*!< USBD_T::CFG7: ISOCH Position           */
#define USBD_CFG7_ISOCH_Msk              (0x1ul << USBD_CFG7_ISOCH_Pos)                    /*!< USBD_T::CFG7: ISOCH Mask               */

#define USBD_CFG7_STATE_Pos              (5)                                               /*!< USBD_T::CFG7: STATE Position           */
#define USBD_CFG7_STATE_Msk              (0x3ul << USBD_CFG7_STATE_Pos)                    /*!< USBD_T::CFG7: STATE Mask               */

#define USBD_CFG7_DSQSYNC_Pos            (7)                                               /*!< USBD_T::CFG7: DSQSYNC Position         */
#define USBD_CFG7_DSQSYNC_Msk            (0x1ul << USBD_CFG7_DSQSYNC_Pos)                  /*!< USBD_T::CFG7: DSQSYNC Mask             */

#define USBD_CFG7_CSTALL_Pos             (9)                                               /*!< USBD_T::CFG7: CSTALL Position          */
#define USBD_CFG7_CSTALL_Msk             (0x1ul << USBD_CFG7_CSTALL_Pos)                   /*!< USBD_T::CFG7: CSTALL Mask              */

#define USBD_CFGP7_CLRRDY_Pos            (0)                                               /*!< USBD_T::CFGP7: CLRRDY Position         */
#define USBD_CFGP7_CLRRDY_Msk            (0x1ul << USBD_CFGP7_CLRRDY_Pos)                  /*!< USBD_T::CFGP7: CLRRDY Mask             */

#define USBD_CFGP7_SSTALL_Pos            (1)                                               /*!< USBD_T::CFGP7: SSTALL Position         */
#define USBD_CFGP7_SSTALL_Msk            (0x1ul << USBD_CFGP7_SSTALL_Pos)                  /*!< USBD_T::CFGP7: SSTALL Mask             */

#define USBD_BUFSEG8_BUFSEG_Pos          (3)                                               /*!< USBD_T::BUFSEG8: BUFSEG Position       */
#define USBD_BUFSEG8_BUFSEG_Msk          (0x3ful << USBD_BUFSEG8_BUFSEG_Pos)               /*!< USBD_T::BUFSEG8: BUFSEG Mask           */

#define USBD_MXPLD8_MXPLD_Pos            (0)                                               /*!< USBD_T::MXPLD8: MXPLD Position         */
#define USBD_MXPLD8_MXPLD_Msk            (0x1fful << USBD_MXPLD8_MXPLD_Pos)                /*!< USBD_T::MXPLD8: MXPLD Mask             */

#define USBD_CFG8_EPNUM_Pos              (0)                                               /*!< USBD_T::CFG8: EPNUM Position           */
#define USBD_CFG8_EPNUM_Msk              (0xful << USBD_CFG8_EPNUM_Pos)                    /*!< USBD_T::CFG8: EPNUM Mask               */

#define USBD_CFG8_ISOCH_Pos              (4)                                               /*!< USBD_T::CFG8: ISOCH Position           */
#define USBD_CFG8_ISOCH_Msk              (0x1ul << USBD_CFG8_ISOCH_Pos)                    /*!< USBD_T::CFG8: ISOCH Mask               */

#define USBD_CFG8_STATE_Pos              (5)                                               /*!< USBD_T::CFG8: STATE Position           */
#define USBD_CFG8_STATE_Msk              (0x3ul << USBD_CFG8_STATE_Pos)                    /*!< USBD_T::CFG8: STATE Mask               */

#define USBD_CFG8_DSQSYNC_Pos            (7)                                               /*!< USBD_T::CFG8: DSQSYNC Position         */
#define USBD_CFG8_DSQSYNC_Msk            (0x1ul << USBD_CFG8_DSQSYNC_Pos)                  /*!< USBD_T::CFG8: DSQSYNC Mask             */

#define USBD_CFG8_CSTALL_Pos             (9)                                               /*!< USBD_T::CFG8: CSTALL Position          */
#define USBD_CFG8_CSTALL_Msk             (0x1ul << USBD_CFG8_CSTALL_Pos)                   /*!< USBD_T::CFG8: CSTALL Mask              */

#define USBD_CFGP8_CLRRDY_Pos            (0)                                               /*!< USBD_T::CFGP8: CLRRDY Position         */
#define USBD_CFGP8_CLRRDY_Msk            (0x1ul << USBD_CFGP8_CLRRDY_Pos)                  /*!< USBD_T::CFGP8: CLRRDY Mask             */

#define USBD_CFGP8_SSTALL_Pos            (1)                                               /*!< USBD_T::CFGP8: SSTALL Position         */
#define USBD_CFGP8_SSTALL_Msk            (0x1ul << USBD_CFGP8_SSTALL_Pos)                  /*!< USBD_T::CFGP8: SSTALL Mask             */

#define USBD_BUFSEG9_BUFSEG_Pos          (3)                                               /*!< USBD_T::BUFSEG9: BUFSEG Position       */
#define USBD_BUFSEG9_BUFSEG_Msk          (0x3ful << USBD_BUFSEG9_BUFSEG_Pos)               /*!< USBD_T::BUFSEG9: BUFSEG Mask           */

#define USBD_MXPLD9_MXPLD_Pos            (0)                                               /*!< USBD_T::MXPLD9: MXPLD Position         */
#define USBD_MXPLD9_MXPLD_Msk            (0x1fful << USBD_MXPLD9_MXPLD_Pos)                /*!< USBD_T::MXPLD9: MXPLD Mask             */

#define USBD_CFG9_EPNUM_Pos              (0)                                               /*!< USBD_T::CFG9: EPNUM Position           */
#define USBD_CFG9_EPNUM_Msk              (0xful << USBD_CFG9_EPNUM_Pos)                    /*!< USBD_T::CFG9: EPNUM Mask               */

#define USBD_CFG9_ISOCH_Pos              (4)                                               /*!< USBD_T::CFG9: ISOCH Position           */
#define USBD_CFG9_ISOCH_Msk              (0x1ul << USBD_CFG9_ISOCH_Pos)                    /*!< USBD_T::CFG9: ISOCH Mask               */

#define USBD_CFG9_STATE_Pos              (5)                                               /*!< USBD_T::CFG9: STATE Position           */
#define USBD_CFG9_STATE_Msk              (0x3ul << USBD_CFG9_STATE_Pos)                    /*!< USBD_T::CFG9: STATE Mask               */

#define USBD_CFG9_DSQSYNC_Pos            (7)                                               /*!< USBD_T::CFG9: DSQSYNC Position         */
#define USBD_CFG9_DSQSYNC_Msk            (0x1ul << USBD_CFG9_DSQSYNC_Pos)                  /*!< USBD_T::CFG9: DSQSYNC Mask             */

#define USBD_CFG9_CSTALL_Pos             (9)                                               /*!< USBD_T::CFG9: CSTALL Position          */
#define USBD_CFG9_CSTALL_Msk             (0x1ul << USBD_CFG9_CSTALL_Pos)                   /*!< USBD_T::CFG9: CSTALL Mask              */

#define USBD_CFGP9_CLRRDY_Pos            (0)                                               /*!< USBD_T::CFGP9: CLRRDY Position         */
#define USBD_CFGP9_CLRRDY_Msk            (0x1ul << USBD_CFGP9_CLRRDY_Pos)                  /*!< USBD_T::CFGP9: CLRRDY Mask             */

#define USBD_CFGP9_SSTALL_Pos            (1)                                               /*!< USBD_T::CFGP9: SSTALL Position         */
#define USBD_CFGP9_SSTALL_Msk            (0x1ul << USBD_CFGP9_SSTALL_Pos)                  /*!< USBD_T::CFGP9: SSTALL Mask             */

#define USBD_BUFSEG10_BUFSEG_Pos         (3)                                               /*!< USBD_T::BUFSEG10: BUFSEG Position      */
#define USBD_BUFSEG10_BUFSEG_Msk         (0x3ful << USBD_BUFSEG10_BUFSEG_Pos)              /*!< USBD_T::BUFSEG10: BUFSEG Mask          */

#define USBD_MXPLD10_MXPLD_Pos           (0)                                               /*!< USBD_T::MXPLD10: MXPLD Position        */
#define USBD_MXPLD10_MXPLD_Msk           (0x1fful << USBD_MXPLD10_MXPLD_Pos)               /*!< USBD_T::MXPLD10: MXPLD Mask            */

#define USBD_CFG10_EPNUM_Pos             (0)                                               /*!< USBD_T::CFG10: EPNUM Position          */
#define USBD_CFG10_EPNUM_Msk             (0xful << USBD_CFG10_EPNUM_Pos)                   /*!< USBD_T::CFG10: EPNUM Mask              */

#define USBD_CFG10_ISOCH_Pos             (4)                                               /*!< USBD_T::CFG10: ISOCH Position          */
#define USBD_CFG10_ISOCH_Msk             (0x1ul << USBD_CFG10_ISOCH_Pos)                   /*!< USBD_T::CFG10: ISOCH Mask              */

#define USBD_CFG10_STATE_Pos             (5)                                               /*!< USBD_T::CFG10: STATE Position          */
#define USBD_CFG10_STATE_Msk             (0x3ul << USBD_CFG10_STATE_Pos)                   /*!< USBD_T::CFG10: STATE Mask              */

#define USBD_CFG10_DSQSYNC_Pos           (7)                                               /*!< USBD_T::CFG10: DSQSYNC Position        */
#define USBD_CFG10_DSQSYNC_Msk           (0x1ul << USBD_CFG10_DSQSYNC_Pos)                 /*!< USBD_T::CFG10: DSQSYNC Mask            */

#define USBD_CFG10_CSTALL_Pos            (9)                                               /*!< USBD_T::CFG10: CSTALL Position         */
#define USBD_CFG10_CSTALL_Msk            (0x1ul << USBD_CFG10_CSTALL_Pos)                  /*!< USBD_T::CFG10: CSTALL Mask             */

#define USBD_CFGP10_CLRRDY_Pos           (0)                                               /*!< USBD_T::CFGP10: CLRRDY Position        */
#define USBD_CFGP10_CLRRDY_Msk           (0x1ul << USBD_CFGP10_CLRRDY_Pos)                 /*!< USBD_T::CFGP10: CLRRDY Mask            */

#define USBD_CFGP10_SSTALL_Pos           (1)                                               /*!< USBD_T::CFGP10: SSTALL Position        */
#define USBD_CFGP10_SSTALL_Msk           (0x1ul << USBD_CFGP10_SSTALL_Pos)                 /*!< USBD_T::CFGP10: SSTALL Mask            */

#define USBD_BUFSEG11_BUFSEG_Pos         (3)                                               /*!< USBD_T::BUFSEG11: BUFSEG Position      */
#define USBD_BUFSEG11_BUFSEG_Msk         (0x3ful << USBD_BUFSEG11_BUFSEG_Pos)              /*!< USBD_T::BUFSEG11: BUFSEG Mask          */

#define USBD_MXPLD11_MXPLD_Pos           (0)                                               /*!< USBD_T::MXPLD11: MXPLD Position        */
#define USBD_MXPLD11_MXPLD_Msk           (0x1fful << USBD_MXPLD11_MXPLD_Pos)               /*!< USBD_T::MXPLD11: MXPLD Mask            */

#define USBD_CFG11_EPNUM_Pos             (0)                                               /*!< USBD_T::CFG11: EPNUM Position          */
#define USBD_CFG11_EPNUM_Msk             (0xful << USBD_CFG11_EPNUM_Pos)                   /*!< USBD_T::CFG11: EPNUM Mask              */

#define USBD_CFG11_ISOCH_Pos             (4)                                               /*!< USBD_T::CFG11: ISOCH Position          */
#define USBD_CFG11_ISOCH_Msk             (0x1ul << USBD_CFG11_ISOCH_Pos)                   /*!< USBD_T::CFG11: ISOCH Mask              */

#define USBD_CFG11_STATE_Pos             (5)                                               /*!< USBD_T::CFG11: STATE Position          */
#define USBD_CFG11_STATE_Msk             (0x3ul << USBD_CFG11_STATE_Pos)                   /*!< USBD_T::CFG11: STATE Mask              */

#define USBD_CFG11_DSQSYNC_Pos           (7)                                               /*!< USBD_T::CFG11: DSQSYNC Position        */
#define USBD_CFG11_DSQSYNC_Msk           (0x1ul << USBD_CFG11_DSQSYNC_Pos)                 /*!< USBD_T::CFG11: DSQSYNC Mask            */

#define USBD_CFG11_CSTALL_Pos            (9)                                               /*!< USBD_T::CFG11: CSTALL Position         */
#define USBD_CFG11_CSTALL_Msk            (0x1ul << USBD_CFG11_CSTALL_Pos)                  /*!< USBD_T::CFG11: CSTALL Mask             */

#define USBD_CFGP11_CLRRDY_Pos           (0)                                               /*!< USBD_T::CFGP11: CLRRDY Position        */
#define USBD_CFGP11_CLRRDY_Msk           (0x1ul << USBD_CFGP11_CLRRDY_Pos)                 /*!< USBD_T::CFGP11: CLRRDY Mask            */

#define USBD_CFGP11_SSTALL_Pos           (1)                                               /*!< USBD_T::CFGP11: SSTALL Position        */
#define USBD_CFGP11_SSTALL_Msk           (0x1ul << USBD_CFGP11_SSTALL_Pos)                 /*!< USBD_T::CFGP11: SSTALL Mask            */

#define USBD_VERSION_MINOR_Pos           (0)                                               /*!< USBD_T::VERSION: MINOR Position        */
#define USBD_VERSION_MINOR_Msk           (0xfffful << USBD_VERSION_MINOR_Pos)              /*!< USBD_T::VERSION: MINOR Mask            */

#define USBD_VERSION_SUB_Pos             (16)                                              /*!< USBD_T::VERSION: SUB Position          */
#define USBD_VERSION_SUB_Msk             (0xfful << USBD_VERSION_SUB_Pos)                  /*!< USBD_T::VERSION: SUB Mask              */

#define USBD_VERSION_MAJOR_Pos           (24)                                              /*!< USBD_T::VERSION: MAJOR Position        */
#define USBD_VERSION_MAJOR_Msk           (0xfful << USBD_VERSION_MAJOR_Pos)                /*!< USBD_T::VERSION: MAJOR Mask            */

/**@}*/ /* USBD_CONST */
/**@}*/ /* end of USBD register group */


/*---------------------- Watch Dog Timer Controller -------------------------*/
/**
    @addtogroup WDT Watch Dog Timer Controller(WDT)
    Memory Mapped Structure for WDT Controller
@{ */
 
typedef struct
{


/**
 * @var WDT_T::CTL
 * Offset: 0x00  WDT Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |RSTCNT    |Reset WDT Up Counter (Write Protect)
 * |        |          |0 = No effect.
 * |        |          |1 = Reset the internal 18-bit WDT up counter value.
 * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |        |          |Note2: This bit will be automatically cleared by hardware.
 * |[1]     |RSTEN     |WDT Time-out Reset Enable Control (Write Protect)
 * |        |          |Setting this bit will enable the WDT time-out reset function If the WDT up counter value has not been cleared after the specific WDT reset delay period expires.
 * |        |          |0 = WDT time-out reset function Disabled.
 * |        |          |1 = WDT time-out reset function Enabled.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[2]     |RSTF      |WDT Time-out Reset Flag
 * |        |          |This bit indicates the system has been reset by WDT time-out reset or not.
 * |        |          |0 = WDT time-out reset did not occur.
 * |        |          |1 = WDT time-out reset occurred.
 * |        |          |Note: This bit is cleared by writing 1 to it.
 * |[3]     |IF        |WDT Time-out Interrupt Flag
 * |        |          |This bit will set to 1 while WDT up counter value reaches the selected WDT time-out interval
 * |        |          |0 = WDT time-out interrupt did not occur.
 * |        |          |1 = WDT time-out interrupt occurred.
 * |        |          |Note: This bit is cleared by writing 1 to it.
 * |[4]     |WKEN      |WDT Time-out Wake-up Function Control (Write Protect)
 * |        |          |If this bit is set to 1, while WDT time-out interrupt flag IF (WDT_CTL[3]) is generated to 1 and interrupt enable bit INTEN (WDT_CTL[6]) is enabled, the WDT time-out interrupt signal will generate a wake-up trigger event to chip.
 * |        |          |0 = Wake-up trigger event Disabled if WDT time-out interrupt signal generated.
 * |        |          |1 = Wake-up trigger event Enabled if WDT time-out interrupt signal generated.
 * |        |          |NotNote1: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |        |          |Note2: Chip can be woken-up by WDT time-out interrupt signal generated only if WDT clock source is selected to 10 kHz internal low speed RC oscillator (LIRC) or LXT.
 * |        |          |Note3: The reset value of this bit is 0.
 * |[5]     |WKF       |WDT Time-out Wake-up Flag (Write Protect)
 * |        |          |This bit indicates the interrupt wake-up flag status of WDT
 * |        |          |0 = WDT does not cause chip wake-up.
 * |        |          |1 = Chip wake-up from Idle or Power-down mode if WDT time-out interrupt signal generated.
 * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |        |          |Note2: This bit is cleared by writing 1 to it.
 * |        |          |Note3: The reset value of this bit is 0.
 * |[6]     |INTEN     |WDT Time-out Interrupt Enable Control (Write Protect)
 * |        |          |If this bit is enabled, the WDT time-out interrupt signal is generated and inform to CPU.
 * |        |          |0 = WDT time-out interrupt Disabled.
 * |        |          |1 = WDT time-out interrupt Enabled.
 * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |        |          |Note2: The reset value of this bit is 0.
 * |[7]     |WDTEN     |WDT Enable Control (Write Protect)
 * |        |          |0 = WDT Disabled (This action will reset the internal up counter value).
 * |        |          |1 = WDT Enabled.
 * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |        |          |Note2: If CWDTEN[2:0] (combined by Config0[31] and Config0[4:3]) bits is not configure to 111, this bit is forced as 1 and user cannot change this bit to 0.
 * |[10:8]  |TOUTSEL   |WDT Time-out Interval Selection (Write Protect)
 * |        |          |These three bits select the time-out interval period for the WDT.
 * |        |          |000 = 24 * WDT_CLK.
 * |        |          |001 = 26 * WDT_CLK.
 * |        |          |010 = 28 * WDT_CLK.
 * |        |          |011 = 210 * WDT_CLK.
 * |        |          |100 = 212 * WDT_CLK.
 * |        |          |101 = 214 * WDT_CLK.
 * |        |          |110 = 216 * WDT_CLK.
 * |        |          |111 = 218 * WDT_CLK.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Control (Write Protect)
 * |        |          |0 = ICE debug mode acknowledgement affects WDT counting.
 * |        |          |WDT up counter will be held while CPU is held by ICE.
 * |        |          |1 = ICE debug mode acknowledgement Disabled.
 * |        |          |WDT up counter will keep going no matter CPU is held by ICE or not.
 * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
 * @var WDT_T::ALTCTL
 * Offset: 0x04  WDT Alternative Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |RSTDSEL   |WDT Reset Delay Selection (Write Protect)
 * |        |          |When WDT time-out happened, user has a time named WDT Reset Delay Period to clear WDT counter by setting RSTCNT (WDT_CTL[0]) to prevent WDT time-out reset happened
 * |        |          |User can select a suitable setting of RSTDSEL for different WDT Reset Delay Period.
 * |        |          |00 = WDT Reset Delay Period is 1026 * WDT_CLK.
 * |        |          |01 = WDT Reset Delay Period is 130 * WDT_CLK.
 * |        |          |10 = WDT Reset Delay Period is 18 * WDT_CLK.
 * |        |          |11 = WDT Reset Delay Period is 3 * WDT_CLK.
 * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
 * |        |          |Note2: This register will be reset to 0 if WDT time-out reset happened.
 * @var WDT_T::VERSION
 * Offset: 0xFFC  WDT RTL Design Version Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 */
    __IO uint32_t CTL;                   /*!< [0x0000] WDT Control Register                                             */
    __IO uint32_t ALTCTL;                /*!< [0x0004] WDT Alternative Control Register                                 */
    __I  uint32_t RESERVE0[1021];
    __IO uint32_t VERSION;               /*!< [0x0ffc] WDT RTL Design Version Register                                  */

} WDT_T;

/**
    @addtogroup WDT_CONST WDT Bit Field Definition
    Constant Definitions for WDT Controller
@{ */

#define WDT_CTL_RSTCNT_Pos               (0)                                               /*!< WDT_T::CTL: RSTCNT Position            */
#define WDT_CTL_RSTCNT_Msk               (0x1ul << WDT_CTL_RSTCNT_Pos)                     /*!< WDT_T::CTL: RSTCNT Mask                */

#define WDT_CTL_RSTEN_Pos                (1)                                               /*!< WDT_T::CTL: RSTEN Position             */
#define WDT_CTL_RSTEN_Msk                (0x1ul << WDT_CTL_RSTEN_Pos)                      /*!< WDT_T::CTL: RSTEN Mask                 */

#define WDT_CTL_RSTF_Pos                 (2)                                               /*!< WDT_T::CTL: RSTF Position              */
#define WDT_CTL_RSTF_Msk                 (0x1ul << WDT_CTL_RSTF_Pos)                       /*!< WDT_T::CTL: RSTF Mask                  */

#define WDT_CTL_IF_Pos                   (3)                                               /*!< WDT_T::CTL: IF Position                */
#define WDT_CTL_IF_Msk                   (0x1ul << WDT_CTL_IF_Pos)                         /*!< WDT_T::CTL: IF Mask                    */

#define WDT_CTL_WKEN_Pos                 (4)                                               /*!< WDT_T::CTL: WKEN Position              */
#define WDT_CTL_WKEN_Msk                 (0x1ul << WDT_CTL_WKEN_Pos)                       /*!< WDT_T::CTL: WKEN Mask                  */

#define WDT_CTL_WKF_Pos                  (5)                                               /*!< WDT_T::CTL: WKF Position               */
#define WDT_CTL_WKF_Msk                  (0x1ul << WDT_CTL_WKF_Pos)                        /*!< WDT_T::CTL: WKF Mask                   */

#define WDT_CTL_INTEN_Pos                (6)                                               /*!< WDT_T::CTL: INTEN Position             */
#define WDT_CTL_INTEN_Msk                (0x1ul << WDT_CTL_INTEN_Pos)                      /*!< WDT_T::CTL: INTEN Mask                 */

#define WDT_CTL_WDTEN_Pos                (7)                                               /*!< WDT_T::CTL: WDTEN Position             */
#define WDT_CTL_WDTEN_Msk                (0x1ul << WDT_CTL_WDTEN_Pos)                      /*!< WDT_T::CTL: WDTEN Mask                 */

#define WDT_CTL_TOUTSEL_Pos              (8)                                               /*!< WDT_T::CTL: TOUTSEL Position           */
#define WDT_CTL_TOUTSEL_Msk              (0x7ul << WDT_CTL_TOUTSEL_Pos)                    /*!< WDT_T::CTL: TOUTSEL Mask               */

#define WDT_CTL_ICEDEBUG_Pos             (31)                                              /*!< WDT_T::CTL: ICEDEBUG Position          */
#define WDT_CTL_ICEDEBUG_Msk             (0x1ul << WDT_CTL_ICEDEBUG_Pos)                   /*!< WDT_T::CTL: ICEDEBUG Mask              */

#define WDT_ALTCTL_RSTDSEL_Pos           (0)                                               /*!< WDT_T::ALTCTL: RSTDSEL Position        */
#define WDT_ALTCTL_RSTDSEL_Msk           (0x3ul << WDT_ALTCTL_RSTDSEL_Pos)                 /*!< WDT_T::ALTCTL: RSTDSEL Mask            */

/**@}*/ /* WDT_CONST */
/**@}*/ /* end of WDT register group */


/*---------------------- Window Watchdog Timer -------------------------*/
/**
    @addtogroup WWDT Window Watchdog Timer(WWDT)
    Memory Mapped Structure for WWDT Controller
@{ */
 
typedef struct
{


/**
 * @var WWDT_T::RLDCNT
 * Offset: 0x00  WWDT Reload Counter Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |RLDCNT    |WWDT Reload Counter Register
 * |        |          |Writing 0x00005AA5 to this register will reload the WWDT counter value to 0x3F.
 * |        |          |Note: User can only write WWDT_RLDCNT register to reload WWDT counter value when current WWDT counter value between 0 and CMPDAT (WWDT_CTL[21:16])
 * |        |          |If user writes WWDT_RLDCNT when current WWDT counter value is larger than CMPDAT , WWDT reset signal will generate immediately.
 * @var WWDT_T::CTL
 * Offset: 0x04  WWDT Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |WWDTEN    |WWDT Enable Control Bit
 * |        |          |Set this bit to enable WWDT counter counting.
 * |        |          |0 = WWDT counter is stopped.
 * |        |          |1 = WWDT counter is starting counting.
 * |[1]     |INTEN     |WWDT Interrupt Enable Control Bit
 * |        |          |If this bit is enabled, the WWDT counter compare match interrupt signal is generated and inform to CPU.
 * |        |          |0 = WWDT counter compare match interrupt Disabled.
 * |        |          |1 = WWDT counter compare match interrupt Enabled.
 * |[11:8]  |PSCSEL    |WWDT Counter Prescale Period Selection
 * |        |          |0000 = Pre-scale is 1; Max time-out period is 1 * 64 * WWDT_CLK.
 * |        |          |0001 = Pre-scale is 2; Max time-out period is 2 * 64 * WWDT_CLK.
 * |        |          |0010 = Pre-scale is 4; Max time-out period is 4 * 64 * WWDT_CLK.
 * |        |          |0011 = Pre-scale is 8; Max time-out period is 8 * 64 * WWDT_CLK.
 * |        |          |0100 = Pre-scale is 16; Max time-out period is 16 * 64 * WWDT_CLK.
 * |        |          |0101 = Pre-scale is 32; Max time-out period is 32 * 64 * WWDT_CLK.
 * |        |          |0110 = Pre-scale is 64; Max time-out period is 64 * 64 * WWDT_CLK.
 * |        |          |0111 = Pre-scale is 128; Max time-out period is 128 * 64 * WWDT_CLK.
 * |        |          |1000 = Pre-scale is 192; Max time-out period is 192 * 64 * WWDT_CLK.
 * |        |          |1001 = Pre-scale is 256; Max time-out period is 256 * 64 * WWDT_CLK.
 * |        |          |1010 = Pre-scale is 384; Max time-out period is 384 * 64 * WWDT_CLK.
 * |        |          |1011 = Pre-scale is 512; Max time-out period is 512 * 64 * WWDT_CLK.
 * |        |          |1100 = Pre-scale is 768; Max time-out period is 768 * 64 * WWDT_CLK.
 * |        |          |1101 = Pre-scale is 1024; Max time-out period is 1024 * 64 * WWDT_CLK.
 * |        |          |1110 = Pre-scale is 1536; Max time-out period is 1536 * 64 * WWDT_CLK.
 * |        |          |1111 = Pre-scale is 2048; Max time-out period is 2048 * 64 * WWDT_CLK.
 * |[21:16] |CMPDAT    |WWDT Window Compare Register
 * |        |          |Set this register to adjust the valid reload window.
 * |        |          |Note: User can only write WWDT_RLDCNT register to reload WWDT counter value when current WWDT counter value between 0 and CMPDAT
 * |        |          |If user writes WWDT_RLDCNT register when current WWDT counter value larger than CMPDAT, WWDT reset signal will generate immediately.
 * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Control
 * |        |          |0 = ICE debug mode acknowledgement effects WWDT counting.
 * |        |          |WWDT down counter will be held while CPU is held by ICE.
 * |        |          |1 = ICE debug mode acknowledgement Disabled.
 * |        |          |WWDT down counter will keep going no matter CPU is held by ICE or not.
 * @var WWDT_T::STATUS
 * Offset: 0x08  WWDT Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |WWDTIF    |WWDT Compare Match Interrupt Flag
 * |        |          |This bit indicates the interrupt flag status of WWDT while WWDT counter value matches CMPDAT (WWDT_CTL[21:16]).
 * |        |          |0 = No effect.
 * |        |          |1 = WWDT counter value matches CMPDAT.
 * |        |          |Note: This bit is cleared by writing 1 to it.
 * |[1]     |WWDTRF    |WWDT Timer-out Reset Flag
 * |        |          |This bit indicates the system has been reset by WWDT time-out reset or not.
 * |        |          |0 = WWDT time-out reset did not occur.
 * |        |          |1 = WWDT time-out reset occurred.
 * |        |          |Note: This bit is cleared by writing 1 to it.
 * @var WWDT_T::CNT
 * Offset: 0x0C  WWDT Counter Value Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[5:0]   |CNTDAT    |WWDT Counter Value
 * |        |          |CNTDAT will be updated continuously to monitor 6-bit WWDT down counter value.
 */
    __O  uint32_t RLDCNT;                /*!< [0x0000] WWDT Reload Counter Register                                     */
    __IO uint32_t CTL;                   /*!< [0x0004] WWDT Control Register                                            */
    __IO uint32_t STATUS;                /*!< [0x0008] WWDT Status Register                                             */
    __I  uint32_t CNT;                   /*!< [0x000c] WWDT Counter Value Register                                      */

} WWDT_T;

/**
    @addtogroup WWDT_CONST WWDT Bit Field Definition
    Constant Definitions for WWDT Controller
@{ */

#define WWDT_RLDCNT_RLDCNT_Pos           (0)                                               /*!< WWDT_T::RLDCNT: RLDCNT Position        */
#define WWDT_RLDCNT_RLDCNT_Msk           (0xfffffffful << WWDT_RLDCNT_RLDCNT_Pos)          /*!< WWDT_T::RLDCNT: RLDCNT Mask            */

#define WWDT_CTL_WWDTEN_Pos              (0)                                               /*!< WWDT_T::CTL: WWDTEN Position           */
#define WWDT_CTL_WWDTEN_Msk              (0x1ul << WWDT_CTL_WWDTEN_Pos)                    /*!< WWDT_T::CTL: WWDTEN Mask               */

#define WWDT_CTL_INTEN_Pos               (1)                                               /*!< WWDT_T::CTL: INTEN Position            */
#define WWDT_CTL_INTEN_Msk               (0x1ul << WWDT_CTL_INTEN_Pos)                     /*!< WWDT_T::CTL: INTEN Mask                */

#define WWDT_CTL_PSCSEL_Pos              (8)                                               /*!< WWDT_T::CTL: PSCSEL Position           */
#define WWDT_CTL_PSCSEL_Msk              (0xful << WWDT_CTL_PSCSEL_Pos)                    /*!< WWDT_T::CTL: PSCSEL Mask               */

#define WWDT_CTL_CMPDAT_Pos              (16)                                              /*!< WWDT_T::CTL: CMPDAT Position           */
#define WWDT_CTL_CMPDAT_Msk              (0x3ful << WWDT_CTL_CMPDAT_Pos)                   /*!< WWDT_T::CTL: CMPDAT Mask               */

#define WWDT_CTL_ICEDEBUG_Pos            (31)                                              /*!< WWDT_T::CTL: ICEDEBUG Position         */
#define WWDT_CTL_ICEDEBUG_Msk            (0x1ul << WWDT_CTL_ICEDEBUG_Pos)                  /*!< WWDT_T::CTL: ICEDEBUG Mask             */

#define WWDT_STATUS_WWDTIF_Pos           (0)                                               /*!< WWDT_T::STATUS: WWDTIF Position        */
#define WWDT_STATUS_WWDTIF_Msk           (0x1ul << WWDT_STATUS_WWDTIF_Pos)                 /*!< WWDT_T::STATUS: WWDTIF Mask            */

#define WWDT_STATUS_WWDTRF_Pos           (1)                                               /*!< WWDT_T::STATUS: WWDTRF Position        */
#define WWDT_STATUS_WWDTRF_Msk           (0x1ul << WWDT_STATUS_WWDTRF_Pos)                 /*!< WWDT_T::STATUS: WWDTRF Mask            */

#define WWDT_CNT_CNTDAT_Pos              (0)                                               /*!< WWDT_T::CNT: CNTDAT Position           */
#define WWDT_CNT_CNTDAT_Msk              (0x3ful << WWDT_CNT_CNTDAT_Pos)                   /*!< WWDT_T::CNT: CNTDAT Mask               */

/**@}*/ /* WWDT_CONST */
/**@}*/ /* end of WWDT register group */

typedef struct
{


/**
 * @var DPWM_T::CTL
 * Offset: 0x00  DPWM Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[1:0]   |FIFOWIDTH |DPWM FIFO DATA WIDTH SELETION From PDMA
 * |        |          |when FLT_EN is ...0u201D, FIFOWIDTH is for fixed point setting
 * |        |          |00 = PDMA MSB 24bits PWDATA[31:8]
 * |        |          |01 = PDMA 16 bits PWDATA[15:0]
 * |        |          |10 = PDMA 8bits PWDATA[7:0]
 * |        |          |11 = PDMA 24bits PWDATA[23:0]
 * |[3]     |DEADTIME  |DPWM Driver DEADTIME Control.
 * |        |          |Enabling this bit will insert an additional clock cycle deadtime into the switching of PMOS and NMOS driver transistors.
 * |[6]     |DPWMEN    |DPWM Enable
 * |        |          |0 = Disable DPWM.
 * |        |          |1 = Enable DPWM
 * |[7]     |DWPMDRVEN |DPWM Driver Enable
 * |        |          |0 = Disable DPWM Driver.
 * |        |          |1 = Enable DPWM Diver.
 * |[11]    |RXTHIE    |DPWM FIFO Threshold Interrupt
 * |        |          |0 = DPWM FIFO threshold interrupt Disabled
 * |        |          |1 = DPWM FIFO threshold interrupt Enabled.
 * |[16:12] |RXTH      |DPWM FIFO Threshold
 * |        |          |If the valid data count of the DPWM FIFO buffer is less than or equal to RXTH setting, the RXTHIF bit will set to 1, else the RXTHIF bit will be cleared to 0.
 * |[19:17] |FLT_INT_BIT|Floating integer bits setting
 * |        |          |000 ---- integer is 0. Data range +/- 0.999
 * |        |          |001 ---- integer is 1. Data range +/- 1.9999
 * |        |          |010 ---- integer is 2, Data range +/- 3.9999
 * |        |          |Others reserved
 * |[20]    |FLT_EN    |Floating Point format enable
 * |        |          |0 ---- input data is fixed point
 * |        |          |1 ---- input data is single precision point
 * |[21]    |BIQ_ON    |BIQ enable
 * |        |          |0 --- BIQ off
 * |        |          |1 --- BIQ on
 * |[22]    |SPLT_ON   |Splitter enable
 * |        |          |0 ----Splitter off
 * |        |          |1--- Splitter on ( use BIQ 4 bands, so set BIQ_BAND_NUM to 4)
 * |[27:24] |BIQ_BAND_NUM|BIQ band number setting ( total 10 band)
 * |        |          |1 --- choose band 1
 * |        |          |2 ---- choose band 2
 * |        |          |-----
 * |        |          |10 ---- choose band 10
 * |        |          |Others reserved
 * |[31]    |DPWM_CLKSET|DPWM working clock selection
 * |        |          |0 ---- choose 512 fs working clock
 * |        |          | example fs is 48KHz, DPWM_CLK is working on 24576KHz
 * |        |          |1 ---- choose 500 fs working clock
 * |        |          | Example fs is 48KHz, DPWM_CLK is working on 24000KHz
 * @var DPWM_T::STS
 * Offset: 0x04  DPWM DATA FIFO Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |FULL      |FIFO Full
 * |        |          |0 = FIFO is not full.
 * |        |          |1 = FIFO is full.
 * |[1]     |EMPTY     |FIFO Empty
 * |        |          |0 = FIFO is not empty.
 * |        |          |1 = FIFO is empty.
 * |[2]     |RXTHIF    |DPWM FIFO Threshold Interrupt Status (Read Only)
 * |        |          |0 = The valid data count within the DPWM FIFO buffer is larger than the setting value of RXTH.
 * |        |          |1 = The valid data count within the transmit FIFO buffer is less than or equal to the setting value of RXTH
 * |[8:4]   |FIFOPTR   |DPWM FIFO Pointer (Read Only)
 * |        |          |The FULL bit and FIFOPOINTER indicates the field that the valid data count within the DPWM FIFO buffer.
 * |        |          |The Maximum value shown in FIFO_POINTER is 15
 * |        |          |When the using level of DPWM FIFO Buffer equal to 16, The FULL bit is set to 1.
 * |[31:30] |BISTEN    |BIST Enable(internal use)
 * |        |          |0 = disable DPWM FIFO BIST testing.
 * |        |          |1 = enable DPWM FIFO BIST testing.
 * |        |          | DPWM FIFO can be testing by Cortex-M0
 * |        |          |Internal use
 * @var DPWM_T::DMACTL
 * Offset: 0x08  DPWM PDMA Control Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |DMAEN     |Enable DPWM DMA Interface
 * |        |          |0 = Disable PDMA. No requests will be made to PDMA controller.
 * |        |          |1 = Enable PDMA. Block will request data from PDMA controller whenever FIFO is not empty.
 * @var DPWM_T::DATA
 * Offset: 0x0C  DPWM DATA FIFO Input
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[31:0]  |INDATA    |DPWM FIFO Audio Data Input
 * |        |          |A write to this register pushes data onto the DPWM FIFO and increments the write pointer
 * |        |          |This is the address that PDMA writes audio data to.
 * @var DPWM_T::ZOHDIV
 * Offset: 0x10  DPWM Zero Order Hold Division Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[7:0]   |ZOHDIV    |DPWM Zero Order Hold, Down-sampling Divisor
 * |        |          |The input sample rate of the DPWM is set by DPWM_CLK frequency and the divisor set in this register by the following formula:
 * |        |          |If DPWM_CLKSET is 0, K = 128.
 * |        |          |If DPWM_CLKSET is 1, K = 125.
 * |        |          |ZOHDIV = DPWM_CLK /(Fs * K ).
 * |        |          |ZOH_DIV must be >= 4
 * |[18:8]  |DPWM_CLK_DIV|Divider to generate the DPWM CLOCK
 * |        |          |DPWM_CLK = (PLL or PCLK)/(1+DPWM_CLK_DIV)
 * |        |          |If fs is 48K or 16K, DPWM_CLK is 24.576MHz or 24MHz
 * |        |          |If fs is 96K, DPWM_CLK is 49.152MHz or 48MHz.
 * @var DPWM_T::COEFF_CTL
 * Offset: 0xFC  BIQ coeffient  control
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |PRGCOEFF  |DPWM PROGRAME Coefficient
 * |        |          |0 = Coefficient RAM is in normal mode.
 * |        |          |1 = coefficient RAM is under programming mode.
 * |[1]     |COEFF_FLTEN|Coefficient single floating enable
 * |        |          |1 ---- coefficient is single floating point
 * |        |          |0 --- coefficient is fixed point
 * @var DPWM_T::COEFF_0
 * Offset: 0x100  Coefficient b0 Transfer function for band 1
fixed point ---3.21 format 
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_1
 * Offset: 0x104  Coefficient b1 Transfer function for band 1
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_2
 * Offset: 0x108  Coefficient b2 Transfer function for band 1
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_3
 * Offset: 0x10C  Coefficient a1 Transfer function for band 1
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_4
 * Offset: 0x110  Coefficient a2 Transfer function for band 1
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_5
 * Offset: 0x114  Coefficient b0 Transfer function for band 2
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_6
 * Offset: 0x118  Coefficient b1 Transfer function for band 2
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_7
 * Offset: 0x11C  Coefficient b2 Transfer function  for band 2
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_8
 * Offset: 0x120  Coefficient a1 Transfer function for band 2
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_9
 * Offset: 0x124  Coefficient a2 Transfer function for band 2
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_10
 * Offset: 0x128  Coefficient b0 Transfer function for band 3
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_11
 * Offset: 0x12C  Coefficient b1 Transfer function for band 3
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_12
 * Offset: 0x130  Coefficient b2 Transfer function  for band 3
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_13
 * Offset: 0x134  Coefficient a1 Transfer function for band 3
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_14
 * Offset: 0x138  Coefficient a2 Transfer function for band 3
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_15
 * Offset: 0x13C  Coefficient b0 Transfer function for band 4
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_16
 * Offset: 0x140  Coefficient b1 Transfer function for band 4
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_17
 * Offset: 0x144  Coefficient b2 Transfer function  for band 4
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_18
 * Offset: 0x148  Coefficient a1 Transfer function for band 4
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_19
 * Offset: 0x14C  Coefficient a2 Transfer function for band 4
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_20
 * Offset: 0x150  Coefficient b0 Transfer function for band 5
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_21
 * Offset: 0x154  Coefficient b1 Transfer function for band 5
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_22
 * Offset: 0x158  Coefficient b2 Transfer function  for band 5
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_23
 * Offset: 0x15C  Coefficient a1 Transfer function for band 5
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_24
 * Offset: 0x160  Coefficient a2 Transfer function for band 5
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_25
 * Offset: 0x164  Coefficient b0 Transfer function for band 6
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_26
 * Offset: 0x168  Coefficient b1 Transfer function for band 6
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_27
 * Offset: 0x16C  Coefficient b2 Transfer function  for band 6
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_28
 * Offset: 0x170  Coefficient a1 Transfer function for band 6
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_29
 * Offset: 0x174  Coefficient a2 Transfer function for band 6
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_30
 * Offset: 0x178  Coefficient b0 Transfer function for band 7
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_31
 * Offset: 0x17C  Coefficient b1 Transfer function for band 7
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_32
 * Offset: 0x180  Coefficient b2 Transfer function  for band 7
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_33
 * Offset: 0x184  Coefficient a1 Transfer function for band 7
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_34
 * Offset: 0x188  Coefficient a2 Transfer function for band 7
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_35
 * Offset: 0x18C  Coefficient b0 Transfer function for band 8
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_36
 * Offset: 0x190  Coefficient b1 Transfer function for band 8
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_37
 * Offset: 0x194  Coefficient b2 Transfer function  for band 8
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_38
 * Offset: 0x198  Coefficient a1 Transfer function for band 8
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_39
 * Offset: 0x19C  Coefficient a2 Transfer function for band 8
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_40
 * Offset: 0x1A0  Coefficient b0 Transfer function for band 9
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_41
 * Offset: 0x1A4  Coefficient b1 Transfer function for band 9
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_42
 * Offset: 0x1A8  Coefficient b2 Transfer function  for band 9
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_43
 * Offset: 0x1AC  Coefficient a1 Transfer function for band 9
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_44
 * Offset: 0x1B0  Coefficient a2 Transfer function for band 9
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_45
 * Offset: 0x1B4  Coefficient b0 Transfer function for band 10
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_46
 * Offset: 0x1B8  Coefficient b1 Transfer function for band 10
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_47
 * Offset: 0x1BC  Coefficient b2 Transfer function  for band 10
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_48
 * Offset: 0x1C0  Coefficient a1 Transfer function for band 10
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * @var DPWM_T::COEFF_49
 * Offset: 0x1C4  Coefficient a2 Transfer function for band 10
fixed point ---3.21 format
floating point ---- single precision point
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 */
    __IO uint32_t CTL;                   /*!< [0x0000] DPWM Control Register                                            */
    __I  uint32_t STS;                   /*!< [0x0004] DPWM DATA FIFO Status Register                                   */
    __IO uint32_t DMACTL;                /*!< [0x0008] DPWM PDMA Control Register                                       */
    __O  uint32_t DATA;                  /*!< [0x000c] DPWM DATA FIFO Input                                             */
    __IO uint32_t ZOHDIV;                /*!< [0x0010] DPWM Zero Order Hold Division Register                           */
    __I  uint32_t RESERVE0[58];
    __IO uint32_t COEFF_CTL;             /*!< [0x00fc] BIQ coeffient  control                                           */
    __IO uint32_t COEFF_0;               /*!< [0x0100] Coefficient b0 Transfer function for band 1
fixed point ---3.21 format 
floating point ---- single precision point */
    __IO uint32_t COEFF_1;               /*!< [0x0104] Coefficient b1 Transfer function for band 1
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_2;               /*!< [0x0108] Coefficient b2 Transfer function for band 1
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_3;               /*!< [0x010c] Coefficient a1 Transfer function for band 1
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_4;               /*!< [0x0110] Coefficient a2 Transfer function for band 1
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_5;               /*!< [0x0114] Coefficient b0 Transfer function for band 2
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_6;               /*!< [0x0118] Coefficient b1 Transfer function for band 2
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_7;               /*!< [0x011c] Coefficient b2 Transfer function  for band 2
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_8;               /*!< [0x0120] Coefficient a1 Transfer function for band 2
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_9;               /*!< [0x0124] Coefficient a2 Transfer function for band 2
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_10;              /*!< [0x0128] Coefficient b0 Transfer function for band 3
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_11;              /*!< [0x012c] Coefficient b1 Transfer function for band 3
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_12;              /*!< [0x0130] Coefficient b2 Transfer function  for band 3
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_13;              /*!< [0x0134] Coefficient a1 Transfer function for band 3
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_14;              /*!< [0x0138] Coefficient a2 Transfer function for band 3
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_15;              /*!< [0x013c] Coefficient b0 Transfer function for band 4
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_16;              /*!< [0x0140] Coefficient b1 Transfer function for band 4
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_17;              /*!< [0x0144] Coefficient b2 Transfer function  for band 4
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_18;              /*!< [0x0148] Coefficient a1 Transfer function for band 4
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_19;              /*!< [0x014c] Coefficient a2 Transfer function for band 4
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_20;              /*!< [0x0150] Coefficient b0 Transfer function for band 5
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_21;              /*!< [0x0154] Coefficient b1 Transfer function for band 5
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_22;              /*!< [0x0158] Coefficient b2 Transfer function  for band 5
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_23;              /*!< [0x015c] Coefficient a1 Transfer function for band 5
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_24;              /*!< [0x0160] Coefficient a2 Transfer function for band 5
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_25;              /*!< [0x0164] Coefficient b0 Transfer function for band 6
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_26;              /*!< [0x0168] Coefficient b1 Transfer function for band 6
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_27;              /*!< [0x016c] Coefficient b2 Transfer function  for band 6
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_28;              /*!< [0x0170] Coefficient a1 Transfer function for band 6
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_29;              /*!< [0x0174] Coefficient a2 Transfer function for band 6
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_30;              /*!< [0x0178] Coefficient b0 Transfer function for band 7
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_31;              /*!< [0x017c] Coefficient b1 Transfer function for band 7
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_32;              /*!< [0x0180] Coefficient b2 Transfer function  for band 7
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_33;              /*!< [0x0184] Coefficient a1 Transfer function for band 7
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_34;              /*!< [0x0188] Coefficient a2 Transfer function for band 7
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_35;              /*!< [0x018c] Coefficient b0 Transfer function for band 8
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_36;              /*!< [0x0190] Coefficient b1 Transfer function for band 8
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_37;              /*!< [0x0194] Coefficient b2 Transfer function  for band 8
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_38;              /*!< [0x0198] Coefficient a1 Transfer function for band 8
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_39;              /*!< [0x019c] Coefficient a2 Transfer function for band 8
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_40;              /*!< [0x01a0] Coefficient b0 Transfer function for band 9
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_41;              /*!< [0x01a4] Coefficient b1 Transfer function for band 9
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_42;              /*!< [0x01a8] Coefficient b2 Transfer function  for band 9
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_43;              /*!< [0x01ac] Coefficient a1 Transfer function for band 9
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_44;              /*!< [0x01b0] Coefficient a2 Transfer function for band 9
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_45;              /*!< [0x01b4] Coefficient b0 Transfer function for band 10
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_46;              /*!< [0x01b8] Coefficient b1 Transfer function for band 10
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_47;              /*!< [0x01bc] Coefficient b2 Transfer function  for band 10
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_48;              /*!< [0x01c0] Coefficient a1 Transfer function for band 10
fixed point ---3.21 format
floating point ---- single precision point */
    __IO uint32_t COEFF_49;              /*!< [0x01c4] Coefficient a2 Transfer function for band 10
fixed point ---3.21 format
floating point ---- single precision point */

} DPWM_T;

/**
    @addtogroup DPWM_CONST DPWM Bit Field Definition
    Constant Definitions for DPWM Controller
@{ */

#define DPWM_CTL_FIFOWIDTH_Pos           (0)                                               /*!< DPWM_T::CTL: FIFOWIDTH Position        */
#define DPWM_CTL_FIFOWIDTH_Msk           (0x3ul << DPWM_CTL_FIFOWIDTH_Pos)                 /*!< DPWM_T::CTL: FIFOWIDTH Mask            */

#define DPWM_CTL_DEADTIME_Pos            (3)                                               /*!< DPWM_T::CTL: DEADTIME Position         */
#define DPWM_CTL_DEADTIME_Msk            (0x1ul << DPWM_CTL_DEADTIME_Pos)                  /*!< DPWM_T::CTL: DEADTIME Mask             */

#define DPWM_CTL_DPWMEN_Pos              (6)                                               /*!< DPWM_T::CTL: DPWMEN Position           */
#define DPWM_CTL_DPWMEN_Msk              (0x1ul << DPWM_CTL_DPWMEN_Pos)                    /*!< DPWM_T::CTL: DPWMEN Mask               */

#define DPWM_CTL_DWPMDRVEN_Pos           (7)                                               /*!< DPWM_T::CTL: DWPMDRVEN Position        */
#define DPWM_CTL_DWPMDRVEN_Msk           (0x1ul << DPWM_CTL_DWPMDRVEN_Pos)                 /*!< DPWM_T::CTL: DWPMDRVEN Mask            */

#define DPWM_CTL_RXTHIE_Pos              (11)                                              /*!< DPWM_T::CTL: RXTHIE Position           */
#define DPWM_CTL_RXTHIE_Msk              (0x1ul << DPWM_CTL_RXTHIE_Pos)                    /*!< DPWM_T::CTL: RXTHIE Mask               */

#define DPWM_CTL_RXTH_Pos                (12)                                              /*!< DPWM_T::CTL: RXTH Position             */
#define DPWM_CTL_RXTH_Msk                (0x1ful << DPWM_CTL_RXTH_Pos)                     /*!< DPWM_T::CTL: RXTH Mask                 */

#define DPWM_CTL_FLT_INT_BIT_Pos         (17)                                              /*!< DPWM_T::CTL: FLT_INT_BIT Position      */
#define DPWM_CTL_FLT_INT_BIT_Msk         (0x7ul << DPWM_CTL_FLT_INT_BIT_Pos)               /*!< DPWM_T::CTL: FLT_INT_BIT Mask          */

#define DPWM_CTL_FLT_EN_Pos              (20)                                              /*!< DPWM_T::CTL: FLT_EN Position           */
#define DPWM_CTL_FLT_EN_Msk              (0x1ul << DPWM_CTL_FLT_EN_Pos)                    /*!< DPWM_T::CTL: FLT_EN Mask               */

#define DPWM_CTL_BIQ_ON_Pos              (21)                                              /*!< DPWM_T::CTL: BIQ_ON Position           */
#define DPWM_CTL_BIQ_ON_Msk              (0x1ul << DPWM_CTL_BIQ_ON_Pos)                    /*!< DPWM_T::CTL: BIQ_ON Mask               */

#define DPWM_CTL_SPLT_ON_Pos             (22)                                              /*!< DPWM_T::CTL: SPLT_ON Position          */
#define DPWM_CTL_SPLT_ON_Msk             (0x1ul << DPWM_CTL_SPLT_ON_Pos)                   /*!< DPWM_T::CTL: SPLT_ON Mask              */

#define DPWM_CTL_BIQ_BAND_NUM_Pos        (24)                                              /*!< DPWM_T::CTL: BIQ_BAND_NUM Position     */
#define DPWM_CTL_BIQ_BAND_NUM_Msk        (0xful << DPWM_CTL_BIQ_BAND_NUM_Pos)              /*!< DPWM_T::CTL: BIQ_BAND_NUM Mask         */

#define DPWM_CTL_DPWM_CLKSET_Pos         (31)                                              /*!< DPWM_T::CTL: DPWM_CLKSET Position      */
#define DPWM_CTL_DPWM_CLKSET_Msk         (0x1ul << DPWM_CTL_DPWM_CLKSET_Pos)               /*!< DPWM_T::CTL: DPWM_CLKSET Mask          */

#define DPWM_STS_FULL_Pos                (0)                                               /*!< DPWM_T::STS: FULL Position             */
#define DPWM_STS_FULL_Msk                (0x1ul << DPWM_STS_FULL_Pos)                      /*!< DPWM_T::STS: FULL Mask                 */

#define DPWM_STS_EMPTY_Pos               (1)                                               /*!< DPWM_T::STS: EMPTY Position            */
#define DPWM_STS_EMPTY_Msk               (0x1ul << DPWM_STS_EMPTY_Pos)                     /*!< DPWM_T::STS: EMPTY Mask                */

#define DPWM_STS_RXTHIF_Pos              (2)                                               /*!< DPWM_T::STS: RXTHIF Position           */
#define DPWM_STS_RXTHIF_Msk              (0x1ul << DPWM_STS_RXTHIF_Pos)                    /*!< DPWM_T::STS: RXTHIF Mask               */

#define DPWM_STS_FIFOPTR_Pos             (4)                                               /*!< DPWM_T::STS: FIFOPTR Position          */
#define DPWM_STS_FIFOPTR_Msk             (0x1ful << DPWM_STS_FIFOPTR_Pos)                  /*!< DPWM_T::STS: FIFOPTR Mask              */

#define DPWM_STS_BISTEN_Pos              (30)                                              /*!< DPWM_T::STS: BISTEN Position           */
#define DPWM_STS_BISTEN_Msk              (0x3ul << DPWM_STS_BISTEN_Pos)                    /*!< DPWM_T::STS: BISTEN Mask               */

#define DPWM_DMACTL_DMAEN_Pos            (0)                                               /*!< DPWM_T::DMACTL: DMAEN Position         */
#define DPWM_DMACTL_DMAEN_Msk            (0x1ul << DPWM_DMACTL_DMAEN_Pos)                  /*!< DPWM_T::DMACTL: DMAEN Mask             */

#define DPWM_DATA_INDATA_Pos             (0)                                               /*!< DPWM_T::DATA: INDATA Position          */
#define DPWM_DATA_INDATA_Msk             (0xfffffffful << DPWM_DATA_INDATA_Pos)            /*!< DPWM_T::DATA: INDATA Mask              */

#define DPWM_ZOHDIV_ZOHDIV_Pos           (0)                                               /*!< DPWM_T::ZOHDIV: ZOHDIV Position        */
#define DPWM_ZOHDIV_ZOHDIV_Msk           (0xfful << DPWM_ZOHDIV_ZOHDIV_Pos)                /*!< DPWM_T::ZOHDIV: ZOHDIV Mask            */

#define DPWM_ZOHDIV_DPWM_CLK_DIV_Pos     (8)                                               /*!< DPWM_T::ZOHDIV: DPWM_CLK_DIV Position  */
#define DPWM_ZOHDIV_DPWM_CLK_DIV_Msk     (0x7fful << DPWM_ZOHDIV_DPWM_CLK_DIV_Pos)         /*!< DPWM_T::ZOHDIV: DPWM_CLK_DIV Mask      */

#define DPWM_COEFF_CTL_PRGCOEFF_Pos      (0)                                               /*!< DPWM_T::COEFF_CTL: PRGCOEFF Position   */
#define DPWM_COEFF_CTL_PRGCOEFF_Msk      (0x1ul << DPWM_COEFF_CTL_PRGCOEFF_Pos)            /*!< DPWM_T::COEFF_CTL: PRGCOEFF Mask       */

#define DPWM_COEFF_CTL_COEFF_FLTEN_Pos   (1)                                               /*!< DPWM_T::COEFF_CTL: COEFF_FLTEN Position*/
#define DPWM_COEFF_CTL_COEFF_FLTEN_Msk   (0x1ul << DPWM_COEFF_CTL_COEFF_FLTEN_Pos)         /*!< DPWM_T::COEFF_CTL: COEFF_FLTEN Mask    */

/**@}*/ /* DPWM_CONST */
/**@}*/ /* end of DPWM register group */


/**@}*/ /* end of REGISTER group */


/**@}*/ /* end of REGISTER group */

typedef struct
{


/**
 * @var SYSTICK_T::CSR
 * Offset: 0x10  SYST Control and Status Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[0]     |ENABLE    |ENABLE
 * |        |          |0 = The counter is disabled.
 * |        |          |1 = The counter will operate in a multi-shot manner.
 * |[1]     |TICKINT   |Enables SYST Exception Request
 * |        |          |0 = Counting down to 0 does not cause the SYST exception to be pended
 * |        |          |Software can use COUNTFLAG to determine if a count to zero has occurred.
 * |        |          |1 = Counting down to 0 will cause SYST exception to be pended
 * |        |          |Clearing the SYST Current Value register by a register write in software will not cause SYST to be pended.
 * |[2]     |CLKSRC    |Clock Source
 * |        |          |0 = Clock selected from CLK_CLKSEL0.STCLKSEL is used as clock source.
 * |        |          |1 = Core clock used for SYST.
 * |[16]    |COUNTFLAG |Count Flag
 * |        |          |Returns 1 if timer counted to 0 since last time this register was read.
 * |        |          |0= Cleared on read or by a write to the Current Value register.
 * |        |          |1= Set by a count transition from 1 to 0.
 * @var SYSTICK_T::RVR
 * Offset: 0x14  SYST Reload Value Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[23:0]  |RELOAD    |SYST Reload
 * |        |          |Value to load into the Current Value register when the counter reaches 0.
 * |        |          |To generate a multi-shot timer with a period of N processor clock cycles, use a RELOAD value of N-1
 * |        |          |For example, if the SYST interrupt is required every 200 clock pulses, set RELOAD to 199.
 * @var SYSTICK_T::CVR
 * Offset: 0x18  SYST Current Value Register
 * ---------------------------------------------------------------------------------------------------
 * |Bits    |Field     |Descriptions
 * | :----: | :----:   | :---- |
 * |[23:0]  |CURRENT   |Current Counter Value
 * |        |          |This is the value of the counter at the time it is sampled
 * |        |          |The counter does not provide read-modify-write protection
 * |        |          |The register is write-clear
 * |        |          |A software write of any value will clear the register to 0 and also clear the COUNTFLAG bit.
 */
    __I  uint32_t RESERVE0[4];
    __IO uint32_t CSR;                   /*!< [0x0010] SYST Control and Status Register                                 */
    __IO uint32_t RVR;                   /*!< [0x0014] SYST Reload Value Register                                       */
    __IO uint32_t CVR;                   /*!< [0x0018] SYST Current Value Register                                      */

} SYSTICK_T;

/* Peripheral and SRAM base address */
#define SRAM_BASE            (0x20000000UL)                              /*!< (SRAM      ) Base Address */
#define PERIPH_BASE          (0x40000000UL)                              /*!< (Peripheral) Base Address */
#define SYSTICK_BASE           0xE000E000UL

/* Peripheral memory map */
#define AHBPERIPH_BASE       PERIPH_BASE
#define APBPERIPH_BASE       (PERIPH_BASE + 0x00040000)

/*!< AHB peripherals */
#define GCR_BASE	         	(AHBPERIPH_BASE + 0x00000)
#define CLK_BASE	         	(AHBPERIPH_BASE + 0x00200)
#define INT_BASE	         	(AHBPERIPH_BASE + 0x00300)
#define GPIO_BASE	         	(AHBPERIPH_BASE + 0x04000)
#define GPIOA_BASE	        (AHBPERIPH_BASE + 0x04000)
#define GPIOB_BASE	        (AHBPERIPH_BASE + 0x04040)
#define GPIOC_BASE	        (AHBPERIPH_BASE + 0x04080)
#define GPIOD_BASE	        (AHBPERIPH_BASE + 0x040C0)

#define GPIO_DBNCECON_BASE  (AHBPERIPH_BASE + 0x04440)
#define GPIO_PIN_DATA_BASE  (AHBPERIPH_BASE + 0x04800)
#define DPWM_BASE           (AHBPERIPH_BASE + 0x64000)

#define PDMA_BASE	         	(AHBPERIPH_BASE + 0x08000)
//#define PDMA_EMBTA_BASE		 	(AHBPERIPH_BASE + 0x08000)
//#define USBH_BASE	         	(AHBPERIPH_BASE + 0x09000)
#define FMC_BASE	         	(AHBPERIPH_BASE + 0x0C000)
//#define EBI_BASE	         	(AHBPERIPH_BASE + 0x10000)
#define CRC_BASE	         	(AHBPERIPH_BASE + 0x31000)
#define SWDC_BASE	         	(AHBPERIPH_BASE + 0x3E000)

/*!< APB0 peripherals */
#define WDT_BASE	         	(APBPERIPH_BASE + 0x00000)
#define WWDT_BASE	         	(APBPERIPH_BASE + 0x00100)
#define I2S0_BASE	         	(APBPERIPH_BASE + 0x08000)
//#define UDC_BASE	         	(APBPERIPH_BASE + 0x0B000)
#define TMR01_BASE          (APBPERIPH_BASE + 0x10000)
#define PWM0_BASE	         	(APBPERIPH_BASE + 0x18000)
#define SPI0_BASE	         	(APBPERIPH_BASE + 0x20000)
//#define SPI2_BASE	         	(APBPERIPH_BASE + 0x22000)
#define UART0_BASE	       	(APBPERIPH_BASE + 0x30000)
//#define UART2_BASE	        (APBPERIPH_BASE + 0x32000)
#define I2C0_BASE	         	(APBPERIPH_BASE + 0x40000)
//#define SC0_BASE	         	(APBPERIPH_BASE + 0x50000)
//#define CAN0_BASE	         	(APBPERIPH_BASE + 0x60000)
//#define TK_BASE	             (APBPERIPH_BASE + 0xA2000)
//   
///*!< APB1 peripherals */
#define RTC_BASE	         (APBPERIPH_BASE + 0x01000)
//#define ADC0_BASE	         (APBPERIPH_BASE + 0x03000)
#define EADC0_BASE	         (APBPERIPH_BASE + 0x03000)
//#define ACMP01_BASE	         (APBPERIPH_BASE + 0x05000)
//#define DAC_BASE	         (APBPERIPH_BASE + 0x07000)
//#define OTG_BASE	         (APBPERIPH_BASE + 0x0D000)
#define TMR23_BASE           (APBPERIPH_BASE + 0x11000)
//#define PWM1_BASE	         (APBPERIPH_BASE + 0x19000)
#define SPI1_BASE	         (APBPERIPH_BASE + 0x21000)
#define SPI2_BASE	         (APBPERIPH_BASE + 0x21000)
//#define UART1_BASE	         (APBPERIPH_BASE + 0x31000)
//#define UART3_BASE	         (APBPERIPH_BASE + 0x33000)
#define I2C1_BASE	         (APBPERIPH_BASE + 0x41000)
#define EADC_BASE	         (APBPERIPH_BASE + 0x03000)
#define USBD_BASE	         (APBPERIPH_BASE + 0x08000)

/*@}*/ /* end of group ISD94XXX_MemoryMap */


/******************************************************************************/
/*                         Peripheral declaration                             */
/******************************************************************************/
/** @addtogroup ISD94XXX_PeripheralDecl ISD94XXX Peripheral Declaration
  @{
*/

#define SYS                ((SYS_T *)   GCR_BASE)
#define SYSTICK            ((SYSTICK_T            *) SYSTICK_BASE)
#define CLK                ((CLK_T *)   CLK_BASE)
#define GPIOA	             ((GPIO_T *)  GPIOA_BASE)
#define GPIOB	             ((GPIO1_T *)  GPIOB_BASE)
#define GPIOC	             ((GPIO_T *)  GPIOC_BASE)
#define GPIOD	             ((GPIO_T *)  GPIOD_BASE)
#define PA	               ((GPIO_T *)  GPIOA_BASE)
#define PB	               ((GPIO1_T *)  GPIOB_BASE)
#define PC	               ((GPIO_T *)  GPIOC_BASE)
#define PD	               ((GPIO_T *)  GPIOD_BASE)
#define PDMA	             ((PDMA_T *)  PDMA_BASE)
#define USBH	             ((USBH_T *)  USBH_BASE)
#define FMC	               ((FMC_T *)   FMC_BASE)
#define EBI	               ((EBI_T *)   EBI_BASE)
#define CRC	               ((CRC_T *)   CRC_BASE)

#define WDT	               ((WDT_T *)   WDT_BASE) 
#define WWDT	             ((WWDT_T *)  WWDT_BASE) 
#define RTC                ((RTC_T *)   RTC_BASE) 
#define EADC               ((EADC_T *)   EADC0_BASE) 
                       
#define TIMER0	           ((TMR01_T *) TMR01_BASE) 
#define TIMER1	           ((TMR01_T *) (TMR01_BASE + 0x100)) 
#define TIMER2	           ((TMR01_T *) TMR23_BASE) 
#define TIMER3	           ((TMR01_T *) (TMR23_BASE+ 0x100)) 
#define PWM0	             ((PWM_T *)   PWM0_BASE) 
//#define PWM1	             ((PWM_T *)   PWM1_BASE) 
#define SPI0	             ((SPI_T *)   SPI0_BASE) 
#define SPI1	             ((SPI_T *)   SPI1_BASE) 
#define SPI2	             ((SPI_T *)   SPI2_BASE) 
#define UART0	             ((UART_T *)  UART0_BASE) 
#define I2C0	             ((I2C_T *)   I2C0_BASE)
#define I2C1	             ((I2C_T *)   I2C1_BASE)
#define CAN0	             ((CAN_T *)   CAN0_BASE)
#define I2S                ((I2S_T*) I2S0_BASE)
#define USBD               ((USBD_T*) USBD_BASE)
#define DPWM               ((DPWM_T*) DPWM_BASE)

/* One Bit Mask Definitions */
#define BIT0    0x00000001
#define BIT1    0x00000002
#define BIT2    0x00000004
#define BIT3    0x00000008
#define BIT4    0x00000010
#define BIT5    0x00000020
#define BIT6    0x00000040
#define BIT7    0x00000080
#define BIT8    0x00000100
#define BIT9    0x00000200
#define BIT10   0x00000400
#define BIT11   0x00000800
#define BIT12   0x00001000
#define BIT13   0x00002000
#define BIT14   0x00004000
#define BIT15   0x00008000
#define BIT16   0x00010000
#define BIT17   0x00020000
#define BIT18   0x00040000
#define BIT19   0x00080000
#define BIT20   0x00100000
#define BIT21   0x00200000
#define BIT22   0x00400000
#define BIT23   0x00800000
#define BIT24   0x01000000
#define BIT25   0x02000000
#define BIT26   0x04000000
#define BIT27   0x08000000
#define BIT28   0x10000000
#define BIT29   0x20000000
#define BIT30   0x40000000
#define BIT31   0x80000000

/* Byte Mask Definitions */
#define BYTE0_Msk               (0x000000FF)
#define BYTE1_Msk               (0x0000FF00)
#define BYTE2_Msk               (0x00FF0000)
#define BYTE3_Msk               (0xFF000000)

#define _GET_BYTE0(u32Param)    (((u32Param) & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
#define _GET_BYTE1(u32Param)    (((u32Param) & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
#define _GET_BYTE2(u32Param)    (((u32Param) & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
#define _GET_BYTE3(u32Param)    (((u32Param) & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */



typedef volatile unsigned char  vu8;
typedef volatile unsigned long  vu32;
typedef volatile unsigned short vu16;
#define M8(adr)  (*((vu8  *) (adr)))
#define M16(adr) (*((vu16 *) (adr)))
#define M32(adr) (*((vu32 *) (adr)))

#define TRUE        1
#define FALSE       0

#define outpw(port,value)   *((volatile unsigned int *)(port))=(value)
#define inpw(port)          (*((volatile unsigned int *)(port)))
#define outpb(port,value)   *((volatile unsigned char *)(port))=(value)
#define inpb(port)          (*((volatile unsigned char *)(port)))
#define outps(port,value)   *((volatile unsigned short *)(port))=(value)
#define inps(port)          (*((volatile unsigned short *)(port)))

#define outp32(port,value)  *((volatile unsigned int *)(port))=(value)
#define inp32(port)         (*((volatile unsigned int *)(port)))
#define outp8(port,value)   *((volatile unsigned char *)(port))=(value)
#define inp8(port)          (*((volatile unsigned char *)(port)))
#define outp16(port,value)  *((volatile unsigned short *)(port))=(value)
#define inp16(port)         (*((volatile unsigned short *)(port)))

/*@}*/ /* end of group ISD94XXX_PeripheralDecl */


#define PWM_CNT_CNT_Pos                 (0)                                               /*!< PWM_T::CNT0: CNT Position              */
#define PWM_CNT_CNT_Msk                 (0xfffful << PWM_CNT0_CNT_Pos)                    /*!< PWM_T::CNT0: CNT Mask                  */

#define PWM_CNT_DIRF_Pos                (16)                                              /*!< PWM_T::CNT0: DIRF Position             */
#define PWM_CNT_DIRF_Msk                (0x1ul << PWM_CNT0_DIRF_Pos)                      /*!< PWM_T::CNT0: DIRF Mask                 */


/********************* Bit definition of CLKSEL0 register **********************/
#define CLK_CLKSEL0_HCLK_MASK		((uint32_t)0x00000007)			/*!<HCLK clock source selection bit mask */
#define CLK_CLKSEL0_HCLK_HXT		((uint32_t)0x00000000)			/*!<Select HCLK clock source from high speed crystal */
#define CLK_CLKSEL0_HCLK_LXT		((uint32_t)0x00000001)			/*!<Select HCLK clock source from low speed crystal */
#define CLK_CLKSEL0_HCLK_PLL		((uint32_t)0x00000002)			/*!<Select HCLK clock source from PLL */
#define CLK_CLKSEL0_HCLK_LIRC		((uint32_t)0x00000003)			/*!<Select HCLK clock source from low speed oscillator */
#define CLK_CLKSEL0_HCLK_HIRC		((uint32_t)0x00000007)			/*!<Select HCLK clock source from high speed oscillator */

#define CLK_CLKSEL0_SYSCLK_MASK		((uint32_t)0x00000038)			/*!<SysTick clock source selection bit mask */
#define CLK_CLKSEL0_SYSCLK_HXT		((uint32_t)0x00000000)			/*!<Select SYSCLK clock source from high speed crystal */
#define CLK_CLKSEL0_SYSCLK_LXT		((uint32_t)0x00000008)			/*!<Select SYSCLK clock source from low speed crystal */
#define CLK_CLKSEL0_SYSCLK_HXT_DIV2	((uint32_t)0x00000010)			/*!<Select SYSCLK clock source from 1/2 high speed crystal */
#define CLK_CLKSEL0_SYSCLK_HCLK_DIV2	((uint32_t)0x00000018)			/*!<Select SYSCLK clock source from 1/2 HCLK */
#define CLK_CLKSEL0_SYSCLK_HIRC_DIV2	((uint32_t)0x00000007)			/*!<Select SYSCLK clock source from 1/2 high speed oscillator */

#define CLK_CLKSEL1_TMR0_MASK		((uint32_t)0x00000700)			/*!<TMR0 clock source selection bit mask */
#define CLK_CLKSEL1_TMR0_HXT		((uint32_t)0x00000000)			/*!<Select TMR0 clock source from high speed crystal */
#define CLK_CLKSEL1_TMR0_LXT		((uint32_t)0x00000100)			/*!<Select TMR0 clock source from low speed crystal */
#define CLK_CLKSEL1_TMR0_PCLK0		((uint32_t)0x00000200)			/*!<Select TMR0 clock source from PCLK */
#define CLK_CLKSEL1_TMR0_EXT		((uint32_t)0x00000300)			/*!<Select TMR0 clock source from external trigger */
#define CLK_CLKSEL1_TMR0_LIRC		((uint32_t)0x00000500)			/*!<Select TMR0 clock source from low speed oscillator */
#define CLK_CLKSEL1_TMR0_HIRC		((uint32_t)0x00000700)			/*!<Select TMR0 clock source from high speed oscillator */

#define CLK_CLKSEL1_TMR1_MASK		((uint32_t)0x00007000)			/*!<TMR1 clock source selection bit mask */
#define CLK_CLKSEL1_TMR1_HXT		((uint32_t)0x00000000)			/*!<Select TMR1 clock source from high speed crystal */
#define CLK_CLKSEL1_TMR1_LXT		((uint32_t)0x00001000)			/*!<Select TMR1 clock source from low speed crystal */
#define CLK_CLKSEL1_TMR1_PCLK0		((uint32_t)0x00002000)			/*!<Select TMR1 clock source from PCLK */
#define CLK_CLKSEL1_TMR1_EXT		((uint32_t)0x00003000)			/*!<Select TMR1 clock source from external trigger */
#define CLK_CLKSEL1_TMR1_LIRC		((uint32_t)0x00005000)			/*!<Select TMR1 clock source from low speed oscillator */
#define CLK_CLKSEL1_TMR1_HIRC		((uint32_t)0x00007000)			/*!<Select TMR1 clock source from high speed oscillator */

#define CLK_CLKSEL1_TMR2_MASK		((uint32_t)0x00070000)			/*!<TMR2 clock source selection bit mask */
#define CLK_CLKSEL1_TMR2_HXT		((uint32_t)0x00000000)			/*!<Select TMR2 clock source from high speed crystal */
#define CLK_CLKSEL1_TMR2_LXT		((uint32_t)0x00010000)			/*!<Select TMR2 clock source from low speed crystal */
#define CLK_CLKSEL1_TMR2_PCLK1		((uint32_t)0x00020000)			/*!<Select TMR2 clock source from PCLK */
#define CLK_CLKSEL1_TMR2_EXT		((uint32_t)0x00030000)			/*!<Select TMR2 clock source from external trigger */
#define CLK_CLKSEL1_TMR2_LIRC		((uint32_t)0x00050000)			/*!<Select TMR2 clock source from low speed oscillator */
#define CLK_CLKSEL1_TMR2_HIRC		((uint32_t)0x00070000)			/*!<Select TMR2 clock source from high speed oscillator */

#define CLK_CLKSEL1_TMR3_MASK		((uint32_t)0x00700000)			/*!<TMR3 clock source selection bit mask */
#define CLK_CLKSEL1_TMR3_HXT		((uint32_t)0x00000000)			/*!<Select TMR3 clock source from high speed crystal */
#define CLK_CLKSEL1_TMR3_LXT		((uint32_t)0x00100000)			/*!<Select TMR3 clock source from low speed crystal */
#define CLK_CLKSEL1_TMR3_PCLK1		((uint32_t)0x00200000)			/*!<Select TMR3 clock source from PCLK */
#define CLK_CLKSEL1_TMR3_EXT		((uint32_t)0x00300000)			/*!<Select TMR3 clock source from external trigger */
#define CLK_CLKSEL1_TMR3_LIRC		((uint32_t)0x00500000)			/*!<Select TMR3 clock source from low speed oscillator */
#define CLK_CLKSEL1_TMR3_HIRC		((uint32_t)0x00700000)			/*!<Select TMR3 clock source from high speed oscillator */

#define CLK_CLKSEL1_UART_MASK		((uint32_t)0x03000000)			/*!<UART clock source selection bit mask */
#define CLK_CLKSEL1_UART_HXT		((uint32_t)0x00000000)			/*!<Select UART clock source from high speed crystal */
#define CLK_CLKSEL1_UART_PLL		((uint32_t)0x01000000)			/*!<Select UART clock source from PLL */
#define CLK_CLKSEL1_UART_HIRC		((uint32_t)0x03000000)			/*!<Select UART clock source from high speed oscillator */


#define CLK_CLKSEL1_WDT_MASK		((uint32_t)0x00000003)			/*!<WDT clock source selection bit mask */
#define CLK_CLKSEL1_WDT_LXT		((uint32_t)0x00000001)			/*!<Select WDT clock source from low speed crystal */
#define CLK_CLKSEL1_WDT_LIRC		((uint32_t)0x00000003)

/********************* Bit definition of CLKSEL2 register **********************/
#define CLK_CLKSEL2_PWM01_MASK		((uint32_t)0x00000001)			/*!<PWM01 clock source selection bit mask */
#define CLK_CLKSEL2_PWM01_PLL		((uint32_t)0x00000000)			/*!<Select PWM01 clock source from high speed crystal */
#define CLK_CLKSEL2_PWM01_PCLK0		((uint32_t)0x00000001)			/*!<Select PWM01 clock source from PCLK */

#define CLK_CLKSEL2_PWM23_MASK		((uint32_t)0x00000002)			/*!<PWM23 clock source selection bit mask */
#define CLK_CLKSEL2_PWM23_PLL		((uint32_t)0x00000000)			/*!<Select PWM23 clock source from high speed crystal */
#define CLK_CLKSEL2_PWM23_PCLK1		((uint32_t)0x00000002)			/*!<Select PWM23 clock source from low speed crystal */

/********************* Bit definition of CLKSEL3 register **********************/
#define CLK_CLKSEL3_SC0_MASK		((uint32_t)0x00000003)			/*!<SC0 clock source selection bit mask */
#define CLK_CLKSEL3_SC0_HXT			((uint32_t)0x00000000)			/*!<Select SC0 clock source from high speed crystal */
#define CLK_CLKSEL3_SC0_PLL			((uint32_t)0x00000001)			/*!<Select SC0 clock source from low speed crystal */
#define CLK_CLKSEL3_SC0_PCLK0		((uint32_t)0x00000002)			/*!<Select SC0 clock source from PCLK */
#define CLK_CLKSEL3_SC0_HIRC		((uint32_t)0x00000003)			/*!<Select SC0 clock source from high speed oscillator */

#define CLK_CLKSEL3_SC1_MASK		((uint32_t)0x0000000C)			/*!<SC1 clock source selection bit mask */
#define CLK_CLKSEL3_SC1_HXT			((uint32_t)0x00000000)			/*!<Select SC1 clock source from high speed crystal */
#define CLK_CLKSEL3_SC1_PLL			((uint32_t)0x00000004)			/*!<Select SC1 clock source from low speed crystal */
#define CLK_CLKSEL3_SC1_PCLK1		((uint32_t)0x00000008)			/*!<Select SC1 clock source from PCLK */
#define CLK_CLKSEL3_SC1_HIRC		((uint32_t)0x0000000C)			/*!<Select SC1 clock source from high speed oscillator */

#define CLK_CLKSEL3_SC2_MASK		((uint32_t)0x00000030)			/*!<SC2 clock source selection bit mask */
#define CLK_CLKSEL3_SC2_HXT			((uint32_t)0x00000000)			/*!<Select SC2 clock source from high speed crystal */
#define CLK_CLKSEL3_SC2_PLL			((uint32_t)0x00000010)			/*!<Select SC2 clock source from low speed crystal */
#define CLK_CLKSEL3_SC2_PCLK0		((uint32_t)0x00000020)			/*!<Select SC2 clock source from PCLK */
#define CLK_CLKSEL3_SC2_HIRC		((uint32_t)0x00000030)			/*!<Select SC2 clock source from high speed oscillator */


#include "sys.h"
#include "clk.h"
#include "uart.h"
#include "wwdt.h"
#include "sys.h"
#include "fmc.h"
#include "gpio.h"
#include "pwm.h"
#include "PDMA.h"
#include "timer.h"


/******************************************************************************/
/*                Device Specific Constants                                   */
/******************************************************************************/
/** @addtogroup ISD94XXX_Exported_Constants ISD94XXX Exported Constants
  ISD94XXX Device Specific Constantss
  @{
*/

/*@}*/ /* end of group ISD94XXX_Exported_Constants */


/******************************************************************************/
/*                Device Specific Macros                                      */
/******************************************************************************/
/** @addtogroup ISD94XXX_Exported_Macros ISD94XXX Exported Macros
  ISD94XXX Device Specific Macros
  @{
*/

/*! Unlock protected register */
#define UNLOCKREG(x)		do{SYS->REGLCTL = 0x59; SYS->REGLCTL = 0x16; SYS->REGLCTL = 0x88;}while(SYS->REGLCTL == 0x00)
/*! Lock protected register */
#define LOCKREG(x)          do{SYS->REGLCTL = 0x00;}while(0)

#define PWM_INTSTS0_CMPDIF0_Pos          (24)                                              /*!< PWM_T::INTSTS0: CMPDIF0 Position          */
#define PWM_INTSTS0_CMPDIF0_Msk          (0x1ul << PWM_INTSTS0_CMPDIF0_Pos)                /*!< PWM_T::INTSTS0: CMPDIF0 Mask              */

#define PWM_INTSTS0_CMPDIF1_Pos          (25)                                              /*!< PWM_T::INTSTS0: CMPDIF1 Position          */
#define PWM_INTSTS0_CMPDIF1_Msk          (0x1ul << PWM_INTSTS0_CMPDIF1_Pos)                /*!< PWM_T::INTSTS0: CMPDIF1 Mask              */

#define PWM_INTSTS0_CMPDIF2_Pos          (26)                                              /*!< PWM_T::INTSTS0: CMPDIF2 Position          */
#define PWM_INTSTS0_CMPDIF2_Msk          (0x1ul << PWM_INTSTS0_CMPDIF2_Pos)                /*!< PWM_T::INTSTS0: CMPDIF2 Mask              */

#define PWM_INTSTS0_CMPDIF3_Pos          (27)                                              /*!< PWM_T::INTSTS0: CMPDIF3 Position          */
#define PWM_INTSTS0_CMPDIF3_Msk          (0x1ul << PWM_INTSTS0_CMPDIF3_Pos)                /*!< PWM_T::INTSTS0: CMPDIF3 Mask              */

#define PWM_INTSTS0_CMPDIF4_Pos          (28)                                              /*!< PWM_T::INTSTS0: CMPDIF4 Position          */
#define PWM_INTSTS0_CMPDIF4_Msk          (0x1ul << PWM_INTSTS0_CMPDIF4_Pos)                /*!< PWM_T::INTSTS0: CMPDIF4 Mask              */

#define PWM_INTSTS0_CMPDIF5_Pos          (29)                                              /*!< PWM_T::INTSTS0: CMPDIF5 Position          */
#define PWM_INTSTS0_CMPDIF5_Msk          (0x1ul << PWM_INTSTS0_CMPDIF5_Pos)                /*!< PWM_T::INTSTS0: CMPDIF5 Mask              */

#define PWM_INTSTS0_CMPUIF0_Pos          (16)                                              /*!< PWM_T::INTSTS0: CMPUIF0 Position          */
#define PWM_INTSTS0_CMPUIF0_Msk          (0x1ul << PWM_INTSTS0_CMPUIF0_Pos)                /*!< PWM_T::INTSTS0: CMPUIF0 Mask              */

#define PWM_INTSTS0_CMPUIF1_Pos          (17)                                              /*!< PWM_T::INTSTS0: CMPUIF1 Position          */
#define PWM_INTSTS0_CMPUIF1_Msk          (0x1ul << PWM_INTSTS0_CMPUIF1_Pos)                /*!< PWM_T::INTSTS0: CMPUIF1 Mask              */

#define PWM_INTSTS0_CMPUIF2_Pos          (18)                                              /*!< PWM_T::INTSTS0: CMPUIF2 Position          */
#define PWM_INTSTS0_CMPUIF2_Msk          (0x1ul << PWM_INTSTS0_CMPUIF2_Pos)                /*!< PWM_T::INTSTS0: CMPUIF2 Mask              */

#define PWM_INTSTS0_CMPUIF3_Pos          (19)                                              /*!< PWM_T::INTSTS0: CMPUIF3 Position          */
#define PWM_INTSTS0_CMPUIF3_Msk          (0x1ul << PWM_INTSTS0_CMPUIF3_Pos)                /*!< PWM_T::INTSTS0: CMPUIF3 Mask              */

#define PWM_INTSTS0_CMPUIF4_Pos          (20)                                              /*!< PWM_T::INTSTS0: CMPUIF4 Position          */
#define PWM_INTSTS0_CMPUIF4_Msk          (0x1ul << PWM_INTSTS0_CMPUIF4_Pos)                /*!< PWM_T::INTSTS0: CMPUIF4 Mask              */

#define PWM_INTSTS0_CMPUIF5_Pos          (21)                                              /*!< PWM_T::INTSTS0: CMPUIF5 Position          */
#define PWM_INTSTS0_CMPUIF5_Msk          (0x1ul << PWM_INTSTS0_CMPUIF5_Pos)                /*!< PWM_T::INTSTS0: CMPUIF5 Mask              */

#define PWM_INTSTS0_IFAIF4_5_Pos         (23)                                              /*!< PWM_T::INTSTS0: IFAIF4_5 Position         */
#define PWM_INTSTS0_IFAIF4_5_Msk         (0x1ul << PWM_INTSTS0_IFAIF4_5_Pos)               /*!< PWM_T::INTSTS0: IFAIF4_5 Mask             */

#define PWM_INTEN0_CMPDIEN0_Pos          (24)                                              /*!< PWM_T::INTEN0: CMPDIEN0 Position          */
#define PWM_INTEN0_CMPDIEN0_Msk          (0x1ul << PWM_INTEN0_CMPDIEN0_Pos)                /*!< PWM_T::INTEN0: CMPDIEN0 Mask              */

#define PWM_INTEN0_CMPDIEN1_Pos          (25)                                              /*!< PWM_T::INTEN0: CMPDIEN1 Position          */
#define PWM_INTEN0_CMPDIEN1_Msk          (0x1ul << PWM_INTEN0_CMPDIEN1_Pos)                /*!< PWM_T::INTEN0: CMPDIEN1 Mask              */

#define PWM_INTEN0_CMPDIEN2_Pos          (26)                                              /*!< PWM_T::INTEN0: CMPDIEN2 Position          */
#define PWM_INTEN0_CMPDIEN2_Msk          (0x1ul << PWM_INTEN0_CMPDIEN2_Pos)                /*!< PWM_T::INTEN0: CMPDIEN2 Mask              */

#define PWM_INTEN0_CMPDIEN3_Pos          (27)                                              /*!< PWM_T::INTEN0: CMPDIEN3 Position          */
#define PWM_INTEN0_CMPDIEN3_Msk          (0x1ul << PWM_INTEN0_CMPDIEN3_Pos)                /*!< PWM_T::INTEN0: CMPDIEN3 Mask              */

#define PWM_INTEN0_CMPDIEN4_Pos          (28)                                              /*!< PWM_T::INTEN0: CMPDIEN4 Position          */
#define PWM_INTEN0_CMPDIEN4_Msk          (0x1ul << PWM_INTEN0_CMPDIEN4_Pos)                /*!< PWM_T::INTEN0: CMPDIEN4 Mask              */

#define PWM_INTEN0_CMPDIEN5_Pos          (29)                                              /*!< PWM_T::INTEN0: CMPDIEN5 Position          */
#define PWM_INTEN0_CMPDIEN5_Msk          (0x1ul << PWM_INTEN0_CMPDIEN5_Pos)                /*!< PWM_T::INTEN0: CMPDIEN5 Mask              */


#define PWM_INTEN0_CMPUIEN0_Pos          (16)                                              /*!< PWM_T::INTEN0: CMPUIEN0 Position          */
#define PWM_INTEN0_CMPUIEN0_Msk          (0x1ul << PWM_INTEN0_CMPUIEN0_Pos)                /*!< PWM_T::INTEN0: CMPUIEN0 Mask              */

#define PWM_INTEN0_CMPUIEN1_Pos          (17)                                              /*!< PWM_T::INTEN0: CMPUIEN1 Position          */
#define PWM_INTEN0_CMPUIEN1_Msk          (0x1ul << PWM_INTEN0_CMPUIEN1_Pos)                /*!< PWM_T::INTEN0: CMPUIEN1 Mask              */

#define PWM_INTEN0_CMPUIEN2_Pos          (18)                                              /*!< PWM_T::INTEN0: CMPUIEN2 Position          */
#define PWM_INTEN0_CMPUIEN2_Msk          (0x1ul << PWM_INTEN0_CMPUIEN2_Pos)                /*!< PWM_T::INTEN0: CMPUIEN2 Mask              */

#define PWM_INTEN0_CMPUIEN3_Pos          (19)                                              /*!< PWM_T::INTEN0: CMPUIEN3 Position          */
#define PWM_INTEN0_CMPUIEN3_Msk          (0x1ul << PWM_INTEN0_CMPUIEN3_Pos)                /*!< PWM_T::INTEN0: CMPUIEN3 Mask              */

#define PWM_INTEN0_CMPUIEN4_Pos          (20)                                              /*!< PWM_T::INTEN0: CMPUIEN4 Position          */
#define PWM_INTEN0_CMPUIEN4_Msk          (0x1ul << PWM_INTEN0_CMPUIEN4_Pos)                /*!< PWM_T::INTEN0: CMPUIEN4 Mask              */

#define PWM_INTEN0_CMPUIEN5_Pos          (21)                                              /*!< PWM_T::INTEN0: CMPUIEN5 Position          */
#define PWM_INTEN0_CMPUIEN5_Msk          (0x1ul << PWM_INTEN0_CMPUIEN5_Pos)                /*!< PWM_T::INTEN0: CMPUIEN5 Mask              */

#define PWM_INTEN0_IFAIEN4_5_Pos         (23)                                              /*!< PWM_T::INTEN0: IFAIEN4_5 Position         */
#define PWM_INTEN0_IFAIEN4_5_Msk         (0x1ul << PWM_INTEN0_IFAIEN4_5_Pos)               /*!< PWM_T::INTEN0: IFAIEN4_5 Mask             */

#define PWM_INTEN0_PIEN0_Pos             (8)                                               /*!< PWM_T::INTEN0: PIEN0 Position             */
#define PWM_INTEN0_PIEN0_Msk             (0x1ul << PWM_INTEN0_PIEN0_Pos)                   /*!< PWM_T::INTEN0: PIEN0 Mask                 */

#define PWM_INTEN0_PIEN1_Pos             (9)                                               /*!< PWM_T::INTEN0: PIEN1 Position             */
#define PWM_INTEN0_PIEN1_Msk             (0x1ul << PWM_INTEN0_PIEN1_Pos)                   /*!< PWM_T::INTEN0: PIEN1 Mask                 */

#define PWM_INTEN0_PIEN2_Pos             (10)                                              /*!< PWM_T::INTEN0: PIEN2 Position             */
#define PWM_INTEN0_PIEN2_Msk             (0x1ul << PWM_INTEN0_PIEN2_Pos)                   /*!< PWM_T::INTEN0: PIEN2 Mask                 */

#define PWM_INTEN0_PIEN3_Pos             (11)                                              /*!< PWM_T::INTEN0: PIEN3 Position             */
#define PWM_INTEN0_PIEN3_Msk             (0x1ul << PWM_INTEN0_PIEN3_Pos)                   /*!< PWM_T::INTEN0: PIEN3 Mask                 */

#define PWM_INTEN0_PIEN4_Pos             (12)                                              /*!< PWM_T::INTEN0: PIEN4 Position             */
#define PWM_INTEN0_PIEN4_Msk             (0x1ul << PWM_INTEN0_PIEN4_Pos)                   /*!< PWM_T::INTEN0: PIEN4 Mask                 */

#define PWM_INTEN0_PIEN5_Pos             (13)                                              /*!< PWM_T::INTEN0: PIEN5 Position             */
#define PWM_INTEN0_PIEN5_Msk             (0x1ul << PWM_INTEN0_PIEN5_Pos)                   /*!< PWM_T::INTEN0: PIEN5 Mask                 */

#define PWM_INTSTS0_ZIF0_Pos             (0)                                               /*!< PWM_T::INTSTS0: ZIF0 Position             */
#define PWM_INTSTS0_ZIF0_Msk             (0x1ul << PWM_INTSTS0_ZIF0_Pos)                   /*!< PWM_T::INTSTS0: ZIF0 Mask                 */

#define PWM_INTSTS0_ZIF1_Pos             (1)                                               /*!< PWM_T::INTSTS0: ZIF1 Position             */
#define PWM_INTSTS0_ZIF1_Msk             (0x1ul << PWM_INTSTS0_ZIF1_Pos)                   /*!< PWM_T::INTSTS0: ZIF1 Mask                 */

#define PWM_INTSTS0_ZIF2_Pos             (2)                                               /*!< PWM_T::INTSTS0: ZIF2 Position             */
#define PWM_INTSTS0_ZIF2_Msk             (0x1ul << PWM_INTSTS0_ZIF2_Pos)                   /*!< PWM_T::INTSTS0: ZIF2 Mask                 */

#define PWM_INTSTS0_ZIF3_Pos             (3)                                               /*!< PWM_T::INTSTS0: ZIF3 Position             */
#define PWM_INTSTS0_ZIF3_Msk             (0x1ul << PWM_INTSTS0_ZIF3_Pos)                   /*!< PWM_T::INTSTS0: ZIF3 Mask                 */

#define PWM_INTSTS0_ZIF4_Pos             (4)                                               /*!< PWM_T::INTSTS0: ZIF4 Position             */
#define PWM_INTSTS0_ZIF4_Msk             (0x1ul << PWM_INTSTS0_ZIF4_Pos)                   /*!< PWM_T::INTSTS0: ZIF4 Mask                 */

#define PWM_INTSTS0_ZIF5_Pos             (5)                                               /*!< PWM_T::INTSTS0: ZIF5 Position             */
#define PWM_INTSTS0_ZIF5_Msk             (0x1ul << PWM_INTSTS0_ZIF5_Pos)                   /*!< PWM_T::INTSTS0: ZIF5 Mask                 */


#define PWM_INTSTS0_PIF0_Pos             (8)                                               /*!< PWM_T::INTSTS0: PIF0 Position             */
#define PWM_INTSTS0_PIF0_Msk             (0x1ul << PWM_INTSTS0_PIF0_Pos)                   /*!< PWM_T::INTSTS0: PIF0 Mask                 */

#define PWM_INTSTS0_PIF1_Pos             (9)                                               /*!< PWM_T::INTSTS0: PIF1 Position             */
#define PWM_INTSTS0_PIF1_Msk             (0x1ul << PWM_INTSTS0_PIF1_Pos)                   /*!< PWM_T::INTSTS0: PIF1 Mask                 */

#define PWM_INTSTS0_PIF2_Pos             (10)                                              /*!< PWM_T::INTSTS0: PIF2 Position             */
#define PWM_INTSTS0_PIF2_Msk             (0x1ul << PWM_INTSTS0_PIF2_Pos)                   /*!< PWM_T::INTSTS0: PIF2 Mask                 */

#define PWM_INTSTS0_PIF3_Pos             (11)                                              /*!< PWM_T::INTSTS0: PIF3 Position             */
#define PWM_INTSTS0_PIF3_Msk             (0x1ul << PWM_INTSTS0_PIF3_Pos)                   /*!< PWM_T::INTSTS0: PIF3 Mask                 */

#define PWM_INTSTS0_PIF4_Pos             (12)                                              /*!< PWM_T::INTSTS0: PIF4 Position             */
#define PWM_INTSTS0_PIF4_Msk             (0x1ul << PWM_INTSTS0_PIF4_Pos)                   /*!< PWM_T::INTSTS0: PIF4 Mask                 */

#define PWM_INTSTS0_PIF5_Pos             (13)                                              /*!< PWM_T::INTSTS0: PIF5 Position             */
#define PWM_INTSTS0_PIF5_Msk             (0x1ul << PWM_INTSTS0_PIF5_Pos)                   /*!< PWM_T::INTSTS0: PIF5 Mask                 */

#define PWM_INTEN0_ZIEN0_Pos             (0)                                               /*!< PWM_T::INTEN0: ZIEN0 Position             */
#define PWM_INTEN0_ZIEN0_Msk             (0x1ul << PWM_INTEN0_ZIEN0_Pos)                   /*!< PWM_T::INTEN0: ZIEN0 Mask                 */

#define PWM_INTEN0_ZIEN1_Pos             (1)                                               /*!< PWM_T::INTEN0: ZIEN1 Position             */
#define PWM_INTEN0_ZIEN1_Msk             (0x1ul << PWM_INTEN0_ZIEN1_Pos)                   /*!< PWM_T::INTEN0: ZIEN1 Mask                 */

#define PWM_INTEN0_ZIEN2_Pos             (2)                                               /*!< PWM_T::INTEN0: ZIEN2 Position             */
#define PWM_INTEN0_ZIEN2_Msk             (0x1ul << PWM_INTEN0_ZIEN2_Pos)                   /*!< PWM_T::INTEN0: ZIEN2 Mask                 */

#define PWM_INTEN0_ZIEN3_Pos             (3)                                               /*!< PWM_T::INTEN0: ZIEN3 Position             */
#define PWM_INTEN0_ZIEN3_Msk             (0x1ul << PWM_INTEN0_ZIEN3_Pos)                   /*!< PWM_T::INTEN0: ZIEN3 Mask                 */

#define PWM_INTEN0_ZIEN4_Pos             (4)                                               /*!< PWM_T::INTEN0: ZIEN4 Position             */
#define PWM_INTEN0_ZIEN4_Msk             (0x1ul << PWM_INTEN0_ZIEN4_Pos)                   /*!< PWM_T::INTEN0: ZIEN4 Mask                 */

#define PWM_INTEN0_ZIEN5_Pos             (5)                                               /*!< PWM_T::INTEN0: ZIEN5 Position             */
#define PWM_INTEN0_ZIEN5_Msk             (0x1ul << PWM_INTEN0_ZIEN5_Pos)                   /*!< PWM_T::INTEN0: ZIEN5 Mask                 */


#define PWM_STATUS_CNTMAXF0_Pos          (0)                                               /*!< PWM_T::STATUS: CNTMAXF0 Position          */
#define PWM_STATUS_CNTMAXF0_Msk          (0x1ul << PWM_STATUS_CNTMAXF0_Pos)                /*!< PWM_T::STATUS: CNTMAXF0 Mask              */

#define PWM_STATUS_CNTMAXF1_Pos          (1)                                               /*!< PWM_T::STATUS: CNTMAXF1 Position          */
#define PWM_STATUS_CNTMAXF1_Msk          (0x1ul << PWM_STATUS_CNTMAXF1_Pos)                /*!< PWM_T::STATUS: CNTMAXF1 Mask              */

#define PWM_STATUS_CNTMAXF2_Pos          (2)                                               /*!< PWM_T::STATUS: CNTMAXF2 Position          */
#define PWM_STATUS_CNTMAXF2_Msk          (0x1ul << PWM_STATUS_CNTMAXF2_Pos)                /*!< PWM_T::STATUS: CNTMAXF2 Mask              */

#define PWM_STATUS_CNTMAXF3_Pos          (3)                                               /*!< PWM_T::STATUS: CNTMAXF3 Position          */
#define PWM_STATUS_CNTMAXF3_Msk          (0x1ul << PWM_STATUS_CNTMAXF3_Pos)                /*!< PWM_T::STATUS: CNTMAXF3 Mask              */

#define PWM_STATUS_CNTMAXF4_Pos          (4)                                               /*!< PWM_T::STATUS: CNTMAXF4 Position          */
#define PWM_STATUS_CNTMAXF4_Msk          (0x1ul << PWM_STATUS_CNTMAXF4_Pos)                /*!< PWM_T::STATUS: CNTMAXF4 Mask              */

#define PWM_STATUS_CNTMAXF5_Pos          (5)                                               /*!< PWM_T::STATUS: CNTMAXF5 Position          */
#define PWM_STATUS_CNTMAXF5_Msk          (0x1ul << PWM_STATUS_CNTMAXF5_Pos)                /*!< PWM_T::STATUS: CNTMAXF5 Mask              */

#define PWM_FTCI_FTCMU0_Pos              (0)                                               /*!< PWM_T::FTCI: FTCMU0 Position              */
#define PWM_FTCI_FTCMU0_Msk              (0x1ul << PWM_FTCI_FTCMU0_Pos)                    /*!< PWM_T::FTCI: FTCMU0 Mask                  */

#define PWM_FTCI_FTCMU2_Pos              (1)                                               /*!< PWM_T::FTCI: FTCMU2 Position              */
#define PWM_FTCI_FTCMU2_Msk              (0x1ul << PWM_FTCI_FTCMU2_Pos)                    /*!< PWM_T::FTCI: FTCMU2 Mask                  */

#define PWM_FTCI_FTCMU4_Pos              (2)                                               /*!< PWM_T::FTCI: FTCMU4 Position              */
#define PWM_FTCI_FTCMU4_Msk              (0x1ul << PWM_FTCI_FTCMU4_Pos)                    /*!< PWM_T::FTCI: FTCMU4 Mask                  */

#define PWM_FTCI_FTCMD0_Pos              (8)                                               /*!< PWM_T::FTCI: FTCMD0 Position              */
#define PWM_FTCI_FTCMD0_Msk              (0x1ul << PWM_FTCI_FTCMD0_Pos)                    /*!< PWM_T::FTCI: FTCMD0 Mask                  */

#define PWM_FTCI_FTCMD2_Pos              (9)                                               /*!< PWM_T::FTCI: FTCMD2 Position              */
#define PWM_FTCI_FTCMD2_Msk              (0x1ul << PWM_FTCI_FTCMD2_Pos)                    /*!< PWM_T::FTCI: FTCMD2 Mask                  */

#define PWM_FTCI_FTCMD4_Pos              (10)                                              /*!< PWM_T::FTCI: FTCMD4 Position              */
#define PWM_FTCI_FTCMD4_Msk              (0x1ul << PWM_FTCI_FTCMD4_Pos)                    /*!< PWM_T::FTCI: FTCMD4 Mask                  */


#define PWM_SYNC_PHSDIR0_Pos             (24)                                              /*!< PWM_T::SYNC: PHSDIR0 Position             */
#define PWM_SYNC_PHSDIR0_Msk             (0x1ul << PWM_SYNC_PHSDIR0_Pos)                   /*!< PWM_T::SYNC: PHSDIR0 Mask                 */

#define PWM_SYNC_PHSDIR2_Pos             (25)                                              /*!< PWM_T::SYNC: PHSDIR2 Position             */
#define PWM_SYNC_PHSDIR2_Msk             (0x1ul << PWM_SYNC_PHSDIR2_Pos)                   /*!< PWM_T::SYNC: PHSDIR2 Mask                 */

#define PWM_SYNC_PHSDIR4_Pos             (26)                                              /*!< PWM_T::SYNC: PHSDIR4 Position             */
#define PWM_SYNC_PHSDIR4_Msk             (0x1ul << PWM_SYNC_PHSDIR4_Pos)                   /*!< PWM_T::SYNC: PHSDIR4 Mask                 */

#define PWM_SYNC_SINSRC0_Pos             (8)                                               /*!< PWM_T::SYNC: SINSRC0 Position             */
#define PWM_SYNC_SINSRC0_Msk             (0x3ul << PWM_SYNC_SINSRC0_Pos)                   /*!< PWM_T::SYNC: SINSRC0 Mask                 */

#define PWM_SYNC_SINSRC2_Pos             (10)                                              /*!< PWM_T::SYNC: SINSRC2 Position             */
#define PWM_SYNC_SINSRC2_Msk             (0x3ul << PWM_SYNC_SINSRC2_Pos)                   /*!< PWM_T::SYNC: SINSRC2 Mask                 */

#define PWM_SYNC_SINSRC4_Pos             (12)                                              /*!< PWM_T::SYNC: SINSRC4 Position             */
#define PWM_SYNC_SINSRC4_Msk             (0x3ul << PWM_SYNC_SINSRC4_Pos)                   /*!< PWM_T::SYNC: SINSRC4 Mask                 */

#define PWM_SYNC_PHSEN0_Pos              (0)                                               /*!< PWM_T::SYNC: PHSEN0 Position              */
#define PWM_SYNC_PHSEN0_Msk              (0x1ul << PWM_SYNC_PHSEN0_Pos)                    /*!< PWM_T::SYNC: PHSEN0 Mask                  */

#define PWM_SYNC_PHSEN2_Pos              (1)                                               /*!< PWM_T::SYNC: PHSEN2 Position              */
#define PWM_SYNC_PHSEN2_Msk              (0x1ul << PWM_SYNC_PHSEN2_Pos)                    /*!< PWM_T::SYNC: PHSEN2 Mask                  */

#define PWM_SYNC_PHSEN4_Pos              (2)                                               /*!< PWM_T::SYNC: PHSEN4 Position              */
#define PWM_SYNC_PHSEN4_Msk              (0x1ul << PWM_SYNC_PHSEN4_Pos)                    /*!< PWM_T::SYNC: PHSEN4 Mask                  */

#define FMC_FTCTL_FOM_Pos                (4)                                               /*!< FMC_T::FTCTL: FOM Position                */
#define FMC_FTCTL_FOM_Msk                (0x7ul << FMC_FTCTL_FOM_Pos)                      /*!< FMC_T::FTCTL: FOM Mask                    */



#define PDMA_REQSEL8_11_REQSRC8_Pos       (0)                                               /*!< PDMA_T::REQSEL8_11: REQSRC4 Position    */
#define PDMA_REQSEL8_11_REQSRC8_Msk       (0x1ful << PDMA_REQSEL8_11_REQSRC8_Pos)            /*!< PDMA_T::REQSEL8_11: REQSRC4 Mask        */
#define PDMA_REQSEL8_11_REQSRC9_Pos       (8)                                               /*!< PDMA_T::REQSEL8_11: REQSRC5 Position    */
#define PDMA_REQSEL8_11_REQSRC9_Msk       (0x1ful << PDMA_REQSEL8_11_REQSRC9_Pos)            /*!< PDMA_T::REQSEL8_11: REQSRC5 Mask        */
#define PDMA_REQSEL8_11_REQSRC10_Pos      (16)                                              /*!< PDMA_T::REQSEL8_11: REQSRC6 Position    */
#define PDMA_REQSEL8_11_REQSRC10_Msk      (0x1ful << PDMA_REQSEL8_11_REQSRC10_Pos)            /*!< PDMA_T::REQSEL8_11: REQSRC6 Mask        */
#define PDMA_REQSEL8_11_REQSRC11_Pos      (24)                                              /*!< PDMA_T::REQSEL8_11: REQSRC7 Position    */
#define PDMA_REQSEL8_11_REQSRC11_Msk      (0x1ful << PDMA_REQSEL8_11_REQSRC11_Pos)            /*!< PDMA_T::REQSEL8_11: REQSRC7 Mask        */

#define PDMA_REQSEL12_15_REQSRC12_Pos      (0)                                               /*!< PDMA_T::REQSEL8_11: REQSRC4 Position    */
#define PDMA_REQSEL12_15_REQSRC12_Msk      (0x1ful << PDMA_REQSEL12_15_REQSRC12_Pos)            /*!< PDMA_T::REQSEL8_11: REQSRC4 Mask        */
#define PDMA_REQSEL12_15_REQSRC13_Pos      (8)                                               /*!< PDMA_T::REQSEL8_11: REQSRC5 Position    */
#define PDMA_REQSEL12_15_REQSRC13_Msk      (0x1ful << PDMA_REQSEL12_15_REQSRC13_Pos)            /*!< PDMA_T::REQSEL8_11: REQSRC5 Mask        */
#define PDMA_REQSEL12_15_REQSRC14_Pos      (16)                                              /*!< PDMA_T::REQSEL8_11: REQSRC6 Position    */
#define PDMA_REQSEL12_15_REQSRC14_Msk      (0x1ful << PDMA_REQSEL12_15_REQSRC14_Pos)            /*!< PDMA_T::REQSEL8_11: REQSRC6 Mask        */
#define PDMA_REQSEL12_15_REQSRC15_Pos      (24)                                              /*!< PDMA_T::REQSEL8_11: REQSRC7 Position    */
#define PDMA_REQSEL12_15_REQSRC15_Msk      (0x1ful << PDMA_REQSEL12_15_REQSRC15_Pos)            /*!< PDMA_T::REQSEL8_11: REQSRC7 Mask        */

#define PDMA_TOC2_3_TOC2_Pos             (0)                                               /*!< PDMA_T::TOC0_1: TOC0 Position          */
#define PDMA_TOC2_3_TOC2_Msk             (0xfffful << PDMA_TOC2_3_TOC2_Pos)                /*!< PDMA_T::TOC0_1: TOC0 Mask              */

#define PDMA_TOC2_3_TOC3_Pos             (16)                                              /*!< PDMA_T::TOC0_1: TOC1 Position          */
#define PDMA_TOC2_3_TOC3_Msk             (0xfffful << PDMA_TOC2_3_TOC3_Pos)                /*!< PDMA_T::TOC0_1: TOC1 Mask              */

#define PDMA_TOC4_5_TOC4_Pos             (0)                                               /*!< PDMA_T::TOC0_1: TOC0 Position          */
#define PDMA_TOC4_5_TOC4_Msk             (0xfffful << PDMA_TOC4_5_TOC4_Pos)                /*!< PDMA_T::TOC0_1: TOC0 Mask              */

#define PDMA_TOC4_5_TOC5_Pos             (16)                                              /*!< PDMA_T::TOC0_1: TOC1 Position          */
#define PDMA_TOC4_5_TOC5_Msk             (0xfffful << PDMA_TOC4_5_TOC5_Pos)                /*!< PDMA_T::TOC0_1: TOC1 Mask              */

#define PDMA_TOC6_7_TOC6_Pos             (0)                                               /*!< PDMA_T::TOC0_1: TOC0 Position          */
#define PDMA_TOC6_7_TOC6_Msk             (0xfffful << PDMA_TOC6_7_TOC6_Pos)                /*!< PDMA_T::TOC0_1: TOC0 Mask              */

#define PDMA_TOC6_7_TOC7_Pos             (16)                                              /*!< PDMA_T::TOC0_1: TOC1 Position          */
#define PDMA_TOC6_7_TOC7_Msk             (0xfffful << PDMA_TOC6_7_TOC6_Pos)                /*!< PDMA_T::TOC0_1: TOC1 Mask              */

#define PDMA_TOC8_9_TOC8_Pos                (0)                                               /*!< PDMA_T::TOC0_1: TOC0 Position          */
#define PDMA_TOC8_9_TOC8_Msk                (0xfffful << PDMA_TOC8_9_TOC8_Pos)                /*!< PDMA_T::TOC0_1: TOC0 Mask              */
#define PDMA_TOC8_9_TOC9_Pos                (16)                                              /*!< PDMA_T::TOC0_1: TOC1 Position          */
#define PDMA_TOC8_9_TOC9_Msk                (0xfffful << PDMA_TOC8_9_TOC9_Pos)                /*!< PDMA_T::TOC0_1: TOC1 Mask              */
#define PDMA_TOC10_11_TOC10_Pos             (0)                                               /*!< PDMA_T::TOC0_1: TOC0 Position          */
#define PDMA_TOC10_11_TOC10_Msk             (0xfffful << PDMA_TOC10_11_TOC10_Pos)                /*!< PDMA_T::TOC0_1: TOC0 Mask              */
#define PDMA_TOC10_11_TOC11_Pos             (16)                                              /*!< PDMA_T::TOC0_1: TOC1 Position          */
#define PDMA_TOC10_11_TOC11_Msk             (0xfffful << PDMA_TOC10_11_TOC11_Pos)                /*!< PDMA_T::TOC0_1: TOC1 Mask              */
#define PDMA_TOC12_13_TOC12_Pos             (0)                                               /*!< PDMA_T::TOC0_1: TOC0 Position          */
#define PDMA_TOC12_13_TOC12_Msk             (0xfffful << PDMA_TOC12_13_TOC12_Pos)                /*!< PDMA_T::TOC0_1: TOC0 Mask              */
#define PDMA_TOC12_13_TOC13_Pos             (16)                                              /*!< PDMA_T::TOC0_1: TOC1 Position          */
#define PDMA_TOC12_13_TOC13_Msk             (0xfffful << PDMA_TOC12_13_TOC13_Pos)                /*!< PDMA_T::TOC0_1: TOC1 Mask              */
#define PDMA_TOC14_15_TOC14_Pos             (0)                                               /*!< PDMA_T::TOC0_1: TOC0 Position          */
#define PDMA_TOC14_15_TOC14_Msk             (0xfffful << PDMA_TOC14_15_TOC14_Pos)                /*!< PDMA_T::TOC0_1: TOC0 Mask              */
#define PDMA_TOC14_15_TOC15_Pos             (16)                                              /*!< PDMA_T::TOC0_1: TOC1 Position          */
#define PDMA_TOC14_15_TOC15_Msk             (0xfffful << PDMA_TOC14_15_TOC15_Pos)                /*!< PDMA_T::TOC0_1: TOC1 Mask              */

#define PDMA_DSCTn_CTL_TBINTDIS_Pos       (7)                                               /*!< DSCT_T::CTL: TBINTDIS Position            */
#define PDMA_DSCTn_CTL_TBINTDIS_Msk       (1ul << PDMA_DSCTn_CTL_TBINTDIS_Pos)               /*!< DSCT_T::CTL: TBINTDIS Mask                */


#define TIMER_PWMSSCTL_SSEN_Pos             (TIMER_PWMSCTL_SYNCMODE_Pos)
#define TIMER_PWMSSCTL_SSEN_Msk             (0x1ul << TIMER_PWMSSCTL_SSEN_Pos)

#define TIMER_PWMSSCTL_SCLREN_Pos           (TIMER_PWMSSCTL_SSEN_Pos+1)
#define TIMER_PWMSSCTL_SCLREN_Msk           (0x1ul << TIMER_PWMSSCTL_SCLREN_Pos)


#define TIMER_PWMSCTL_SSEN_Pos             (TIMER_PWMSCTL_SYNCMODE_Pos)
#define TIMER_PWMSCTL_SSEN_Msk             (0x1ul << TIMER_PWMSCTL_SSEN_Pos)

#define TIMER_PWMSCTL_SCLREN_Pos           (TIMER_PWMSCTL_SSEN_Pos+1)
#define TIMER_PWMSCTL_SCLREN_Msk           (0x1ul << TIMER_PWMSCTL_SCLREN_Pos)


#define PWM_CTL0_CTRLDn_Pos              (0)                                               /*!< PWM_T::CTL0: CTRLDn Position           */
#define PWM_CTL0_CTRLDn_Msk              (0x3ful << PWM_CTL0_CTRLDn_Pos)                   /*!< PWM_T::CTL0: CTRLDn Mask               */

#define PWM_CTL0_WINLDENn_Pos            (8)                                               /*!< PWM_T::CTL0: WINLDENn Position         */
#define PWM_CTL0_WINLDENn_Msk            (0x3ful << PWM_CTL0_WINLDENn_Pos)                 /*!< PWM_T::CTL0: WINLDENn Mask             */

#define PWM_CTL0_IMMLDENn_Pos            (16)                                              /*!< PWM_T::CTL0: IMMLDENn Position         */
#define PWM_CTL0_IMMLDENn_Msk            (0x3ful << PWM_CTL0_IMMLDENn_Pos)                 /*!< PWM_T::CTL0: IMMLDENn Mask             */

#define PWM_CTL0_GROUPEN_Pos             (24)                                              /*!< PWM_T::CTL0: GROUPEN Position          */
#define PWM_CTL0_GROUPEN_Msk             (0x1ul << PWM_CTL0_GROUPEN_Pos)                   /*!< PWM_T::CTL0: GROUPEN Mask              */

#define PWM_CTL0_DBGHALT_Pos             (30)                                              /*!< PWM_T::CTL0: DBGHALT Position          */
#define PWM_CTL0_DBGHALT_Msk             (0x1ul << PWM_CTL0_DBGHALT_Pos)                   /*!< PWM_T::CTL0: DBGHALT Mask              */

#define PWM_CTL0_DBGTRIOFF_Pos           (31)                                              /*!< PWM_T::CTL0: DBGTRIOFF Position        */
#define PWM_CTL0_DBGTRIOFF_Msk           (0x1ul << PWM_CTL0_DBGTRIOFF_Pos)                 /*!< PWM_T::CTL0: DBGTRIOFF Mask            */

#define PWM_CTL1_CNTTYPE0_Pos            (0)                                               /*!< PWM_T::CTL1: CNTTYPE0 Position            */
#define PWM_CTL1_CNTTYPE0_Msk            (0x3ul << PWM_CTL1_CNTTYPE0_Pos)                  /*!< PWM_T::CTL1: CNTTYPE0 Mask                */

#define PWM_CTL1_CNTTYPE1_Pos            (2)                                               /*!< PWM_T::CTL1: CNTTYPE1 Position            */
#define PWM_CTL1_CNTTYPE1_Msk            (0x3ul << PWM_CTL1_CNTTYPE1_Pos)                  /*!< PWM_T::CTL1: CNTTYPE1 Mask                */

#define PWM_CTL1_CNTTYPE2_Pos            (4)                                               /*!< PWM_T::CTL1: CNTTYPE2 Position            */
#define PWM_CTL1_CNTTYPE2_Msk            (0x3ul << PWM_CTL1_CNTTYPE2_Pos)                  /*!< PWM_T::CTL1: CNTTYPE2 Mask                */

#define PWM_CTL1_CNTTYPE3_Pos            (6)                                               /*!< PWM_T::CTL1: CNTTYPE3 Position            */
#define PWM_CTL1_CNTTYPE3_Msk            (0x3ul << PWM_CTL1_CNTTYPE3_Pos)                  /*!< PWM_T::CTL1: CNTTYPE3 Mask                */

#define PWM_CTL1_CNTTYPE4_Pos            (8)                                               /*!< PWM_T::CTL1: CNTTYPE4 Position            */
#define PWM_CTL1_CNTTYPE4_Msk            (0x3ul << PWM_CTL1_CNTTYPE4_Pos)                  /*!< PWM_T::CTL1: CNTTYPE4 Mask                */

#define PWM_CTL1_CNTTYPE5_Pos            (10)                                              /*!< PWM_T::CTL1: CNTTYPE5 Position            */
#define PWM_CTL1_CNTTYPE5_Msk            (0x3ul << PWM_CTL1_CNTTYPE5_Pos)                  /*!< PWM_T::CTL1: CNTTYPE5 Mask                */
#define PWM_WGCTL0_ZPCTLn_Pos            (0)                                               /*!< PWM_T::WGCTL0: ZPCTLn Position         */
#define PWM_WGCTL0_ZPCTLn_Msk            (0xffful << PWM_WGCTL0_ZPCTLn_Pos)                /*!< PWM_T::WGCTL0: ZPCTLn Mask             */

#define PWM_WGCTL0_PRDPCTLn_Pos          (16)                                              /*!< PWM_T::WGCTL0: PRDPCTLn Position       */
#define PWM_WGCTL0_PRDPCTLn_Msk          (0xffful << PWM_WGCTL0_PRDPCTLn_Pos)              /*!< PWM_T::WGCTL0: PRDPCTLn Mask           */

#define PWM_WGCTL0_ZPCTL0_Pos            (0)                                               /*!< PWM_T::WGCTL0: ZPCTL0 Position            */
#define PWM_WGCTL0_ZPCTL0_Msk            (0x3ul << PWM_WGCTL0_ZPCTL0_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL0 Mask                */

#define PWM_WGCTL0_ZPCTL1_Pos            (2)                                               /*!< PWM_T::WGCTL0: ZPCTL1 Position            */
#define PWM_WGCTL0_ZPCTL1_Msk            (0x3ul << PWM_WGCTL0_ZPCTL1_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL1 Mask                */

#define PWM_WGCTL0_ZPCTL2_Pos            (4)                                               /*!< PWM_T::WGCTL0: ZPCTL2 Position            */
#define PWM_WGCTL0_ZPCTL2_Msk            (0x3ul << PWM_WGCTL0_ZPCTL2_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL2 Mask                */

#define PWM_WGCTL0_ZPCTL3_Pos            (6)                                               /*!< PWM_T::WGCTL0: ZPCTL3 Position            */
#define PWM_WGCTL0_ZPCTL3_Msk            (0x3ul << PWM_WGCTL0_ZPCTL3_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL3 Mask                */

#define PWM_WGCTL0_ZPCTL4_Pos            (8)                                               /*!< PWM_T::WGCTL0: ZPCTL4 Position            */
#define PWM_WGCTL0_ZPCTL4_Msk            (0x3ul << PWM_WGCTL0_ZPCTL4_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL4 Mask                */

#define PWM_WGCTL0_ZPCTL5_Pos            (10)                                              /*!< PWM_T::WGCTL0: ZPCTL5 Position            */
#define PWM_WGCTL0_ZPCTL5_Msk            (0x3ul << PWM_WGCTL0_ZPCTL5_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL5 Mask                */

#define PWM_WGCTL0_PRDPCTL0_Pos          (16)                                              /*!< PWM_T::WGCTL0: PRDPCTL0 Position          */
#define PWM_WGCTL0_PRDPCTL0_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL0_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL0 Mask              */

#define PWM_WGCTL0_PRDPCTL1_Pos          (18)                                              /*!< PWM_T::WGCTL0: PRDPCTL1 Position          */
#define PWM_WGCTL0_PRDPCTL1_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL1_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL1 Mask              */

#define PWM_WGCTL0_PRDPCTL2_Pos          (20)                                              /*!< PWM_T::WGCTL0: PRDPCTL2 Position          */
#define PWM_WGCTL0_PRDPCTL2_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL2_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL2 Mask              */

#define PWM_WGCTL0_PRDPCTL3_Pos          (22)                                              /*!< PWM_T::WGCTL0: PRDPCTL3 Position          */
#define PWM_WGCTL0_PRDPCTL3_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL3_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL3 Mask              */

#define PWM_WGCTL0_PRDPCTL4_Pos          (24)                                              /*!< PWM_T::WGCTL0: PRDPCTL4 Position          */
#define PWM_WGCTL0_PRDPCTL4_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL4_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL4 Mask              */

#define PWM_WGCTL0_PRDPCTL5_Pos          (26)                                              /*!< PWM_T::WGCTL0: PRDPCTL5 Position          */
#define PWM_WGCTL0_PRDPCTL5_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL5_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL5 Mask              */

#define PWM_WGCTL1_CMPUCTL0_Pos          (0)                                               /*!< PWM_T::WGCTL1: CMPUCTL0 Position          */
#define PWM_WGCTL1_CMPUCTL0_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL0_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL0 Mask              */

#define PWM_WGCTL1_CMPUCTL1_Pos          (2)                                               /*!< PWM_T::WGCTL1: CMPUCTL1 Position          */
#define PWM_WGCTL1_CMPUCTL1_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL1_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL1 Mask              */

#define PWM_WGCTL1_CMPUCTL2_Pos          (4)                                               /*!< PWM_T::WGCTL1: CMPUCTL2 Position          */
#define PWM_WGCTL1_CMPUCTL2_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL2_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL2 Mask              */

#define PWM_WGCTL1_CMPUCTL3_Pos          (6)                                               /*!< PWM_T::WGCTL1: CMPUCTL3 Position          */
#define PWM_WGCTL1_CMPUCTL3_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL3_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL3 Mask              */

#define PWM_WGCTL1_CMPUCTL4_Pos          (8)                                               /*!< PWM_T::WGCTL1: CMPUCTL4 Position          */
#define PWM_WGCTL1_CMPUCTL4_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL4_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL4 Mask              */

#define PWM_WGCTL1_CMPUCTL5_Pos          (10)                                              /*!< PWM_T::WGCTL1: CMPUCTL5 Position          */
#define PWM_WGCTL1_CMPUCTL5_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL5_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL5 Mask              */

#define PWM_WGCTL1_CMPDCTL0_Pos          (16)                                              /*!< PWM_T::WGCTL1: CMPDCTL0 Position          */
#define PWM_WGCTL1_CMPDCTL0_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL0_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL0 Mask              */

#define PWM_WGCTL1_CMPDCTL1_Pos          (18)                                              /*!< PWM_T::WGCTL1: CMPDCTL1 Position          */
#define PWM_WGCTL1_CMPDCTL1_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL1_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL1 Mask              */

#define PWM_WGCTL1_CMPDCTL2_Pos          (20)                                              /*!< PWM_T::WGCTL1: CMPDCTL2 Position          */
#define PWM_WGCTL1_CMPDCTL2_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL2_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL2 Mask              */

#define PWM_WGCTL1_CMPDCTL3_Pos          (22)                                              /*!< PWM_T::WGCTL1: CMPDCTL3 Position          */
#define PWM_WGCTL1_CMPDCTL3_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL3_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL3 Mask              */

#define PWM_WGCTL1_CMPDCTL4_Pos          (24)                                              /*!< PWM_T::WGCTL1: CMPDCTL4 Position          */
#define PWM_WGCTL1_CMPDCTL4_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL4_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL4 Mask              */

#define PWM_WGCTL1_CMPDCTL5_Pos          (26)                                              /*!< PWM_T::WGCTL1: CMPDCTL5 Position          */
#define PWM_WGCTL1_CMPDCTL5_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL5_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL5 Mask              */
 

/*---------------------------------------------------------------------------------------------------------*/
/* CNR Constants Definitions                                                                               */                                                                            
/*---------------------------------------------------------------------------------------------------------*/
/* PWM_GEN0 Bit Field Definitions */
/* PWM_WGCTL0 Bit Field Definitions */
#define PWM_WGCTL0_PPC5_Pos       26
#define PWM_WGCTL0_PPC5_Msk       (3ul << PWM_WGCTL0_PPC5_Pos)
#define PWM_WGCTL0_PPC4_Pos       24
#define PWM_WGCTL0_PPC4_Msk       (3ul << PWM_WGCTL0_PPC4_Pos)
#define PWM_WGCTL0_PPC3_Pos       22
#define PWM_WGCTL0_PPC3_Msk       (3ul << PWM_WGCTL0_PPC3_Pos)
#define PWM_WGCTL0_PPC2_Pos       20
#define PWM_WGCTL0_PPC2_Msk       (3ul << PWM_WGCTL0_PPC2_Pos)
#define PWM_WGCTL0_PPC1_Pos       18
#define PWM_WGCTL0_PPC1_Msk       (3ul << PWM_WGCTL0_PPC1_Pos)
#define PWM_WGCTL0_PPC0_Pos       16
#define PWM_WGCTL0_PPC0_Msk       (3ul << PWM_WGCTL0_PPC0_Pos)
#define PWM_WGCTL0_ZPC5_Pos       10
#define PWM_WGCTL0_ZPC5_Msk       (3ul << PWM_WGCTL0_ZPC5_Pos)
#define PWM_WGCTL0_ZPC4_Pos       8
#define PWM_WGCTL0_ZPC4_Msk       (3ul << PWM_WGCTL0_ZPC4_Pos)
#define PWM_WGCTL0_ZPC3_Pos       6
#define PWM_WGCTL0_ZPC3_Msk       (3ul << PWM_WGCTL0_ZPC3_Pos)
#define PWM_WGCTL0_ZPC2_Pos       4
#define PWM_WGCTL0_ZPC2_Msk       (3ul << PWM_WGCTL0_ZPC2_Pos)
#define PWM_WGCTL0_ZPC1_Pos       2
#define PWM_WGCTL0_ZPC1_Msk       (3ul << PWM_WGCTL0_ZPC1_Pos)
#define PWM_WGCTL0_ZPC0_Pos       0
#define PWM_WGCTL0_ZPC0_Msk       (3ul << PWM_WGCTL0_ZPC0_Pos)

/* PWM_WGCTL1 Bit Field Definitions */
#define PWM_WGCTL1_CMDC5_Pos      26
#define PWM_WGCTL1_CMDC5_Msk      (3ul << PWM_WGCTL1_CMDC5_Pos)
#define PWM_WGCTL1_CMDC4_Pos      24
#define PWM_WGCTL1_CMDC4_Msk      (3ul << PWM_WGCTL1_CMDC4_Pos)
#define PWM_WGCTL1_CMDC3_Pos      22
#define PWM_WGCTL1_CMDC3_Msk      (3ul << PWM_WGCTL1_CMDC3_Pos)
#define PWM_WGCTL1_CMDC2_Pos      20
#define PWM_WGCTL1_CMDC2_Msk      (3ul << PWM_WGCTL1_CMDC2_Pos)
#define PWM_WGCTL1_CMDC1_Pos      18
#define PWM_WGCTL1_CMDC1_Msk      (3ul << PWM_WGCTL1_CMDC1_Pos)
#define PWM_WGCTL1_CMDC0_Pos      16
#define PWM_WGCTL1_CMDC0_Msk      (3ul << PWM_WGCTL1_CMDC0_Pos)
#define PWM_WGCTL1_CMUC5_Pos      10
#define PWM_WGCTL1_CMUC5_Msk      (3ul << PWM_WGCTL1_CMUC5_Pos)
#define PWM_WGCTL1_CMUC4_Pos      8
#define PWM_WGCTL1_CMUC4_Msk      (3ul << PWM_WGCTL1_CMUC4_Pos)
#define PWM_WGCTL1_CMUC3_Pos      6
#define PWM_WGCTL1_CMUC3_Msk      (3ul << PWM_WGCTL1_CMUC3_Pos)
#define PWM_WGCTL1_CMUC2_Pos      4
#define PWM_WGCTL1_CMUC2_Msk      (3ul << PWM_WGCTL1_CMUC2_Pos)
#define PWM_WGCTL1_CMUC1_Pos      2
#define PWM_WGCTL1_CMUC1_Msk      (3ul << PWM_WGCTL1_CMUC1_Pos)
#define PWM_WGCTL1_CMUC0_Pos      0
#define PWM_WGCTL1_CMUC0_Msk      (3ul << PWM_WGCTL1_CMUC0_Pos)


#define PWM_WGCTL0_PPC0_DO_NOT_THING  (0x0UL << PWM_WGCTL0_PPC0_Pos)

#define PWM_WGCTL1_CMUC0_HIGH          (0x2UL << PWM_WGCTL1_CMUC0_Pos)

#define PWM_WGCTL1_CMDC0_LOW           (0x1UL << PWM_WGCTL1_CMDC0_Pos)

#define PWM_WGCTL0_ZPC0_DO_NOT_THING  (0x0UL << PWM_WGCTL0_ZPC0_Pos)

#define _PWM_SET_CNR(PWM, ch, val)   (*((__IO uint32_t *) (((uint32_t)&((PWM)->PERIOD0) + (ch)*4))) = (val))

#define _PWM_PPC_DO_NOT_THING(PWM, x) ((PWM)->WGCTL0 = (PWM)->WGCTL0 & ~(PWM_WGCTL0_PPC0_Msk << ((x)*2)) | (PWM_WGCTL0_PPC0_DO_NOT_THING << ((x)*2)))

#define _PWM_CMUC_HIGH(PWM, x) ((PWM)->WGCTL1 = (PWM)->WGCTL1 & ~(PWM_WGCTL1_CMUC0_Msk << ((x)*2)) | (PWM_WGCTL1_CMUC0_HIGH << ((x)*2)))

#define _PWM_CMDC_LOW(PWM, x) ((PWM)->WGCTL1 = (PWM)->WGCTL1 & ~(PWM_WGCTL1_CMDC0_Msk << ((x)*2)) | (PWM_WGCTL1_CMDC0_LOW << ((x)*2)))

#define _PWM_ZPC_DO_NOT_THING(PWM, x) ((PWM)->WGCTL0 = (PWM)->WGCTL0 & ~(PWM_WGCTL0_ZPC0_Msk << ((x)*2)) | (PWM_WGCTL0_ZPC0_DO_NOT_THING << ((x)*2)))

#define _SYS_GPC_MFPL_PC0(x)     (SYS->GPC_MFPL = (SYS->GPC_MFPL & (~SYS_GPC_MFPL_PC0MFP_Msk)) | (x)) //PC.0
#define DMA0_MAINTA0     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x000)) 
#define DMA0_MAINTA1     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x004)) 
#define DMA0_MAINTA2     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x008)) 
#define DMA0_MAINTA3     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x00C)) 
#define DMA1_MAINTA0     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x010))  
#define DMA1_MAINTA1     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x014)) 
#define DMA1_MAINTA2     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x018)) 
#define DMA1_MAINTA3     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x01C)) 
#define DMA2_MAINTA0     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x020)) 
#define DMA2_MAINTA1     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x024)) 
#define DMA2_MAINTA2     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x028)) 
#define DMA2_MAINTA3     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x02C)) 
#define DMA3_MAINTA0     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x030)) 
#define DMA3_MAINTA1     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x034)) 
#define DMA3_MAINTA2     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x038)) 
#define DMA3_MAINTA3     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x03C)) 
#define DMA4_MAINTA0     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x040)) 
#define DMA4_MAINTA1     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x044)) 
#define DMA4_MAINTA2     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x048)) 
#define DMA4_MAINTA3     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x04C)) 
#define DMA5_MAINTA0     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x050)) 
#define DMA5_MAINTA1     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x054)) 
#define DMA5_MAINTA2     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x058)) 
#define DMA5_MAINTA3     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x05C)) 
#define DMA6_MAINTA0     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x060)) 
#define DMA6_MAINTA1     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x064)) 
#define DMA6_MAINTA2     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x068)) 
#define DMA6_MAINTA3     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x06C)) 
#define DMA7_MAINTA0     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x070)) 
#define DMA7_MAINTA1     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x074)) 
#define DMA7_MAINTA2     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x078)) 
#define DMA7_MAINTA3     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x07C)) 
#define DMA8_MAINTA0     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x080)) 
#define DMA8_MAINTA1     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x084)) 
#define DMA8_MAINTA2     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x088)) 
#define DMA8_MAINTA3     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x08C)) 
#define DMA9_MAINTA0     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x090)) 
#define DMA9_MAINTA1     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x094)) 
#define DMA9_MAINTA2     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x098)) 
#define DMA9_MAINTA3     (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x09C)) 
#define DMA10_MAINTA0    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0A0))  
#define DMA10_MAINTA1    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0A4)) 
#define DMA10_MAINTA2    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0A8)) 
#define DMA10_MAINTA3    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0AC)) 
#define DMA11_MAINTA0    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0B0)) 
#define DMA11_MAINTA1    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0B4)) 
#define DMA11_MAINTA2    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0B8)) 
#define DMA11_MAINTA3    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0BC)) 
#define DMA12_MAINTA0    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0C0)) 
#define DMA12_MAINTA1    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0C4)) 
#define DMA12_MAINTA2    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0C8)) 
#define DMA12_MAINTA3    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0CC)) 
#define DMA13_MAINTA0    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0D0)) 
#define DMA13_MAINTA1    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0D4)) 
#define DMA13_MAINTA2    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0D8)) 
#define DMA13_MAINTA3    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0DC)) 
#define DMA14_MAINTA0    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0E0)) 
#define DMA14_MAINTA1    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0E4)) 
#define DMA14_MAINTA2    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0E8)) 
#define DMA14_MAINTA3    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0EC)) 
#define DMA15_MAINTA0    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0F0)) 
#define DMA15_MAINTA1    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0F4)) 
#define DMA15_MAINTA2    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0F8)) 
#define DMA15_MAINTA3    (*(volatile unsigned *) 		(PDMA_EMBTA_BASE + 0x0FC)) 


#define PWM_STATUS_ADCTRGFn_Msk          (0x3ful << PWM_STATUS_ADCTRGF0_Pos)               /*!< PWM_T::STATUS: ADCTRGFn Mask           */
#define PWM_CTL1_CNTMODEn_Pos              PWM_CTL1_CNTMODE0_Pos
#define PWM_CTL1_CNTMODEn_Msk            (0x3ful << PWM_CTL1_CNTMODE0_Pos)                 /*!< PWM_T::CTL1: CNTMODEn Mask             */

#define PWM_WGCTL1_CMPDCTLn_Pos          PWM_WGCTL1_CMPDCTL0_Pos                                             /*!< PWM_T::WGCTL1: CMPDCTLn Position       */
#define PWM_WGCTL1_CMPDCTLn_Msk          (0xffful << PWM_WGCTL1_CMPDCTLn_Pos)              /*!< PWM_T::WGCTL1: CMPDCTLn Mask           */

#define TMR01_PWMSCTL_SCLREN_Pos           (TMR01_PWMSCTL_SYNCMODE_Pos+1)
#define TMR01_PWMSCTL_SCLREN_Msk           (0x1ul << TMR01_PWMSCTL_SCLREN_Pos)

#define FMC_ISPCTL_SPUEN_Pos		2								/*!<FMC ISPCTL: SPUEN Position */
#define FMC_ISPCTL_SPUEN_Msk		(1ul << FMC_ISPCTL_SPUEN_Pos)   /*!<FMC ISPCTL: SPUEN Mask */


typedef struct
{
    uint32_t u32Year;           /*!< Year value */
    uint32_t u32Month;          /*!< Month value */
    uint32_t u32Day;            /*!< Day value */
    uint32_t u32DayOfWeek;      /*!< Day of week value */
    uint32_t u32Hour;           /*!< Hour value */
    uint32_t u32Minute;         /*!< Minute value */
    uint32_t u32Second;         /*!< Second value */
    uint32_t u32TimeScale;      /*!< 12-Hour, 24-Hour */
    uint32_t u32AmPm;           /*!< Only Time Scale select 12-hr used */
} S_RTC_TIME_DATA_T;

typedef struct
{  
    __IO uint32_t  CONFIG0;  
    __IO uint32_t  CONFIG1;     
		__IO uint32_t  CONFIG2;     
	__IO uint32_t  CONFIG3;     
	__IO uint32_t  CONFIG4;     
	__IO uint32_t  CONFIG5;     
	__IO uint32_t  CONFIG6;     
	__IO uint32_t  CONFIG7;     
	
}CONFIG_T;
#define TIMER_T TMR01_T


/*------------- Flash Memory Controller (FMC) -----------------------------*/
/** @addtogroup M451_FMC M451 Flash Memory Controller Register (FMC)
  @{
*/
typedef struct
{
  __IO uint32_t ISPCTL;					    /*!< Offset: 0x0000   ISP Control Register                               */
  __IO uint32_t ISPADDR;					/*!< Offset: 0x0004   ISP Address Register                               */ 
  __IO uint32_t ISPDAT;						/*!< Offset: 0x0008   ISP Data Register                                  */ 
  __IO uint32_t ISPCMD;					    /*!< Offset: 0x000C   ISP Command Register                               */
  __IO uint32_t ISPTRG;					    /*!< Offset: 0x0010   ISP Trigger Register                               */
  __I  uint32_t DFBA;						/*!< Offset: 0x0014   Data Flash Start Address (CONFIG1)                 */ 
  __IO uint32_t FTCTL;					    /*!< Offset: 0x0018   Flash Access Window Control Register               */
  __IO uint32_t ICPCTL;                     /*!< Offset: 0x001C   ICP Enabled Control Register                       */
       uint32_t RESERVED0[8];               /*!< Offset: 0x0020 ~ 0x003C   Reserved                                  */ 
  __IO uint32_t ISPSTS;					    /*!< Offset: 0x0040   ISP Status Register                                */
       uint32_t RESERVED1[2];               /*!< Offset: 0x0044 ~ 0x0048   Reserved                                  */ 
  __IO uint32_t CYCCTL;					    /*!< Offset: 0x004C   Flash Access Cycle Control Register                */
  __IO uint32_t KEY0;                       /*!< Offset: 0x0050   KEY0 Data Register                                 */   
  __IO uint32_t KEY1;                       /*!< Offset: 0x0054   KEY1 Data Register                                 */   
  __IO uint32_t KEY2;                       /*!< Offset: 0x0058   KEY2 Data Register                                 */   
  __IO uint32_t KEYTRG;                     /*!< Offset: 0x005C   KEY trigger Register                               */
  __IO uint32_t KEYSTS;                     /*!< Offset: 0x0060   KEY Comparison Status Register                     */
  __IO uint32_t KECNT;                      /*!< Offset: 0x0064   KEY-Unmatched Counting Register                    */
  __IO uint32_t KPCNT;                      /*!< Offset: 0x0068   KEY-Unmatched Power-On Counting Register           */
       uint32_t RESERVED2[5];               /*!< Offset: 0x006C ~ 0x007C   Reserved                                  */ 
  __IO uint32_t MPDAT0;						/*!< Offset: 0x0080   ISP Data0 Register                                 */ 
  __IO uint32_t MPDAT1;					    /*!< Offset: 0x0084   ISP Data1 Register                                 */ 
  __IO uint32_t MPDAT2;					    /*!< Offset: 0x0088   ISP Data2 Register                                 */ 
  __IO uint32_t MPDAT3;					    /*!< Offset: 0x008C   ISP Data3 Register                                 */ 
       uint32_t RESERVED3[12];              /*!< Offset: 0x0090 ~ 0x00BC   Reserved                                  */ 
  __IO uint32_t MPSTS;					    /*!< Offset: 0x00C0   ISP Page Program status                            */ 
  __IO uint32_t MPADDR;					    /*!< Offset: 0x00C4   ISP Page Program Address status                    */ 
       uint32_t RESERVED4[972];             /*!< Offset: 0x00C8 ~ 0x0FF4   Reserved                                  */ 
  __IO uint32_t FUNCASS;					/*!< Offset: 0x0FF8   Chip function assignment                           */ 
  __IO uint32_t FMC_VERSION;				/*!< Offset: 0x0FFC   FMC version                                        */ 
} FMC1_T;


#define FMC_KEYTRG_KEYGO_Pos             (0)                                               /*!< FMC KEYTRG: KEYGO Position             */
#define FMC_KEYTRG_KEYGO_Msk             (0x1ul << FMC_KEYTRG_KEYGO_Pos)                   /*!< FMC KEYTRG: KEYGO Mask                 */

#define FMC_KEYTRG_TCEN_Pos              (1)                                               /*!< FMC KEYTRG: TCEN Position              */
#define FMC_KEYTRG_TCEN_Msk              (0x1ul << FMC_KEYTRG_TCEN_Pos)                    /*!< FMC KEYTRG: TCEN Mask                  */

#define FMC_KEYSTS_KEYBUSY_Pos           (0)                                               /*!< FMC KEYSTS: KEYBUSY Position           */
#define FMC_KEYSTS_KEYBUSY_Msk           (0x1ul << FMC_KEYSTS_KEYBUSY_Pos)                 /*!< FMC KEYSTS: KEYBUSY Mask               */

#define FMC_KEYSTS_KEYLOCK_Pos           (1)                                               /*!< FMC KEYSTS: KEYLOCK Position           */
#define FMC_KEYSTS_KEYLOCK_Msk           (0x1ul << FMC_KEYSTS_KEYLOCK_Pos)                 /*!< FMC KEYSTS: KEYLOCK Mask               */

#define FMC_KEYSTS_KEYMATCH_Pos          (2)                                               /*!< FMC KEYSTS: KEYMATCH Position          */
#define FMC_KEYSTS_KEYMATCH_Msk          (0x1ul << FMC_KEYSTS_KEYMATCH_Pos)                /*!< FMC KEYSTS: KEYMATCH Mask              */

#define FMC_KEYSTS_FORBID_Pos            (3)                                               /*!< FMC KEYSTS: FORBID Position            */
#define FMC_KEYSTS_FORBID_Msk            (0x1ul << FMC_KEYSTS_FORBID_Pos)                  /*!< FMC KEYSTS: FORBID Mask                */

#define FMC_KEYSTS_KEYFLAG_Pos           (4)                                               /*!< FMC KEYSTS: KEYFLAG Position           */
#define FMC_KEYSTS_KEYFLAG_Msk           (0x1ul << FMC_KEYSTS_KEYFLAG_Pos)                 /*!< FMC KEYSTS: KEYFLAG Mask               */

#define FMC_KEYSTS_CFGFLAG_Pos           (5)                                               /*!< FMC KEYSTS: CFGFLAG Position           */
#define FMC_KEYSTS_CFGFLAG_Msk           (0x1ul << FMC_KEYSTS_CFGFLAG_Pos)                 /*!< FMC KEYSTS: CFGFLAG Mask               */

#define FMC_KEYSTS_SPFLAG_Pos            (6)                                               /*!< FMC KEYSTS: SPFLAG Position            */
#define FMC_KEYSTS_SPFLAG_Msk            (0x1ul << FMC_KEYSTS_SPFLAG_Pos)                  /*!< FMC KEYSTS: SPFLAG Mask                */

#define FMC_KEYSTS_SBKPBUSY_Pos          (8)                                               /*!< FMC KEYSTS: SBKPBUSY Position          */
#define FMC_KEYSTS_SBKPBUSY_Msk          (0x1ul << FMC_KEYSTS_SBKPBUSY_Pos)                /*!< FMC KEYSTS: SBKPBUSY Mask              */

#define FMC_KEYSTS_SBKPFLAG_Pos          (9)                                               /*!< FMC KEYSTS: SBKPFLAG Position          */
#define FMC_KEYSTS_SBKPFLAG_Msk          (0x1ul << FMC_KEYSTS_SBKPFLAG_Pos)                /*!< FMC KEYSTS: SBKPFLAG Mask              */

#define FMC_KECNT_KECNT_Pos              (0)                                               /*!< FMC KECNT: KECNT Position              */
#define FMC_KECNT_KECNT_Msk              (0x3ful << FMC_KECNT_KECNT_Pos)                   /*!< FMC KECNT: KECNT Mask                  */

#define FMC_KECNT_KEMAX_Pos              (8)                                               /*!< FMC KECNT: KEMAX Position              */
#define FMC_KECNT_KEMAX_Msk              (0x3ful << FMC_KECNT_KEMAX_Pos)                   /*!< FMC KECNT: KEMAX Mask                  */

#define FMC_KPCNT_KPCNT_Pos              (0)                                               /*!< FMC KPCNT: KPCNT Position              */
#define FMC_KPCNT_KPCNT_Msk              (0x7ul << FMC_KPCNT_KPCNT_Pos)                    /*!< FMC KPCNT: KPCNT Mask                  */

#define FMC_KPCNT_KPMAX_Pos              (8)                                               /*!< FMC KPCNT: KPMAX Position              */
#define FMC_KPCNT_KPMAX_Msk              (0x7ul << FMC_KPCNT_KPMAX_Pos)                    /*!< FMC KPCNT: KPMAX Mask                  */

/********************* Bit definition of ICPCTL register **********************/
#define FMC_ICPCTL_ICPEN_Pos             (0)                                               /*!< FMC ICPCTL: ICPEN Position             */
#define FMC_ICPCTL_ICPEN_Msk             (0x1ul << FMC_ICPCTL_ICPEN_Pos)                   /*!< FMC ICPCTL: ICPEN Mask                 */
#define FMC_ICPCTL_UNLOAD_Pos            (1)                                               /*!< FMC ICPCTL: UNLOAD Position            */
#define FMC_ICPCTL_UNLOAD_Msk            (0x1ul << FMC_ICPCTL_UNLOAD_Pos)                  /*!< FMC ICPCTL: UNLOAD Mask                */

#define FMC_ISPSTS_SCODE_Pos             (31)                                              /*!< FMC ISPSTS: SCODE Position             */
#define FMC_ISPSTS_SCODE_Msk             (0x1ul << FMC_ISPSTS_SCODE_Pos)                   /*!< FMC ISPSTS: SCODE Mask                 */

/********************* Bit definition of ISPCTL register **********************/
#define FMC1	                 ((FMC1_T *)   FMC_BASE)
/*@}*/ /* end of group TC8226_FMC */




/*@}*/ /* end of group ISD94XXX_Exported_Macros */

/*@}*/ /* end of group ISD94XXX_Definitions */

//void SYS_UnlockReg() { do{SYS->REGLCTL = 0x59; SYS->REGLCTL = 0x16; SYS->REGLCTL = 0x88;}while(SYS->REGLCTL == 0x00);}
//void SYS_LockReg() {do{SYS->REGLCTL = 0x00;}while(0);}
#ifdef __cplusplus
}
#endif

#endif  /* __ISD94XXXSERIES_H__ */

/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
